{
  "58551176": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int maxn=131072;\n\n//const ll INF = 1e18;\nconst ll INF =  1e9;\n//const ll mod = 1e9+7;\nconst ld pi = acos(-1);\n\nconst ld eps = 1e-9;\n\nvoid solve() {\n   ll n,k;\n   cin >> n >> k;\n   string s;\n   cin >> s;\n   vector<int> pos[2];\n   for (int i=0;i<s.size();i++) {\n       pos[s[i]-'0'].push_back(i);\n   }\n   if (pos[0].size()==0 || pos[1].size()==0) {\n       cout << \"tokitsukaze\";\n       return;\n   }\n   bool escape = false;\n   for (int l=0;l<=n-k;l++) {\n       for (int i=0;i<2;i++) {\n           int pos1 = pos[1-i][0];\n           if (pos1>=l) {\n               auto it = lower_bound(pos[1 - i].begin(), pos[1 - i].end(), l + k);\n               if (it == pos[1 - i].end()) {\n                   cout << \"tokitsukaze\";\n                   return;\n               }\n           }\n           vector<int> tmp;\n           if (pos[1-i][0]<l) {\n               tmp.push_back(pos[1-i][0]);\n           }\n           auto it = lower_bound(pos[1-i].begin(), pos[1-i].end(), l);\n           if (it!=pos[1-i].begin()) {\n               it--;\n               tmp.push_back(*it);\n           }\n           it = lower_bound(pos[1-i].begin(), pos[1-i].end(), l+k);\n           if (it!=pos[1-i].end()) {\n               tmp.push_back(*it);\n           }\n           if (pos[1-i].back()>=l+k) {\n               tmp.push_back(pos[1-i].back());\n           }\n           if (tmp.size()>=2 && tmp.back()-tmp[0]>=k) {\n               escape = true;\n           }\n       }\n   }\n   if (escape) {\n       cout << \"once again\";\n   } else {\n       cout << \"quailty\";\n   }\n}\nint main() {\n    cin.tie(0);\n    cout.tie(0);\n    ios_base::sync_with_stdio(false);\n//    cout << setprecision(7) << fixed;\n   // freopen(\"input.txt\",\"r\", stdin);\n    solve();\n    return 0;\n}",
    "ext": "cpp"
  },
  "58530656": {
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define int long long\n\nint n, k;\n\nbool check(string s)\n{\n    int begin = 1, end = 1;\n    for(int i = 1; i < n; i++) \n    {\n        if(s[i] == s[i - 1]) begin++;\n        else break;\n    }\n    for(int i = n - 2; i >= 0; i--)\n    {\n        if(s[i] == s[i + 1]) end++;\n        else break;\n    }\n    if(begin == n) return true;\n    if(s[0] == s[n - 1])\n    {\n        if(begin + end >= n - k) return true;\n        return false;\n    }\n    if(max(begin, end) >= n - k) return true;\n    return false;\n}\n\nstring update(string s, int i, char c)\n{\n    for(int j = i; j < i + k; j++) s[j] = c;\n    return s;\n}\n\nint32_t main()\n{\n    string s, t;\n\n    cin >> n >> k;\n    cin >> s;\n    if(check(s))\n    {\n        cout << \"tokitsukaze\";\n        return 0;\n    }\n    \n    if(check(update(s, 0, '1')) && check(update(s, 0, '0')) && check(update(s, 1, '0')) && check(update(s, 1, '1')) && check(update(s, n - k, '1')) && check(update(s, n - k, '0')) && check(update(s, n - k - 1, '0')) && check(update(s, n - k - 1, '1'))) \n    {\n        cout << \"quailty\";\n        return 0;\n    }\n    \n    cout << \"once again\";\n    return 0;\n}\n\n",
    "ext": "cpp"
  },
  "58520453": {
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing qi = queue<int>;\n\n\nint n, k;\nstring s;\nint main() {\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n >> k >> s;\n\tint l0 = s.find('0');\n\tint r0 = s.rfind('0');\n\tint l1 = s.find('1');\n\tint r1 = s.rfind('1');\n\t//cout << l0 << ' ' << r0 << ' ' << l1 << ' ' << r1 << '\\n';\n\tif (r0 - l0 + 1 <= k || r1 - l1 + 1 <= k || l0 == -1 || l1 == -1) {\n\t\tcout << \"tokitsukaze\\n\";\n\t\treturn 0;\n\t}\n\tbool flag = false;\n\tflag |= (r0 - l0 - 1>= k || r1 - l1 - 1>= k);\n\tint t;\n\tt = s.find('0', k);\n\tif (t != -1 && r0 - t + 1 > k) {\n\t\tflag |= 1;\n\t}\n\tt = s.find('1', k);\n\tif (t != -1 && r1 - t + 1 > k) {\n\t\tflag |= 1;\n\t}\n\tt = s.rfind('0', s.size() - 1 - k);\n\tif (t != -1 && t - l0 + 1> k) {\n\t\tflag |= 1;\n\t}\n\tt = s.rfind('1', s.size() - 1 - k);\n\tif (t != -1 && t - l1 + 1> k) {\n\t\tflag |= 1;\n\t}\n\n\tif (!flag) {\n\t\tcout << \"quailty\\n\";\n\t\treturn 0;\n\t}\n\tcout << \"once again\\n\";\n}",
    "ext": "cpp"
  },
  "58417724": {
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n \n \nusing namespace std;\n \nchar op[100010];\nint a[100010];\nint sum[100010];\n \nint n,m;\n/*\n5 1\n11111\n*/\nint q_sum(int l,int r)\n{\n    if(l>r) return 0;\n    return sum[r]-sum[l-1];\n}\nbool fir() ///\u5224\u65ad\u5148\u624b\u80fd\u5426\u7b2c\u4e00\u6b21\u5c31win\n{\n    for(int i=1;i<=n-m+1;i++)\n    {\n        int item=q_sum(1,i-1)+q_sum(i+m,n);\n        if(item==0||item+m==n) return 1;\n    }\n    return 0;\n}\n \nbool sec()\n{\n \n    ///\u540e\u624b\n    if(m==1||2*m<n) return 0;\n \n    int len=n-m-1;\n \n    ///\u8fd9\u91cc\u7684\u610f\u601d\u5176\u5b9e\u5c31\u662f\u524dm-1\u4e2a\u5b57\u7b26\u8981\u7edf\u4e00\uff0c\u540em-1\u4e2a\u5b57\u7b26\u8981\u7edf\u4e00\uff0c\u4e14\u5de6\u53f3\u4e24\u4e32\u5b57\u7b26\u4e0d\u540c\n    ///\u90a3\u4e48\u5148\u624b\u4e0d\u7ba1\u600e\u4e48\u53d6\uff0c\u540e\u624b\u603b\u80fdwin\n    for(int i=2;i<=len;i++)\n    {\n        if(a[i]!=a[i-1]||a[n-i+1]!=a[n-i+2]) return 0;\n    }\n \n    if(a[1]==a[n]) return 0;\n    return 1;\n}\nint main()\n{\n \n    scanf(\"%d%d\",&n,&m);\n \n    scanf(\"%s\",op);\n \n    for(int i=1;i<=n;i++)\n    {\n        a[i]=op[i-1]-'0';\n        sum[i]=sum[i-1]+a[i];\n    }\n \n \n    if(fir()){\n        puts(\"tokitsukaze\");\n    }\n    else{\n        if(sec()){\n            puts(\"quailty\");\n        }\n        else{\n            puts(\"once again\");\n        }\n    }\n \n    return 0;\n}",
    "ext": "cpp"
  },
  "58350779": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint solve(int n, int k, const string& s) {\n  int to = count(s.begin(), s.end(), '1');\n  if (to == n) {\n    cout << \"tokitsukaze\\n\";\n    exit(0);\n  }\n  vector<int> pref(n + 1);\n  for (int i = 1; i <= n; i++)\n    pref[i] = pref[i - 1] + (s[i] - '0');\n  vector<int> after;\n  vector<int> before;\n  for (int i = k; i <= n; i++) {\n    if (s[i] == '0') after.push_back(i);\n  }\n  reverse(after.begin(), after.end());\n  bool player_two = true;\n  for (int i = 1; i <= n - k + 1; i++) {\n    if (s[i + k - 1] == '0')\n      after.pop_back();\n    int ones = pref[i + k - 1] - pref[i - 1];\n    if (to - ones + k == n)\n      return 0;\n    /* check if quailty can finish */\n    bool check_player_two = false;\n    if ((before.size() < 2 ||\n        (before.back() - before.front() + 1 <= k)) &&\n        (pref[n] - pref[i + k - 1] == (n - (i + k) + 1))) {\n      check_player_two = true;\n    }\n    if ((after.size() < 2 ||\n         (after.front() - after.back() + 1 <= k)) &&\n         (pref[i - 1] == i - 1)) {\n      check_player_two = true;\n    }\n    player_two = player_two && check_player_two;\n    if (s[i] == '0')\n      before.push_back(i);\n  }\n  return player_two ? 1 : 2;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  int n, k;\n  string s;\n  cin >> n >> k >> s;\n  s = \"$\" + s;\n  int a1 = solve(n, k, s);\n  for (int i = 1; i <= n; i++) {\n    s[i] = '0' + 1 - (s[i] - '0');\n  }\n  int a2 = solve(n, k, s);\n  if (a1 == 0 || a2 == 0) cout << \"tokitsukaze\\n\";\n  else if (a1 == 1 && a2 == 1) cout << \"quailty\\n\";\n  else cout << \"once again\\n\";\n  return 0;\n}\n",
    "ext": "cpp"
  },
  "58306592": {
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint zi[100010], zf[100010], oi[100010], of[100010];\n\nint main()\n{\n    int n, k;\n    string s;\n    cin >> n >> k >> s;\n    int z1=0, z2=0, o1=0, o2=0;\n    for (int i = 0; s[i] == '0'; i++) z1++;\n    for (int i = 0; s[i] == '1'; i++) o1++;\n    for (int i = n - 1; i >= 0 && s[i] == '0'; i--) z2++;\n    for (int i = n - 1; i >= 0 && s[i] == '1'; i--) o2++;\n    if (n - z1 - z2 <= k || n - o1 - o2 <= k)\n    {\n        cout << \"tokitsukaze\";\n        return 0;\n    }\n    int z = 0, o = 0;\n    for (int i = 0; i < n; i++)\n    {\n        zi[i] = z; oi[i] = o;\n        if (s[i] == '0') z++, o = 0;\n        else o++, z = 0;\n    }\n    for (int i = n-1; i>=0;--i)\n    {\n        zf[i] = z; of[i] = o;\n        if (s[i] == '0') z++, o = 0;\n        else o++, z = 0;\n    }\n    int ok = 0;\n    for (int i = k - 1; i < n; i++)\n    {\n        ok = 0;\n        if (z1 > i - k && n - i - zf[i] - z2 - 1<= k) ok++;\n        else if (n - i - zf[i]  - 1 <= z2 && i - k - zi[i] - z1 + 1 <= k) ok++;\n        if (o1 > i-k && n - i - of[i] - o2 - 1 <= k) ok++;\n        else if (n - i - of[i] -1<= o2 && i - k - oi[i] - o1+1 <= k) ok++;\n        if(ok!=2)\n        {\n            cout << \"once again\";\n            return 0;\n        }\n    }\n    cout << \"quailty\";\n    return 0;\n}",
    "ext": "cpp"
  },
  "58297342": {
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=1000005;\nint n,k,T;\nint a[MAXN],sum[MAXN];\nint q_sum(int l,int r)\n{\n    if(l>r)return 0;\n    return sum[r]-sum[l-1];\n}\nbool check_fir()\n{\n    for(int i=1;i+k-1<=n;++i)\n    {\n        int lala=q_sum(1,i-1)+q_sum(i+k,n);\n        if(lala==0||lala+k==n)return true;\n    }\n    return false;\n}\nbool check_sec()\n{\n    if(k*2<n||k==1)return false;\n    int len=n-k-1;\n    for(int i=2;i<=len;++i)\n    {\n        if(a[i]!=a[i-1]||a[n-i+1]!=a[n-i+2])return false;\n    }\n    if(a[len]==a[len+1]||a[n-len]==a[n-len+1]||a[1]==a[n])return false;\n    return true;\n}\nint main()\n{\n    scanf(\"%d %d\",&n,&k);\n    for(int i=1;i<=n;++i)\n    {\n        scanf(\"%1d\",&a[i]);\n        sum[i]=sum[i-1]+a[i];\n    }\n    if(check_fir())\n    {\n        printf(\"tokitsukaze\\n\");\n    }\n    else\n    {\n        if(check_sec())\n        {\n            printf(\"quailty\\n\");\n        }\n        else\n        {\n            printf(\"once again\\n\");\n        }\n    }\n    return 0;\n}",
    "ext": "cpp"
  },
  "58260509": {
    "code": "#include<bits/stdc++.h>\n#define REP(i,s,t) for(int i=s;i<=t;i++)\nusing namespace std;\nconst int maxn=1e5+5;\nchar s[maxn],s1[20]=\"tokitsukaze\",s2[20]=\"quailty\",s3[20]=\"once again\";\nint n,k,p1[maxn],p2[maxn],p3[maxn],p4[maxn];\nint main(){\n\tcin>>n>>k;\n\tscanf(\"%s\",s+1);\n\tbool flg1=true,flg2=true;\n\tREP(i,1,n){\n\t\tif(s[i]=='0') flg1=false;\n\t\tif(s[i]=='1') flg2=false;\n\t}\n\tif(flg1||flg2){cout<<s1; return 0;}\n\tREP(i,1,n) if(s[i]=='0') p1[i]=i; else p1[i]=p1[i-1];\n\tp2[n+1]=n+1;\n\tfor(int i=n;i;i--) if(s[i]=='0') p2[i]=i; else p2[i]=p2[i+1];\n\tREP(i,1,n) if(s[i]=='1') p3[i]=i; else p3[i]=p3[i-1];\n\tp4[n+1]=n+1;\n\tfor(int i=n;i;i--) if(s[i]=='1') p4[i]=i; else p4[i]=p4[i+1];\n\tif(p1[n]-p2[1]+1<=k||p3[n]-p4[1]+1<=k){cout<<s1; return 0;}\n\tbool flg=false;\n\tREP(i,1,n-k+1){\n\t\tint t1=min(i,p2[1]),t2=max(i+k-1,p1[n]),t3,t4;\n\t\tif(p4[1]>=i&&p4[1]<=i+k-1) t3=p4[i+k],t4=p3[n];\n\t\telse if(p3[n]>=i&&p3[n]<=i+k-1) t3=p4[1],t4=p3[i-1];\n\t\telse t3=p4[1],t4=p3[n];\n\t\tif(t2-t1+1>k&&t4-t3+1>k) flg=true;\n\t}\n\tREP(i,1,n-k+1){\n\t\tint t3=min(i,p4[1]),t4=max(i+k-1,p3[n]),t1,t2;\n\t\tif(p2[1]>=i&&p2[1]<=i+k-1) t1=p2[i+k],t2=p1[n];\n\t\telse if(p1[n]>=i&&p1[n]<=i+k-1) t1=p2[1],t2=p1[i-1];\n\t\telse t1=p2[1],t2=p1[n];\n\t\tif(t2-t1+1>k&&t4-t3+1>k) flg=true;\n\t}\n\tif(!flg) cout<<s2;\n\telse cout<<s3;\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "58244300": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, k;\n\nchar a[100005];\n\nint pre[100005];\n\nbool ok(int l){\n\tint sum = pre[n] - pre[l + k - 1] + pre[l - 1];\n\tif(sum == n - k || sum == 0){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool first_win(){\n\tfor(int i = 1; i <= n - k + 1; i++){\n\t\tif(ok(i)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool second_win(){\n\tif(k * 2 < n || k == 1) return false;\n\tfor(int i = 2; i <= n - k - 1; i++){\n\t\tif(a[i] != a[i - 1] || a[n - i + 1] != a[n - i + 2]) return false;\n\t}\n\tif(a[n - k] == a[n - k - 1] || a[k + 1] == a[k + 2] || a[1] == a[n]) return false;\n\treturn true;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &k);\n\tscanf(\"%s\", a + 1);\n\n\tfor(int i = 1; i <= n; i++){\n\t\tpre[i] = pre[i - 1] + a[i] - '0';\n\t}\n\n\tif(first_win()){\n\t\tputs(\"tokitsukaze\");\n\t\treturn 0;\n\t}\n\tif(second_win()){\n\t\tputs(\"quailty\");\n\t\treturn 0;\n\t}\n\tputs(\"once again\");\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "58236986": {
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nint n, k;\nstring s;\n\nint lft[2][100005];\nint rht[2][100005];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n >> k;\n    cin >> s;\n    s = '#' + s + '#';\n\n    lft[0][0] = lft[1][0] = -1111111;\n    for (int i = 1; i <= n + 1; i++) {\n        lft[0][i] = s[i] == '0' ? i : lft[0][i - 1];\n        lft[1][i] = s[i] == '1' ? i : lft[1][i - 1];\n    }\n\n    rht[0][n + 1] = rht[1][n + 1] = 1111111;\n    for (int i = n; i >= 0; i--) {\n        rht[0][i] = s[i] == '0' ? i : rht[0][i + 1];\n        rht[1][i] = s[i] == '1' ? i : rht[1][i + 1];\n    }\n\n    if(lft[0][n] - rht[0][1] < k || lft[1][n] - rht[1][1] < k) {\n        cout << \"tokitsukaze\" << endl;\n        return 0;\n    }\n\n    bool draw = false;\n    for (int turn = 0; turn <= 1; turn++) {\n        for (int i = 1; i + k - 1 <= n; i++) {\n            int lftmost = rht[!turn][1] < i ? rht[!turn][1] : rht[!turn][i + k];\n            int rhtmost = lft[!turn][n] > i + k - 1 ? lft[!turn][n] : lft[!turn][i - 1];\n            if(rhtmost - lftmost >= k)\n                draw = true;\n        }\n    }\n\n    cout << (draw ? \"once again\" : \"quailty\") << endl;\n}\n",
    "ext": "cpp"
  },
  "58197143": {
    "code": "#include<stdio.h>\n\n#define maxn 100005\nstruct Node\n{\n    int item;\n    int num_0,num_1;\n}node[maxn];\nchar s[maxn];\nint n,k;\nbool judge_first()\n{\n    if(k>=n)\n        return true;\n    for(int left=0;left+k-1<=n-1;left++)\n    {\n        bool flag=true;\n        if(left!=0)\n            if(node[left-1].num_0!=left&&node[left-1].num_1!=left)\n                flag=false;\n        if(left+k-1!=n-1)\n            if((node[n-1].num_0-node[left+k-1].num_0!=(n-1-(left+k-1)))&&(node[n-1].num_1-node[left+k-1].num_1!=(n-1-(left+k-1))))\n                flag=false;\n        if(flag&&left!=0&&left+k-1!=n-1)\n            if(node[0].item!=node[n-1].item)\n                flag=false;\n        if(flag)\n            return true;\n    }\n    return false;\n}\n\nbool judge_second()\n{\n    bool answer=true;\n    if(2*k<n||k==1)\n        return false;\n    for(int left=0;left+k-1<=n-1;left++)\n    {\n        bool temp_answer=false;\n        bool flag_1=true,flag_2=true;\n        if(left!=0)\n            if(node[left-1].num_0!=left&&node[left-1].num_1!=left)\n                flag_1=false;\n        if(left+k-1!=n-1)\n            if((node[n-1].num_0-node[left+k-1].num_0!=(n-1-(left+k-1)))&&(node[n-1].num_1-node[left+k-1].num_1!=(n-1-(left+k-1))))\n                flag_2=false;\n        if(left==0||left+k-1==n-1)\n            temp_answer=true;\n        if(left!=0&&left+k-1!=n-1&&flag_1&&flag_2)\n            if((node[0].item==0&&node[n-1].item==1)||(node[0].item==1&&node[n-1].item==0))\n                temp_answer=true;\n        if(!temp_answer)\n            answer=false;\n    }\n    return answer;\n}\n\nint main()\n{\n\n    scanf(\"%d%d\",&n,&k);\n    scanf(\"%s\",s);\n    node[0].item=s[0]-'0';\n    node[0].num_0=node[0].num_1=0;\n    if(node[0].item==0)\n        node[0].num_0++;\n    else\n        node[0].num_1++;\n    for(int i=1;i<n;i++)\n    {\n        node[i]=node[i-1];\n        node[i].item=s[i]-'0';\n        if(node[i].item==0)\n            node[i].num_0++;\n        else\n            node[i].num_1++;\n    }\n    if(judge_first())\n        printf(\"tokitsukaze\\n\");\n    else if(judge_second())\n        printf(\"quailty\\n\");\n    else\n        printf(\"once again\\n\");\n    return 0;\n}\n\n\t\t\t \t  \t \t \t \t    \t  \t\t    \t \t",
    "ext": "cpp"
  },
  "58197029": {
    "code": "#include<stdio.h>\n\n#define maxn 100005\nstruct Node\n{\n    int item;\n    int num_0,num_1;\n}node[maxn];\nchar s[maxn];\nint n,k;\nbool judge_first()\n{\n//    printf(\"**\\n\");\n    if(k>=n)\n        return true;\n//        printf(\"**\\n\");\n    for(int left=0;left+k-1<=n-1;left++)\n    {\n//        printf(\"left=%d left+k-1=%d**\\n\",left,left+k-1);\n        bool flag=true;\n        if(left!=0)\n        {\n//            printf(\"node[left-1].num_0=%d node[left-1].num_1=%d\\n\",node[left-1].num_0,node[left-1].num_1);\n            if(node[left-1].num_0!=left&&node[left-1].num_1!=left)\n                flag=false;\n        }\n        if(left+k-1!=n-1)\n        {\n//            printf(\"node[n-1].num_0=%d - node[left+k-1].num_0=%d != (n-1-(left+k-1))=%d \\n\",node[n-1].num_0, node[left+k-1].num_0, (n-1-(left+k-1)));\n//            printf(\"node[n-1].num_1=%d - node[left+k-1].num_1=%d != (n-1-(left+k-1))=%d \\n\",node[n-1].num_1, node[left+k-1].num_1, (n-1-(left+k-1)));\n            if((node[n-1].num_0-node[left+k-1].num_0!=(n-1-(left+k-1)))&&(node[n-1].num_1-node[left+k-1].num_1!=(n-1-(left+k-1))))\n                flag=false;\n        }\n        if(flag&&left!=0&&left+k-1!=n-1)\n        {\n            if(node[0].item!=node[n-1].item)\n                flag=false;\n        }\n        if(flag)\n            return true;\n    }\n    return false;\n}\n\nbool judge_second()\n{\n    bool answer=true;\n    if(2*k<n||k==1)\n        return false;\n    for(int left=0;left+k-1<=n-1;left++)\n    {\n        bool temp_answer=false;\n        bool flag_1=true,flag_2=true;\n        if(left!=0)\n        {\n            if(node[left-1].num_0!=left&&node[left-1].num_1!=left)\n                flag_1=false;\n        }\n        if(left+k-1!=n-1)\n        {\n            if((node[n-1].num_0-node[left+k-1].num_0!=(n-1-(left+k-1)))&&(node[n-1].num_1-node[left+k-1].num_1!=(n-1-(left+k-1))))\n                flag_2=false;\n        }\n        if(left==0||left+k-1==n-1)\n            temp_answer=true;\n        if(left!=0&&left+k-1!=n-1&&flag_1&&flag_2)\n        {\n            if((node[0].item==0&&node[n-1].item==1)||(node[0].item==1&&node[n-1].item==0))\n                temp_answer=true;\n        }\n        if(!temp_answer)\n            answer=false;\n    }\n    return answer;\n}\n\nint main()\n{\n\n    scanf(\"%d%d\",&n,&k);\n    scanf(\"%s\",s);\n    node[0].item=s[0]-'0';\n    node[0].num_0=node[0].num_1=0;\n    if(node[0].item==0)\n        node[0].num_0++;\n    else\n        node[0].num_1++;\n    for(int i=1;i<n;i++)\n    {\n        node[i]=node[i-1];\n        node[i].item=s[i]-'0';\n        if(node[i].item==0)\n            node[i].num_0++;\n        else\n            node[i].num_1++;\n//        printf(\"node[%d].item=%d node[%d].num_0=%d node[%d].num_1=%d \\n\",i,node[i].item,i,node[i].num_0,i,node[i].num_1);\n    }\n    if(judge_first())\n        printf(\"tokitsukaze\\n\");\n    else if(judge_second())\n        printf(\"quailty\\n\");\n    else\n        printf(\"once again\\n\");\n    return 0;\n}\n\n\t\t  \t\t\t  \t\t      \t\t\t\t\t\t \t\t \t\t \t",
    "ext": "cpp"
  },
  "58159400": {
    "code": "#include <cstring>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nint n, k, pre[MAXN], suf[MAXN];\nchar s[MAXN];\n\nbool chk1() {\n\tfor (int i = 1; i <= n - k + 1; i ++) {\n\t\tint all = pre[i - 1] + suf[i + k];\n\t\tif (all == 0 || all == n - k) return 1;\n\t}\n\treturn 0;\n}\n\nbool chk_mid() {\n\tint ok = 1;\n\tfor (int i = 2; i <= n - k; i ++) {\n\t\tint h = i - 1, t = n - (i + k - 1);\n\t\tif (h > k || t > k) return 0; \n\t\tif (pre[i - 1] == i - 1 && suf[i + k] == 0 || pre[i - 1] == 0 && suf[i + k] == t) ok = 1; else\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nbool chk(int c, int lx, int rx) {\n\tint l = n + 1, r = 0;\n\tfor (int i = lx; i <= rx; i ++) {\n\t\tif (s[i] - '0' == c) l = min(l, i), r = max(r, i);\n\t}\n\tif (r - l + 1 > k) return 0;\n\treturn 1;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tscanf(\"%s\", s + 1);\n\tfor (int i = 1; i <= n; i ++) \n\t\tpre[i] = pre[i - 1] + s[i] - '0';\n\tfor (int i = n; i >= 1; i --)\n\t\tsuf[i] = suf[i + 1] + s[i] - '0';\n\tif (chk1()) {\n\t\tprintf(\"tokitsukaze\\n\");\n\t\treturn 0;\n\t}\n\tif (chk_mid() && chk(1, k + 1, n) && chk(0, k + 1, n) && chk(1, 1, n - k) && chk(0, 1, n - k)) {\n\t\tprintf(\"quailty\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"once again\\n\");\n}",
    "ext": "cpp"
  },
  "58146865": {
    "code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Solution{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        st = new StringTokenizer(br.readLine());\n        char[] c = st.nextToken().toCharArray();\n        int b = 0;\n        while(b<n&&c[b]=='0') b++;\n        int e = n-1;\n        while(e>=0&&c[e]=='0') e--;\n        int db = b,de = e;\n        if(e<b){\n            System.out.println(\"tokitsukaze\");\n        }\n        else if(e-b+1<=k) System.out.println(\"tokitsukaze\");\n        else{\n            b = 0;\n            while(b<n&&c[b]=='1') b++;\n            e = n-1;\n            while(e>=0&&c[e]=='1') e--;\n            if(e<b){\n                System.out.println(\"tokitsukaze\");\n            }\n            else if(e-b+1<=k) System.out.println(\"tokitsukaze\");\n            else{\n                if(n<=2*k){\n                    if(e-b-1>=k||de-db-1>=k) System.out.println(\"once again\");\n                    else System.out.println(\"quailty\");\n                }\n                else System.out.println(\"once again\");\n            }\n        }\n    }\n}\n\n",
    "ext": "java"
  },
  "58146857": {
    "code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Solution{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        st = new StringTokenizer(br.readLine());\n        char[] c = st.nextToken().toCharArray();\n        int b = 0;\n        while(b<n&&c[b]=='0') b++;\n        int e = n-1;\n        while(e>=0&&c[e]=='0') e--;\n        int db = b,de = e;\n        if(e<b){\n            System.out.println(\"tokitsukaze\");\n        }\n        else if(e-b+1<=k) System.out.println(\"tokitsukaze\");\n        else{\n            b = 0;\n            while(b<n&&c[b]=='1') b++;\n            e = n-1;\n            while(e>=0&&c[e]=='1') e--;\n            if(e<b){\n                System.out.println(\"tokitsukaze\");\n            }\n            else if(e-b+1<=k) System.out.println(\"tokitsukaze\");\n            else{\n                if(n<=2*k){\n                    if(e-b-1>=k||de-db-1>=k) System.out.println(\"once again\");\n                    else System.out.println(\"quailty\");\n                }\n                else System.out.println(\"once again\");\n            }\n        }\n    }\n}\n\n",
    "ext": "java"
  },
  "58134685": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nclass Game {\n private:\n    string s;\n    int left_zero = -1;\n    int right_zero = -1;\n    int left_one = -1;\n    int right_one = -1;\n    pair<int, int> get_zeroes() {\n        if (left_zero != -1) {\n            return {left_zero, right_zero};\n        }\n        for (int i = 0; i < n; ++i) {\n            if (s[i] == '0') {\n                left_zero = i;\n                break;\n            }\n        }\n        for (int i = n - 1; i >= 0; --i) {\n            if (s[i] == '0') {\n                right_zero = i;\n                break;\n            }\n        }\n        return {left_zero, right_zero};\n    }\n    pair<int, int> get_ones() {\n        if (left_one != -1) {\n            return {left_one, right_one};\n        }\n        for (int i = 0; i < n; ++i) {\n            if (s[i] == '1') {\n                left_one = i;\n                break;\n            }\n        }\n        for (int i = n - 1; i >= 0; --i) {\n            if (s[i] == '1') {\n                right_one = i;\n                break;\n            }\n        }\n        return {left_one, right_one};\n    }\n public:\n    Game (string s): s(s) {};\n\n    bool check() {\n        if (right_one - left_one - 1 >= k)\n            return false;\n        if (right_zero - left_zero - 1 >= k)\n            return false;\n        if (left_one >= k || left_zero >= k)\n            return false;\n        if (right_one < n - k  || right_zero < n - k)\n            return false;\n        return true;\n    }\n    string ans() {\n        get_ones();\n        get_zeroes();\n        if (left_one == -1 || left_zero == -1) {\n            return \"tokitsukaze\";\n        }\n        if (right_one - left_one + 1 <= k)\n            return \"tokitsukaze\";\n        if (right_zero - left_zero + 1 <= k)\n            return \"tokitsukaze\";\n        if (check()) {\n            return \"quailty\";\n        }\n        return \"once again\";\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n    cin >> n >> k;\n    string s;\n    cin >> s;\n    Game g(s);\n    cout << g.ans();\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "58084171": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long Long;\n\nconst Long MX = 1e5 + 10;\n\nLong ac[2][MX];\nset<Long> L[2];\nset<Long> R[2];\n\t\nbool puede(Long val, Long k){\n\tval = (val+1)%2;\n\tif(L[val].empty() && R[val].empty()){\n\t\treturn true;\n\t}else if(L[val].empty()){\n\t\tauto l = R[val].begin();\n\t\tauto r = R[val].end();\n\t\tr--;\n\t\tif((*r - *l) + 1 <= k){\n\t\t\treturn true;\n\t\t}\n\t}else if(R[val].empty()){\n\t\tauto l = L[val].begin();\n\t\tauto r = L[val].end();\n\t\tr--;\n\t\tif((*r - *l) + 1 <= k){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tcout.precision(10);\n\tcout << fixed;\n\t\n\tLong n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\tfor(Long i = 0; i < n; i++){\n\t\tac[0][i+1] = ac[0][i] + (s[i] == '0' ? 1 : 0);\n\t\tac[1][i+1] = ac[1][i] + (s[i] == '1' ? 1 : 0);\n\t}\n\t\n\tfor(Long i = k; i <= n; i++){\n\t\tif((n == k + ac[0][i-k] + ac[0][n] - ac[0][i]) || (n == k + ac[1][i-k] + ac[1][n] - ac[1][i])){\n\t\t\tcout << \"tokitsukaze\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tfor(Long i = k-1; i < n; i++){\n\t\tif(s[i] == '0'){\n\t\t\tR[0].insert(i);\n\t\t}else{\n\t\t\tR[1].insert(i);\n\t\t}\n\t}\n\tbool ok = true;\n\tfor(Long i = k-1; i < n; i++){\n\t\tif(s[i] == '0'){\n\t\t\tR[0].erase(i);\n\t\t}else{\n\t\t\tR[1].erase(i);\n\t\t}\n\t\tok = ok & puede(0,k);\n\t\tok = ok & puede(1,k);\n\t\tif(s[i+1-k] == '0'){\n\t\t\tL[0].insert(i);\n\t\t}else{\n\t\t\tL[1].insert(i);\n\t\t}\n\t}\n\tif(ok){\n\t\tcout << \"quailty\\n\";\n\t}else{\n\t\tcout << \"once again\\n\";\n\t}\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "58081318": {
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<algorithm>\n#include<iostream>\n#include<numeric>\n#include<iomanip>\n#include<cassert>\n#include<chrono>\n#include<string>\n#include<vector>\n#include<random>\n#include<cmath>\n#include<ctime>\n#include<deque>\n#include<queue>\n#include<array>\n#include<set>\n#include<map>\n\nusing namespace std;\n\ntypedef long long ll;\n\nvoid tokitsukaze() {\n\tprintf(\"tokitsukaze\\n\");\n\texit(0);\n}\n\nvoid quailty() {\n\tprintf(\"quailty\\n\");\n\texit(0);\n}\n\nvoid draw() {\n\tprintf(\"once again\\n\");\n\texit(0);\n}\n\nconst int mx = 202020;\n\nchar a[mx];\nint n, k;\nvector<int> one, zer;\n\nbool wins0(int i) {\n\tif(one[0] < i && one.back() > i + k - 1) {\n\t\treturn false;\n\t}\n\tif(one[0] >= i) {\n\t\tint j = upper_bound(one.begin(), one.end(), i + k - 1) -  one.begin();\n\t\treturn (one.back() - one[j] < k);\n\t} else {\n\t\tint j = upper_bound(one.rbegin(), one.rend(), i, greater<int>()) - one.rbegin();\n\t\tj = (int)one.size() - j - 1;\n\t\treturn (one[j] - one[0] < k);\n\t}\n}\n\nbool wins1(int i) {\n\tif(zer[0] < i && zer.back() >  i + k - 1) {\n\t\treturn false;\n\t}\n\tif(zer[0] >= i) {\n\t\tint j = upper_bound(zer.begin(), zer.end(), i + k - 1) - zer.begin();\n\t\treturn (zer.back() - zer[j] < k);\n\t} else {\n\t\tint j = upper_bound(zer.rbegin(), zer.rend(), i, greater<int>()) - zer.rbegin();\n\t\tj = (int)zer.size() - j - 1;\n\t\treturn (zer[j] - zer[0] < k);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d %s\", &n, &k, a);\n\tfor(int i = 0; i < n; i++) {\n\t\tif(a[i] == '1') {\n\t\t\tone.push_back(i);\n\t\t} else {\n\t\t\tzer.push_back(i);\n\t\t}\n\t}\n\tif(one.empty() || zer.empty() || one.back() - one[0] < k || zer.back() - zer[0] < k) {\n\t\ttokitsukaze();\n\t}\n\tif(k == 1) {\n\t\tdraw();\n\t}\n\tbool everytime_wins = true;\n\tfor(int i = 0; i < n - k + 1; i++) {\n\t\teverytime_wins &= wins0(i);\n\t\teverytime_wins &= wins1(i);\n\t}\n\tif(everytime_wins) {\n\t\tquailty();\n\t}\n\tdraw();\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "58038755": {
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=100005;\nint n,k;\nchar str[MAXN];\nvector<int> loc[2];\nint main()\n{\n    scanf(\"%d%d%s\",&n,&k,str);\n    for(int i=0;i<n;i++)\n        loc[str[i]-'0'].push_back(i);\n    if(loc[0].empty() || loc[1].empty())\n        return 0*printf(\"tokitsukaze\\n\");\n    int flag=0;\n    for(int l=0,r=k-1;r<n;l++,r++)\n    {\n        vector<int> tmp[2];\n        for(int i=0;i<2;i++)\n        {\n            if(loc[i].front()<l || loc[i].front()>r)\n                tmp[i].push_back(loc[i].front());\n            if(loc[i].back()<l || loc[i].back()>r)\n                tmp[i].push_back(loc[i].back());\n            auto itr=lower_bound(loc[i].begin(),loc[i].end(),l);\n            if(itr!=loc[i].begin())\n                tmp[i].push_back(*--itr);\n            itr=upper_bound(loc[i].begin(),loc[i].end(),r);\n            if(itr!=loc[i].end())\n                tmp[i].push_back(*itr);\n            sort(tmp[i].begin(),tmp[i].end());\n        }\n        if(tmp[0].empty() || tmp[1].empty())\n            return 0*printf(\"tokitsukaze\\n\");\n        flag|=(tmp[0].back()-tmp[0].front()>=k\n            || tmp[1].back()-tmp[1].front()>=k);\n    }\n    return 0*printf(\"%s\\n\",(flag ? \"once again\" : \"quailty\"));\n}\n",
    "ext": "cpp"
  },
  "57993600": {
    "code": "<?php\n#1190C\n$start = microtime(1);\n[$n, $k] = explode(' ', trim(fgets(STDIN)));\n$str = trim(fgets(STDIN));\nfor ($i = 0; $i < $n; $i++) {\n    if ($str[$i] === '0') {\n        $firstZero = $firstZero ?? $i;\n        $lastZero = $i;\n    } else {\n        $firstOne = $firstOne ?? $i;\n        $lastOne = $i;\n    }\n}\n$deltaZero = $lastZero - $firstZero;\n$deltaOne = $lastOne - $firstOne;\nif (min($deltaZero, $deltaOne) < $k) {\n    echo 'tokitsukaze';\n} elseif (max($deltaZero, $deltaOne) > $k) {\n    echo 'once again';\n} else {\n    $amountZero = 0;\n    $amountOne = 0;\n    for ($i = 0; $i < $n; $i++) {\n        if ($str[$i] === '0') {\n            $amountZero++;\n            $amountOne = 0;\n        } else {\n            $amountZero = 0;\n            $amountOne++;\n        }\n        if (max($amountZero, $amountOne) >= $k) {\n            die('once again');\n        }\n    }\n    echo 'quailty';\n}\n",
    "ext": ""
  },
  "57988136": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint n,k;\n\tstring a;\n\tint z[2], o[2];\n\tz[0]=z[1]=o[0]=o[1]=-1;\n\n\tcin>>n>>k;\n\tcin>>a;\n\tfor(int i=0; i<n; ++i) {\n\t\tif(a[i] == '0') {\n\t\t\tif(z[0] == -1) {\n\t\t\t\tz[0] = i;\n\t\t\t} else {\n\t\t\t\tz[1] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(a[i] == '1') {\n\t\t\tif(o[0] == -1) {\n\t\t\t\to[0] = i;\n\t\t\t} else {\n\t\t\t\to[1] = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(z[1] - z[0] <= k-1 || o[1] - o[0] <= k-1) {\n\t\tcout<<\"tokitsukaze\";\n\t\treturn 0;\n\t}\n\t\n\tint start=1, end=n-2;\n\twhile(start < n) {\n\t\tif(a[start] == a[start-1]) {\n\t\t\tstart++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\twhile(end >= 0) {\n\t\tif(a[end] == a[end+1]) {\n\t\t\tend--;\n\t\t} else{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif( (k >= n/2) && (start+1>n-k-1) && ((n-end)>n-k-1) ) {\n\t\tcout<<\"quailty\";\n\t} else {\n\t\tcout<<\"once again\";\n\t}\n\t// your code goes here\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57980073": {
    "code": "\ufeff#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <set>\n#include <map>\n#include <string>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <iterator>\n#include <cmath>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <chrono>\n#include <assert.h>\n#include <memory>\n#include <cstddef>\n#include <iterator>\n\n#pragma comment(linker, \"/stack:20000000\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n\nusing namespace std;\ntypedef int mt;\ntypedef double fl;\n\ntemplate<typename T>\nconstexpr mt infValue = std::numeric_limits<T>::max() - 1000;\ntemplate<typename T>\nconstexpr mt maxValue = std::is_same<T, int>::value ? 1000000007 : 1000000000000000001ll;\n\n#define rep(a, b, i) for(mt i = a; i < b; ++i)\n#define repe(a, b, i) for(mt i = a; i <= (b); ++i)\n#define repd(a, b, i) for(mt i = a; i > b; --i)\n#define repde(a, b, i) for(mt i = a; i >= b; --i)\n\nconst mt INF = infValue<mt>;\nconst long long MOD = 1000000007ll;\nconst double EPS = 1e-6;\nconst mt MAX = maxValue<mt>;\nusing pr = pair<mt, mt>;\n\n#define N 100020\n#define K 5\n#define P 3\n#define M (N * N)\n#define p2(x) ((((x) * (x)) % (MOD)))\n#define mxy(x, y) ((((x) * (y)) % (MOD)))\n#define p2p(x) ((((x) * (x))))\n\nmt n, k;\nchar s[N], t[N];\nmt d0 = 0, d1 = 0;\n\ninline bool check_first() {\n\tif (s[0] == s[n - 1]) return d0 + d1 + k >= n;\n\telse return max(d0, d1) + k >= n;\n}\n\ninline bool check_second() {\n\treturn s[0] != s[n - 1] && n - (d0 + d1) <= k && 1 + k + d0 >= n && 1 + k + d1 >= n && max(d0, d1) < k;\n}\n\nint main(void) {\n#ifdef _DEBUG\n\tfreopen(\"in.txt\", \"r\", stdin);\n#endif\n\tscanf(\"%d %d\", &n, &k);\n\tscanf(\"%s\", s);\n\n\twhile (s[d0] == s[0]) ++d0;\n\twhile (d1 < n && s[n - 1 - d1] == s[n - 1]) ++d1;\n\n\tif (check_first()) puts(\"tokitsukaze\");\n\telse if (check_second()) puts(\"quailty\");\n\telse puts(\"once again\");\n\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57980016": {
    "code": "\ufeff#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <set>\n#include <map>\n#include <string>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <iterator>\n#include <cmath>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <chrono>\n#include <assert.h>\n#include <memory>\n#include <cstddef>\n#include <iterator>\n\n#pragma comment(linker, \"/stack:20000000\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n\nusing namespace std;\ntypedef int mt;\ntypedef double fl;\n\ntemplate<typename T>\nconstexpr mt infValue = std::numeric_limits<T>::max() - 1000;\ntemplate<typename T>\nconstexpr mt maxValue = std::is_same<T, int>::value ? 1000000007 : 1000000000000000001ll;\n\n#define rep(a, b, i) for(mt i = a; i < b; ++i)\n#define repe(a, b, i) for(mt i = a; i <= (b); ++i)\n#define repd(a, b, i) for(mt i = a; i > b; --i)\n#define repde(a, b, i) for(mt i = a; i >= b; --i)\n\nconst mt INF = infValue<mt>;\nconst long long MOD = 1000000007ll;\nconst double EPS = 1e-6;\nconst mt MAX = maxValue<mt>;\nusing pr = pair<mt, mt>;\n\n#define N 100020\n#define K 5\n#define P 3\n#define M (N * N)\n#define p2(x) ((((x) * (x)) % (MOD)))\n#define mxy(x, y) ((((x) * (y)) % (MOD)))\n#define p2p(x) ((((x) * (x))))\n\nmt n, k;\nchar s[N], t[N];\nmt d0 = 0, d1 = 0;\n\ninline bool check_first() {\n\tif (s[0] == s[n - 1]) return d0 + d1 + k >= n;\n\telse return max(d0, d1) + k >= n;\n}\n\ninline bool check_second() {\n\tif (s[0] == s[n - 1]) return false;\n\telse return n - (d0 + d1) <= k && 1 + k + d0 >= n && 1 + k + d1 >= n && max(d0, d1) < k;\n}\n\nint main(void) {\n#ifdef _DEBUG\n\tfreopen(\"in.txt\", \"r\", stdin);\n#endif\n\tscanf(\"%d %d\", &n, &k);\n\tscanf(\"%s\", s);\n\n\twhile (s[d0] == s[0]) ++d0;\n\twhile (d1 < n && s[n - 1 - d1] == s[n - 1]) ++d1;\n\n\tif (check_first()) puts(\"tokitsukaze\");\n\telse if (check_second()) puts(\"quailty\");\n\telse puts(\"once again\");\n\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57979924": {
    "code": "\ufeff#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <set>\n#include <map>\n#include <string>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <iterator>\n#include <cmath>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <chrono>\n#include <assert.h>\n#include <memory>\n#include <cstddef>\n#include <iterator>\n\n#pragma comment(linker, \"/stack:20000000\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n\nusing namespace std;\ntypedef int mt;\ntypedef double fl;\n\ntemplate<typename T>\nconstexpr mt infValue = std::numeric_limits<T>::max() - 1000;\ntemplate<typename T>\nconstexpr mt maxValue = std::is_same<T, int>::value ? 1000000007 : 1000000000000000001ll;\n\n#define rep(a, b, i) for(mt i = a; i < b; ++i)\n#define repe(a, b, i) for(mt i = a; i <= (b); ++i)\n#define repd(a, b, i) for(mt i = a; i > b; --i)\n#define repde(a, b, i) for(mt i = a; i >= b; --i)\n\nconst mt INF = infValue<mt>;\nconst long long MOD = 1000000007ll;\nconst double EPS = 1e-6;\nconst mt MAX = maxValue<mt>;\nusing pr = pair<mt, mt>;\n\n#define N 100020\n#define K 5\n#define P 3\n#define M (N * N)\n#define p2(x) ((((x) * (x)) % (MOD)))\n#define mxy(x, y) ((((x) * (y)) % (MOD)))\n#define p2p(x) ((((x) * (x))))\n\nmt n, k;\nchar s[N], t[N];\n\nbool check_first() {\n\tmt d0 = 0, d1 = 0;\n\twhile (s[d0] == s[0]) ++d0;\n\twhile (d1 < n && s[n - 1 - d1] == s[n - 1]) ++d1;\n\n\tif (s[0] == s[n - 1]) return d0 + d1 + k >= n;\n\telse return max(d0, d1) + k >= n;\n}\n\nbool check_second() {\n\tmt d0 = 0, d1 = 0;\n\twhile (s[d0] == s[0]) ++d0;\n\twhile (d1 < n && s[n - 1 - d1] == s[n - 1]) ++d1;\n\n\tif (s[0] == s[n - 1]) return false;\n\telse {\n\t\t//return k + min(d0, d1) >= n;\n\t\tif (max(d0, d1) >= k) return false;\n\t\treturn n - (d0 + d1) <= k && 1 + k + d0 >= n && 1 + k + d1 >= n;\n\t\t//d0 + k == n - 1\n\n\t}\n\n\t/*bool v = false;\n\tmemcpy(t, s, n);\n\tmt d0 = k, d1 = 0;\n\trep(0, n - k, i) {\n\t\t\n\t}*/\n}\n\nint main(void) {\n#ifdef _DEBUG\n\tfreopen(\"in.txt\", \"r\", stdin);\n#endif\n\tscanf(\"%d %d\", &n, &k);\n\tscanf(\"%s\", s);\n\tif (check_first()) puts(\"tokitsukaze\");\n\telse if (check_second()) puts(\"quailty\");\n\telse puts(\"once again\");\n\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57953577": {
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,k;\n    cin>>n>>k;\n    string s;\n    cin>>s;\n    int lz=n,rz=-1;\n    int lo=n,ro=-1;\n    int cz=0,co=0;\n    for(int i=0;i<n;i++){\n        if(s[i]=='0'){\n            lz = min(lz, i);\n            rz = max(rz, i);\n            cz++;\n        }else{\n            lo = min(lo, i);\n            ro = max(ro, i);\n            co++;\n        }\n    }\n    //checking if tokitsukaze wins\n    // cout<<\"lz rz\"<<lz<<' '<<rz<<endl;\n    // cout<<\"lo ro\"<<lo<<' '<<ro<<endl;\n    if(rz>=lz && rz - lz + 1<=k || ro>=lo && ro - lo + 1<=k || co==n || cz==n){\n        cout<<\"tokitsukaze\"<<endl;\n        return 0;\n    }\n    \n    //toki trying to find a move in which quality loses\n    set<int> zi,oi;\n    for(int i=0;i<n;i++){\n        if(s[i]=='0') zi.insert(i);\n        else oi.insert(i);\n    }\n    //toki trying to convert to zeros\n    for(int i=0;i+k<=n;i++){\n        // int tlz = min(lz,i);\n        // int trz = max(rz, i+k-1);\n        int tlo = *oi.begin();\n        int tro = *(--oi.end());\n        if(i<=tlo && tlo<=i+k-1){\n            tlo = *(oi.upper_bound(i+k-1));\n        }\n        else if(i<=tro && tro<=i+k-1){\n            tro = *(--oi.lower_bound(i));\n        }\n        if(tro-tlo+1>k){\n            cout<<\"once again\"<<endl;\n            return 0;\n        }\n    }\n    //toki trying to convert to ones\n    for(int i=0;i+k<=n;i++){\n        int tlz = *(zi.begin());\n        int trz = *(--zi.end());\n        if(i<=tlz && tlz<=i+k-1){\n            tlz = *(zi.upper_bound(i+k-1));\n        }\n        else if(i<=trz && trz<=i+k-1){\n            trz = *(--zi.lower_bound(i));\n        }\n        if(trz - tlz + 1 > k){\n            cout<<\"once again\"<<endl;\n            return 0;\n        }\n    }\n    //quatily wins\n    cout<<\"quailty\"<<endl;\n    return 0;\n}",
    "ext": "cpp"
  },
  "57952977": {
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#define all(x) x.begin(),x.end()\n#define len(x) (int)(x).size()\n#define m_p make_pair\n#define int long long\n\n/*\n#pragma GCC omptimize(\"unroll-loops\")\n#pragma optimize(\"SEX_ON_THE_BEACH\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma comment(linker, \"/STACK:1000000000\")\n*/\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pari;\n\nld PI = 3.14159265358979323846;\n\n\nstruct Point{\n    string a;\n    int x,ind;\n};\n\ntypedef tree<int, null_type, less<int >,\n    rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nvoid volodya22(){\n    #ifdef THERE\n        freopen(\"input.txt\", \"r\", stdin);\n    //    freopen(\"output.txt\", \"w\", stdout);\n    #else\n        //#define endl \"\\n\"\n    #endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    //cout.precision(15);\n    //cout << fixed;\n}\n\n\nint n,k;\nconst int N = 1e6+7;\nconst int alphabet = 256;\nconst int INF = 1e18+7;\nconst ll MOD = 1e9+7;\nconst ld eps = 1e-10;\nconst int L = 30;\n\nint m1 = 137*137*137*137*13;\nint m2 = 1e9+9;\n//int p = 347;\n\nint arr[N];\nint pref[N];\n\nvoid input(){\n    cin >> n >> k;\n    for(int i = 0;i < n;i++){\n        char a;\n        cin >> a;\n        arr[i] = a-'0';\n    }\n    for(int i = 0;i < n;i++)\n        pref[i+1] = pref[i]+arr[i];\n\n    for(int i = 1;i+k-1 <= n;i++){\n        //cout << i << ' ' << pref[n] << endl;\n        if(pref[i-1] == 0 && pref[n]-pref[i+k-1] == 0){\n            cout << \"tokitsukaze\" << endl;\n            exit(0);\n        }\n        if(pref[i-1] == i-1 && pref[n]-pref[i+k-1] == n-k-i+1){\n            cout << \"tokitsukaze\";\n            exit(0);\n        }\n    }\n\n    bool b = 1;\n\n    for(int i = 1;i+k-1 <= n;i++){\n            if(pref[i-1] == 0 && pref[n]-pref[i+k-1] == n-k-i+1\n               && n-k-i-1 <= k && i-1 <= k){\n\n            }\n            else if(pref[i-1] == i-1 && pref[n]-pref[i+k-1] == 0\n                    && n-k-i-1 <= k && i-1 <= k){\n\n            }else if(i == 1){\n                if(n-k-i+1 <= k) continue;\n                bool d = 0;\n                for(int j = k+1;j+k-1 <= n;j++){\n                    if(pref[j-1]-pref[k] == j-i && pref[n]-pref[j+k-1] == n-k-j+1)\n                        d = 1;\n                    else if(pref[j-1]-pref[k] == 0 && pref[n]-pref[j+k-1] == 0)\n                        d = 1;\n                }\n                b = min(d,b);\n            }else if(i+k-1 == n){\n                if(i-1 <= k) continue;\n                bool d = 0;\n                int p = n-k;\n                for(int j = 1;j+k-1 <= p;j++){\n                    if(pref[j-1] == 0 && pref[p]-pref[j+k-1] == 0)\n                        d = 1;\n                    else if(pref[j-1] == j-1 && pref[p]-pref[j+k-1] == p-k-j+1)\n                        d = 1;\n                }\n                b = min(d,b);\n            }else b = 0;\n    }\n\n    if(b){\n        cout << \"quailty\";\n        exit(0);\n    }\n    cout << \"once again\";\n}\n\n\nvoid solve(){\n\n}\n\nsigned main(){\n    volodya22();\n    input();\n    solve();\n}\n",
    "ext": "cpp"
  },
  "57935895": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\n\nchar shit[maxn];\nint sum[maxn];\nint main()\n{\n    int n, k;\n    scanf(\"%d%d\", &n, &k);\n    scanf(\"%s\", shit);\n    sum[0] = 0;\n    for(int i=0; i<=n; i++)\n    {\n        sum[i] = sum[i-1];\n        if(shit[i-1] == '1')\n            sum[i]++;\n    }\n    // wether the first could win\n    bool couldwin = 0;\n    for(int i=k; i<=n; i++)\n    {\n        if(sum[n] == sum[i] && sum[i - k] == 0){\n            couldwin = 1;\n            break;\n        }\n        if(sum[n] - sum[i] == n - i && sum[i-k] == i-k){\n            couldwin = 1;\n            break;\n        }\n    }\n    if(couldwin){\n        puts(\"tokitsukaze\");\n        return 0;\n    }\n    for(int i=k+1; i<n; i++)\n    {\n        if(sum[i-k] && sum[n]!=sum[i]){\n            couldwin = 1;\n            break;\n        }\n        if(sum[i-k]!=i-k && sum[n] - sum[i] != n - i){\n            couldwin = 1;\n            break;\n        }\n    }\n\n\n    int lone, rone;\n    int lzero, rzero;\n\n    rzero = -1;\n    rone = -1;\n\n    for(int i=n; i>k; i--)\n    {\n        if(shit[i-1] == '1'){\n            lone = i;\n            if(rone==-1) rone = i;\n        }\n        if(shit[i-1] == '0'){\n            lzero = i;\n            if(rzero==-1) rzero = i;\n        }\n    }\n    if(rone - lone +1 > k) couldwin = 1;\n    if(rzero - lzero + 1 > k) couldwin = 1;\n\n\n    lone = lzero = -1;\n    for(int i=1; i<= n - k; i ++ )\n    {\n        if(shit[i-1] == '1'){\n            rone = i;\n            if(lone==-1) lone = i;\n        }\n        if(shit[i-1] == '0'){\n            rzero = i;\n            if(lzero == -1) lzero = i;\n        }\n\n    }\n    if(rone - lone +1 > k) couldwin = 1;\n    if(rzero - lzero + 1 > k) couldwin = 1;\n    if(couldwin){\n        puts(\"once again\");\n    }\n    else{\n        puts(\"quailty\");\n    }\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57930713": {
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,k;\nint a[100001],s[100001];\nbool check1 ()\n{\n\tfor (int i=1;i+k-1<=n;i++)\n\t{\n\t\tint sum=s[n]-s[i+k-1]+s[i-1];\n\t\tif (sum==0 || sum==n-k) return 1;\n\t}\n\treturn 0;\n}\nbool check2 ()\n{\n\tif (k*2<n || k==1) return 0;\n\tfor (int i=2;i<=n-k-1;i++)\n\tif (a[i-1]!=a[i] || a[n-i+2]!=a[n-i+1]) return 0;\n\tif (a[n-k]==a[n-k-1] || a[k+1]==a[k+2] || a[1]==a[n]) return 0;\n\treturn 1;\n}\nchar c;\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tgetchar();\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tc=getchar();\n\t\tif (c=='1') a[i]=1;\n\t\ts[i]=s[i-1]+a[i];\n//\t\tprintf(\"%d\\n\",a[i]);\n\t}\n\tif (check1()) return puts(\"tokitsukaze\"),0;\n\t\telse if (check2()) return puts(\"quailty\"),0;\n\t\t\telse return puts(\"once again\"),0;\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57872636": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nchar s[100100];\nint pre[100100];int n,k;\nint jud(){\n\tfor(int i=1;i<=n-k+1;i++){\n\t\tint tmp=pre[i-1]+pre[n]-pre[i+k-1];\n\t\tif(tmp==0 || tmp==n-k) return 1;\n\t}\n\treturn 0;\n}\nint sec(){\n\tif(k*2<n) return 0;\n\tint lim=n-k-1; \n\tfor(int i=2;i<=lim;i++){\n\t\tif(s[i]!=s[i-1] || s[n-i+1]!=s[n-i+2]) return 0;\n\t}\n\treturn 1;\n}\nint main(){\t\n\tscanf(\"%d%d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=n;i++){\n\t\tpre[i]=pre[i-1]+s[i]-'0';\n\t}\n\tif(jud()){\n\t\tprintf(\"tokitsukaze\\n\");\n\t}\n\telse{\n\t\tif(sec()){\n\t\t\tprintf(\"quailty\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"once again\\n\");\n\t\t}\n\t}\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57826456": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tstring str;\n\tcin >> str;\n\tint** ptr = new int*[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tptr[i] = new int[4];\n\t}\n\tptr[0][0] = str[0] == '0' ? 0 : -1;\n\tptr[0][1] = str[0] == '1' ? 0 : -1;\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int k = 0; k < 2; k++) {\n\t\t\tptr[i][k] = str[i] == '0' + k ? i : ptr[i - 1][k];\n\t\t}\n\t}\n\tptr[n - 1][2] = str[n - 1] == '0' ? n - 1 : n;\n\tptr[n - 1][3] = str[n - 1] == '1' ? n - 1 : n;\n\tfor (int i = n - 2; i >= 0; i--) {\n\t\tfor (int k = 0; k < 2; k++) {\n\t\t\tptr[i][k + 2] = str[i] == '0' + k ? i : ptr[i + 1][k + 2];\n\t\t}\n\t}\n\t// if (ptr[0][2] == n || ptr[0][3] == n) {\n\t// \tcout << \"tokitsukaze\" << endl;\n\t// \treturn 0;\n\t// }\n\tbool quailty = true;\n\tfor (int i = 0; i <= n - m; i++) {\n\t\tint j = i + m - 1;\n\t\tfor (int k = 0; k < 2; k++) {\n\t\t\tint rk = k ^ 1;\n\t\t\tint l = ptr[0][rk + 2];\n\t\t\tif (l >= i) {\n\t\t\t\tl = j < n - 1 ? ptr[j + 1][rk + 2] : n;\n\t\t\t}\n\t\t\tint r = ptr[n - 1][rk];\n\t\t\tif (r <= j) {\n\t\t\t\tr = i ? ptr[i - 1][rk] : -1;\n\t\t\t}\n\t\t\t// printf(\"%d %d: %d %d %d\\n\", i, j, k, l, r);\n\t\t\tif (r - l + 1 > m) {\n\t\t\t\tquailty = false;\n\t\t\t}\n\t\t\tif (r < l) {\n\t\t\t\tcout << \"tokitsukaze\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (quailty) {\n\t\tcout << \"quailty\" << endl;\n\t} else {\n\t\tcout << \"once again\" << endl;\n\t}\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57810545": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nint n, k;\nint v[2][2]; // v[i]: leftmost and rightmost cards in state i\nint cur[2];\nbool draw;\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n#ifdef _DEBUG\n  freopen(\"input.txt\", \"r\", stdin);\n  freopen(\"output.txt\", \"w\", stdout);\n  freopen(\"debug_output.txt\", \"w\", stderr);\n#endif\n\n\n  cin >> n >> k;\n  v[0][0] = v[1][0] = n;\n  v[0][1] = v[1][1] = -1;\n  draw = false;\n  for (int i = 0; i < n; i++) {\n    char c;\n    cin >> c;\n    int a = c - '0';\n    v[a][0] = min(v[a][0], i);\n    v[a][1] = max(v[a][1], i);\n    cur[a]++;\n    if (cur[a] == k) {\n      draw = true;\n    }\n    cur[a ^ 1] = 0;\n  }\n  for (int i = 0; i <= 1; i++) {\n    if (v[i][1] == -1 || v[i][1] - v[i][0] + 1 <= k) {\n      cout << \"tokitsukaze\\n\"; // wins in one move\n      return 0;\n    }\n  }\n  for (int i = 0; i <= 1; i++) {\n    if (v[i][1] - v[i][0] + 1 >= k + 2 || (v[i][0] >= k && v[i][1] < n - k)) {\n      draw = true; // first player can force a draw\n    }\n  }\n  cout << (draw ? \"once again\" : \"quailty\") << '\\n';\n\n\n  return 0;\n}\n",
    "ext": "cpp"
  },
  "57810245": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n#ifdef _DEBUG\n  freopen(\"input.txt\", \"r\", stdin);\n  freopen(\"output.txt\", \"w\", stdout);\n  freopen(\"debug_output.txt\", \"w\", stderr);\n#endif\n\n\n  int n, k;\n  cin >> n >> k;\n  int ends[2][2] = {{n, -1}, {n, -1}}; // ends[i]: leftmost and rightmost cards in state i\n  int cur[2];\n  bool draw = false;\n  for (int i = 0; i < n; i++) {\n    char c;\n    cin >> c;\n    int a = c - '0';\n    ends[a][0] = min(ends[a][0], i);\n    ends[a][1] = max(ends[a][1], i);\n    cur[a]++;\n    if (cur[a] == k) {\n      draw = true;\n    }\n    cur[a ^ 1] = 0;\n  }\n  for (int i = 0; i <= 1; i++) {\n    if (ends[i][1] == -1 || ends[i][1] - ends[i][0] + 1 <= k) {\n      cout << \"tokitsukaze\\n\"; // wins in one move\n      return 0;\n    }\n  }\n  for (int i = 0; i <= 1; i++) {\n    if (ends[i][1] - ends[i][0] + 1 >= k + 2 || (ends[i][0] >= k && ends[i][1] < n - k)) {\n      draw = true; // first player can force a draw\n    }\n  }\n  cout << (draw ? \"once again\" : \"quailty\") << '\\n';\n\n\n  return 0;\n}\n",
    "ext": "cpp"
  },
  "57781784": {
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace Flandle_Scarlet\n{\n    #define N 300100\n    #define p_b push_back\n    int n,k;\n    int s[N];\n    void Input()\n    {\n        cin>>n>>k;\n        char c=getchar();\n        while(c!='0' and c!='1') c=getchar();\n        int len=0;\n        while(c=='0' or c=='1') s[++len]=c-'0',c=getchar();\n    }\n\n    int l0,l1,r0,r1;\n    void Soviet()\n    {\n        l0=l1=0;\n        for(int i=1;i<=n;++i)\n        {\n            if (s[i]==0)\n            {\n                if (!l0) l0=i;\n                r0=i;\n            }\n            if (s[i]==1)\n            {\n                if (!l1) l1=i;\n                r1=i;\n            }\n        }\n\n//        printf(\"%d %d %d %d\\n\",l0,r0,l1,r1);\n        if (r0-l0<k or r1-l1<k)\n        {\n            puts(\"tokitsukaze\");\n            return;\n        }\n        int cxk[4];\n        cxk[0]=l0;\n        cxk[1]=r0;\n        cxk[2]=l1;\n        cxk[3]=r1;\n        sort(cxk,cxk+4);\n        if (cxk[3]-cxk[1]<=k and cxk[2]-cxk[0]<=k)\n        {\n            puts(\"quailty\");\n        }\n        else puts(\"once again\");\n    }\n    void IsMyWife()\n    {\n        if (0)\n        {\n            freopen(\"\",\"r\",stdin);\n            freopen(\"\",\"w\",stdout);\n        }\n        Input();\n        Soviet();\n    }\n};\nint main()\n{\n    Flandle_Scarlet::IsMyWife();\n    return 0;\n}\n\n  \t  \t\t   \t   \t\t\t\t  \t  \t  \t\t\t",
    "ext": "cpp"
  },
  "57769479": {
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class E {\n\n\tvoid run() {\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt();\n\n\t\t// player 1 win with 1 move\n\t\t\t// max(d) - min(d) + 1 >= k, for d = 0 or d = 1\n\t\t// player 2 -> \n\t\t\t// win with 1 move\n\t\t\t// draw\n\n\t\t//v[i][prefix|suffix][d][min|max]\n\t\tint v[][][][] = new int[n+1][2][2][2];\n\t\tString ss = in.next();\t\t\n\t\tchar a[] = ss.toCharArray();\n\t\tint i, d;\n\n\t\tfor(int t=0;t<2;t++){\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\tfor(d=0;d<2;d++){\t\t\t\t\t\n\t\t\t\t\tv[i][t][d][0] = v[i-1][t][d][0];\n\t\t\t\t\tv[i][t][d][1] = v[i-1][t][d][1];\n\t\t\t\t}\n\t\t\t\td = a[i-1] - '0';\n\t\t\t\tif(v[i][t][d][0] == 0)\n\t\t\t\t\tv[i][t][d][0] = (t == 0 ? i : n-i+1);\n\t\t\t\tv[i][t][d][1] = (t == 0 ? i : n-i+1);\n\t\t\t}\n\t\t\ta = new StringBuffer(ss).reverse().toString().toCharArray();\n\t\t}\n\n\t\tboolean canWin = false, canDraw = false;\n\n\t\tfor(i=1; i + k - 1 <= n; i++){\n\t\t\tint j = i+k-1; //move [i,j]\n\t\t\t// win move for A?\n\t\t\tfor(d=0;d<2;d++){\n\t\t\t\tint minP = v[i-1][0][1-d][0];\n\t\t\t\tif(minP == 0)\n\t\t\t\t\tminP = v[n-j][1][1-d][1];\n\t\t\t\tint maxP = v[n-j][1][1-d][0];\n\t\t\t\tif(maxP == 0)\n\t\t\t\t\tmaxP = v[i-1][0][1-d][1];\n\t\t\t\t\n\t\t\t\tif(minP == 0)\n\t\t\t\t\tcanWin = true;\n\t\t\t\tif(maxP - minP + 1 > k)\n\t\t\t\t\tcanDraw = true;\n\t\t\t}\n\t\t}\n\t\tString ans;\n\t\tif(canWin)\n\t\t\tans = \"tokitsukaze\";\n\t\telse if(canDraw)\n\t\t\tans = \"once again\";\n\t\telse\n\t\t\tans = \"quailty\";\n\t\t\n\t\tout.println(ans);\n\t\t\n\t}\n\t\n\tstatic MyScanner in;\n\tstatic PrintWriter out;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tboolean stdStream = true;\n\t\tif(stdStream){\n\t\t\tin = new MyScanner();\n\t\t\tout = new PrintWriter(System.out);\n\t\t}else{\n\t\t\tString fileName = E.class.getSimpleName();\n\t\t\tint n_test = 1;\t\t\t\n\t\t\tString inputFileName = fileName + String.format(\".%02d\", n_test) + \".inp\";\n\t\t\tString outputFileName = fileName + String.format(\".%02d\", n_test) + \".out\";\n\t\t\tin = new MyScanner(new BufferedReader(new FileReader(inputFileName)));\n\t\t\tout = new PrintWriter(outputFileName);\n\t\t}\n\t\t\t\n\t\tnew E().run();\n\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n        MyScanner(){\n            this.br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n\t\tMyScanner(BufferedReader br) {\n\t\t\tthis.br = br;\n        }\n\n        void close() throws IOException {\n            br.close();\n        }\n        \n\t\tvoid findToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tString next() {\n\t\t\tfindToken();\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}",
    "ext": "java"
  },
  "57741094": {
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\nint k, n;\nstring s;\nconst int mxn = (1e5) + 5;\nint prl[2][mxn];\nint prr[2][mxn];\nint sul[2][mxn];\nint sur[2][mxn];\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    cin>>s;\n    int l[2] = {-1, -1};\n    int r[2] = {-1, -1};\n    for(int i = 0 ; i < n ; ++i)\n    {\n        int e = s[i] - '0';\n        if(l[e] == -1)l[e] = i;\n        r[e] = max(r[e], i);\n        for(int j = 0 ; j <= 1; ++j)\n        {\n            prl[j][i] = l[j];\n            prr[j][i] = r[j];\n        }\n    }\n    l[0] = l[1] = n;\n    r[0] = r[1] = -1;\n    for(int i = n - 1 ; i >= 0 ; i--)\n    {\n        int e = s[i] - '0';\n        if(r[e] == -1)r[e] = i;\n        l[e] = min(l[e], i);\n        for(int j = 0 ; j <= 1 ; ++j)\n        {\n            sur[j][i] = r[j];\n            sul[j][i] = l[j];\n        }\n    }\n    if(prr[0][n - 1] - prl[0][n - 1] + 1 <= k || prr[1][n - 1] - prl[1][n - 1] + 1 <= k)\n    {\n        puts(\"tokitsukaze\");\n        return 0;\n    }\n    delete(l);\n    delete(r);\n\n    bool lose = true;\n    for(int l = 0 ; l <= n - k ; ++l)\n    {\n        int c[2] = {0};\n        bool less_than_k[2]={0};\n        if(l > 0)\n        {\n            for(int e = 0 ; e <= 1 ; ++e)\n            {\n                if(prr[e][l - 1] != -1)\n                {\n                    ++c[e];\n                    less_than_k[e] |= ((prr[e][l - 1] - prl[e][l - 1] + 1) <= k);\n                }\n            }\n        }\n        int r = l + k - 1;\n        if(r < n - 1)\n        {\n            for(int e = 0 ; e <= 1 ; ++e)\n            {\n                if(sur[e][r + 1] != -1)\n                {\n                    ++c[e];\n                    less_than_k[e] |= ((sur[e][r + 1] - sul[e][r + 1] + 1) <= k);\n                }\n            }\n        }\n        if(c[0] >= 2 || c[1] >= 2)\n            lose = false;\n        if(c[0] == 1 && less_than_k[0] == false)\n            lose = false;\n        if(c[1] == 1 && less_than_k[1] == false)\n            lose = false;\n    }\n    if(lose == true)\n        puts(\"quailty\");\n    else\n        puts(\"once again\");\n}",
    "ext": "cpp"
  },
  "57635254": {
    "code": "#pragma GCC optimize (\"Ofast\")\n#include<bits/stdc++.h>\n#define pb push_back\n#define __V vector\n#define all(x) x.begin(), x.end()\n#define oit ostream_iterator\n#define mod 1000000007ll\nusing namespace std;\nvoid doin() {\n\tcin.tie();\n\tcout.tie();\n\tios::sync_with_stdio(0);\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n}\ntemplate<typename X, typename Y>\nistream& operator>>(istream& in, pair<X, Y> &a) {\n\tin >> a.first >> a.second;\n\treturn in;\n}\ntemplate<typename T>\nvoid getv(T& i) {\n\tcin >> i;\n}\ntemplate<typename T, typename ... Ns>\nvoid getv(vector<T>& v, int n, Ns ... ns) {\n\tv.resize(n);\n\tfor (auto& i : v)\n\t\tgetv(i, ns...);\n}\ntemplate<typename T>\nvoid getv1(T& i) {\n\tcin >> i;\n}\ntemplate<typename T, typename ... Ns>\nvoid getv1(vector<T>& v, int n, Ns ... ns) {\n\tv.resize(n + 1);\n\tfor (int i = 1; i <= n; i++)\n\t\tgetv(v[i], ns...);\n}\n#ifdef _WIN32\n#define getchar_unlocked() _getchar_nolock()\n#define _CRT_DISABLE_PERFCRIT_LOCKS\n#endif\ninline void getch(char &x) {\n\twhile (x = getchar_unlocked(), x < 33) {\n\t\t;\n\t}\n}\ninline void getstr(string &str) {\n\tstr.clear();\n\tchar cur;\n\twhile (cur = getchar_unlocked(), cur < 33) {\n\t\t;\n\t}\n\twhile (cur > 32) {\n\t\tstr += cur;\n\t\tcur = getchar_unlocked();\n\t}\n}\ntemplate<typename T> inline bool sc(T &num) {\n\tbool neg = 0;\n\tint c;\n\tnum = 0;\n\twhile (c = getchar_unlocked(), c < 33) {\n\t\tif (c == EOF)\n\t\t\treturn false;\n\t}\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = getchar_unlocked();\n\t}\n\tfor (; c > 47; c = getchar_unlocked())\n\t\tnum = num * 10 + c - 48;\n\tif (neg)\n\t\tnum *= -1;\n\treturn true;\n}\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef float ld;\ntypedef int _I;\ntypedef pair<_I, _I> pi;\ntypedef pair<ld, ld> pd;\ntypedef map<_I, _I> mii;\ntypedef __V <_I> vi;\ntypedef __V <char> vc;\ntypedef __V <ld> vd;\ntypedef __V <vd> vvd;\ntypedef __V <pi> vpi;\ntypedef __V <__V<_I>> vvi;\ntypedef __V <__V<char>> vvc;\ntypedef __V <__V<pi>> vvpi;\nusing AntonTsypko = void;\nusing arsijo = AntonTsypko;\nusing god = arsijo;\nuniform_real_distribution<double> double_dist(0, 1);\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\nint main() {\n\tdoin();\n\tint n, k;\n\tstring s;\n\tcin >> n >> k >> s;\n\tvi o[2];\n\tint pr[2] = { 0 }, sf[2] = { 0 };\n\tfor (int i = 0; i < n; i++) {\n\t\to[s[i] - '0'].pb(i);\n\t\tif (i >= k)\n\t\t\tsf[s[i] - '0']++;\n\t}\n\tif (o[0].empty() || o[1].empty() || o[0].back() - o[0][0] < k\n\t\t\t|| o[1].back() - o[1][0] < k)\n\t\treturn cout << \"tokitsukaze\", 0;\n\tbool w = n <= 2*k;\n\tpr[s[0] - '0']++;\n\tif (k < n)\n\t\tsf[s[k] - '0']--;\n\tfor (int i = 1; w && i + k < n; i++) {\n\t\tw &= !((pr[0]>0)&&(pr[1]>0));\n\t\tw &= !((sf[0]>0)&&(sf[1]>0));\n\t\tw &= i==0||i+k==n||(pr[0]!=sf[0]&&pr[1]!=sf[1]);\n\t\tpr[s[i] - '0']++;\n\t\tif (i + k < n)\n\t\t\tsf[s[i + k] - '0']--;\n\t}\n\tif (w)\n\t\treturn cout << \"quailty\", 0;\n\tcout << \"once again\";\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57606786": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pll;\ntypedef vector<bool> vb;\nconst ll oo = 0x3f3f3f3f3f3f3f3f;\nconst double eps = 1e-9;\n#define sz(c) ll((c).size())\n#define all(c) begin(c), end(c)\n#define FOR(i,a,b) for (ll i = (a); i < (b); i++)\n#define FORD(i,a,b) for (ll i = (b)-1; i >= (a); i--)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define xx first\n#define yy second\n#define TR(X) ({ if(1) cerr << \"TR: \" << (#X) << \" = \" << (X) << endl; })\n\nvl brute(ll n, ll k, bool dbg = false) {\n\t\n\tvvl adj(1 << n), radj(1 << n);\n\tFOR(mask,1,(1 << n)-1) {\n\t\tvl &v = adj[mask];\n\t\tFOR(i,0,n-k+1) {\n\t\t\tll imask = ((1 << k) - 1) << i;\n\t\t\tll nmask1 = mask | imask;\n\t\t\tll nmask2 = mask & ~imask;\n\t\t\tv.pb(nmask1), v.pb(nmask2);\n\t\t}\n\t\tsort(all(v));\n\t\tv.erase(unique(all(v)),end(v));\n\t\tfor (ll nmask: v) radj[nmask].pb(mask);\n\t}\n\n\tvl dp(1 << n);\n\tdp[0] = dp[(1<<n)-1] = -1;\n\n\tvl outdeg(1 << n);\n\tFOR(mask,0,1 << n) outdeg[mask] = sz(adj[mask]);\n\t\n\tqueue<ll> q;\n\tq.push(0), q.push((1<<n)-1);\n\t\n\twhile (sz(q)) {\n\t\tll mask = q.front();\n\t\tq.pop();\n\n\t\tif (dp[mask] == -1) {\n\t\t\tfor (ll omask: radj[mask]) {\n\t\t\t\tassert(dp[omask] != -1);\n\t\t\t\tif (dp[omask] == 1) continue;\n\t\t\t\tdp[omask] = 1;\n\t\t\t\tq.push(omask);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (ll omask: radj[mask]) {\n\t\t\t\tassert(dp[omask] != -1);\n\t\t\t\tif (dp[omask] == 1) continue;\n\t\t\t\tif (--outdeg[omask] == 0) {\n\t\t\t\t\tdp[omask] = -1;\n\t\t\t\t\tq.push(omask);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (dbg) {\n\t\tFOR(mask,0,1 << n) if (dp[mask] == -1) {\n\t\t\tFORD(i,0,n) cout << bool(mask & (1 << i));\n\t\t\tcout << \" \" << dp[mask] << endl;\n\t\t}\n\t}\n\treturn dp;\n}\n\nll solve_naive(ll n, ll k, string s) {\n\tvl dp = brute(n,k);\n\tll mask = 0;\n\tFOR(i,0,n) if (s[i] == '1') mask |= 1 << i;\n\treturn dp[mask];\n}\n\nll solve(ll n, ll k, string s) {\n\tvl pmin(2,oo), pmax(2,-oo);\n\tFOR(i,0,n) {\n\t\tll k = s[i]-'0';\n\t\tpmin[k] = min(pmin[k],i);\n\t\tpmax[k] = max(pmax[k],i);\n\t}\n\t\n\tif (pmin[0] == oo || pmin[1] == oo) return -1;\n\t\n\tFOR(i,0,2) if (pmax[i]-pmin[i]+1 <= k) return 1;\n\t\n\tassert(k < n-1);\n\n\tif (k >= n/2) {\n\t\tll r = n-k-1;\n\t\tchar c = s[0];\n\t\tbool ok = true;\n\t\tFOR(i,0,r) if (s[i] != c) ok = false;\n\t\tFOR(i,n-r,n) if (s[i] == c) ok = false;\n\t\tif (s[r] == c) ok = false;\n\t\tif (s[n-r-1] != c) ok = false;\n\t\t\n\t\tif (ok) return -1;\n\t}\n\n\treturn 0;\t\n\treturn solve_naive(n,k,s);\n}\n\nvoid test() {\n\tFOR(n,1,8) FOR(k,1,n+1) FOR(mask,0,1 << n) {\n\t\tif (k == 1 && mask == 0) cout << n << endl;\n\t\tstring s(n,'0');\n\t\tFOR(i,0,n) if (mask & (1 << i)) s[i] = '1';\n\t\tif (solve(n,k,s) != solve_naive(n,k,s)) {\n\t\t\tcout << n << \" \" << k << \" \" << s << endl;\n\t\t\tcout << solve(n,k,s) << \" \" << solve_naive(n,k,s) << endl;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t\n\t//test();\n\n\tll n, k;\n\tcin >> n >> k;\n\tstring s; cin >> s;\n\n\tll res = solve(n,k,s);\n\tif (s == string(n,'0')) res = 1;\n\tif (s == string(n,'1')) res = 1;\n\tif (res == -1) cout << \"quailty\" << endl;\n\tif (res == 1) cout << \"tokitsukaze\" << endl;\n\tif (res == 0) cout << \"once again\" << endl;\n}\n\n",
    "ext": "cpp"
  },
  "57602948": {
    "code": "//author Forsaken\n#define Hello the_cruel_world!\n#pragma GCC optimize(2)\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<utility>\n#include<cmath>\n#include<climits>\n#include<deque>\n#include<functional>\n#include<numeric>\n#define max(x,y) ((x) > (y) ? (x) : (y))\n#define min(x,y) ((x) < (y) ? (x) : (y))\n#define lowbit(x) ((x) & (-(x)))\n#define FRIN freopen(\"C:\\\\Users\\\\Administrator.MACHENI-KA32LTP\\\\Desktop\\\\1.in\", \"r\", stdin)\n#define FROUT freopen(\"C:\\\\Users\\\\Administrator.MACHENI-KA32LTP\\\\Desktop\\\\1.out\", \"w\", stdout)\n#define FAST ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define outd(x) printf(\"%d\\n\", x)\n#define outld(x) printf(\"%lld\\n\", x)\n#define memset0(arr) memset(arr, 0, sizeof(arr))\n#define il inline\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\nconst int maxn = 3e5;\nconst int INF = 0x7fffffff;\nconst int mod = 1e9 + 7;\nconst double eps = 1e-7;\nconst double Pi = acos(-1.0);\nil int read_int() {\n\tchar c;\n\tint ret = 0, sgn = 1;\n\tdo { c = getchar(); } while ((c < '0' || c > '9') && c != '-');\n\tif (c == '-') sgn = -1; else ret = c - '0';\n\twhile ((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + (c - '0');\n\treturn sgn * ret;\n}\nil ll read_ll() {\n\tchar c;\n\tll ret = 0, sgn = 1;\n\tdo { c = getchar(); } while ((c < '0' || c > '9') && c != '-');\n\tif (c == '-') sgn = -1; else ret = c - '0';\n\twhile ((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + (c - '0');\n\treturn sgn * ret;\n}\nil ll quick_pow(ll base, ll index, ll p) {\n\tll res = 1;\n\twhile (index) {\n\t\tif (index & 1)res = res * base % p;\n\t\tbase = base * base % p;\n\t\tindex >>= 1;\n\t}\n\treturn res;\n}\nchar s[maxn + 5];\nint n, k, sum[maxn + 5];\nint solve(){\n\tif (k == 1 || 2 * k < n) return 0;\n\tint len = n - k - 1;\n\tfor (int i = 2; i <= len; i++)\n\t\tif (s[i] != s[i - 1] || s[n - i + 1] != s[n - i + 2]) return 0;\n\tif (s[1] == s[n]) return 0;\n\treturn 1;\n}\nint main()\n{\n\tn = read_int(), k = read_int();\n\tscanf(\"%s\", s + 1);\n\tfor (int i = 1; i <= n; ++i)sum[i] = sum[i - 1] + (s[i] == '1');\n\tint ok = 0;\n\tfor (int i = 1; i + k - 1 <= n; ++i) {\n\t\tint s = sum[i - 1] + sum[n] - sum[i + k - 1];\n\t\tif (s == 0 || s == n - k) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ok)printf(\"tokitsukaze\\n\");\n\telse {\n\t\tok = solve();\n\t\tif (ok == 1)printf(\"quailty\\n\");\n\t\telse printf(\"once again\\n\");\n\t}\n\t//system(\"pause\"); \n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57598173": {
    "code": "#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int limit=1000000;\n\nint n,k;\nint v[limit];\nint previous[limit][2];\nint seg[limit][2];\n\nvoid check(int c)\n{\n  int p2=previous[n][c];\n  if (p2==0) {\n    cout<<\"tokitsukaze\"<<endl;\n    exit(0);\n  }\n  if (p2<=k) {\n    cout<<\"tokitsukaze\"<<endl;\n    exit(0);\n  }\n  int p1=previous[p2-k][c];\n  if (p1==0) {\n    cout<<\"tokitsukaze\"<<endl;\n    exit(0);\n  }\n}\n\nvoid check()\n{\n  for (int c=0;c<2;c++)\n    check(c);\n}\n\nbool check(int le,int c)\n{\n  int ri=le+k-1;\n  {\n    int p2=previous[n][c];\n    if (p2<ri) {\n      int p1=previous[le-1][c];\n      if (p1==0) return false;\n    }\n  }\n  {\n    int p2=previous[n][1-c];\n    if (ri<p2) {\n      int p1=seg[1][1-c];\n      if (le<=p1) p1=seg[ri+1][1-c];\n      if (p2-p1+1>k) return true;\n    }\n    p2=previous[le-1][1-c];\n    if (p2==0) return false;\n    int p1=seg[1][1-c];\n    if (p2-p1+1>k) return true;\n  }\n  return false;\n}\n\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin>>n>>k;\n  for (int i=1;i<=n;i++) {\n    char c;\n    cin>>c;\n    v[i]=c-'0';\n    for (int c=0;c<2;c++)\n      previous[i][c]=previous[i-1][c];\n    previous[i][v[i]]=i;\n  }\n  seg[n+1][0]=seg[n+1][1]=n+1;\n  for (int i=n;i>=1;i--) {\n    for (int c=0;c<2;c++)\n      seg[i][c]=seg[i+1][c];\n    seg[i][v[i]]=i;\n  }\n  /*\n  for (int c=0;c<2;c++) {\n    for (int i=1;i<=n;i++)\n      cout<<previous[i][c]<<\",\";\n    cout<<endl;\n  }\n  for (int c=0;c<2;c++) {\n    for (int i=1;i<=n;i++)\n      cout<<seg[i][c]<<\",\";\n    cout<<endl;\n  }\n  */\n  check();\n  bool found=false;\n  for (int i=1;i<=n-k+1 and not found;i++) {\n    for (int c=0;c<2 and not found;c++) {\n      found=check(i,c);\n      //if (found) cout<<\" i \"<<i<<\" c \"<<c<<endl;\n    }\n  }\n  if (not found) cout<<\"quailty\"<<endl;\n  else cout<<\"once again\"<<endl;\n}\n",
    "ext": "cpp"
  },
  "57596730": {
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\nconst int N=10000;\nconst db pi=acos(-1.0);\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define fir first\n#define sec second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define maxd 998244353\n#define eps 1e-8\nint n,k,sta[100100],cnt[2],sum[100100],pre[100100];\nchar s[100100];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nbool chk_one()\n{\n\tcnt[0]=cnt[1]=0;\n\trep(i,1,n) cnt[sta[i]]++;\n\tint i;\n\trep(i,1,n) sum[i]=sum[i-1]+(sta[i]==0);\n\tfor (i=1;i+k-1<=n;i++)\n\t{\n\t\tint j=i+k-1;\n\t\tif (sum[j]-sum[i-1]==cnt[0]) return 1;\n\t}\n\trep(i,1,n) sum[i]=sum[i-1]+(sta[i]==1);\n\tfor (i=1;i+k-1<=n;i++)\n\t{\n\t\tint j=i+k-1;\n\t\tif (sum[j]-sum[i-1]==cnt[1]) return 1;\n\t}\n\treturn 0;\n}\n\nbool chk_two()\n{\n\tint i;\n\trep(i,1,n) sum[i]=sum[i-1]+sta[i];\n\tif (k*2<n) return 1;\n\tfor (i=2;i+k-1<n;i++)\n\t{\n\t\tint j=i+k-1;\n\t\tint lenl=i-1,lenr=n-j;\n\t\tint suml=sum[i-1],sumr=sum[n]-sum[j];\n\t\tif ((suml && lenl!=suml) || (sumr && lenr!=sumr)) return 1;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tn=read();k=read();\n\tscanf(\"%s\",s+1);\n\trep(i,1,n) sta[i]=s[i]-'0';\n\tif (chk_one()) puts(\"tokitsukaze\");\n\telse if (chk_two()) puts(\"once again\");\n\telse puts(\"quailty\");\n\treturn 0;\n}\n\n",
    "ext": "cpp"
  },
  "57509905": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring s;\nbool arr[100003];\nint a[2][100003];\n\nint main(){\n    int n,k;\n    cin>>n>>k;\n    cin>>s;\n    //int a[2][n-k+1];\n    int n0=0,n1=0;\n    for(int i=0;i<n;i++){\n    //    cout<<\"!\";\n        if(s[i]=='0'){\n            n0++;\n            arr[i]=0;\n        }\n        else{\n            n1++;\n            arr[i]=1;\n        }\n    }\n    for(int i=0;i<k;i++){\n        if(s[i]=='0')a[0][0]++;\n        else a[1][0]++;\n    }\n  //  cout<<a[1][0];\n    if(a[1][0]==n1){\n        cout<<\"tokitsukaze\";\n        return 0;\n    }\n    if(a[0][0]==n0){\n        cout<<\"tokitsukaze\";\n        return 0;\n    }\n    for(int i=1;i<=n-k;i++){\n//        cout<<\"@\";\n        a[1][i]=a[1][i-1]+arr[i+k-1]-arr[i-1];\n        a[0][i]=k-a[1][i];\n        if(a[1][i]==n1){\n            cout<<\"tokitsukaze\";\n            return 0;\n        }\n        if(a[0][i]==n0){\n            cout<<\"tokitsukaze\";\n            return 0;\n        }\n    }\n    int r0=n-1,r1=n-1,l1=0,l0=0;\n    while(arr[l0]==1){\n   //     cout<<\"!\";\n        l0++;\n    }\n    while(arr[l1]==0){\n   //     cout<<\"@\";\n        l1++;\n    }\n    while(arr[r0]==1){\n  //      cout<<\"#\";\n        r0--;\n    }\n    while(arr[r1]==0){\n  //      cout<<\"$\";\n        r1--;\n    }\n    if(l0>=k || r0-l0>k || n-r0>k){\n        cout<<\"once again\";\n        return 0;\n    }\n    if(l1>=k || r1-l1>k || n-r1>k){\n        cout<<\"once again\";\n        return 0;\n    }\n    cout<<\"quailty\";\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57508091": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = (int) 1e5 + 10;\n\nint ss[MAXN];\nint pref[2][MAXN], suf[2][MAXN];\nint fst[2], lst[2];\nint n, k;\n\nbool good (int l) {\n\tint r = l + k - 1;\n\tfor (int j = 0; j < 2; j++) {\n\t\tbool left = !l || !pref[j][l - 1];\n\t\tbool right = (r == n - 1) || !suf[j][r + 1];\n\t\tif (left && right) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool bad (int l) {\n\tint r = l + k - 1;\n\tfor (int j = 0; j < 2; j++) {\n\t\tif ((l && pref[j][l - 1] > k) || (r != n - 1 && suf[j][r + 1] > k)) {\n\t\t\treturn false;\n\t\t}\n\t\tbool left = !l || !pref[j][l - 1];\n\t\tbool right = (r == n - 1) || !suf[j][r + 1];\n\t\tif (!left && !right) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main () {\n\tstring s;\n\n\tcin >> n >> k >> s;\n\n\tfst[0] = fst[1] = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tss[i] = (int) (s[i] - '0');\n\t\tif (fst[ss[i]] == -1) {\n\t\t\tfst[ss[i]] = i;\n\t\t}\t\t\n\t\tlst[ss[i]] = i;\n\t}\n\n\tpref[ss[0]][0] = 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tpref[ss[i]][i] = i - fst[ss[i]] + 1;\n\t\tpref[1 - ss[i]][i] = pref[1 - ss[i]][i - 1];\n\t}\n\n\tsuf[ss[n - 1]][n - 1] = 1;\n\tfor (int i = n - 2; i >= 0; i--) {\n\t\tsuf[ss[i]][i] = lst[ss[i]] - i + 1;\n\t\tsuf[1 - ss[i]][i] = suf[1 - ss[i]][i + 1];\n\t}\n\n\tbool flag = true;\n\tfor (int i = 0; i + k <= n; i++) {\n\t\tif (good (i)) {\n\t\t\tcout << \"tokitsukaze\";\n\t\t\treturn 0;\n\t\t}\n\t\tflag &= bad (i);\n\t}\n\n    if (flag) {\n    \tcout << \"quailty\";\n    } else {\n    \tcout << \"once again\";\n    }\n\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57483605": {
    "code": "#include <bits/stdc++.h>\n\n#define MOD 1000000007\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<vector<int> > ady_list;\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int t, n, m, k;\n    cin >> k >> n;\n\n    int one[2];\n    int zero[2];\n    one[0] = zero[0] = k;\n    string winner[3] = {\"tokitsukaze\\n\", \"quailty\\n\", \"once again\\n\"};\n    int win;\n\n    char c;\n    for(int i = 0; i < k; ++i){\n        cin >> c;\n        if(c == '1'){\n            one[0] = min(i, one[0]);\n            one[1] = i;\n        }\n        else{\n            zero[0] = min(i, zero[0]);\n            zero[1] = i;\n        }\n    }\n\n    if(zero[0] == k || one[0] == k || (one[1] - one[0] < n) || (zero[1] - zero[0] < n))\n        win = 0;\n    else{\n        vector<int> data = {-1, one[0], one[1], zero[0], zero[1], k};\n        sort(all(data));\n        win = 1;\n        for(int i = 1; i < 5; ++i){\n            if(data[i - 1] + n < data[i + 1]){\n                win = 2;\n                break;\n            }\n        }\n    }\n\n    cout << winner[win];\n\n    return 0;\n}//RUL0",
    "ext": "cpp"
  },
  "57481322": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> A,B;\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    int n,k;\n    string s;\n    cin>>n>>k>>s;\n    for (int i=0;i<s.size();i++)\n    {\n        if (s[i]=='0')A.insert(i);\n        else B.insert(i);\n    }\n    if (A.empty() || B.empty())\n    {\n        cout<<\"tokitsukaze\"<<endl;\n        return 0;\n    }\n    if ((*A.rbegin()-*A.begin())<k || (*B.rbegin()-*B.begin())<k)\n    {\n        cout<<\"tokitsukaze\"<<endl;\n        return 0;\n    }\n    set<int> TA=A,TB=B;\n    for (int i=0;i<k;i++)\n    {\n        if (s[i]=='0')A.erase(i);\n        else B.erase(i);\n        A.insert(i);\n    }\n    if ((*A.rbegin()-*A.begin())>=k && (*B.rbegin()-*B.begin())>=k)\n    {\n        cout<<\"once again\"<<endl;\n        return 0;\n    }\n    for (int i=k;i<n;i++)\n    {\n        A.erase(i-k);\n        if (s[i-k]=='0')A.insert(i-k);\n        else B.insert(i-k);\n        if (s[i]=='0')A.erase(i);\n        else B.erase(i);\n        A.insert(i);\n        if ((*A.rbegin()-*A.begin())>=k && (*B.rbegin()-*B.begin())>=k)\n        {\n            cout<<\"once again\"<<endl;\n            return 0;\n        }\n    }\n    A=TA,B=TB;\n    for (int i=0;i<k;i++)\n    {\n        if (s[i]=='0')A.erase(i);\n        else B.erase(i);\n        B.insert(i);\n    }\n    if ((*A.rbegin()-*A.begin())>=k && (*B.rbegin()-*B.begin())>=k)\n    {\n        cout<<\"once again\"<<endl;\n        return 0;\n    }\n    for (int i=k;i<n;i++)\n    {\n        B.erase(i-k);\n        if (s[i-k]=='0')A.insert(i-k);\n        else B.insert(i-k);\n        if (s[i]=='0')A.erase(i);\n        else B.erase(i);\n        B.insert(i);\n        if ((*A.rbegin()-*A.begin())>=k && (*B.rbegin()-*B.begin())>=k)\n        {\n            cout<<\"once again\"<<endl;\n            return 0;\n        }\n    }\n    cout<<\"quailty\"<<endl;\n}\n",
    "ext": "cpp"
  },
  "57464025": {
    "code": "#include <fstream>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <map>\n#include <functional>\n#include <queue>\n#include <vector>\n#include <set>\n#include <string>\n#include <vector>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\ndouble eps=1e-7;\n#define maxn 100005\nint arr[maxn],sum[maxn],n,k;\nint ju1()\n{\n\tfor(int i=1;i+k-1<=n;i++)\n\t{\n\t\tif(k+sum[i-1]+sum[n]-sum[i+k-1]==n)return 1;\n\t\tif(sum[i-1]+sum[n]-sum[i+k-1]==0)return 1;\n\t}\n\treturn 0;\n}\nint ju2()\n{\n\tif(2*k<n)return 0;\n\tint len=n-k-1;\n\tfor(int i=2;i<=len;i++)\n\t\tif(arr[i]!=arr[i-1]||arr[n-i+1]!=arr[n-i+2])return 0;\n\tif(arr[1]==arr[n])return 0;\n\treturn 1;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%1d\",&arr[i]);\n\t\tsum[i]=sum[i-1]+arr[i];\t\t\n\t}\n\tif(ju1())printf(\"tokitsukaze\\n\");\n\telse if(ju2())printf(\"quailty\\n\");\n\telse printf(\"once again\\n\");\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57452209": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr char kFirstPlayer[] = \"tokitsukaze\";\nconstexpr char kSecondPlayer[] = \"quailty\";\nconstexpr char kDraw[] = \"once again\";\n\nint main() {\n  int n, m;\n  string chess;\n\n  scanf(\"%d%d\", &n, &m);\n  cin >> chess;\n\n  const int left = [&chess, n]() {\n    int index = 0;\n    while (index < n && chess.at(index) == chess.at(0)) {\n      ++index;\n    }\n    return index;\n  }();\n  const int right = [&chess, n] {\n    int index = n - 1;\n    while (index >= 0 && chess.at(index) == chess.at(n - 1)) {\n      --index;\n    }\n    return n - 1 - index;\n  }();\n\n  if (left + right > n) {\n    puts(kFirstPlayer);\n  } else {\n    const int mid = n - left - right;\n    // printf(\"%d %d %d\\n\", left, mid, right);\n    if (chess.at(0) == chess.at(n - 1)) {\n      if (m >= mid) {\n        puts(kFirstPlayer);\n      } else {\n        puts(kDraw);\n      }\n    } else {\n      if (m >= left + mid || m >= right + mid) {\n        puts(kFirstPlayer);\n      } else if (m == left + mid - 1 && m == right + mid - 1) {\n        if (m >= left + 1 && m >= right + 1) {\n          puts(kSecondPlayer);\n        } else {\n          puts(kDraw);\n        }\n      } else {\n        puts(kDraw);\n      }\n    }\n  }\n  return 0;\n}\n",
    "ext": "cpp"
  },
  "57447420": {
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nchar op[100010];\nint a[100010];\nint sum[100010];\nint n, m;\nint q_sum(int l, int r)\n{\n    if (l > r) \n        return 0;\n    return sum[r] - sum[l - 1];\n}\nbool fir() ///\u5224\u65ad\u5148\u624b\u80fd\u5426\u7b2c\u4e00\u6b21\u5c31win\n{\n    for (int i = 1; i <= n - m + 1; i++)\n    {\n        int item = q_sum(1, i - 1) + q_sum(i + m, n);\n        if (item == 0 || item + m == n) \n            return 1;\n    }\n    return 0;\n}\n \nbool sec()\n{\n    ///\u540e\u624b\n    if (m == 1 || 2 * m < n) \n        return 0;\n    int len = n - m - 1;\n    ///\u8fd9\u91cc\u7684\u610f\u601d\u5176\u5b9e\u5c31\u662f\u524dm-1\u4e2a\u5b57\u7b26\u8981\u7edf\u4e00\uff0c\u540em-1\u4e2a\u5b57\u7b26\u8981\u7edf\u4e00\uff0c\u4e14\u5de6\u53f3\u4e24\u4e32\u5b57\u7b26\u4e0d\u540c\n    ///\u90a3\u4e48\u5148\u624b\u4e0d\u7ba1\u600e\u4e48\u53d6\uff0c\u540e\u624b\u603b\u80fdwin\n    for (int i = 2; i <= len; i++)\n    {\n        if (a[i] != a[i-1] || a[n - i + 1] != a[n - i + 2]) \n            return 0;\n    }\n    if (a[1] == a[n]) \n        return 0;\n    return 1;\n}\nint main()\n{\n    scanf(\"%d %d\", &n, &m);\n    scanf(\"%s\", op);\n    for (int i = 1; i <= n; i++)\n    {\n        a[i] = op[i - 1] - '0';\n        sum[i] = sum[i - 1] + a[i];\n    }\n    if (fir())\n    {\n        puts(\"tokitsukaze\");\n    }\n    else\n    {\n        if (sec())\n        {\n            puts(\"quailty\");\n        }\n        else\n        {\n            puts(\"once again\");\n        }\n    }\n    return 0;\n}",
    "ext": "cpp"
  },
  "57435443": {
    "code": "#include <iostream>\n#include <bits/stdc++.h>\nusing namespace std;\n/* run this program using the console pauser or add your own getch, system(\"pause\") or input loop */\nchar save[10000001];\n\nint main(int argc, char** argv) {\n//\tint n;\n//\tcin>>n;\n//\tint m=n%4;\n//\tif(m==3){\n//\t\tcout<<2<<\" A\";\n//\t}\n//\tif(m==0){\n//\t\tcout<<1<<\" A\";\n//\t}\n//\tif(m==1){\n//\t\tcout<<0<<\" A\";\n//\t}\n//\tif(m==2){\n//\t\tcout<<1<<\" B\";\n//\t}\n//\t\n//    int a,b,c;char x,y,z;\n//    cin>>a>>x>>b>>y>>c>>z;\n//    if((a==b&&b==c&&x==y&&y==z)||(x==y&&y==z&&abs(a-b)==1&&abs(b-c)==1&&abs(a-c)==2)||(x==y&&y==z&&abs(a-b)==2&&abs(b-c)==1&&abs(a-c)==1)||(x==y&&y==z&&abs(a-b)==1&&abs(b-c)==2&&abs(a-c)==1)){\n//    \tcout<<0;\n//\t}\n//\telse if((a==b&&x==y)||(b==c&&y==z)||(a==c&&x==z)||(x==y&&(abs(a-b)==1||abs(a-b)==2))||(y==z&&(abs(b-c)==1||abs(b-c)==2))||(x==z&&(abs(a-c)==1||abs(a-c)==2))){\n//\t\tcout<<1;\n//\t}\n//\telse cout<<2;\n\n\tint n,k;\n\tcin>>n>>k;\n\tset<int> st0,st1;\n\tscanf(\"%s\",save+1);\n\tfor(int i=1;i<=n;i++){\n\t\tif(save[i]=='0')\n\t\t\tst0.insert(i);\n\t\telse\n\t\t\tst1.insert(i);\n\t}//\u04bb\ufffd\ufffd\n\tif(st0.size()<=1||st1.size()<=1){\n\t\tcout<<\"tokitsukaze\\n\";\n\t\treturn 0;\n\t} //win\n\tint mi0=*st0.begin(),mx0=*(--st0.end());\n\tint mi1=*st1.begin(),mx1=*(--st1.end());\n\tif(mx0-mi0+1<=k||mx1-mi1+1<=k){\n\t\tcout<<\"tokitsukaze\\n\";\n\t\treturn 0;\n\t}//\u04bb\ufffd\ufffd \n\tif(mx0-mi0-1>=k||mx1-mi1-1>=k){\n\t\tcout<<\"once again\\n\";\n\t\treturn 0;\n\t}//\n\tif(mi0+k*2<=n||mi1+k*2<=n||mx0-k*2>=1||mx1-k*2>=1){\n\t\tcout<<\"once again\\n\";\n\t\treturn 0;\n\t}\n\tcout<<\"quailty\\n\";\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57425906": {
    "code": "let readInt () = Scanf.scanf \" %d\" (fun x -> x)\nlet readString () = Scanf.scanf \" %s\" (fun s -> s)\n\ntype result = First | Second | Draw\nexception First\n\n(* Note: all winning strategies use 1 move because otherwise the opponent\n * can just copy the previous move. *)\nlet solve n k s : result =\n  let l = ref 0 in\n  let m = ref 0 in\n  let r = ref 0 in\n  for i=0 to n-1 do if s.[i] = '1' then incr r done;\n  let canSplit = ref false in\n  try\n  for i = 0 to n-1 do\n    if s.[i] = '1' then begin incr m; decr r end;\n    if i >= k && s.[i-k] = '1' then begin decr m; incr l end;\n    if i >= k-1 then begin\n      (* See if player 1 can win with this move. *)\n      if !l + !r = 0 || !l + k + !r = n then raise First\n      (* Otherwise, see if he can use it to stop player 2 from\n       * winning with his move, by stranding 1s on each side of k 0s or\n       * vice versa. *)\n      else if 0 < !l && 0 < !r\n           || !l < i+1-k && !r < n-i-1 then canSplit := true\n    end\n  done;\n  (* Note that the splitting strategy is the only possible way to draw\n   * when n \u2264 2k (either side can be chomped up in one go).\n   *\n   * When n \u2265 2k+1, and canSplit is false, then we must have\n   * s = <prefix of 0s><suffix of 1s> or vice versa. Either the prefix\n   * or suffix will have length \u2265 k+1 so pick that side and flip the\n   * k bits on the end.*)\n  if !canSplit || n > 2*k then Draw else Second\n  with First -> First\n\nlet main () =\n  let n = readInt () in\n  let k = readInt () in\n  let s = readString () in\n  print_endline (match solve n k s with First -> \"tokitsukaze\"\n                                      | Second -> \"quailty\"\n                                      | Draw -> \"once again\")\n\nlet () = main ()\n",
    "ext": ""
  },
  "57378735": {
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nconst int N = 1e5 + 5;\nchar s[N];\nvector<int>p[2];\nint n, k;\nint fun(int L, int R, int x)\n{\n    int tL = n + 1, tR = -1;\n    x ^= 1;\n    int pos = lower_bound(p[x].begin(), p[x].end(), L) - p[x].begin();\n    if(pos != 0){\n        tL = p[x][0];\n        tR = p[x][pos - 1];\n    }\n    pos = upper_bound(p[x].begin(), p[x].end(), R) - p[x].begin();\n    if(pos < p[x].size()){\n        tL = min(tL, p[x][pos]);\n        tR = max(tR, p[x][p[x].size() - 1]);\n    }\n    if(tR == -1) return 0;\n    if(tR - tL + 1 <= k) return 1;\n    return 2;\n}\nint main()\n{\n    \n    scanf(\"%d %d %s\", &n, &k, s + 1);\n    for(int i = 1; i <= n; i++){\n        p[s[i] - '0'].push_back(i);\n    }\n    int ans = 1;\n    for(int i = 1; i + k - 1 <= n; i++){\n        for(int j = 0; j < 2; j++){\n            int tmp = fun(i, i + k - 1, j);\n            if(tmp == 0){\n                ans = 0;\n            }\n            else if(ans != 0 && tmp == 2){\n                ans = 2;\n            }\n        }\n    }\n    if(ans == 0){\n        printf(\"tokitsukaze\\n\");\n    }\n    else if(ans == 1){\n        printf(\"quailty\\n\");\n    }\n    else{\n        printf(\"once again\\n\");\n    }\n    return 0;\n}",
    "ext": "cpp"
  },
  "57351112": {
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=1000005;\nint n,k,T;\nint a[MAXN],sum[MAXN];\nint q_sum(int l,int r)\n{\n    if(l>r)return 0;\n    return sum[r]-sum[l-1];\n}\nbool check_fir()\n{\n    for(int i=1;i+k-1<=n;++i)\n    {\n        int lala=q_sum(1,i-1)+q_sum(i+k,n);\n        if(lala==0||lala+k==n)return true;\n    }\n    return false;\n}\nbool check_sec()\n{\n    if(k*2<n||k==1)return false;\n    int len=n-k-1;\n    for(int i=2;i<=len;++i)\n    {\n        if(a[i]!=a[i-1]||a[n-i+1]!=a[n-i+2])return false;\n    }\n    if(a[len]==a[len+1]||a[n-len]==a[n-len+1]||a[1]==a[n])return false;\n    return true;\n}\nint main()\n{\n    scanf(\"%d %d\",&n,&k);\n    for(int i=1;i<=n;++i)\n    {\n        scanf(\"%1d\",&a[i]);\n        sum[i]=sum[i-1]+a[i];\n    }\n    if(check_fir())\n    {\n        printf(\"tokitsukaze\\n\");\n    }\n    else\n    {\n        if(check_sec())\n        {\n            printf(\"quailty\\n\");\n        }\n        else\n        {\n            printf(\"once again\\n\");\n        }\n    }\n    return 0;\n}",
    "ext": "cpp"
  },
  "57350404": {
    "code": "#include<bits/stdc++.h>\nconst int MAXN = 1e5 + 5, INF = 0x3f3f3f3f, MOD = 1e9 + 7;\nusing namespace std;\n#define lson o<<1,l,m\n#define rson o<<1|1,m+1,r\n#define mid l + ((r-l)>>1)\ntypedef long long ll;\n\nint n, k;\nchar s[MAXN];\nvector<int> loc[2];\nint main() {\n\tcin >> n >> k >> (s + 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tloc[s[i] - '0'].push_back(i);\n\t}\n\tif (loc[0].empty() || loc[1].empty()) {\n\t\tcout << \"tokitsukaze\\n\";\n\t\treturn 0;\n\t}\n\tbool flag = false;\n\tfor (int l = 1, r = k; r <= n; l++, r++) {\n\t\tvector<int> tmp[2];\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tif (loc[i].front() < l || loc[i].front() > r)tmp[i].push_back(loc[i].front());\n\t\t\tif (loc[i].back() < l || loc[i].back() > r)tmp[i].push_back(loc[i].back());\n\t\t\tauto it = lower_bound(loc[i].begin(), loc[i].end(), l);\n\t\t\tif (it != loc[i].begin())tmp[i].push_back(*--it);\n\t\t\tit = upper_bound(loc[i].begin(), loc[i].end(), r);\n\t\t\tif (it != loc[i].end())tmp[i].push_back(*it);\n\t\t}\n\t\tif (tmp[0].empty() || tmp[1].empty()) {\n\t\t\tcout << \"tokitsukaze\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tsort(tmp[0].begin(), tmp[0].end());\n\t\tsort(tmp[1].begin(), tmp[1].end());\n\t\tflag |= (tmp[0].back() - tmp[0].front() >= k) ||\n\t\t\t(tmp[1].back() - tmp[1].front() >= k);\n\t}\n\tif (flag)cout << \"once again\\n\";\n\telse cout << \"quailty\\n\";\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57350311": {
    "code": "#include<bits/stdc++.h>\n\n#define qcin; ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define pb push_back\n#define mp make_pair\n#define clr(x) memset(x,0,sizeof x)\n#define fmax(x) memset(x,0x3f,sizeof x)\n#define finit(x) memset(x,-1,sizeof x)\n\n#define dis(l,r) r-l+1\n#define gstr(str) scanf(\"%s\",str)\n#define glen(str) strlen(str\n#define VI vector<int>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<ll,ll>pll;\nconst int maxn = 2e5+10;\nconst int mod = 1e9+7;\nconst int seed = 1333331;\n\nll qm(ll a,ll b,ll res=1){\n    for(a%=mod;b;b>>=1,a=a*a%mod)\n        if(b&1)res=res*a%mod;\n    return res;\n}\nll n,m,k;\nll a[maxn],res,lim[maxn],sum,cnt=0;\nVI vec;\n\nint pre[maxn];\nstring s;\nset<ll>S;\n\nint main(){\n    cin>>n>>m;\n    cin>>s;\n    int fl=0,fl2=1;\n    for(int i=1;i<=n;i++){\n        pre[i]=pre[i-1]+(s[i-1]=='1');\n    }\n    for(int i=m;i<=n;i++){\n        if(pre[i]-pre[i-m]==pre[n])fl=1;\n        if(pre[i-m]&&pre[n]-pre[i])fl2=0;\n        if(m-(pre[i]-pre[i-m])==n-pre[n])fl=1;\n        if(i-m-pre[i-m]&&n-i-(pre[n]-pre[i])){\n            fl2=0;\n        }\n    }\n    if(fl)puts(\"tokitsukaze\");\n    else if(fl2&&2*m>=n)puts(\"quailty\");\n    else puts(\"once again\");\n}\n",
    "ext": "cpp"
  },
  "57348334": {
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n \nusing namespace std;\n \nint main()\n{\n    ll n, k;\n    cin >> n >> k;\n    string s;\n    cin >> s;\n    s = \"s\"+s;\n    vector<ll> pos_1, pos_0;\n    for(ll i = 1; i <= n; i++){\n        if (s[i] == '1') pos_1.push_back(i);\n        else pos_0.push_back(i);\n    }\n    if (pos_1.empty() || pos_0.empty() || pos_1.back()-pos_1[0]+1 <= k || pos_0.back()-pos_0[0]+1 <= k)\n        cout << \"tokitsukaze\";\n    else if (k*2 < n || pos_1.back()-pos_1[0]-1 >= k || pos_0.back()-pos_0[0]-1 >= k)\n        cout << \"once again\";\n    else cout << \"quailty\";\n}",
    "ext": "cpp"
  },
  "57332012": {
    "code": "#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <map>\n\n// ================================ //\n\n#define INLINE inline __attribute__((always_inline))\ntemplate <class... Args> INLINE void read(Args& ...args)\n{ (std::cin >> ... >> args); }\ntemplate <class... Args> INLINE void write(Args&& ...args)\n{ (std::cout << ... << std::forward<Args>(args)); }\ntemplate <class... Args> INLINE void writeln(Args&& ...args)\n{ write(std::forward<Args>(args)..., '\\n'); }\nINLINE void flush() { std::flush(std::cout); }\n#undef INLINE\n\n// ================================ //\n\n// [first, second, nobody]\nint solve(std::string s, int k) {\n\tint n = s.size();\n\n\tstd::vector<int> fl[2]; // first from left  on [i, n)\n\tstd::vector<int> fr[2]; // first from right on [0, i)\n\tfor (int j = 0; j < 2; ++j) {\n\t\tfl[j].resize(n+1); fl[j][n] = -1;\n\t\tfr[j].resize(n+1); fr[j][0] = -1;\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tint j = s[i] - '0';\n\t\tfr[ j][i+1] = i;\n\t\tfr[!j][i+1] = fr[!j][i];\n\t}\n\n\tfor (int i = n; i; --i) {\n\t\tint j = s[i-1] - '0';\n\t\tfl[ j][i-1] = i-1;\n\t\tfl[!j][i-1] = fl[!j][i];\n\t}\n\n\t// can win in first move\n\tfor (int j = 0; j < 2; ++j)\n\t\tif (fr[j][n] - fl[j][0] + 1 <= k)\n\t\t\treturn 0;\n\n\t// can't win in first move, try all moves\n\tfor (int i = 0; i <= n-k; ++i) {\n\t\tfor (int j = 0; j < 2;  ++j) {\n\t\t\t// try paint [i, i+k) in !j\n\n\t\t\t// [0, i) [i, i+k) [i+k, n)\n\t\t\t// ???100 00000000 001????? -> can't\n\t\t\t// ???100 00000000 00000000 -> can iff can on left part\n\t\t\t// 000000 00000000 001????? -> can iff can on right part\n\n\t\t\tstruct { int fst, lst; } vs[2] = {\n\t\t\t\t{fl[j][0], fr[j][i]}, {fl[j][i+k], fr[j][n]} };\n\n\t\t\tbool can = true;\n\t\t\tint cnt = 0;\n\t\t\tfor (auto sg : vs) {\n\t\t\t\tif (sg.fst != -1 && sg.lst != -1) {\n\t\t\t\t\tassert(sg.fst <= sg.lst);\n\t\t\t\t\tcan &= (sg.lst - sg.fst + 1 <= k);\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// \"can't\" is best move\n\t\t\tif (!can || cnt == 2)\n\t\t\t\treturn 2;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nint main() {\n\tint n, k; read(n, k);\n\tstd::string s; read(s);\n\tassert((int)s.size() == n);\n\n\tconst char* res_strs[3] = {\n\t\t\"tokitsukaze\", \"quailty\", \"once again\" };\n\n\twriteln(res_strs[solve(s, k)]);\n\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57325049": {
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=1e5+5;\nchar str[maxn];\nint n,m;\nint f1(char ch)\n{\n\tfor(int i=0;i<n;i++)\n\t\tif(str[i]==ch)\n\t\t\treturn i+1;\n}\nint f2(char ch)\n{\n\tfor(int i=n-1;i>=0;i--)\n\t\tif(str[i]==ch)\n\t\t\treturn i+1;\n}\nint lest()\n{\n\tint re=0,cnt=1;\n\tfor(int i=1;i<n;i++){\n\t\tif(str[i]==str[i-1])\n\t\t\tcnt++;\n\t\telse{\n\t\t\tre=max(re,cnt);\n\t\t\tcnt=1;\n\t\t}\n\t}\n\treturn re;\n}\nint main()\n{\n\t//int n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",str);\n\tint sum=0;\n\tfor(int i=0;i<n;i++)\n\t\tsum+=str[i]-'0';\n\tif(sum==0||sum==n)\n\t{\n\t\tputs(\"tokitsukaze\");\n\t\treturn 0;\n\t}\n\tint s1=f1('0'),s2=f1('1');\n\tint e1=f2('0'),e2=f2('1');\n\tif(min(e1-s1+1,e2-s2+1)<=m)\n\t\tputs(\"tokitsukaze\");\n\telse if(max(e1-s1-1,e2-s2-1)>=m||lest()>=m)\n\t\tputs(\"once again\");\n\telse\n\t\tputs(\"quailty\");\n}",
    "ext": "cpp"
  },
  "57320360": {
    "code": "#include <bits/stdc++.h>\nusing namespace std; \nusing ll = long long;\n\nbool canwin1(vector<int> &v, int k){\n    int n = v.size();\n    int n1 = 0;\n    int l0, r0, indr0;\n    l0 = 1e9;\n    r0 = 0;\n    for(int i = 0; i < n; i++){\n        n1 += v[i];\n        if(!v[i]){\n            l0 = min(l0, i);\n            r0 = max(r0, i);\n        }\n\n    }\n    if(r0-l0+1 <= k)\n        return true;\n    return false;\n}\n\nbool canwin2(vector<int> &v, int k){\n    int n = v.size();\n    int n1 = 0;\n    int l0, r0, indr0;\n    l0 = 1e9;\n    r0 = 0;\n    bool f= true;\n    for(int i = k; i < n; i++){\n        n1 += v[i];\n        if(!v[i]){\n            l0 = min(l0, i);\n            r0 = max(r0, i);\n        }\n    }\n\n    for(int i = k; i < n; i++){\n        if(!(r0-l0+1 <= k)){\n            f = false;\n            break;\n        }\n        if(!v[i-k]){\n            l0 = min(i-k, l0);\n            r0 = max(r0, i-k);\n        }\n        if(!v[i] && r0 == i){\n            r0++;\n            while(r0 < n && !v[r0++]){}\n            if(r0 == n){\n                r0 = i-k;\n                while(r0 >= 0 && !v[r0--]){}\n            }\n        }\n    }\n\n    if(!(r0-l0+1 <= k)){\n        f = false;\n    }\n    return f;\n}\n\nsigned main() { \n    int n, k; \n    cin>>n>>k;\n    vector<int> v(n);\n    vector<int> v1(n);\n    string s;\n    cin>>s;\n    for(int i = 0; i< n; i++){\n        v[i] = s[i]-'0';\n        v1[i] = !v[i];\n    }\n    if(canwin1(v, k) || canwin1(v1, k)){\n        cout<<\"tokitsukaze\";\n        return 0;\n    }\n    if(canwin2(v, k) || canwin2(v1, k)){\n        cout<<\"quailty\";\n        return 0;\n    }\n    cout<<\"once again\";\n    \n}",
    "ext": "cpp"
  },
  "57313402": {
    "code": "#include <bits/stdc++.h>\n\n#define pii pair<int, int>\n#define endl \"\\n\"\n//#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\nconst int INF = 1e9;\nconst double E = 1e-10;\nconst ll P = 998244353;\nconst ll Q = 31;\n\nusing namespace std;\n\nvoid hello()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n}\n\nvoid show(vector<int>& arr)\n{\n    for (auto i : arr)\n        cout << i << \" \";\n    cout << endl;\n}\nvoid show(vector<vector<int>>& arr)\n{\n    for (auto i : arr)\n        show(i);\n    cout << endl;\n}\n\npii parse(string s)\n{\n    int a;\n    if (s[1] == 's')\n        a = 0;\n    else if (s[1] == 'm')\n        a = 1;\n    else\n        a = 2;\n    return {a, s[0] - '1'};\n}\n\nsigned main()\n{\n    hello();\n\n    int n, k;\n    cin >> n >> k;\n    vector <int> seq(n);\n    vector <int> tsum(n + 1);\n    string s;\n    cin >> s;\n\n    for (int i = 0; i < n; ++i)\n    {\n        seq[i] = s[i] - '0';\n        tsum[i + 1] = tsum[i] + seq[i];\n    }\n\n    for (int i = 0; i <= n - k; ++i)\n    {\n        if (tsum[i] + tsum[n] - tsum[i + k] == 0)\n        {\n            cout << \"tokitsukaze\" << endl;\n            return 0;\n        }\n        if (tsum[i] + tsum[n] - tsum[i + k] == n - k)\n        {\n            cout << \"tokitsukaze\" << endl;\n            return 0;\n        }\n    }\n\n    for (int i = 0; i <= n - k; ++i)\n    {\n        bool flag1 = 0, flag2 = 0;\n        flag1 = i <= k && tsum[n] - tsum[i + k] == n - k - i || tsum[i] == i && n - k - i <= k;\n        flag2 = i <= k && tsum[n] - tsum[i + k] == 0 || tsum[i] == 0 && n - k - i <= k;\n        //cout << flag1 << \" \" << flag2 << endl;\n        if (!flag1 || !flag2)\n        {\n            cout << \"once again\" << endl;\n            return 0;\n        }\n    }\n\n    cout << \"quailty\" << endl;\n}\n",
    "ext": "cpp"
  },
  "57313315": {
    "code": "#include <cstdio>\nusing namespace std;\nconst int maxn = 1e5+10;\nint sum[maxn];\nchar a[maxn];\nint main(){\n//    freopen(\"case.txt\", \"r\", stdin);\n    int n, k, cnt=0;\n\n    bool ans = false;\n    scanf(\"%d%d\", &n, &k);\n    getchar();\n    for(int i=0; i<n; i++){\n        scanf(\"%c\", &a[i]);\n        if(i==0) sum[i]=a[i]-'0';\n        else sum[i]=sum[i-1]+a[i]-'0';\n    }\n    for(int i=0; i<=n-k; i++){\n        int l=i-1, r=i+k;\n        int t=0;\n        if(l>=0) t+=sum[l];\n        if(r<n) t+=sum[n-1]-sum[r-1];\n        if(t == 0 || t == n-k) {\n            ans = true;\n            break;\n        }\n    }\n    if(ans) printf(\"tokitsukaze\");\n    else if(k*2<n || k==1) printf(\"once again\");\n    else {\n        ans=true;\n        for(int i=1; i<n-k; i++){\n            int left = sum[i-1];\n            int right = sum[n-1]-sum[i+k-1];\n            if(left != 0 && left != i || right != 0 && right != (n-i-k)) {\n                ans=false;\n                break;\n            }\n        }\n        printf(\"%s\", ans?\"quailty\":\"once again\");\n\n    }\n    return 0;\n}",
    "ext": "cpp"
  },
  "57311456": {
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\n#define ll long long \n#define pii pair<int, int>\n#define ull unsigned ll\n#define f first\n#define s second\n#define FOR(i,a,b) for (int i=(a); i<(b); i++)\n#define REP(i,n) for (int i=0; i<(n); i++)\n#define RREP(i,n) for (int i=(n-1); i>=0; i--)\n#define ALL(x) x.begin(),x.end()\n#define SZ(x) x.size()\n#define SQ(x) (x)*(x)\n#define MNTO(a,b) a = min(a,(__typeof__(a))(b))\n#define MXTO(a,b) a = max(a,(__typeof__(a))(b))\n#define pb push_back\n#define debug(x) cerr<<#x<<\" is \"<<x<<endl\nusing namespace std;\n\n// #define int ll\n\nconst int maxn = 1e5+5;\nconst int iinf = 1<<29;\nconst ll inf = 1ll<<60;\nconst ll mod = 1e9+7;\n\n\nvoid GG(){cout<<\"No\\n\"; exit(0);}\n\nll pow(ll a, ll n){ // a^n % mod\n\tll re=1;\n\twhile (n>0){\n\t\tif (n&1) re = re*a %mod;\n\t\ta = a*a %mod;\n\t\tn>>=1;\n\t}\n\treturn re;\n}\n\nll inv (ll b){\n\tif (b==1) return b;\n\treturn (mod-mod/b) * inv(mod%b) % mod;\n}\n\nint n, k; \n\nbool one(string s){\n\tfor (char ch = '0'; ch<='1'; ch++){\n\t\tint f1= iinf, f2=-1;\n\t\tREP(i, n){\n\t\t\tif (s[i]==ch) {\n\t\t\t\tf1 = i; break;\n\t\t\t}\n\t\t}\n\t\tRREP(i, n){\n\t\t\tif (s[i]==ch) {\n\t\t\t\tf2 = i; break;\n\t\t\t}\n\t\t}\n\t\tif (f2-f1+1<=k) return true;\n\t}\n\treturn 0;\n}\n\nbool two(string s){\n\tvector<int> at[2];\n\tfor (char ch = '0'; ch<='1'; ch++){\n\t\tREP(i,n){\n\t\t\tif (s[i]==ch){\n\t\t\t\tat[ch-'0'].pb(i);\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,n-k+1){\n\t\t// From i to i+k-1\n\t\tfor (char ch = '0'; ch <= '1'; ch++){\n\t\t\t// Switching this section to ch\n\t\t\t// Test to see of second player can change the rest to ch\n\t\t\t// Second player cannot switch to ch^1 because it would have to reverse 1st player's move\n\t\t\tint x = ch-'0';\n\t\t\tint lx, rx; // Leftmost appearance of x^1\n\t\t\tif (i > at[x^1][0]){\n\t\t\t\tlx = at[x^1][0];\n\t\t\t}else{\n\t\t\t\tlx = *upper_bound (ALL(at[x^1]), i+k-1);\n\t\t\t}\n\t\t\tif (i+k-1 < at[x^1].back()){\n\t\t\t\trx = at[x^1].back();\n\t\t\t}else{\n\t\t\t\trx = *prev(lower_bound (ALL(at[x^1]), i));\n\t\t\t}\n\t\t\tif (rx-lx+1>k){ // Doesn't work for player 2\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t}\n\treturn 1;\n}\n\nmain(){\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin>>n>>k;\n    string s; cin>>s;\n    string FIRST = \"tokitsukaze\", SECOND = \"quailty\";\n    if (one(s)){\n    \tcout<<FIRST<<endl; return 0;\n    }\n    if (two(s)) {\n    \tcout<<SECOND<<endl; return 0;\n    }\n    else {\n    \tcout<<\"once again\"<<endl; return 0;\n    }\n\n    \n}",
    "ext": "cpp"
  },
  "57303945": {
    "code": "let readInt () = Scanf.scanf \" %d\" (fun x -> x)\nlet readString () = Scanf.scanf \" %s\" (fun s -> s)\n\ntype result = First | Second | Draw\nexception First\n\n(* Note: all winning strategies use 1 move because otherwise the opponent\n * can just copy the previous move. *)\nlet solve n k s : result =\n  let l = ref 0 in\n  let m = ref 0 in\n  let r = ref 0 in\n  for i=0 to n-1 do if s.[i] = '1' then incr r done;\n  let canDraw = ref false in\n  try\n  for i = 0 to n-1 do\n    if s.[i] = '1' then begin incr m; decr r end;\n    if i >= k && s.[i-k] = '1' then begin decr m; incr l end;\n    if i >= k-1 then begin\n      (* See if player 1 can win with this move. *)\n      if !l = 0 && !r = 0 || !l + k + !r = n then raise First\n      (* Otherwise, see if he use it to stop player 2 from\n       * winning with his move, by stranding 1s on each side of k 0s or\n       * vice versa. *)\n      else if 0 < !l && 0 < !r\n           || !l < i+1-k && !r < n-i-1 then canDraw := true\n    end\n  done;\n  (* It's also always possible to draw when n \u2265 2k+1 (at each stage\n   * just take the move that gets you closest to an even number of\n   * 1s and 0s).\n   *\n   * The splitting strategy is the only way to draw when n \u2264 2k\n   * (either side can be chomped up in one move). *)\n  if !canDraw || n > 2*k then Draw else Second\n  with First -> First\n\nlet main () =\n  let n = readInt () in\n  let k = readInt () in\n  let s = readString () in\n  print_endline (match solve n k s with First -> \"tokitsukaze\"\n                                      | Second -> \"quailty\"\n                                      | Draw -> \"once again\")\n\nlet () = main ()\n",
    "ext": ""
  },
  "57301242": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, mx[2] = {-1, -1}, mn[2] = {INT_MAX, INT_MAX};\nbool flag;\nstring str;\n\nint main(){\n    cin>>n>>k>>str;\n\n    for(int i = 0; i < n; i++){\n        if(str[i] == '0')\n            mn[0] = min(mn[0], i);\n        else\n            mn[1] = min(mn[1], i);\n\n        if(mn[0] != INT_MAX && mn[1] != INT_MAX)\n            break;\n    }\n\n    for(int i = n - 1; i >= 0; i--){\n        if(str[i] == '0')\n            mx[0] = max(mx[0], i);\n        else\n            mx[1] = max(mx[1], i);\n\n        if(mx[0] >= 0 && mx[1] >= 0)\n            break;\n    }\n\n    if(mx[0] - mn[0] + 1 <= k || mx[1] - mn[1] + 1 <= k){\n        cout<<\"tokitsukaze\"<<endl;\n        return 0;\n    }\n\n    if(mn[0] >= k || mn[1] >= k)\n        flag = true;\n    if(n - mx[0] - 1 >= k || n - mx[1] - 1 >= k)\n        flag = true;\n    if(mx[0] - mn[0] - 1 >= k || mx[1] - mn[1] - 1 >= k)\n        flag = true;\n\n    if(flag)\n        cout<<\"once again\"<<endl;\n    else\n        cout<<\"quailty\"<<endl;\n\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57300300": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tint k;\n\tcin >> k >> k;\n\tstring s;\n\tcin >> s;\n\tsize_t min_a = s.size(), min_b = s.size(), max_a = 0, max_b = 0; \n\tfor (size_t i = 0; i < s.size(); i++) {\n\t\tif (s[i] == '0') {\n\t\t\tif (min_a == s.size()) {\n\t\t\t\tmin_a = i;\n\t\t\t}\n\t\t\tmax_a = max(max_a, i);\n\t\t} else {\n\t\t\tif (min_b == s.size()) {\n\t\t\t\tmin_b = i;\n\t\t\t}\n\t\t\tmax_b = max(max_b, i);\n\t\t}\n\t}\n\tif (min_a == s.size() || max_a - min_a < k || min_b == s.size() || max_b - min_b < k) {\n\t\tcout << \"tokitsukaze\";\n\t\treturn 0;\n\t}\n\tif (max_a - min_a == k && max_b - min_b == k && !(max_a < min_b || max_b < min_a)) {\n\t\tcout << \"quailty\";\n\t\treturn 0;\n\t}\n\tcout << \"once again\";\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57280485": {
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n,k;\nchar ch[100100];\nint aa,bb;\nint cc,dd;\nint A[100100],B[100100],C[100100],D[100100];\n\nvoid process()\n{\n    aa=-300000;\n    bb=300000;\n    cc=-300000;\n    dd=300000;\n    for(int i=0;i<n;i++)\n    {\n        if(ch[i]=='1')\n        {\n            aa=i;\n            break;\n        }\n    }\n    for(int i=0;i<n;i++)\n    {\n        if(ch[i]=='0')\n        {\n            cc=i;\n            break;\n        }\n    }\n    for(int i=n-1;i>=0;i--)\n    {\n        if(ch[i]=='1')\n        {\n            bb=i;\n            break;\n        }\n    }\n    for(int i=n-1;i>=0;i--)\n    {\n        if(ch[i]=='0')\n        {\n            dd=i;\n            break;\n        }\n    }\n}\n\n/*void process()\n{\n    int last=-1;\n    for(int i=0;i<n;i++)\n    {\n        if(ch[i]=='1')\n        {\n            last=i;\n        }\n        A[i]=last;\n    }\n    last=-1;\n    for(int i=0;i<n;i++)\n    {\n        if(ch[i]=='0')\n        {\n            last=i;\n        }\n        C[i]=last;\n    }\n    last=-1;\n    for(int i=n-1;i>=0;i--)\n    {\n        if(ch[i]=='1')\n        {\n            last=i;\n        }\n        B[i]=last;\n    }\n    last=-1;\n    for(int i=n-1;i>=0;i--)\n    {\n        if(ch[i]=='0')\n        {\n            last=i;\n        }\n        D[i]=last;\n    }\n}*/\n\nint canWin()\n{\n    if(aa==-300000 || cc==-300000) return 1;\n    if(bb-aa+1<=k) return 1;\n    if(dd-cc+1<=k) return 1;\n    return 0;\n}\n\nint getNext(int a)\n{\n    for(int i=a;i<n;i++)\n    {\n        if(ch[i]!=ch[a]) return i-1;\n    }\n    return n-1;\n}\n\nint canLose()\n{\n    for(int i=aa+1;i<=bb-1;i++)\n    {\n        if(ch[i]=='0')\n        {\n            int uu=i+1;\n            if(uu+k<=bb) return 0;\n            break;\n        }\n    }\n    for(int i=bb-1;i>=aa+1;i--)\n    {\n        if(ch[i]=='0')\n        {\n            int uu=i-1;\n            if(uu-k>=aa) return 0;\n            break;\n        }\n    }\n    for(int i=cc+1;i<=dd-1;i++)\n    {\n        if(ch[i]=='1')\n        {\n            int uu=i+1;\n            if(uu+k<=dd) return 0;\n            break;\n        }\n    }\n    for(int i=dd-1;i>=cc+1;i--)\n    {\n        if(ch[i]=='1')\n        {\n            int uu=i-1;\n            if(uu-k>=cc) return 0;\n            break;\n        }\n    }\n    for(int i=0;i<n;i++)\n    {\n        int uu=getNext(i);\n        if(uu-i+1>=k) return 0;\n        i=uu;\n    }\n    if(bb-aa-1>=k && (cc<aa || dd>bb)) return 0;\n    if(dd-cc-1>=k && (aa<cc || bb>dd)) return 0;\n    return 1;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    scanf(\"%s\",&ch);\n\n    process();\n\n    if(canWin())\n    {\n        printf(\"tokitsukaze\\n\");\n        return 0;\n    }\n\n    if(canLose())\n    {\n        printf(\"quailty\\n\");\n        return 0;\n    }\n\n    printf(\"once again\\n\");\n\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57269237": {
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n    string s;\n    int n,m;\n    cin >> n >> m;\n    cin >> s;\n    int nums0=0,nums1=0;\n    int nume0=0,nume1=0;\n    for(int i=m;i<n;i++){\n        if(s[i]=='0')\n            nume0++;\n        else\n            nume1++;\n    }\n    if(nume0==n-m||nume1==n-m){\n        cout << \"tokitsukaze\\n\";\n        return 0;\n    }\n    int flag=0;\n//    if(max(nume0+nums1,nume1+nums0)!=n-m)\n//            flag=1;\n    for(int i=0;i<n-m;i++){\n        if(s[i]=='0')nums0++;\n        else nums1++;\n        if(s[i+m]=='0')nume0--;\n        else nume1--;\n\n        //cout << nums0 << nums1 << nume0 << nume1 << endl;\n\n        if(max(nume0+nums0,nume1+nums1)==n-m){\n            cout << \"tokitsukaze\\n\";\n            return 0;\n        }\n        if(i!=n-m-1){\n            if(max(nume0+nums1,nume1+nums0)!=n-m)\n            flag=1;\n        }\n        else if(2*m<n)\n            flag=1;\n            //cout << flag <<endl;\n    }\n\n    if(flag)\n        cout << \"once again\\n\" << endl;\n    else\n        cout << \"quailty\\n\" << endl;\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57255013": {
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n\nusing namespace std;\n\n#define long long long\n#define fi first\n#define se second\ntypedef pair<int,int> ii;\n\nint n, k;\nint pref[100003];\nchar pet[100003];\nint sum1(int a, int b) { return pref[b]-pref[a-1]; }\nint sum0(int a, int b) { return (b-a+1)-sum1(a, b); }\n\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\t// freopen(\"input.in\", \"r\", stdin);\n\n\tcin >> n >> k;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tchar c; cin >> c;\n\t\tpref[i] = (c - '0') + pref[i-1];\n\t}\n\n\tfor(int i = 1; i+k-1 <= n; i++)\n\t{\n\t\tint kir = i;\n\t\tint kan = i+k-1;\n\t\tif(sum1(1,kir-1)+sum1(kan+1,n) == 0 || sum0(1,kir-1)+sum0(kan+1,n) == 0)\n\t\t{\n\t\t\tcout << \"tokitsukaze\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(n > 2*k) cout << \"once again\\n\";\n\telse\n\t{\n\t\tfor(int i = 2; i+k-1 < n; i++)\n\t\t{\n\t\t\tint kir = i;\n\t\t\tint kan = i+k-1;\n\t\t\t\n\t\t\tif((sum0(1,kir-1)&&sum1(1,kir-1)) || (sum0(kan+1,n)&&sum1(kan+1,n)))\n\t\t\t{\n\t\t\t\tcout << \"once again\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tcout << \"quailty\\n\";\n\t\treturn 0;\n\t}\n}\n\n\n\n\n\n\n\n\n",
    "ext": "cpp"
  },
  "57245662": {
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<ll, ll> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<ll> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (ll i = (a); i < (b); i++)\n#define F0R(i, a) for (ll i = 0; i < (a); i++)\n#define FORd(i,a,b) for (ll i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (ll i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (ll)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst ll MOD = 998244353; // 998244353\nconst ll INF = 1e18;\nconst ll MX = 100001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\ntemplate<class A, class B> A operator+=(A& l, const B& r) { return l = l+r; }\ntemplate<class A, class B> A operator-=(A& l, const B& r) { return l = l-r; }\ntemplate<class A, class B> A operator*=(A& l, const B& r) { return l = l*r; }\ntemplate<class A, class B> A operator/=(A& l, const B& r) { return l = l/r; }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; trav(a,x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); } \n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // prll w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modll {\n    T val;\n    T mod = 0;\n    // static const T mod = MOD;\n\n    void normalize() {\n        if (mod == 0) return;\n        val %= mod; if (val < 0) val += mod;\n    }\n    modll(T v = 0, T m = 0) : val(v), mod(m) { normalize(); }\n    // modll(T v = 0, T m = 0) : val(v) { normalize(); }\n\n    explicit operator T() const { return val; }\n    friend ostream& operator<<(ostream& os, const modll& a) { return os << a.val; }\n    friend bool operator==(const modll& a, const modll& b) { return a.val == b.val; }\n    friend bool operator!=(const modll& a, const modll& b) { return !(a == b); }\n\n    friend void check(modll& a, modll& b) { // make sure all operations are valid\n        // comment out if mod is static const\n        if (a.mod > 0 && b.mod > 0) { assert(a.mod == b.mod); return; }\n        T mod = max(a.mod,b.mod); if (mod == 0) mod = MOD;\n        if (a.mod != mod) { a.mod = mod; a.normalize(); }\n        if (b.mod != mod) { b.mod = mod; b.normalize(); }\n    }\n    friend modll operator+(modll a, modll b) {\n        check(a,b); a.val += (T)b;\n        if (a.val >= a.mod) a.val -= a.mod;\n        return a;\n    }\n    friend modll operator-(modll a, modll b) {\n        check(a,b); a.val -= (T)b; \n        if (a.val < 0) a.val += a.mod; \n        return a;\n    }\n    friend modll operator-(const modll& a) { return modll(0)-a; }\n\n    friend modll operator*(modll a, modll b) {\n        check(a,b); a.val = (ll)a.val*(T)b%a.mod; return a;\n    }\n    friend modll exp(modll a, ll p) {\n        modll ans(1,a.mod);\n        for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modll inv(const modll& a) {\n        return {invGeneral(a.val,a.mod),a.mod};\n        // return exp(b,b.mod-2) if prime\n    }\n    friend modll operator/(modll a, modll b) { \n        check(a,b); return a*inv(b); \n    }\n};\n\ntypedef modll<ll> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint main() {\n    setIO();\n    int n, k;\n    cin >> n >> k;\n    string s;\n    cin >> s;\n    int fi0 = -1;\n    int la0 = -1;\n    int fi1 = -1;\n    int la1 = -1;\n    for(int i = 0; i < n; i++){\n    \tif(s[i] == '0'){\n    \t\tif(fi0 == -1) fi0 = i;\n    \t\tla0 = i;\n    \t}\n    \telse{\n    \t\tif(fi1 == -1) fi1 = i;\n    \t\tla1 = i;\n    \t}\n    }\n    if(fi0 == -1 || fi1 == -1){\n    \tcout << \"tokitsukaze\";\n    }\n    else if(min(la0-fi0, la1-fi1) +1 <= k){\n    \tcout << \"tokitsukaze\";\n    }\n    else{\n    \tbool works = 0;\n    \t// first make k _0s\n    \tset<int> _0s;\n    \tset<int> _1s;\n    \tfor(int i = 0; i < k; i++){\n    \t\t_0s.insert(i);\n    \t}\n    \tfor(int i = k; i < n; i++){\n    \t\tif(s[i] == '0'){\n    \t\t\t_0s.insert(i);\n    \t\t}\n    \t\telse _1s.insert(i);\n    \t}\n    \tif(min(*prev(_0s.end())-*_0s.begin()+1, *prev(_1s.end())-*_1s.begin()+1) > k){\n    \t\tworks = 1;\n    \t}\n    \tfor(int i = k; i < n; i++){\n    \t\t\n    \t\tif(s[i] == '0'){\n    \t\t\t_0s.erase(i);\n    \t\t}\n    \t\telse _1s.erase(i);\n    \t\t\n    \t\t_0s.erase(i-k);\n    \t\t\n    \t\t_0s.insert(i);\n    \t\t\n    \t\tif(s[i-k] == '0'){\n    \t\t\t_0s.insert(i-k);\n    \t\t}\n    \t\telse _1s.insert(i-k);\n    \t\t\n    \t\tif(min(*prev(_0s.end())-*_0s.begin()+1, *prev(_1s.end())-*_1s.begin()+1) > k){\n    \t\t\tworks = 1;\n    \t\t}\n    \t}\n    \t\n    \t// make k _1s\n    \t_0s.clear();\n    \t_1s.clear();\n    \tfor(int i = 0; i < n; i++){\n    \t\tif(s[i] == '0') s[i] = '1';\n    \t\telse s[i] = '0';\n    \t}\n    \tfor(int i = 0; i < k; i++){\n    \t\t_0s.insert(i);\n    \t}\n    \tfor(int i = k; i < n; i++){\n    \t\tif(s[i] == '0'){\n    \t\t\t_0s.insert(i);\n    \t\t}\n    \t\telse _1s.insert(i);\n    \t}\n    \tif(min(*prev(_0s.end())-*_0s.begin()+1, *prev(_1s.end())-*_1s.begin()+1) > k){\n    \t\tworks = 1;\n    \t}\n    \tfor(int i = k; i < n; i++){\n    \t\t\n    \t\tif(s[i] == '0'){\n    \t\t\t_0s.erase(i);\n    \t\t}\n    \t\telse _1s.erase(i);\n    \t\t\n    \t\t_0s.erase(i-k);\n    \t\t\n    \t\t_0s.insert(i);\n    \t\t\n    \t\tif(s[i-k] == '0'){\n    \t\t\t_0s.insert(i-k);\n    \t\t}\n    \t\telse _1s.insert(i-k);\n    \t\t\n    \t\tif(min(*prev(_0s.end())-*_0s.begin()+1, *prev(_1s.end())-*_1s.begin()+1) > k){\n    \t\t\tworks = 1;\n    \t\t}\n    \t}\n    \tif(works == 1){\n    \t\tcout <<  \"once again\";\n    \t}\n    \telse cout << \"quailty\";\n    }\n}\n\n/* stuff you should look for\n    * ll overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n",
    "ext": "cpp"
  },
  "57243561": {
    "code": "#include <bits/stdc++.h>\n#include <unordered_map>\n#define ll long long\n#define mod 1000000007\n#define vi vector<int>\n#define F(i,n) for(int i = 0; i < n; i++)\n#define scan(n) scanf(\"%d\",&n)\n#define pi 3.14159265359\nusing namespace std;\nll power(ll a, ll b) {\n\tif (b == 0)return 1;\n\tll res = 1;\n\twhile (b) {\n\t\tif (b & 1)res = res * a % mod;\n\t\ta = a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nunsigned ll mulmod(unsigned ll a, unsigned ll b, unsigned ll m) {\n\ta = a % m;\n\tunsigned ll res = 0;\n\twhile (b > 0) {\n\t\tif (b & 1)res = (res + a) % m;\n\t\ta = (a << 1) % m;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nunsigned ll power(unsigned ll a, unsigned ll b, unsigned ll m) {\n\tif (b == 0)return 1;\n\tll res = 1;\n\twhile (b) {\n\t\tif (b & 1)res = mulmod(res, a, m);\n\t\ta = mulmod(a, a, m);\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nll gcd(ll a, ll b) {\n\tif (a == 0)return b;\n\treturn gcd(b % a, a);\n}\n\nbool millerTest(unsigned ll n, unsigned ll d) {\n\tunsigned ll a = 2 + rand() % (n - 4);\n\tunsigned ll x = power(a, d, n);\n\tif (x == 1 || x == n - 1)return true;\n\n\twhile (d != n - 1) {\n\t\tx = mulmod(x, x, n);\n\t\td <<= 1;\n\t\tif (x == 1)return false;\n\t\tif (x == n - 1)return true;\n\t}\n\treturn false;\n}\n\nbool isPrime(unsigned ll n, int k) {\n\tif (n == 2 || n == 3)return true;\n\tif ((n & 1) == 0)return false;\n\tif (n <= 1)return false;\n\n\tll d = n - 1;\n\twhile ((d & 1) == 0)d >>= 1;\n\n\tF(i, k)if (!millerTest(n, d))return false;\n\treturn true;\n}\n\nint pref[100010];\nint suf[100010];\n\nint firstPref[100010][2];\nint lastPref[100010][2];\n\nint firstSuf[100010][2];\nint lastSuf[100010][2];\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tint n, k;\n\tcin >> n >> k;\n\n\tstring s; cin >> s;\n\tpref[0] = 0;\n\tint first = -1;\n\tfor (int i = 1; i <= s.size(); i++) {\n\t\tpref[i] = pref[i - 1] + s[i - 1] - '0';\n\n\t\tif (!firstPref[i - 1][0] && s[i - 1] == '0') firstPref[i][0] = i;\n\t\telse firstPref[i][0] = firstPref[i - 1][0];\n\t\tif (!firstPref[i - 1][1] && s[i - 1] == '1') firstPref[i][1] = i;\n\t\telse firstPref[i][1] = firstPref[i - 1][1];\n\t\tif (s[i - 1] == '0') lastPref[i][0] = i;\n\t\tif (s[i - 1] == '1') lastPref[i][1] = i;\n\n\t\tlastPref[i][0] = max(lastPref[i - 1][0], lastPref[i][0]);\n\t\tlastPref[i][1] = max(lastPref[i - 1][1], lastPref[i][1]);\n\t}\n\n\tsuf[n + 1] = 0;\n\tfor (int i = n; i >= 1; i--) {\n\t\tsuf[i] = suf[i + 1] + s[i - 1] - '0';\n\n\t\tif (!firstSuf[i + 1][0] && s[i - 1] == '0') firstSuf[i][0] = i;\n\t\telse firstSuf[i][0] = firstSuf[i + 1][0];\n\t\tif (!firstSuf[i + 1][1] && s[i - 1] == '1') firstSuf[i][1] = i;\n\t\telse firstSuf[i][1] = firstSuf[i + 1][1];\n\t\t\n\t\tif (s[i - 1] == '0') lastSuf[i][0] = i;\n\t\telse lastSuf[i][0] = lastSuf[i + 1][0];\n\n\t\tif (s[i - 1] == '1') lastSuf[i][1] = i;\n\t\telse lastSuf[i][1] = lastSuf[i + 1][1];\n\t}\n\n\tbool good = true;\n\tfor (int i = 1; i + k <= n + 1; i++) {\n\t\tif (pref[i - 1] == i - 1 && suf[i + k] == (n - i - k + 1) || pref[i - 1] == 0 && suf[i + k] == 0) {\n\t\t\tcout << \"tokitsukaze\";\n\t\t\treturn 0;\n\t\t}\n\n\t\tint upLeft = lastPref[i - 1][0] - firstPref[i - 1][0] + 1;\n\t\tif (lastPref[i - 1][0] == 0)upLeft = 0;\n\n\t\tint downLeft = lastPref[i - 1][1] - firstPref[i - 1][1] + 1;\n\t\tif (lastPref[i - 1][1] == 0)downLeft = 0;\n\n\t\tint upRight = firstSuf[i + k][0] - lastSuf[i + k][0] + 1;\n\t\tif (firstSuf[i + k][0] == 0) upRight = 0;\n\t\tint downRight = firstSuf[i + k][1] - lastSuf[i + k][1] + 1;\n\t\tif (firstSuf[i + k][1] == 0)downRight = 0;\n\n\t\tif ((upLeft == 0 && upRight <= k || upLeft <= k && upRight == 0) && (downLeft == 0 && downRight <= k || downLeft <= k && downRight == 0)) {\n\t\t\tgood = good;\n\t\t}\n\t\telse good = false;\n\t}\n\n\tif (good) {\n\t\tcout << \"quailty\";\n\t}\n\telse\n\tcout << \"once again\";\n}\n\n",
    "ext": "cpp"
  },
  "57231070": {
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <stack>\n#include <set>\n#include <unordered_map>\n#define _for(i, a, b) for (int i = a; i <= b; i++)\n#define for_(i, a, b) for (int i = a; i >= b; i--)\n#define INF = 1<<30\n#define maxn 100005\n#define mod 998244353\nusing namespace std;\ntypedef long long ll;\nint n, k, a[maxn];\n\nint main() {\n    char c;\n    cin >> n >> k; cin.ignore();\n    _for (i, 1, n) {scanf(\"%c\", &c); a[i] = c-'0';}\n    int p = 1, q = n, w, l = n-k-1;\n    while (a[p] == a[p+1] && p < n) p++;\n    while (a[q] == a[q-1] && q > 1) q--;\n    q = n-q+1;\n    if (a[1] == a[n]) w = n-p-q;\n    else w = n-max(p, q);\n    if (w <= k) printf(\"tokitsukaze\\n\");\n    else if ((k!=1&&k*2>=n) && (p>=l&&q>=l) && (a[l]!=a[l+1]&&a[n-l]!=a[n-l+1]&&a[1]!=a[n])) printf(\"quailty\\n\");\n    else printf(\"once again\\n\");\n\n\n    return 0;\n}",
    "ext": "cpp"
  },
  "57189715": {
    "code": "#include <bits/stdc++.h>\n     \n        using namespace std;\n        typedef long long ll;\n        typedef vector<ll> vl ;\n     \n        #define mp make_pair\n        #define pb push_back\n        #define f first\n        #define s second\n        #define all(v) (v).begin(),(v).end()\n     \n     \n        const int MOD = 1000000007;\n        const int N = 400005;\n        const double PI =4*atan(1);\n        const double eps = 1e-7;\n \n        ll n,m,k;\n        ll a[N];\n        ll u[N][2];\n        ll d[N][2];\n        string ch;\n \n        int main(){\n            ios::sync_with_stdio(0);\n            //freopen(\"easy.txt\",\"r\",stdin);\n            cin >> n;\n            cin >> k;\n            cin >> ch;\n            u[0][0]=u[0][1]=0;\n            for(int i=1;i<=n;i++){\n                ll x=ch[i-1]-'0';\n                if(x==0){\n                    u[i][0]=1+u[i-1][0];\n                    u[i][1]=u[i-1][1];\n                }else{\n                    u[i][1]=1+u[i-1][1];\n                    u[i][0]=u[i-1][0];\n                }\n            }\n            d[n+1][0]=d[n+1][1]=0;\n            for(int i=n;i>=1;i--){\n                ll x=ch[i-1]-'0';\n                if(x==0){\n                    d[i][0]=1+d[i+1][0];\n                    d[i][1]=d[i+1][1];\n                }else{\n                    d[i][1]=1+d[i+1][1];\n                    d[i][0]=d[i+1][0];\n                }\n            }\n            bool cond=true;\n            for(int i=1;i<=n-k+1;i++){\n                ll x=u[i-1][0]+d[i+k][0];\n                if(x+k == n){\n                    cout << \"tokitsukaze\\n\";\n                    return 0;\n                }\n                x = u[i-1][1]+d[i+k][1];\n                if(x+k == n){\n                    cout << \"tokitsukaze\\n\";\n                    return 0;\n                }\n            }\n            for(int i=1;i<=n-k+1;i++){\n                ll x=u[i-1][0];\n                ll y=d[i+k][0];\n                if(x>=1 && y>=1){\n                    cout << \"once again\";\n                    return 0;\n                }\n                x= u[i-1][1];\n                y= d[i+k][1];\n                if(x>=1 && y>=1){\n                    cout << \"once again\";\n                    return 0;\n                }\n                x=u[i-1][0];\n                if(x==i-1 && n-(i+k)+1 <=k){\n                    continue;\n                }\n                x=u[i-1][1];\n                if(x==i-1 && n-(i+k)+1 <=k){\n                    continue;\n                }\n                x=d[i+k][0];\n                if(i-1<=k && x==n-(i+k)+1){\n                    continue;\n                }\n                x=d[i+k][1];\n                if(i-1<=k && x==n-(i+k)+1){\n                    continue;\n                }\n                cout << \"once again\";\n                return 0;\n            }\n            cout << \"quailty\";\n\n            return 0;\n        }",
    "ext": "cpp"
  },
  "57189038": {
    "code": "#include <bits/stdc++.h>\n#define IOS ios_base::sync_with_stdio(false); cin.tie(0);\nusing namespace std;\n\nint main(){\n\tIOS;\n\tint n,k;\n\tstring str;\n\tcin >> n >> k >> str;\n\tint size=str.size();\n\tvector<vector<int>> pos(2,vector<int>());\n\tfor(int i=0;i<size;i++) pos[str[i]-'0'].push_back(i);\n\tif(pos[0].empty() || pos[1].empty() || pos[0].back()-pos[0].front()<k || pos[1].back()-pos[1].front()<k) cout << \"tokitsukaze\\n\";\n\telse{\n\t\tbool ok=true;\n\t\tfor(int i=0;i+k-1<size && ok;i++){\n\t\t\tfor(int c=0;c<=1 && ok;c++){\n\t\t\t\tint l=pos[1-c].front(),r=pos[1-c].back();\n\t\t\t\tif(i<=l && l<=i+k-1) l=*(lower_bound(pos[1-c].begin(),pos[1-c].end(),i+k));\n\t\t\t\tif(i<=r && r<=i+k-1) r=*(--lower_bound(pos[1-c].begin(),pos[1-c].end(),i));\n\t\t\t\tok&=(r-l<k);\n\t\t\t}\n\t\t}\n\t\tif(ok) cout << \"quailty\\n\";\n\t\telse cout << \"once again\\n\";\n\t}\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57188530": {
    "code": "#include <bits/stdc++.h>\n#define IOS ios_base::sync_with_stdio(false); cin.tie(0);\nusing namespace std;\n\nint main(){\n\tIOS;\n\tint n,k;\n\tstring str;\n\tcin >> n >> k >> str;\n\tint size=str.size();\n\tvector<vector<int>> pos(2,vector<int>());\n\tfor(int i=0;i<size;i++) pos[str[i]-'0'].push_back(i);\n\tif(pos[0].empty() || pos[1].empty() || pos[0].back()-pos[0].front()<k || pos[1].back()-pos[1].front()<k) cout << \"tokitsukaze\\n\";\n\telse{\n\t\tbool ok=true;\n\t\tfor(int i=0;i+k-1<size && ok;i++){\n\t\t\tfor(int c=0;c<=1 && ok;c++){\n\t\t\t\tint l=pos[1-c].front(),r=pos[1-c].back();\n\t\t\t\tif(i<=l && l<=i+k-1){\n\t\t\t\t\tif(i+k-1>=pos[1-c].back()) l=-1;\n\t\t\t\t\telse l=*(lower_bound(pos[1-c].begin(),pos[1-c].end(),i+k));\n\t\t\t\t}\n\t\t\t\tif(i<=r && r<=i+k-1){\n\t\t\t\t\tif(i<=pos[1-c].front()) r=-1;\n\t\t\t\t\tr=*(--lower_bound(pos[1-c].begin(),pos[1-c].end(),i));\n\t\t\t\t}\n\t\t\t\tif(l==-1 && r==-1) continue;\n\t\t\t\telse ok&=(r-l<k);\n\t\t\t}\n\t\t}\n\t\tif(ok) cout << \"quailty\\n\";\n\t\telse cout << \"once again\\n\";\n\t}\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57188364": {
    "code": "#include <bits/stdc++.h>\n#define IOS ios_base::sync_with_stdio(false); cin.tie(0);\nusing namespace std;\n\nint n,k,size;\nvector<int> zero,one;\nstring str;\n\nint main(){\n\tIOS;\n\tvector<vector<int>> pos(2,vector<int>());\n\tcin >> n >> k >> str;\n\tsize=str.size();\n\tfor(int i=0;i<size;i++) pos[str[i]-'0'].push_back(i);\n\tif(pos[0].empty() || pos[1].empty() || pos[0].back()-pos[0].front()<k || pos[1].back()-pos[1].front()<k) cout << \"tokitsukaze\\n\";\n\telse{\n\t\tbool ok=true;\n\t\tfor(int i=0;i+k-1<size && ok;i++){\n\t\t\tfor(int c=0;c<=1 && ok;c++){\n\t\t\t\tint l=pos[1-c].front(),r=pos[1-c].back();\n\t\t\t\tif(i<=l && l<=i+k-1){\n\t\t\t\t\tif(i+k-1>=pos[1-c].back()) l=-1;\n\t\t\t\t\telse l=*(lower_bound(pos[1-c].begin(),pos[1-c].end(),i+k));\n\t\t\t\t}\n\t\t\t\tif(i<=r && r<=i+k-1){\n\t\t\t\t\tif(i<=pos[1-c].front()) r=-1;\n\t\t\t\t\tr=*(--lower_bound(pos[1-c].begin(),pos[1-c].end(),i));\n\t\t\t\t}\n\t\t\t\tif(l==-1 && r==-1) continue;\n\t\t\t\telse ok&=(r-l<k);\n\t\t\t}\n\t\t}\n\t\tif(ok) cout << \"quailty\\n\";\n\t\telse cout << \"once again\\n\";\n\t}\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57184481": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define dd(x) cout << #x << \" = \" << x << \", \"\n#define de(x) cout << #x << \" = \" << x << endl\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n//INF = 1 061 109 567 ; INF + INF = 2 122 219 134 ;\n//LINF = 4 557 430 888 798 830 399 ; LINF + LINF = 9 114 861 777 597 660 798 ;\nconst int INF = 0x3f3f3f3f;     // -INF: 0xc0   abs(-INF) = INF + 1\nconst ll LINF = 0x3f3f3f3f3f3f3f3f;\n/*}}}*/                         // zr, zm\nconst int MOD = (int)1e9+7;     // when MOD = 1e9+7, inv2 = 500000004\nconst int N = (int)1e5+7;\nchar s[N];\nbool h0[N],h1[N],t0[N],t1[N];\nint ht1[N],ht0[N],tt1[N],tt0[N];\nint main()\n{\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint n,k;scanf(\"%d%d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\th0[0] = h1[0] = 1;\n\tt0[n+1] = t1[n+1] = 1;\n\trep(i,1,n+1) {\n\t\th0[i] = h0[i-1] & (s[i] == '0');\n\t\th1[i] = h1[i-1] & (s[i] == '1');\n\t}\n\tper(i,1,n+1) {\n\t\tt0[i] = t0[i+1] & (s[i] == '0');\n\t\tt1[i] = t1[i+1] & (s[i] == '1');\n\t}\n\tint l0 = INF,r0 = 0,l1 = INF,r1 = 0;\n\trep(i,1,n+1) {\n\t\tif(s[i] == '1') l1 = min(l1,i),r1 = max(r1,i);\n\t\telse l0 = min(l0,i),r0 = max(r0,i);\n\t\tif(!r0) ht1[i] = 0;\n\t\telse if(r0 - l0 < k) ht1[i] = 1;\n\t\telse ht1[i] = 2;\n\t\tif(!r1) ht0[i] = 0;\n\t\telse if(r1 - l1 < k) ht0[i] = 1;\n\t\telse ht1[i] = 2;\n\t}\n\tl0 = INF,r0 = 0,l1 = INF,r1 = 0;\n\tper(i,1,n+1) {\n\t\tif(s[i] == '1') l1 = min(l1,i),r1 = max(r1,i);\n\t\telse l0 = min(l0,i),r0 = max(r0,i);\n\t\n\t\tif(!r0) tt1[i] = 0;\n\t\telse if(r0 - l0 < k) tt1[i] = 1;\n\t\telse tt1[i] = 2;\n\t\tif(!r1) tt0[i] = 0;\n\t\telse if(r1 - l1 < k) tt0[i] = 1;\n\t\telse tt1[i] = 2;\n\t}\n\tbool f = 0,s = 1;\n\trep(i,1,n-k+2) {\n\t\tf |= (h0[i-1] && t0[i+k]) || (h1[i-1] && t1[i+k]);\n\t\ts &= (ht1[i-1] ^ tt1[i+k]) == 1 && \n\t\t\t(ht0[i-1] ^ tt0[i+k]) == 1;\n\n\t\t//dd(ht1[i-1]),de(tt1[i+k]);\n\t\t//dd(ht0[i-1]),de(tt0[i+k]);\n\t}\n\tif(f) printf(\"tokitsukaze\\n\");\n\telse if(s) printf(\"quailty\\n\");\n\telse printf(\"once again\\n\");\n\treturn 0;\n}\n",
    "ext": "cpp"
  }
}
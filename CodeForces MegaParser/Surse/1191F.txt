{
  "58548195": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int maxn=131072;\n\n//const ll INF = 1e18;\nconst ll INF =  1e9;\n//const ll mod = 1e9+7;\nconst ld pi = acos(-1);\n\nconst ld eps = 1e-9;\n\nstruct Node {\n    Node* left, *right;\n    int sz;\n    ll x,y;\n    Node(ll x): left(NULL), right(NULL), sz(1), x(x), y(rand()) {};\n};\n\nint getSz(Node* root) {\n    return root ? root->sz : 0;\n}\nvoid recalc(Node* root) {\n    root->sz = getSz(root->left)+getSz(root->right)+1;\n}\n\npair<Node*, Node*> split(Node* root, ll x) {\n    if (!root) return {NULL, NULL};\n    if (root->x<=x) {\n        auto p = split(root->right, x);\n        root->right = p.first;\n        recalc(root);\n        return {root, p.second};\n    } else {\n        auto p =split(root->left, x);\n        root->left = p.second;\n        recalc(root);\n        return {p.first, root};\n    }\n}\n\nNode* merge(Node* root1, Node* root2) {\n    if (!root1) return root2;\n    if (!root2) return root1;\n    if (root1->y>root2->y) {\n        root1->right = merge(root1->right, root2);\n        recalc(root1);\n        return root1;\n    } else {\n        root2->left = merge(root1, root2->left);\n        recalc(root2);\n        return root2;\n    }\n}\n\nNode* insert(Node* root, ll x) {\n    Node* tmp = new Node(x);\n    auto p = split(root, x-1);\n    auto p2 = split(p.second, x);\n    return merge(merge(p.first, tmp), p2.second);\n}\n\nstruct pt {\n    ll x,y;\n    friend bool operator<(const pt& lhs, const pt& rhs) {\n        return lhs.y<rhs.y;\n    };\n};\nvoid solve() {\n   ll n;\n   cin >> n;\n   vector<pt> pnts(n);\n   set<ll> x_, y_;\n   map<ll, vector<int>, std::greater<ll>> hint;\n   for (int i=0;i<n;i++) {\n       cin >> pnts[i].x >> pnts[i].y;\n       hint[pnts[i].y].push_back(pnts[i].x);\n   }\n\n   ll ans = 0;\n   Node* root = NULL;\n   for (auto it: hint) {\n       sort(it.second.begin(), it.second.end());\n       for (int i=0;i<it.second.size();i++) {\n           root = insert(root, it.second[i]);\n       }\n       for (int i=0;i<it.second.size();i++) {\n           //root = insert(root, it.second[i]);\n           ll last_l = (i==0) ? -INF : it.second[i-1];\n           ll cur = it.second[i];\n           auto p = split(root, last_l);\n           auto p2 = split(p.second, cur);\n           ll sz1 = getSz(p2.first);\n           root = merge(p.first, merge(p2.first, p2.second));\n           p = split(root, cur-1);\n           ll sz2 = getSz(p.second);\n           root = merge(p.first, p.second);\n           ans+=sz1*sz2;\n       }\n   }\n   cout << ans;\n}\nint main() {\n    cin.tie(0);\n    cout.tie(0);\n    ios_base::sync_with_stdio(false);\n//    cout << setprecision(7) << fixed;\n//freopen(\"input.txt\",\"r\", stdin);\n    solve();\n    return 0;\n}",
    "ext": "cpp"
  },
  "58546987": {
    "code": "#include <bits/stdc++.h>\n#include <chrono> \nusing namespace std::chrono; \n \nusing namespace std;\n\n#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n\n#define f0r(a, b) for (int a = 0; a < b; a++)\n#define f1r(a, b, c) for (int a = b; a < c; a++)\n#define ms(arr, v) memset(arr, v, sizeof(arr))\n#define pb push_back\n#define io ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n#define mp make_pair\n#define f first\n#define s second\n#define presum(p, a, n) p[0] = a[0]; for (int i = 1; i < n; i++) p[i] = a[i] + p[i-1];\n#define all(v) v.begin(), v.end()\n#define readgraph(list, edges) for (int i = 0; i < edges; i++) {int a, b; cin >> a >> b; a--; b--; list[a].pb(b); list[b].pb(a);};\ntypedef long long ll;\ntypedef double ld;\ntypedef long double lld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pii> vpi;\ntypedef vector<pll> vpl;\n \ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << \"(\" << p.f << \", \" << p.s << \")\"; }\ntemplate<typename A> ostream& operator<<(ostream &cout, vector<A> const &v) {\n  cout << \"[\"; for(int i = 0; i < v.size(); i++) {if (i) cout << \", \"; cout << v[i];} return cout << \"]\";\n}\n// template<typename A, typename B> ll max(A x, B y) {\n//   return x > y ? x : y;\n// }\n// template<typename A, typename B> ll min(A x, B y) {\n//   return x < y ? x : y;\n// }\n \nll gcd(ll x, ll y) {\n  if (y == 0) return x;\n  return gcd(y, x%y);\n}\n \n// bool prime[1000001]; \n// void sieve(int n) { \n//   ms(prime, 1);\n//   for (int p=2; p*p<=n; p++) { \n//     if (prime[p] == true) { \n//       for (int i=p*p; i<=n; i += p) \n//         prime[i] = false; \n//     } \n//   } \n// } \n \n// ll mpow(ll base, ll exp) {\n//   ll res = 1;\n//   while (exp) {\n//     if (exp % 2 == 1){\n//         res = (res * base) % mod;\n//     }\n//     exp >>= 1;\n//     base = (base * base) % mod;\n//   }\n//   return res;\n// }\n\n// long long count(string s) {\n//   long long ans = 0, c1 = 0, c2 = 0, c3 = 0;\n//   for (int i = 0; i < s.length(); i++) {\n//     if (s[i] == '1') c1++;\n//     else if (s[i] == '3') {\n//       c3 += c2;\n//       c2 += c1;\n//     }\n//     else ans += c3;\n//   }\n//   return ans;\n// }\n\n/*\nif (count(qqq) == x) {\n      cout << \"OK \" << cnt++;\n    } else {\n      cout << \"FAIL \" << x << endl;\n      exit(0);\n    }\n*/\n\ntemplate <typename num_t> \nstruct segtree {\n  int n, depth;\n  vector<num_t> tree, lazy;\n\n  void init(int s, long long* arr) {\n    n = s;\n    tree = vector<num_t>(4 * s, 0);\n    lazy = vector<num_t>(4 * s, 0);\n    init(0, 0, n - 1, arr);\n  }\n\n  num_t init(int i, int l, int r, long long* arr) {\n    if (l == r) return tree[i] = arr[l];\n\n    int mid = (l + r) / 2;\n    num_t a = init(2 * i + 1, l, mid, arr),\n          b = init(2 * i + 2, mid + 1, r, arr);\n    return tree[i] = a.op(b);\n  }\n\n  void update(int l, int r, num_t v) {\n    update(0, 0, n - 1, l, r, v);\n  }\n\n  num_t update(int i, int tl, int tr, int ql, int qr, num_t v) {\n    eval_lazy(i, tl, tr);\n\n    if (ql <= tl && tr <= qr) {\n      lazy[i] = lazy[i].val + v.val;\n      eval_lazy(i, tl, tr);\n      return tree[i];\n    }\n    if (tl > tr || tr < ql || qr < tl) return tree[i];\n    if (tl == tr) return tree[i];\n\n    int mid = (tl + tr) / 2;\n    num_t a = update(2 * i + 1, tl, mid, ql, qr, v),\n          b = update(2 * i + 2, mid + 1, tr, ql, qr, v);\n    return tree[i] = a.op(b);\n  }\n\n  num_t query(int l, int r) {\n    return query(0, 0, n-1, l, r);\n  }\n\n  num_t query(int i, int tl, int tr, int ql, int qr) {\n    eval_lazy(i, tl, tr);\n    \n    if (ql <= tl && tr <= qr) return tree[i];\n    if (tl > tr || tr < ql || qr < tl) return num_t::null_v;\n\n    int mid = (tl + tr) / 2;\n    num_t a = query(2 * i + 1, tl, mid, ql, qr),\n          b = query(2 * i + 2, mid + 1, tr, ql, qr);\n    return a.op(b);\n  }\n\n  /* varies by implementation */\n  /* this one is for range additions */\n  void eval_lazy(int i, int l, int r) {\n    /* special part */\n    tree[i] = tree[i].lazy_op(lazy[i], (r - l + 1));\n    if (l != r) {\n      lazy[i * 2 + 1] = max(lazy[i].val, lazy[i * 2 + 1].val);\n      lazy[i * 2 + 2] = max(lazy[i].val, lazy[i * 2 + 2].val);\n    }\n    /* end special part */\n\n    lazy[i] = num_t();\n  }\n};\n\nstruct sum_t {\n  long long val;\n  static const long long null_v = 0;\n\n\n  sum_t(): val(0) {}\n  sum_t(long long v): val(v) {}\n\n  sum_t op(sum_t& other) {\n    return sum_t(val + other.val);\n  }\n  \n  sum_t lazy_op(sum_t v, int size) {\n    return sum_t(val + v.val * size);\n  }\n};\n\nll i, j;\nconst ll mod = 1e9 + 7;\nll n, q, Q, T, m, k, r, y, z, g;\npii x[200001];\nint comp[200001];\nll a[200001];\nsegtree<sum_t> st;\nvi levels[200001];\n\nint main() {\n  io;\n  // freopen(\"case\", \"r\", stdin);\n  // freopen(\"case\", \"w\", stdout);\n  \n  cin >> n;\n  f0r(i, n) cin >> x[i].f >> x[i].s;\n  sort(x, x+n);\n  int cnt = 1;\n  comp[0] = 1;\n  f1r(i, 1, n) {\n    if (x[i].f == x[i-1].f) comp[i] = cnt;\n    else comp[i] = ++cnt;\n  }\n  f0r(i, n) x[i].f = comp[i];\n\n  f0r(i, n) {swap(x[i].f, x[i].s); x[i].f = -x[i].f;}\n  sort(x, x+n);\n  cnt = 0;\n  comp[0] = 0;\n  f1r(i, 1, n) {\n    if (x[i].f == x[i-1].f) comp[i] = cnt;\n    else comp[i] = ++cnt;\n  }\n  f0r(i, n) x[i].f = comp[i];\n  f0r(i, n) swap(x[i].f, x[i].s);\n\n  /* end compression */\n  ms(a, 0);\n  st.init(n+1, a);\n  f0r(i, n) levels[i].pb(0);\n  f0r(i, n) levels[x[i].s].pb(x[i].f);\n  ll l = x[n-1].s;\n  ll ans = 0;\n  st.update(0, 0, 1);\n  f0r(i, l+1) {\n    f1r(j, 1, levels[i].size()) {\n      st.update(levels[i][j], levels[i][j], 1 - st.query(levels[i][j], levels[i][j]).val);\n    }\n    f1r(j, 1, levels[i].size()) {\n      ans += (st.query(levels[i][j-1], levels[i][j]).val - 1) * (st.query(levels[i][j], n).val);\n    }\n  }\n  cout << ans << endl;\n}\n\n",
    "ext": "cpp"
  },
  "58505825": {
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef pair<int, int> II;\ntypedef long long LL;\ntypedef vector<int> vi;\ntypedef vector<II> vii;\n\nconst int N = 2e5 + 10;\n\nint n;\nint bit[N], cnt[N];\nLL res = 0;\nII a[N];\n\nvoid Update(int x) {\n    for (; x; x -= x & -x)\n        bit[x]++;\n}\n\nint Get(int x) {\n    int ret = 0;\n    for (; x <= n; x += x & -x)\n        ret += bit[x];\n    return ret;\n}\n\nint Sum(int l, int r) {\n    if (l > r) return 0;\n    return Get(l) - Get(r + 1);\n}\n\nvoid Compress() {\n    vii Rar;\n    for (int i = 1; i <= n; i++)\n        Rar.push_back({a[i].se, i});\n    sort(Rar.begin(), Rar.end());\n    a[Rar[0].se].se = 1;\n    for (int i = 1; i < n; i++)\n        a[Rar[i].se].se = a[Rar[i - 1].se].se + (Rar[i].fi != Rar[i - 1].fi);\n}\n\nint main() {\n    if (fopen(\"F.inp\", \"r\"))\n        freopen(\"F.inp\", \"r\", stdin),\n        freopen(\"F.out\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d%d\", &a[i].se, &a[i].fi);\n    sort(a + 1, a + 1 + n);\n    Compress();\n    int j = n;\n    for (int i = n; i >= 1; i--) {\n        if (i == 1 || a[i].fi != a[i - 1].fi) {\n            while (j >= i) {\n                int l = (i == j ? 1 : a[j - 1].se + 1);\n                res += 1ll * Get(a[j].se + 1);\n                if (!cnt[a[j].se])\n                    cnt[a[j].se] = 1, Update(a[j].se);\n                res += 1ll * Sum(l, a[j].se - 1) * Get(a[j].se);\n                j--;\n            }\n        }\n        //cout << i << \" \" << res << endl;\n    }\n    cout << res + 1ll * n;\n}\n",
    "ext": "cpp"
  },
  "58502257": {
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <tuple>\n#include <map>\n#include <deque>\n#include <set>\n\nusing namespace std;\n\nvector<int> S;\n\nint sum(int i){\n  int ans = 0;\n  for (; i >= 0; i = (i & (i + 1)) - 1)\n    ans += S[i];\n  return ans;\n}\n\nvoid add(int i, int x){\n  for (; i < S.size(); i = i | (i + 1))\n    S[i] += x;\n}\n\nint sum(int l, int r){\n  return sum(r - 1) - sum(l - 1);\n}\n\nint main(){\n  int n;\n  cin >> n;\n  vector<pair<int, int>> points(n);\n  vector<int> allx;\n  for (int i = 0; i < n; ++i){\n    int x, y;\n    cin >> x >> y;\n    allx.push_back(x);\n    points[i] = {-y, x};\n  }\n  sort(points.begin(), points.end());\n  sort(allx.begin(), allx.end());\n  S.resize(n);\n  vector<bool> is(n, false);\n  long long ans = 0;\n  int first = 0;\n  while (first < n){\n    int last = first + 1;\n    while (last < n && points[last].first == points[first].first)\n      ++last;\n    vector<int> cnt(last - first + 1);\n    cnt[0] = sum(0, lower_bound(allx.begin(), allx.end(), points[first].second) - allx.begin()) + 1;\n    cnt.back() = sum(upper_bound(allx.begin(), allx.end(), points[last - 1].second) - allx.begin(), n) + 1;\n    for (int i = first + 1; i < last; ++i)\n      cnt[i - first] = sum(upper_bound(allx.begin(), allx.end(), points[i - 1].second) - allx.begin(),\n          lower_bound(allx.begin(), allx.end(), points[i].second) - allx.begin()) + 1;\n    long long sum = 0;\n    long long sqrSum = 0;\n    for (int x : cnt){\n      sum += (long long) x;\n      sqrSum += ((long long) x) * ((long long) x);\n    }\n    ans += (sum * sum - sqrSum) / 2;\n    for (int i = first; i < last; ++i){\n      int ind = lower_bound(allx.begin(), allx.end(), points[i].second) - allx.begin();\n      if (!is[ind]) {\n        add(ind, 1);\n        is[ind] = true;\n      }\n    }\n    first = last;\n  }\n  cout << ans;\n  return 0;\n}",
    "ext": "cpp"
  },
  "58465949": {
    "code": "//#include<khoda>\n#include<bits/stdc++.h>\n\n#define int ll\n#define F first\n#define S second\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst int N = 2e5 + 5 , inf = 1e18;\n\nll n , t , x[N] , y[N] , ans , c1 , c2 , fen[N] , mx[N];\nvector < int > V1 , V2;\nvector < int > vec[N];\nmap < int , int > mp1 , mp2;\n\nvoid ADD( int id , int val )\n{\n\tfor ( ; id < N ; id += ( id & (-id) ) )\n\t\tfen[id] += val;\n}\n\nll get( int id )\n{\n\tll res = 0;\n\tfor ( ; id > 0 ; id -= ( id & (-id) ) )\n\t\tres += fen[id];\n\treturn res;\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> n;\n\tfor ( int i = 1 ; i <= n ; i++ )\n\t{\n\t\tcin >> x[i] >> y[i];\n\t\tV1.push_back(x[i]);\n\t\tV2.push_back(y[i]);\n\t}\n\tsort( V1.begin() , V1.end() );\n\tsort( V2.begin() , V2.end() );\n\tfor ( int i = 0 ; i < n ; i++ )\n\t\tif ( i == 0 || V1[i] != V1[i-1] )\n\t\t\tc1++ , mp1[V1[i]] = c1;\n\tfor ( int i = 0 ; i < n ; i++ )\n\t\tif ( i == 0 || V2[i] != V2[i-1] )\n\t\t\tc2++ , mp2[V2[i]] = c2;\n\tfor ( int i = 1 ; i <= n ; i++ )\n\t\tvec[mp2[y[i]]].push_back(mp1[x[i]]) , mx[mp1[x[i]]] = max( mx[mp1[x[i]]] , mp2[y[i]] );\n\tfor ( int i = 1 ; i <= c1 ; i++ )\n\t\tADD( i , 1 );\n\tfor ( int i = 1 ; i <= c2 ; i++ )\n\t{\n\t\tsort( vec[i].begin() , vec[i].end() );\n\t\tt = get( c1 );\t\n\t\tans += ( t * ( t+1 ) ) / 2;\t\n\t\tll last = 0;\n\t\tfor ( auto X : vec[i] )\n\t\t{\n\t\t\tt = get(X-1) - get(last);\n\t\t\tans -= ( t * ( t + 1 ) ) / 2;\n\t\t\tlast = X;\n\t\t}\n\t\tt = get(c1) - get(last);\n\t\tans -= ( t * ( t + 1 ) ) / 2;\n\t\tfor ( auto X : vec[i] )\n\t\t\tif ( mx[X] == i )\n\t\t\t\tADD( X , -1 );\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "58386644": {
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\nmap<int, vector<int> > p;\n\nstruct node {\n    int x;\n    int y;\n    bool operator< (const node &a) const {\n        return x < a.x;\n    }\n}o[200010];\n\nunordered_set<int> chk;\n\nint dx[200010];\n\nunordered_map<int, int> tr;\n\n\nint BIT[300010];\n\nvoid update(int i, int val) {\n    while(i <= 300000) {\n        BIT[i] += val;\n        i += i & (-i);\n    }\n}\n\nint query(int i) {\n    int sum = 0;\n    while(i > 0) {\n        sum += BIT[i];\n        i -= i & (-i);\n    }\n    return sum;\n}\n\n\nint main() {\n    int n;\n    scanf(\"%d\",&n);\n    for(int i = 0; i < n; i++) {\n        scanf(\"%d %d\",&o[i].x, &o[i].y);\n        dx[i] = o[i].x;\n    }\n    \n    int m = n;\n    sort(dx, dx + m);\n    m = (int)(unique(dx, dx + m) - dx);\n    for(int i = 0; i < m; i++) tr[dx[i]] = i + 1;\n    \n    sort(o, o + n);\n    for(int i = 0; i < n; i++) p[-o[i].y].push_back(o[i].x);\n    \n    long long ans = 0;\n    \n    for(map<int, vector<int> >::iterator it = p.begin(); it != p.end(); it++) {\n        vector<int> &tmp = it->second;\n        \n        int last = 0;\n        for(auto &v : tmp) {\n            long long x = query(tr[v]) - query(last);\n            if(chk.count(v)) x--;\n            \n            ans -= x * (x + 1) / 2;\n            last = tr[v];\n        }\n        long long x = query(299999) - query(last);\n        ans -= x * (x + 1) / 2;\n        \n        for(auto &v : tmp) {\n            if(chk.count(v)) continue;\n            chk.insert(v);\n            update(tr[v], 1);\n        }\n        \n        ans += (long long)chk.size() * (chk.size() + 1) / 2;\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}",
    "ext": "cpp"
  },
  "58327635": {
    "code": "#include<bits/stdc++.h>\n\n#ifdef lagrang3_DEBUG\n#include \"debug.h\"\n#else\n#define debug(...)\n#endif\n\n#define __fast_io__ \\\n\tstd::ios_base::sync_with_stdio(false);std::cin.tie(0);std::cout.tie(0);\n\n#define get_max(a,b) a=std::max(a,b)\n#define get_min(a,b) a=std::min(a,b)\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int oo=0x7fffffff;\nconst ll  OO=0x7fffffffffffffff;\n\ntemplate<class node_t>\nclass segment_tree \n{\n\t\n\tprivate:\n\tint N; // range goes from [0 to N-1], where N is a power of 2\n\tstd::vector<node_t> nodes;\n\t\n\tvoid allocate(int n)\n\t{\n\t\tfor(N=1;N < n;N <<= 1);\n\t\tnodes.resize(2*N);\t\n\t}\n\tvoid pull_up()\n\t{\n\t\tfor(int i=N-1,r=-1,l=-1,len=1\n\t\t\t;i>0;\n\t\t\t--i,r-=len,l-=len)\n\t\t{\n\t\t\tif(l<0)\n\t\t\t{\n\t\t\t\tlen <<=1;\n\t\t\t\tr=N;\n\t\t\t\tl=r-len;\n\t\t\t}\n\t\t\tnodes[i].pull_up(l,r,nodes[i*2],nodes[i*2+1]);\n\t\t}\n\t}\n\t\n\tpublic:\n\t\n\tsegment_tree(int n)\n\t{\n\t\tallocate(n);\n\t\tpull_up();\n\t}\n\ttemplate<class iter>\n\tsegment_tree(iter first,iter last)\n\t{\n\t\tallocate(std::distance(first,last));\n\t\tfor(int i=0; first!=last  ;++i,++first)\n\t\t\tnodes[N+i]=node_t(*first);\n\t\tpull_up();\n\t}\n\t\n\tint size()const{return N;}\n\tnode_t operator () (int i)const {return nodes[i];}\n\t\n\t\n\tauto query(int L,int R) //interval [L,R)\n\t{\n\t\tstd::function< decltype(nodes[0].query(1,1))(int,int,int) > \n\t\t\t_dfs = [&](int i,int l,int r)\n\t\t{\n\t\t\tif(i < N) nodes[i].push_down(l,r,nodes[2*i],nodes[2*i+1]);\n\t\t\t\n\t\t\tif( L<=l and r<=R )\n\t\t\t\treturn nodes[i].query(l,r);\n\t\t\t\n\t\t\tint m = (l+r)/2;\n\t\t\tif(m>=R)\n\t\t\t\treturn _dfs(i*2,l,m);\n\t\t\telse if( m<=L )\n\t\t\t\treturn _dfs(i*2+1,m,r);\n\t\t\t\n\t\t\tauto q1 = _dfs(i*2,l,m);\n\t\t\tauto q2 = _dfs(i*2+1,m,r);\n\t\t\t\n\t\t\treturn nodes[0].combine(q1,q2);\n\t\t};\n\t\treturn _dfs(1,0,N);\n\t}\n\t\n\ttemplate<class T>\n\tvoid update(int L,int R,T data) // interval [L,R)\n\t{\n\t\tstd::function< void(int,int,int) > _dfs = [&](int i,int l,int r)\n\t\t{\n\t\t\tif(i < N) nodes[i].push_down(l,r,nodes[2*i],nodes[2*i+1]);\n\t\t\t\n\t\t\tif( L<=l and r<=R )\n\t\t\t{\n\t\t\t\tnodes[i].update(l,r,data);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif( l>=R or r<=L )return;\n\t\t\t\n\t\t\tint m = (l+r)/2;\n\t\t\t_dfs(i*2,l,m);\n\t\t\t_dfs(i*2+1,m,r);\n\t\t\tnodes[i].pull_up(l,r,nodes[i*2],nodes[i*2+1]);\n\t\t\t\n\t\t};\n\t\t_dfs(1,0,N);\n\t}\n\t\n};\n\ntemplate<class T>\nstruct node_sum\n{\n\tT value;\n\t\n\tvoid pull_up(int l,int r,const node_sum<T>& L,const node_sum<T>& R)\n\t{\n\t\tvalue = L.value + R.value;\n\t}\n\tvoid push_down(int l,int r,node_sum<T>& L,node_sum<T>& R)\n\t{\n\t}\n\tvoid update(int l,int r,T d)\n\t{\n\t\tvalue = std::min(value+d,1);\n\t}\n\t\n\tT query(int l,int r)const\n\t{\n\t\treturn value;\n\t}\n\tT combine(T a,T b)const\n\t{\t\n\t\treturn a+b;\n\t}\n\tnode_sum(int x): value(x){}\n\tnode_sum(): value(0){}\n};\n\ntemplate<class node_t>\nstd::ostream& operator << (\n\tstd::ostream& O, \n\tconst segment_tree<node_t>& tree)\n{\n\tint n=tree.size();\n\tO<<'\\n';\n\tfor(int len=n,i=1;len>0;len>>=1)\n\t{\n\t\tfor(int l=1,r=l+len-1;r<=n;l+=len,r+=len,++i)\n\t\t{\n\t\t\tO<<\"[\"<<l<<\",\"<<r<<\"] \"<<tree(i)<<\"  \";\n\t\t}\n\t\tO<<'\\n';\n\t}\n\treturn O;\n}\ntemplate<class T>\nstd::ostream& operator << (\n\tstd::ostream& O, \n\tconst node_sum<T>& no)\n{\n\treturn O<<\"(\"<<no.value<<\")\";\n}\n\n\n\nusing namespace std;\n\nint main(){\n\t__fast_io__;\n\tint n;cin>>n;\n\t\n\tmap<int,int> coord;\n\tvector< pair<int,int> > P(n);\n\t\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tint x,y;cin>>x>>y;\n\t\tcoord[x]=0;\n\t\tP[i]={y,x};\n\t}\n\tsort(P.begin(),P.end(),\n\t\t[](auto p1,auto p2){\n\t\t\treturn p1.first == p2.first ? \n\t\t\t\tp1.second < p2.second :\n\t\t\t\tp1.first > p2.first;\n\t\t});\n\t\n\tint nc=0;\n\t\n\tfor(auto &p: coord)\n\t{\n\t\tp.second = ++nc;\n\t\tdebug(p);\n\t}\n\t\n\tsegment_tree< node_sum<int> > T(nc+5);\n\t\n\tdebug(T.size());\n\t\n\tll res=0;\n\t\n\tfor(int i=0,j;i<n;)\n\t{\n\t\tdebug(i);\n\t\tint x,y = P[i].first,k,dk;\n\t\tll subs;\n\t\t\n\t\tj=i+1;\n\t\twhile(j < n and P[j].first==y)++j;\n\t\t\n\t\tdebug(j);\n\t\tfor(int p=i;p<j;++p)\n\t\t\tdebug(P[p]);\n\t\t\n\t\tx=coord[P[i].second];\n\t\tdk =T.query(0, x );\n\t\tsubs = (ll(dk+1)*dk)/2;\n\t\tdebug(x,dk,subs,\"left\");\n\t\tres -= subs;\n\t\t\n\t\tx=coord[P[j-1].second];\n\t\tdk =T.query(x+1,T.size() );\n\t\tsubs=(ll(dk+1)*dk)/2;\n\t\tdebug(x,dk,subs,\"right\");\n\t\tres -= subs;\n\t\n\t\tfor(int p=i;p+1<j;++p)\n\t\t{\n\t\t\tdebug(p);\n\t\t\tint l=coord[P[p].second],r=coord[P[p+1].second];\n\t\t\t\n\t\t\tif((l+1)<r){\n\t\t\t\tdk=T.query(l+1,r);\n\t\t\t\tsubs = (dk*ll(dk+1))/2;\n\t\t\t\tdebug(dk,subs,\"center\");\n\t\t\t\tres -= subs ;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\twhile(i<j)\n\t\t{\n\t\t\tx=P[i].second;\n\t\t\tT.update(coord[x],coord[x]+1,1);\n\t\t\t++i;\n\t\t}\n\t\t\n\t\t//debug(T);\n\t\t\n\t\tk=T.query(0,T.size());\n\t\tll add = (k*ll(k+1))/2;\n\t\tdebug(k,add);\n\t\tres += add;\n\t}\n\t\n\tcout<<res<<'\\n';\n\t\n\treturn 0;\n}\n\n",
    "ext": "cpp"
  },
  "58291363": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/************* debug begin *************/\nstring to_string(string s){return '\"'+s+'\"';}\nstring to_string(const char* s){return to_string((string)s);}\nstring to_string(const bool& b){return(b?\"true\":\"false\");}\ntemplate<class T>string to_string(T x){ostringstream sout;sout<<x;return sout.str();}\ntemplate<class A,class B>string to_string(pair<A,B> p){return \"(\"+to_string(p.first)+\", \"+to_string(p.second)+\")\";}\ntemplate<class A>string to_string(const vector<A> v){\n\tint f=1;string res=\"{\";for(const auto x:v){if(!f)res+= \", \";f=0;res+=to_string(x);}res+=\"}\";\n\treturn res;\n}\nvoid debug_out(){puts(\"\");}\ntemplate<class T,class... U>void debug_out(const T& h,const U&... t){cout<<\" \"<<to_string(h);debug_out(t...);}\n#ifdef tokitsukaze \n#define debug(...) cout<<\"[\"<<#__VA_ARGS__<<\"]:\",debug_out(__VA_ARGS__);\n#else\n#define debug(...) 233;\n#endif\n/*************  debug end  *************/\n#define mem(a,b) memset((a),(b),sizeof(a))\n#define MP make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(x) (int)x.size()\n#define all(x) x.begin(),x.end()\n#define sqr(x) (x)*(x)\nusing namespace __gnu_cxx;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\ntypedef pair<int,ll> PIL;\ntypedef pair<ll,int> PLI;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\nvoid go();\nint main(){\n\t#ifdef tokitsukaze\n//\t\tfreopen(\"TEST.txt\",\"r\",stdin);\n\t#endif\n\tgo();return 0;\n}\nconst int INF=0x3f3f3f3f;\nconst ll LLINF=0x3f3f3f3f3f3f3f3fLL;\nconst double PI=acos(-1.0);\nconst double eps=1e-6;\nconst int MAX=2e5+10;\nconst ll mod=998244353;\n/*********************************  head  *********************************/\nstruct Fenwick_Tree\n{\n\tint bit[MAX];\n\tint n;\n\tvoid init(int _n){n=_n;mem(bit,0);}\n\tint lowbit(int x){return x&(-x);}\n\tvoid insert(int x,int v)\n\t{\n\t\twhile(x<=n)\n\t\t{\n\t\t\tbit[x]+=v;\n\t\t\tx+=lowbit(x);\n\t\t}\n\t}\n\tint get(int x)\n\t{\n\t\tint res=0;\n\t\twhile(x)\n\t\t{\n\t\t\tres+=bit[x];\n\t\t\tx-=lowbit(x);\n\t\t}\n\t\treturn res;\n\t}\n\tint query(int l,int r)\n\t{\n\t\treturn get(r)-get(l-1);\n\t}\n}tr;\nVI x[MAX],y;\nvoid go()\n{\n\tint n,i,tot,pre;\n\tll ans;\n\twhile(~scanf(\"%d\",&n))\n\t{\n\t\ttr.init(n);\n\t\ty.clear();\n\t\tmap<int,int> idx,idy,cntx;\n\t\ttot=0;\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tint X,Y;\n\t\t\tscanf(\"%d%d\",&X,&Y);\n\t\t\tif(!idy.count(Y))\n\t\t\t{\n\t\t\t\tx[tot].clear();\n\t\t\t\tidy[Y]=tot++;\n\t\t\t\ty.pb(Y);\n\t\t\t}\n\t\t\tx[idy[Y]].pb(X);\n\t\t\tcntx[X]++;\n\t\t}\n\t\ttot=0;\n\t\tfor(auto it:cntx)\n\t\t{\n\t\t\tidx[it.fi]=++tot;\n\t\t\ttr.insert(tot,1);\n\t\t}\n\t\tsort(all(y));\n\t\tans=0;\n\t\tfor(auto Y:y)\n\t\t{\n\t\t\tsort(all(x[idy[Y]]));\n\t\t\tpre=1;\n\t\t\tfor(auto X:x[idy[Y]])\n\t\t\t{\n\t\t\t\tans+=1LL*tr.query(pre,idx[X])*tr.query(idx[X],tot);\n\t\t\t\tpre=idx[X]+1;\n\t\t\t\tcntx[X]--;\n\t\t\t\tif(cntx[X]==0)\n\t\t\t\t{\n\t\t\t\t\tcntx.erase(X);\n\t\t\t\t\ttr.insert(idx[X],-1);\n\t\t\t\t}\n\t//\t\t\tdebug(Y,ans);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}\n",
    "ext": "cpp"
  },
  "58254165": {
    "code": "#include<bits/stdc++.h>\n#define lowbit(x) (x&-x)\n#define REP(i,s,t) for(int i=s;i<=t;i++)\nusing namespace std;\nconst int maxn=2e5+5;\nint n,x[maxn],y[maxn],dis[maxn],cx,cy;\nvector<int> vec[maxn];\nlong long ans;\nint c[maxn];\nvoid modify(int x){for(;x<=cx;x+=lowbit(x)) c[x]++;}\nint _query(int x){\n\tint ret=0;\n\tfor(;x;x-=lowbit(x)) ret+=c[x];\n\treturn ret;\n}\nint query(int l,int r){return _query(r)-_query(l-1);}\nint main(){\n\tcin>>n;\n\tREP(i,1,n) cin>>x[i]>>y[i];\n\tREP(i,1,n) dis[i]=x[i];\n\tsort(dis+1,dis+1+n);\n\tcx=unique(dis+1,dis+1+n)-dis-1;\n\tREP(i,1,n) x[i]=lower_bound(dis+1,dis+1+cx,x[i])-dis;\n\tREP(i,1,n) dis[i]=y[i];\n\tsort(dis+1,dis+1+n);\n\tcy=unique(dis+1,dis+1+n)-dis-1;\n\tREP(i,1,n) y[i]=lower_bound(dis+1,dis+1+cy,y[i])-dis;\n\tREP(i,1,n) vec[y[i]].push_back(x[i]);\n\tfor(int i=cy;i;i--){\n\t\tsort(vec[i].begin(),vec[i].end());\n\t\tfor(int j:vec[i]) if(!query(j,j)) modify(j);\n\t\tans+=1ll*query(1,vec[i][0])*query(vec[i][0],cx);\n\t\tfor(int j=1;j<vec[i].size();j++) ans+=1ll*query(vec[i][j-1]+1,vec[i][j])*query(vec[i][j],cx);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "58236277": {
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nstruct point {int x; int y;};\n\nint n;\npoint points[200005];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n;\n    for(int i = 1; i <= n; i++)\n        cin >> points[i].x >> points[i].y;\n    sort(points + 1, points + n + 1, [](point a, point b) {\n        if(a.y == b.y) return a.x < b.x;\n        return a.y > b.y;\n    });\n\n    long long ans = 0;\n\n    ordered_set s;\n    for(int i = 1; i <= n; i++) {\n        if(i == 1 || points[i].y != points[i - 1].y) {\n            for(int j = i; j <= n; j++) {\n                if(j > i && points[j].y != points[i].y)\n                    break;\n                s.insert(points[j].x);\n            }\n\n            int ord = s.order_of_key(points[i].x);\n            ans += (ord + 1) * 1LL * (s.size() - ord);\n        } else {\n            int ord = s.order_of_key(points[i].x);\n            int prev_ord = s.order_of_key(points[i - 1].x);\n            ans += (ord - prev_ord) * 1LL * (s.size() - ord);\n        }\n    }\n    cout << ans << endl;\n}\n",
    "ext": "cpp"
  },
  "58231752": {
    "code": "#include<bits/stdc++.h>\n#define dd(x) cout<<#x<<\" = \"<<x<<\" \"\n#define de(x) cout<<#x<<\" = \"<<x<<\"\\n\"\n#define sz(x) int(x.size())\n#define All(x) x.begin(),x.end()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef priority_queue<int> BQ;\ntypedef priority_queue<int,vector<int>,greater<int> > SQ;\nconst int maxn=4e5+10,mod=1e9+7,INF=0x3f3f3f3f;\nP p[maxn];\nvector<int> d,v[maxn];\ninline int hs(int x){\n\treturn lower_bound(All(d),x)-d.begin()+1;\n}\nint sum[maxn<<2];\nvoid upd(int p,int l,int r,int rt){\n\tif (l==r){\n\t\tsum[rt]|=1;\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tif (p<=m)\n\t\tupd(p,l,m,rt<<1);\n\telse\n\t\tupd(p,m+1,r,rt<<1|1);\n\tsum[rt]=sum[rt<<1]+sum[rt<<1|1];\n}\nint qry(int L,int R,int l,int r,int rt){\n\tif (L<=l&&r<=R)\n\t\treturn sum[rt];\n\tint res=0,m=(l+r)>>1;\n\tif (L<=m)\n\t\tres+=qry(L,R,l,m,rt<<1);\n\tif (R>m)\n\t\tres+=qry(L,R,m+1,r,rt<<1|1);\n\treturn res;\n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\tfor (int i=1;i<=n;++i){\n\t\tscanf(\"%d%d\",&p[i].fi,&p[i].se);\n\t\td.pb(p[i].se),d.pb(p[i].fi);\n\t}\n\tsort(All(d));\n\tint N=sz(d);\n\tfor (int i=1;i<=n;++i){\n\t\tint x=hs(p[i].fi),y=hs(p[i].se);\n\t\tv[y].pb(x);\n\t}\n\tll ans=0;\n\tfor (int i=N;i;--i){\n\t\tif (!sz(v[i]))\n\t\t\tcontinue;\n\t\tsort(All(v[i]));\n\t\tfor (auto j:v[i])\n\t\t\tupd(j,1,N,1);\n\t\tint last=0;\n\t\tfor (auto j:v[i]){\n\t\t\tint tmp=qry(1,j,1,N,1);\n\t\t\tans+=ll(tmp-last)*qry(j,N,1,N,1);\n\t\t\tlast=tmp;\n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "58169901": {
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll read(){\n\tll a=0,b=getchar(),c=1;\n\twhile(!isdigit(b))c=b=='-'?-1:1,b=getchar();\n\twhile(isdigit(b))a=a*10+b-'0',b=getchar();\n\treturn a*c;\n}\nvoid print(ll x){\n\tif(x<0)putchar('-'),x=-x;\n\tint y=x%10+'0';\n\tif(x>=10)print(x/10);\n\tputchar(y);\n}\nll n,ans,tot,tree[200005];\nmap<ll,ll> id,cnt;\nmap<ll,vector<ll> > g;\nvoid add(int x,int y){\n\twhile(x<200005)\n\t\ttree[x]+=y,x+=x&(-x);\n}\nll sum(int x){\n\tll res=0;\n\twhile(x)\n\t\tres+=tree[x],x-=x&(-x);\n\treturn res;\n}\nint main(){\n\tn=read();\n\tfor(int i=0;i<n;i++){\n\t\tint x=read(),y=read();\n\t\tg[y].push_back(x),cnt[x]++;\n\t}\n\tfor(map<ll,ll>::iterator i=cnt.begin();i!=cnt.end();i++)\n\t\tid[(*i).first]=++tot,add(tot,1);\n\tfor(map<ll,vector<ll> >::iterator i=g.begin();i!=g.end();i++){\n\t\tsort((*i).second.begin(),(*i).second.end());\n\t\tll x=1,y;\n\t\tfor(int j=0;j<(*i).second.size();j++){\n\t\t\ty=id[(*i).second[j]];\n\t\t\tans+=(sum(y)-sum(x-1))*(sum(tot)-sum(y-1));\n\t\t\tif(!--cnt[(*i).second[j]])add(y,-1);\n\t\t\tx=y+1;\n\t\t}\n\t}\n\tprint(ans);\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "58160595": {
    "code": "#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2e5 + 5;\n\nstruct dot {\n\tint x, y;\n\tdot(int _x, int _y) {x = _x, y = _y;}\n\tdot() {}\n};\n\nLL ans = 0;\nint n, tr[MAXN], flag[MAXN], tot, mx, d[MAXN];\ndot p[MAXN];\nmap<int,int> list;\n\nbool cmp(dot a, dot b) {\n\treturn a.y > b.y || a.y == b.y && a.x < b.x;\n}\n\nvoid prepare() {\n\tsort(d + 1, d + tot + 1);\n\tfor (int i = 1; i <= tot; i ++) \n\t\tif (i == 1 || d[i] != d[i - 1]) list[d[i]] = ++ mx;\n\tfor (int i = 1; i <= n ; i ++) p[i].x = list[p[i].x];\n}\n\nLL cal(int x) {\n\treturn 1ll * x * (x + 1) / 2;\n}\n\nvoid modify(int x) {\n\tfor (; x <= mx; x += x & -x) tr[x] ++;\n}\n\nint ask(int x) {\n\tint num = 0;\n\tfor (; x; x -= x & -x) num += tr[x];\n\treturn num;\n}\n\nint query(int l, int r) {\n\treturn ask(r) - ask(l - 1);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i ++) scanf(\"%d%d\", &p[i].x, &p[i].y), d[++ tot] = p[i].x;\n\tprepare();\n\tsort(p + 1, p + n + 1, cmp);\n\tint num = 0;\n\tfor (int i = 1; i <= n; i ++) {\n\t\tint h = p[i].y, res, lst = 0;\n\t\tLL del = 0;\n\t\tif (!flag[p[i].x]) flag[p[i].x] = 1, num ++, modify(p[i].x);\n\t\tres = query(lst + 1, p[i].x - 1);\n\t\tdel += cal(res);\n\t\tlst = p[i].x;\n\t\twhile (i < n && p[i + 1].y == h) {\n\t\t\ti ++;\n\t\t\tif (!flag[p[i].x]) num ++, flag[p[i].x] = 1, modify(p[i].x);\n\t\t\tres = query(lst + 1, p[i].x - 1);\n\t\t\tdel += cal(res);\n\t\t\tlst = p[i].x;\n\t\t}\n\t\tres = query(lst + 1, mx);\n\t\tdel += cal(res);\n\t\tans += cal(num) - del;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}",
    "ext": "cpp"
  },
  "58159892": {
    "code": "// #include<iostream>\n// #include<algorithm>\n// #include<cstdio>\n// #include<cstring>\n// #include<queue>\n// #include<string>\n// #include<map>\n// #include<cmath>\n// #define INF 0x3f3f3f3f\n// #define rep(i,a,n) for(int i=a;i<n;i++)\n// #define per(i,a,n) for(int i=n-1;i>=a;i--)\n// #define fori(x) for(int i=0;i<x;i++)\n// #define forj(x) for(int j=0;j<x;j++)\n// #define memset(x,y) memset(x,y,sizeof(x))\n// #define memcpy(x,y) memcpy(x,y,sizeof(y))\n// #define sca(x) scanf(\"%d\", &x)\n// #define scas(x) scanf(\"%s\",x)\n// #define sca2(x,y) scanf(\"%d%d\",&x,&y)\n// #define sca3(x,y,z) scanf(\"%d%d%d\",&x,&y,&z)\n// #define scl(x) scanf(\"%lld\",&x)\n// #define scl2(x,y) scanf(\"%lld%lld\",&x,&y)\n// #define scl3(x,y,z) scanf(\"%lld%lld%lld\",&x,&y,&z)\n// #define pri(x) printf(\"%d\\n\",x)\n// #define pri2(x,y) printf(\"%d %d\\n\",x,y)\n// #define pris(x) printf(\"%s\\n\",x)\n// #define prl(x) printf(\"%lld\\n\",x)\n// //#include <bits/stdc++.h>\n//\n// typedef long long ll;\n// const int maxn=2e5+50;\n// const int mod=1e9+7;\n// const double eps=1e-8;\n// // const double pi = acos(-1);\n//\n// using namespace std;\n//\n// int n;\n// ll num[maxn];\n// ll b[maxn];\n// struct node{\n//   ll x,y;\n// }a[maxn];\n// int lowbit(int x)\n// {\n//   return x & -x;\n// }\n// ll query(int x)\n// {\n//   ll sum = 0;\n//   while(x>0)\n//   {\n//     sum += num[x];\n//     // cout<<num[x]<<\"---\"<<endl;\n//     x -= lowbit(x);\n//   }\n//   return sum;\n// }\n//\n// void add(int i, int x)\n// {\n//   while(i <= maxn)\n//   {\n//     num[i] += x;\n//     i += lowbit(i);\n//   }\n// }\n//\n// bool cmp(node a, node b)\n// {\n//   if(a.y == b.y) return a.x < b.x;\n//   return a.y > b.y;\n// }\n// int visit[maxn];\n// int main()\n// {\n//\n//     ll m;\n//     sca(n);\n//     rep(i,1,n+1)\n//     {\n//       scl2(a[i].x, a[i].y);\n//       b[i] = a[i].x;\n//       num[i] = 0;\n//       visit[i] = 0;\n//     }\n//     sort(b+1,b+n+1);\n//     int pos = 2;\n//     rep(i,2,n+1) if(b[i] != b[i-1]) b[pos++] = b[i];\n//     ll ans = 0;\n//     sort(a+1,a+n+1, cmp);\n//     int pre = -1;\n//     // rep(i,1,n+1)\n//     // {\n//     //   cout<<a[i].x <<\" \"<< a[i].y<<endl;\n//     // }\n//     rep(i,1,n+1)\n//     {\n//       int p = lower_bound(b+1, b+1+pos, a[i].x) - b;\n//       // cout<<p<<endl;\n//       if(!visit[p])  visit[p] = 1, add(p,1);\n//       if(a[i].y != a[i+1].y){\n//         if(pre == -1){\n//           ll l = query(p);\n//           ll r = query(pos) - l;\n//           ans += l * (r+1);\n//         }\n//         else{\n//           int res = 0;\n//           ll r = query(pos);\n//           // cout<<r<<endl;\n//           rep(j,pre, i+1)\n//           {\n//             int pp = lower_bound(b+1, b+1+pos, a[j].x)-b;\n//             ll l = query(pp) - query(res);\n//             ans += l*(r - query(pp) + 1);\n//             res = pp;\n//           }\n//         }\n//         pre = -1;\n//       }\n//       else if(pre==-1) pre = i;\n//     }\n//     prl(ans);\n//     return 0;\n// }\n\n\n#include<bits/stdc++.h>\n#define ll long long\n#define lowbit(x) (x & -x)\nusing namespace std;\nconst int maxn = 2e5 + 50;\nll cx[maxn], cy[maxn];\nint nx, ny;\nll l[maxn], r[maxn];\nint n;\nll a[maxn];\nvoid add(int i, int x)\n{\n    while(i < maxn){\n        a[i] += x;\n        i += lowbit(i);\n    }\n}\nll query(int i)\n{\n    ll ans = 0;\n    while(i){\n        ans += a[i];\n        i -= lowbit(i);\n    }return ans;\n}\nstruct node{\n    ll x, y;\n    bool operator < (const node & a){\n        if(y != a.y) return y > a.y;\n        return x < a.x;\n    }\n}e[maxn];\nint main()\n{\n    memset(l,0x3f,sizeof l);\n    memset(r,0,sizeof r);\n    nx = ny = 0;\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; ++i) {\n        scanf(\"%I64d%I64d\",&e[i].x, &e[i].y);\n        cx[++nx] = e[i].x;\n        cy[++ny] = e[i].y;\n    }\n    cx[++nx] = 0x3f3f3f3f;\n    sort(cx+1, cx+1+nx);\n    nx = unique(cx+1, cx+1+nx) - cx - 1;\n    sort(cy+1, cy+1+ny);\n    ny = unique(cy+1, cy+1+ny) - cy - 1;\n    ll ans = 0;\n    sort(e+1, e+1+n);\n    add(nx, 1);\n    int pre = -1;\n    for(int i = 1; i <= n; ++i){\n        int posx = lower_bound(cx+1, cx+nx+1, e[i].x) - cx;\n        if(query(posx) - query(posx-1) == 0) add(posx, 1);\n        if(e[i].y != e[i+1].y){\n            if(pre == -1){\n                int posx = lower_bound(cx+1, cx+nx+1, e[i].x) - cx;\n                ll L = query(posx);\n                ll R = query(nx) - L;\n                ans += L*R;\n            }\n            else{\n                ll res = 0;\n                ll A = query(nx);\n                for(int j = pre; j <= i; ++j){\n                    int posx = lower_bound(cx+1, cx+nx+1, e[j].x) - cx;\n                    ll L = query(posx) - query(res);\n                    ans += L*(A - query(posx));\n                    res = posx;\n                }\n                pre = -1;\n            }\n        }\n        else if(pre == -1) pre = i;\n    }\n    cout<<ans<<endl;\n}\n",
    "ext": "cpp"
  },
  "58146759": {
    "code": "#include <algorithm>\n#include <iostream>\n#include <numeric>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <map>\n\n\n// ================================ //\n\n#define INLINE inline __attribute__((always_inline))\ntemplate <class... Args> INLINE void read(Args& ...args)\n{ (std::cin >> ... >> args); }\ntemplate <class... Args> INLINE void write(Args&& ...args)\n{ (std::cout << ... << std::forward<Args>(args)); }\ntemplate <class... Args> INLINE void writeln(Args&& ...args)\n{ write(std::forward<Args>(args)..., '\\n'); }\nINLINE void flush() { std::flush(std::cout); }\n#undef INLINE\n\n// ================================ //\n\nstruct bi_tree { // Fenwick\n\tstd::vector<int> data;\n\texplicit bi_tree(int sz) : data(sz) {}\n\n\tint pref_sum(int r) {\n\t\tint res = 0;\n\t\tfor (; r; r -= r & (-r))\n\t\t\tres += data[r-1];\n\t\treturn res;\n\t}\n\n\tvoid add(int i, int d) {\n\t\tfor (++i; i <= (int)data.size(); i += i & (-i))\n\t\t\tdata[i-1] += d;\n\t}\n\n\tint sum(int l, int r) {\n\t\treturn pref_sum(r) - pref_sum(l);\n\t}\n\n\tint get(int i) {\n\t\treturn sum(i, i+1);\n\t}\n\n\tvoid set(int pos, int val) {\n\t\tint cur = sum(pos, pos + 1);\n\t\tif (cur != val)\n\t\t\tadd(pos, val - cur);\n\t}\n};\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tstd::fixed(std::cout).precision(20);\n\tstd::cin.tie(nullptr);\n\n\tint n; read(n);\n\n\tstruct point_t { int x, y; };\n\tstd::vector<point_t> ps(n);\n\tfor (auto& [x, y] : ps) read(x, y);\n\n\tstd::vector<int> xs; xs.reserve(n);\n\tfor (auto p : ps) xs.push_back(p.x);\n\tstd::sort(xs.begin(), xs.end());\n\txs.erase(std::unique(xs.begin(), xs.end()), xs.end());\n\tint cnt_xs = 1 + xs.size();\n\tfor (auto& p : ps)\n\t\tp.x = 1 + (std::lower_bound(xs.begin(), xs.end(), p.x) - xs.begin());\n\n\tstd::sort(ps.begin(), ps.end(), \n\t\t[] (const point_t& a, const point_t& b) {\n\t\t\treturn a.y != b.y ? a.y > b.y \n\t\t\t                  : a.x < b.x;\n\t\t});\n\n\n\tbi_tree used_xs(cnt_xs);\n\tint64_t res = 0;\n\n\txs.clear();\n\txs.push_back(0);\n\tint cur_y = ps[0].y;\n\tps.push_back({0, 0});\n\tfor (auto [x, y] : ps) {\n\t\tif (cur_y != y) {\n\n\t\t\tfor (int i = 1; i < (int)xs.size(); ++i) {\n\t\t\t\tint64_t left_ends = used_xs.sum(xs[i-1]+1, xs[i]+1);\n\t\t\t\tint64_t right_ends = used_xs.sum(xs[i], cnt_xs);\n\t\t\t\tres += left_ends * right_ends;\n\t\t\t}\n\n\t\t\tcur_y = y;\n\t\t\txs.clear();\n\t\t\txs.push_back(0);\n\t\t}\n\t\tused_xs.set(x, 1);\n\t\txs.push_back(x);\n\t}\n\n\twriteln(res);\n\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "58096500": {
    "code": "#include<bits/stdc++.h>\n#include<algorithm>\nusing namespace std;\n\n#define ll long long\n#define ld long double\n\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define repb(i,a,b) for(ll i=a;i>=b;i--)\n#define repA(i,A)   for(auto i:A)\n\n#define err() cout<<\"==================================\"<<endl;\n#define errA(A) for(auto i:A)   cout<<i<<\" \";cout<<endl;\n#define err1(a) cout<<#a<<\" \"<<a<<endl\n#define err2(a,b) cout<<#a<<\" \"<<a<<\" \"<<#b<<\" \"<<b<<endl\n#define err3(a,b,c) cout<<#a<<\" \"<<a<<\" \"<<#b<<\" \"<<b<<\" \"<<#c<<\" \"<<c<<endl\n#define err4(a,b,c,d) cout<<#a<<\" \"<<a<<\" \"<<#b<<\" \"<<b<<\" \"<<#c<<\" \"<<c<<\" \"<<#d<<\" \"<<d<<endl\n\n#define mp make_pair\n#define pb push_back\n#define all(A)  A.begin(),A.end()\n#define allr(A)\tA.rbegin(),A.rend()\n#define ft first\n#define sd second\n\n#define pll pair<ll,ll>\n#define V vector<ll>\n#define S set<ll>\n#define VV vector<V> \n#define Vpll vector<pll>\n\n#define endl \"\\n\"\n\nconst ll logN = 20;\nconst ll N = 200005;\nconst ll M = 1000000007;\nconst ll INF = 1e12;\n#define PI 3.14159265\n\nconst ll dx[4] = {1,0,-1,0};\nconst ll dy[4] = {0,1,0,-1};\n\nV v[N];\nset<ll> s;\n\nll fen[N];\n\nvoid add(ll x,ll n){\n\twhile(x<n){\n\t\tfen[x]+=1;\n\t\tx+=(x&(-x));\n\t}\n\treturn;\n}\n\nll get(ll x){\n\tll ans=0;\n\twhile(x>0){\n\t\tans+=fen[x];\n\t\tx-=(x&(-x));\n\t}\n\treturn ans;\n}\n\nll A[N][2];\nV X;\n\nint main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    ll n;\n    cin>>n;\n    map<ll,ll> m1;\n    ll ans=0;\n    map<ll,V> m;\n    rep(i,0,n){\n    \tll x,y;\n    \tcin>>x>>y;\n    \tA[i][0]=x;A[i][1]=y;\n    \tX.pb(x);\n    }\n    sort(all(X));\n    ll cnt=1;\n    for(auto i:X){\n    \tif(m1.count(i)==0){\n    \t\tm1[i]=cnt;\n    \t\tcnt++;\n    \t}\n    }\n    rep(i,0,n){\n    \tm[A[i][1]].pb(m1[A[i][0]]);\n    }\n    for(auto i=m.rbegin();i!=m.rend();i++){\n    \tfor(auto j:i->sd){\n    \t\tif(s.find(j)==s.end()){\n    \t\t\tadd(j,cnt);\n    \t\t\ts.insert(j);\n    \t\t}\n    \t}\n    \tsort(all(i->sd));\n    \tll last=0,tot=0;\n    \tll sz = s.size();\n    \tfor(auto j:i->sd){\n    \t\tll l = get(last);\n    \t\tll r = get(j);\n    \t\ttot += (r-l);\n    \t\tans += (r-l)*(sz-tot+1);\n    \t\tlast=j;\n    \t}\n    }\n    cout<<ans<<endl;\n    return 0;\n}",
    "ext": "cpp"
  },
  "58084184": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long Long;\n\nconst Long MX = 4e5 + 100;\n\nvector< pair<Long,Long> > pun;\n\nLong tree[2][MX];\n\n//Tree[0] acumula los aumentos para cuando ingrese un \"x\" nuevo\n//Tree[1] acumula los aumentos de los ultimos \"y\"\nLong query(Long i, Long t){\n\tLong sum = 0;\n\twhile(i > 0){\n\t\tsum += tree[t][i];\n\t\ti -= ( i & -i );\n\t}\n\treturn sum;\n}\n\nvoid update(Long i, Long dif, Long t){\n\twhile(i < MX){\n\t\ttree[t][i] += dif;\n\t\ti += ( i & -i );\n\t}\n\treturn;\n}\n\nvoid llena(vector<Long> &YY, Long &ans, Long pos){\n\t//auemnta lo mismo que antes a partir del menor \"y\"\n\tLong sum = query(MX-1,1) - query(YY[YY.size() - 1]-1,1);\n\t//quita los valores pasados de los \"y\" encontrados\n\tfor(Long y : YY){\n\t\tLong resta = query(y,1) - query(y-1,1);\n\t\tsum -= resta;\n\t\tupdate(y,-resta,1);\n\t}\n\t//actualiza los \"y\" para cuando llegue un nuevo \"x\"\n\tupdate(YY[YY.size() - 1],1,0);\n\t//actualiza los nuevos valores de los \"y\" encontrados\n\tfor(Long y : YY){\n\t\tLong aumenta = query(y,0);\n\t\tupdate(y,aumenta,1);\n\t\tsum += aumenta;\n\t}\n\tans += sum;\n\t//cout << \"-- \" << sum << endl;\n\treturn;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tcout.precision(10);\n\tcout << fixed;\n\t\n\tset<Long> S;\n\tvector<Long> V;\n\t\n\tLong n, x, y;\n\tcin >> n;\n\tfor(Long i = 0; i < n; i++){\n\t\tcin >> x >> y;\n\t\tpun.push_back({x,y});\n\t\tS.insert(x);\n\t\tS.insert(y);\n\t}\n\t\n\tfor(Long xx : S){\n\t\tV.push_back(xx);\n\t}\n\t\n\tfor(Long i = 0; i < n; i++){\n\t\tx = pun[i].first;\n\t\tx = lower_bound(V.begin(),V.end(),x) - V.begin(); x++;\n\t\ty = pun[i].second;\n\t\ty = lower_bound(V.begin(),V.end(),y) - V.begin(); y++;\n\t\tpun[i] = {x,y};\n\t}\n\t\n\tsort(pun.begin(),pun.end());\n\t\n\tvector<Long> YY;\n\tLong ind = 0;\n\tLong ans = 0;\n\tfor(Long i = 0; i < n; i++){\n\t\tYY.clear();\n\t\tx = pun[i].first;\n\t\twhile(i < n && x == pun[i].first){\n\t\t\t//cambio de \"y\" para q el infinito sea hacia el 0\n\t\t\tYY.push_back(MX - pun[i].second - 1);\n\t\t\ti++;\n\t\t}\n\t\ti--;\n\t\t\n\t\tllena(YY,ans,ind);\n\t\tind++;\n\t}\n\t\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "58062652": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,pll> ppll;\ntypedef long double ld;\n\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define fst first\n#define snd second\n#define ins insert\n#define pb push_back\n\nconst int N = 5e5 + 5;\nconst int MOD = 1e9 + 7;\nvector<int> g[N];\nint cnt[N];\nint t[4 * N];\nvoid upd(int v,int tl,int tr,int pos,int val){\n    if(tl == tr){\n        t[v] += val;\n        return;\n    }\n    int tm = (tl + tr) >> 1;\n    if(pos <= tm)upd(2 * v,tl,tm,pos,val); else upd(2 * v + 1,tm + 1,tr,pos,val);\n    t[v] = t[2 * v] + t[2 * v + 1];\n}\nint get(int v,int tl,int tr,int l,int r){\n    if(l <= tl && tr <= r){\n        return t[v];\n    }\n    int tm = (tl + tr) >> 1;\n    if(r <= tm)return get(2 * v,tl,tm,l,r);\n    if(l > tm)return get(2 * v + 1,tm + 1,tr,l,r);\n    return get(2 * v,tl,tm,l,r) + get(2 * v + 1,tm + 1,tr,l,r);\n}\nvector<pll> a;\nint main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    //freopen(\".in\", \"r\", stdin);\n    //freopen(\".out\", \"w\", stdout);\n    int n;\n    cin >> n;\n    for(int i = 0;i < n; ++i){\n        int x,y;\n        cin >> x >> y;\n        a.pb({x,y});\n    }\n    sort(all(a));\n    int cn = 0;\n    for(int i = 1;i < n; ++i){\n        if(a[i].fst == a[i - 1].fst)a[i - 1].fst = cn;else a[i - 1].fst = cn++;\n    }\n    a[n - 1].fst = cn;\n    sort(all(a),[](pll a,pll b){\n        if(a.snd == b.snd)return a.fst < b.fst;else return a.snd < b.snd;\n    });\n    cn = 0;\n    for(int i = 1;i < n; ++i){\n        if(a[i].snd == a[i - 1].snd)g[cn].pb(a[i - 1].fst);else g[cn++].pb(a[i - 1].fst);\n    }\n    g[cn].pb(a[n - 1].fst);\n    for(int i = 0;i < n; ++i){\n        cnt[a[i].fst]++;\n        if(cnt[a[i].fst] == 1)upd(1,0,n,a[i].fst,1);\n    }\n    ll ans = 0;\n    for(int i = 0;i < n; ++i){\n        if(g[i].empty())break;\n        g[i].pb(n + 1);\n        int r = 0;\n        for(int j = 0;j < g[i].size() - 1; ++j){\n            r = g[i][j + 1] - 1;\n            ll sl = get(1,0,n,0,g[i][j]),sr = get(1,0,n,g[i][j],r);\n            ans += sl * sr;\n        }\n        for(int j = 0;j < g[i].size() - 1; ++j){\n            cnt[g[i][j]]--;\n            if(cnt[g[i][j]] == 0)upd(1,0,n,g[i][j],-1);\n        }\n    }\n    cout << ans;\n    return 0;\n}\n\n\n\n",
    "ext": "cpp"
  },
  "57991925": {
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define MAX 200200\nusing namespace std;\n\n// vector<int> memo(MAX,0);\n// void update(int x){\n//     memo[x]=1;\n// }\n// int query(int x){\n//     int sum = 0;\n//     for(int i=0;i<=x;i++){\n//         sum += memo[i];\n//     }\n//     return sum;\n// }\n\nvector<int> tree(4*MAX, 0);\n\nint update(int idx, int start=0, int end=MAX-1, int node = 0){\n    if(start == end){\n        int retval = int(tree[node]==0);\n        tree[node] = 1;\n        return retval;\n    }\n    int mid = (start + end)/2;\n    int retval;\n    if(idx<=mid)\n        retval = update(idx, start, mid, 2*node + 1);\n    else\n        retval = update(idx, mid+1, end, 2*node+2);\n    \n    tree[node] += retval;\n    return retval;\n}\n\nint query(int r, int l=0, int start=0, int end=MAX-1, int node=0){\n    if(l<=start && end<=r){\n        return tree[node];\n    }\n    \n    int mid = (start+end)/2;\n    int ans = 0;\n    if(mid<l){\n        ans = query(r, l, mid+1, end, 2*node + 2);\n    }else if(r<=mid){\n        ans = query(r, l, start, mid, 2*node + 1);\n    }else{\n        ans = query(mid, l, start, mid, 2*node + 1);\n        ans += query(r, mid+1, mid+1, end, 2*node + 2);\n    }\n    return ans;\n}\nint main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\n    int n;\n    cin>>n;\n    vector<pair<int, int> > corr(n);\n    for(int i=0;i<n;i++){\n        cin>>corr[i].X>>corr[i].Y;\n    }\n    sort(corr.begin(), corr.end());\n    {\n        int i=0;\n        int cnt = 0;\n        while(i<n){\n            int curr = corr[i].X;\n            while(i<n && corr[i].X==curr)\n                corr[i++].X = cnt;\n            cnt++;\n        }\n    }\n    map<int, vector<int> > mp;\n    for(int i=0;i<n;i++)\n        mp[corr[i].Y].push_back(corr[i].X);\n\n    long long ans = 0;\n    for(auto it = mp.rbegin(); it!=mp.rend(); it++){\n        // cout<<\"y level \"<<(*it).first<<endl;\n        vector<int> &arr = (*it).second;\n        int sz = arr.size();\n        long long tmp;\n        for(int i=0;i+1<sz;i++){\n            update(arr[i]);\n            tmp = query(arr[i]);\n            ans += tmp;\n            ans += (query(arr[i+1]-1) - tmp)*tmp;\n        }\n        // have to handle case for array last element\n        update(arr[sz-1]);\n        tmp = query(arr[sz-1]);\n        ans += tmp;\n        ans += (query(MAX-1) - tmp)*tmp;\n    }\n    cout<<ans<<endl;\n    return 0;\n}",
    "ext": "cpp"
  },
  "57967426": {
    "code": "#include<bits/stdc++.h>\n#include<vector>\nusing namespace std;\n#define maxn 200005\nstruct Node {int x,y;}p[maxn];\nint cmp(Node a,Node b){\n\tif(a.y==b.y)return a.x<b.x;\n\treturn a.y>b.y;\n}\nint n,m;\nvector<int>x,y;\n \nint bit[maxn],f[maxn];\nvoid update(int x){\n\twhile(x<=m){\n\t\tbit[x]++;\n\t\tx+=x&-x;\n\t}\n}\nint query(int x){\n\tint res=0;\n\twhile(x){\n\t\tres+=bit[x];\n\t\tx-=x&-x;\n\t}\n\treturn res;\n}\n \nint main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>p[i].x>>p[i].y;\n\t\tx.push_back(p[i].x);\n\t}\n\tsort(p+1,p+1+n,cmp);\n\tsort(x.begin(),x.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\tm=x.size();\n\t\n\tlong long ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint pos,R;\n\t\tif(i==n || p[i+1].y!=p[i].y)\n\t\t\tR=m;\n\t\t\t\n\t\telse R=lower_bound(x.begin(),x.end(),p[i+1].x)-x.begin()+1-1;\n\t\tpos=lower_bound(x.begin(),x.end(),p[i].x)-x.begin()+1;//p[i]\u6240\u5728\u4f4d\u7f6e\n\t\tif(!f[pos])\n\t\t\tupdate(pos),f[pos]=1;\n\t\tans+=(long long)query(pos)*(query(R)-query(pos-1));\t\n\t}\n\tcout<<ans<<endl;\n}",
    "ext": "cpp"
  },
  "57964017": {
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define maxn 200000 \nusing namespace std;\nstruct segment_tree{\n\tstruct node{\n\t\tint l;\n\t\tint r;\n\t\tint v;\n\t}tree[maxn*4+5];\n\tvoid push_up(int pos){\n\t\ttree[pos].v=tree[pos<<1].v+tree[pos<<1|1].v;\n\t}\n\tvoid build(int l,int r,int pos){\n\t\ttree[pos].l=l;\n\t\ttree[pos].r=r;\n\t\ttree[pos].v=0;\n\t\tif(l==r) return;\n\t\tint mid=(l+r)>>1;\n\t\tbuild(l,mid,pos<<1);\n\t\tbuild(mid+1,r,pos<<1|1); \n\t}\n\tvoid update(int upos,int uval,int pos){\n\t\tif(tree[pos].l==tree[pos].r){\n\t\t\ttree[pos].v=uval;//\u76f8\u540c\u5750\u6807\u7684\u70b9\u53ea\u7b971\u6b21\uff0c\u56e0\u4e3a\u7ecf\u8fc7\u5b83\u7684\u76f4\u7ebfx=l\u53ea\u67091\u6761 \n\t\t\treturn;\n\t\t}\n\t\tint mid=(tree[pos].l+tree[pos].r)>>1; \n\t\tif(upos<=mid) update(upos,uval,pos<<1);\n\t\telse update(upos,uval,pos<<1|1);\n\t\tpush_up(pos); \n\t}\n\tint query(int L,int R,int pos){\n\t\tif(L<=tree[pos].l&&R>=tree[pos].r){\n\t\t\treturn tree[pos].v;\n\t\t}\n\t\tint mid=(tree[pos].l+tree[pos].r)>>1;\n\t\tint ans=0;\n\t\tif(L<=mid) ans+=query(L,R,pos<<1);\n\t\tif(R>mid) ans+=query(L,R,pos<<1|1);\n\t\treturn ans;\n\t}\n}T;\n\nstruct point{\n\tint x;\n\tint y;\n\tpoint(){\n\t\t\n\t}\n\tpoint(int _x,int _y){\n\t\tx=_x;\n\t\ty=_y;\n\t} \n\tfriend bool operator < (point p,point q){\n\t\tif(p.y==q.y) return p.x<q.x;\n\t\telse return p.y>q.y;\n\t}\n}a[maxn+5];\nint b[maxn+5];\nint n,xn,y_n;\nint tmp[maxn+5];\nvoid discrete(){\n\tfor(int i=1;i<=n;i++) tmp[i]=a[i].x;\n\tsort(tmp+1,tmp+1+n);\n\txn=unique(tmp+1,tmp+1+n)-tmp-1;\n\tfor(int i=1;i<=n;i++) a[i].x=lower_bound(tmp+1,tmp+1+xn,a[i].x)-tmp; \n\tfor(int i=1;i<=n;i++) tmp[i]=a[i].y;\n\tsort(tmp+1,tmp+1+n);\n\ty_n=unique(tmp+1,tmp+1+n)-tmp-1;\n\tfor(int i=1;i<=n;i++) a[i].y=lower_bound(tmp+1,tmp+1+y_n,a[i].y)-tmp; \n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d %d\",&a[i].x,&a[i].y);\n\t}\n\tdiscrete();\n\tsort(a+1,a+1+n);\n\tlong long ans=0;\n\tT.build(1,xn+1,1);\n\tint l=1,r=1;\n\twhile(l<=n){\n\t\twhile(a[r].y==a[l].y){\n\t\t\tT.update(a[r].x,1,1);\n\t\t\tb[r]=a[r].x;\n\t\t\tr++;\n\t\t}\n\t\tb[r]=xn+1;\n\t\tfor(int i=l;i<r;i++){\n\t\t\t//\u8be5\u5c42\u6700\u53f3\u7aef\u7684\u65b0\u70b9\u4e3ab[i] \n\t\t\tlong long cntl=T.query(1,b[i]-1,1);\n\t\t\tlong long cntr=T.query(b[i]+1,b[i+1]-1,1);\n\t\t\tans+=(cntl+1)*(cntr+1);//\u8fd8\u8981\u52a0\u4e0a\u672c\u8eab \n\t\t}\n\t\tl=r;\n\t}\n\tprintf(\"%I64d\\n\",ans);\n}\n",
    "ext": "cpp"
  },
  "57958411": {
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#define all(x) x.begin(),x.end()\n#define len(x) (int)(x).size()\n#define m_p make_pair\n#define int long long\n\n/*\n#pragma GCC omptimize(\"unroll-loops\")\n#pragma optimize(\"SEX_ON_THE_BEACH\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma comment(linker, \"/STACK:1000000000\")\n*/\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pari;\n\nld PI = 3.14159265358979323846;\n\n\nstruct Point{\n    string a;\n    int x,ind;\n};\n\ntypedef tree<int, null_type, less<int >,\n    rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nvoid volodya22(){\n    #ifdef THERE\n        freopen(\"input.txt\", \"r\", stdin);\n    //    freopen(\"output.txt\", \"w\", stdout);\n    #else\n        //#define endl \"\\n\"\n    #endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    //cout.precision(15);\n    //cout << fixed;\n}\n\n\nint n,k;\nconst int N = 1e6+7;\nconst int alphabet = 256;\nconst int INF = 1e18+7;\nconst ll MOD = 1e9+7;\nconst ld eps = 1e-10;\nconst int L = 30;\n\nint m1 = 137*137*137*137*13;\nint m2 = 1e9+9;\n//int p = 347;\n\npari arr[N];\nmap<int,int> up;\n\nvoid input(){\n    cin >> n;\n    for(int i = 0;i < n;i++)\n        cin >> arr[i].first >> arr[i].second;\n    sort(arr,arr+n,[](pari a,pari b){\n         if(a.second == b.second) return a.first < b.first;\n         return a.second < b.second;\n    });\n\n    ordered_set X;\n    set<int> Y;\n    for(int i = 0;i < n;i++){\n        X.insert(arr[i].first);\n        Y.insert(arr[i].second);\n        up[arr[i].first] = max(up[arr[i].first],arr[i].second);\n    }\n\n    vi x;\n    for(int i : X) x.push_back(i);\n    int ans = 0;\n    int j = 0;\n    for(int i : Y){\n        int l = 0;\n        for(int e : x){\n            int cnt = X.order_of_key(e);\n            if(X.find(e) != X.end()){\n                ans += (cnt+1-l)*(len(X)-cnt);\n            }else{\n                ans += (cnt-l)*(len(X)-cnt);\n            }\n            l = cnt+1;\n            if(X.find(e) == X.end())\n                l--;\n        }\n        x.clear();\n        while(j < n && arr[j].second == i){\n            x.push_back(arr[j].first);\n            if(up[arr[j].first] == arr[j].second){\n                X.erase(X.find(arr[j].first));\n                //cout << arr[j].first << endl;\n            }\n            j++;\n        }\n        //cout << ans << ' ' << i << endl;\n    }\n    cout << ans;\n}\n\n\nvoid solve(){\n\n}\n\nsigned main(){\n    volodya22();\n    input();\n    solve();\n}\n",
    "ext": "cpp"
  },
  "57913263": {
    "code": "#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef long double ldb;\ntypedef vector<ll> vll;\ntypedef ll __T;\ntypedef tree<__T, null_type, less<__T>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\n#define ff first\n#define ss second\n#define pll pair<ll,ll>\n#define CL(a) memset(a,0,sizeof(a))\n#define all(x) x.begin(),x.end()\n#define sz(x) ((ll)x.size())\n#define lp0(i,n) for(ll i=0;i<n;i++)\n#define lp1(i,n) for(ll i=1;i<=n;i++)\n#define pb push_back\n#define mpr make_pair\n#define op(a) cout << a << \"\\n\";\n#define tc ll testcase; cin>>testcase; while(testcase--)\n#define fast_io() ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n#define l(x)                     cout <<\"lol\"<<x<<\"\\n\";\n#define trace1(x)                cout <<#x<<\":\"<<x<< endl;\n#define trace2(x, y)             cout <<#x<<\":\"<<x<<\" | \"<<#y<<\":\"<<y<< endl;\n#define trace3(x, y, z)          cout <<#x<<\":\"<<x<<\" | \"<<#y<<\":\"<<y<<\" | \"<<#z<<\":\"<<z<<endl;\n#define trace4(a, b, c, d)       cout <<#a<<\":\"<<a<<\" | \"<<#b<<\":\"<<b<<\" | \"<<#c<<\":\"<<c<<\" | \"<<#d<<\":\"<<d<<endl;\n\nconst ll mod = 1e9+7;\nconst ldb PI = acos(-1);\n\nll POWER[65];\nvoid precompute() {POWER[0]=1; for(ll i=1;i<63;i++) POWER[i]=POWER[i-1]<<1LL; }\nll fastMul(ll a,ll b,ll mod){ll res = 0; a %= mod; while (b){   if (b & 1){res = (res + a) % mod;} a = (2 * a) % mod; b >>= 1;} return res;}\nll power(ll x,ll y,ll mod2) {ll res=1; x%=mod2; while(y) {if(y&1) res=fastMul(res,x,mod2); y>>=1; x=fastMul(x,x,mod2); }return res;}\nll inv(ll x,ll mod){return power(x,mod-2,mod);}\n\n// freopen(\"testfile.txt\", \"r\", stdin);\n// freopen(\"output.txt\", \"w\", stdout);\n// Array Stack Queue Segment_tree Map Set Oredred_set\n// order_of_key , find_by_order\n\n/* Look at the stars , look how they shine for you ! */\n\nmap<ll,vector<ll>,greater<ll>> adj;\nint main()\n{\n        fast_io();\n\n        ll n;\n        cin >> n;\n\n        for(ll i=0;i<n;i++){\n                ll x,y;\n                cin >> x >> y;\n                adj[y].pb(x);\n        }\n\n        ordered_set sett;\n        ll ans = 0;\n        for(auto e:adj){\n                vector<ll> p = e.second;\n                sort(all(p));\n                for(auto it:e.second) {\n\t\t\tsett.insert(it);\n\t\t}\n\n                ll len = sz(sett);\n                ans += (len*(len+1))/2;\n                for(ll i=1;i<sz(p);i++){\n                        if(p[i-1] < p[i]){\n                                ll u = sett.order_of_key(p[i]) - sett.order_of_key(p[i-1]+1);\n                                ans -= (u*(u+1))/2;\n                        }\n                }\n\n                ll u1 = sett.order_of_key(p[0]);\n                ans -= (u1*(u1+1))/2;\n                ll u2 = len - sett.order_of_key(p[sz(p)-1]+1);\n                ans -= (u2*(u2+1))/2;\n        }\n\n        cout << ans << \"\\n\";\n        return 0;\n}\n",
    "ext": "cpp"
  },
  "57873406": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint discretize(vector<int> &ori) {\n\tvector<pair<int, int>> ele;\n\tfor (int i = 0; i < ori.size(); i++) {\n\t\tele.push_back(make_pair(ori[i], i));\n\t}\n\tsort(ele.begin(), ele.end());\n\tint idx = 0, pre = ele[0].first - 1;\n\tfor (auto e: ele) {\n\t\tif (e.first > pre) {\n\t\t\tidx++;\n\t\t}\n\t\tori[e.second] = idx;\n\t\tpre = e.first;\n\t}\n\treturn idx + 1;\n}\n\ninline ll calc(ll x) {\n\treturn x * (x - 1) / 2 + x;\n}\n\nvoid add(vector<int> &c, int x) {\n\twhile (x < c.size()) {\n\t\tc[x] += 1;\n\t\tx += x & -x;\n\t}\n}\n\nint get(vector<int> &c, int x) {\n\tint res = 0;\n\twhile (x) {\n\t\tres += c[x];\n\t\tx -= x & -x;\n\t}\n\treturn res;\n}\n\nint query(vector<int> &c, int l, int r) {\n\tif (l > r) {\n\t\treturn 0;\n\t}\n\tif (l) {\n\t\tl = get(c, l - 1);\n\t}\n\tr = get(c, r);\n\treturn r - l;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tint rng = discretize(x);\n\tvector<pair<int, int>> p;\n\tfor (int i = 0; i < n; i++) {\n\t\tp.push_back(make_pair(y[i], x[i]));\n\t}\n\tsort(p.begin(), p.end(), greater<pair<int, int>>());\n\tvector<int> c(rng + 1, 0);\n\tint tot = 0;\n\tll ans = 0;\n\tfor (int i = 0, j = 0; i < n; i = j) {\n\t\twhile (p[j].first == p[i].first) {\n\t\t\tif (!query(c, p[j].second, p[j].second)) {\n\t\t\t\tadd(c, p[j].second);\n\t\t\t\ttot++;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tans += calc(tot);\n\t\tint pre = rng;\n\t\tfor (int k = i; k < j; k++) {\n\t\t\tans -= calc(query(c, p[k].second + 1, pre));\n\t\t\tpre = p[k].second - 1;\n\t\t}\n\t\tans -= calc(query(c, 0, pre));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57811344": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nstruct Point {\n  int x, y;\n};\n\nclass FenwickTree {\npublic:\n  int n;\n  vector<int> fenw;\n\n  FenwickTree(int _n) : n(_n) {\n    fenw.resize(n + 1, 0);\n  }\n\n  void add(int k, int v) {\n    k++;\n    while (k <= n) {\n      fenw[k] += v;\n      k += k & -k;\n    }\n  }\n\n  void assign(int k, int v) {\n    add(k, v - sum(k, k));\n  }\n\n  int sum(int k) {\n    k++;\n    int s = 0;\n    while (k >= 1) {\n      s += fenw[k];\n      k -= k & -k;\n    }\n    return s;\n  }\n\n  int sum(int ll, int rr) {\n    return sum(rr) - sum(ll - 1);\n  }\n};\n\n\nconst int INF = 2e9;\n\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n#ifdef _DEBUG\n  freopen(\"input.txt\", \"r\", stdin);\n  freopen(\"output.txt\", \"w\", stdout);\n  freopen(\"debug_output.txt\", \"w\", stderr);\n#endif\n\n\n  int n;\n  cin >> n;\n  vector<Point> pts(n);\n  for (int i = 0; i < n; i++) {\n    cin >> pts[i].x >> pts[i].y;\n  }\n  sort(pts.begin(), pts.end(), [](const Point &a, const Point &b) {\n    return a.x < b.x;\n  });\n  unordered_map<int, int> mm;\n  for (int i = 0; i < n; i++) {\n    if (!mm.count(pts[i].x)) {\n      int sz = mm.size();\n      mm[pts[i].x] = sz;\n    }\n  }\n  sort(pts.begin(), pts.end(), [](const Point &a, const Point &b) {\n    if (a.y != b.y) {\n      return a.y > b.y;\n    }\n    return a.x < b.x;\n  });\n  int c = 0;\n  FenwickTree ft(n);\n  long long ans = 0;\n  while (c < n) {\n    int e = c;\n    while (e < n && pts[e].y == pts[c].y) {\n      int x = mm[pts[e++].x];\n      ft.assign(x, 1);\n    }\n    // [c, e) have equal y-coord\n    for (int i = c; i < e; i++) {\n      int x = mm[pts[i].x];\n      int last = (i == c ? -1 : mm[pts[i - 1].x]);\n      int l = ft.sum(last + 1, x);\n      int r = ft.sum(x, n - 1);\n      ans += (long long) l * r;\n    }\n    c = e;\n  }\n  cout << ans << '\\n';\n\n\n  return 0;\n}\n",
    "ext": "cpp"
  },
  "57783756": {
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e6+10, INF = 0x3f3f3f3f;\nint bit[maxn],b[maxn],coun=0,vis[maxn];\nstruct node {\n    int x,y;\n}a[maxn];\nbool cmp(node a,node b){\n    if(a.y==b.y)return a.x<b.x;\n    else return a.y>b.y;\n}\nint mp(int x){\n    return  lower_bound(b+1,b+1+coun,x)-b-1;\n}\nint lowbit(int x)\n{\n    return x&(-x);\n}\nvoid update(int i)\n{ \n    i=mp(i);\n    if(!vis[i]){\n        vis[i]=1;\n       \n        while(i<=coun)\n        {\n            bit[i]++;\n            i+=lowbit(i);\n        }\n    }\n}\nint query(int i)\n{\n    int s=0;\n    while(i>0)\n    {\n        s+=bit[i];\n        i-=lowbit(i);\n    }\n    return s;\n}\nint query(int l,int r){\n    return query(mp(r))-query(mp(l-1));\n}\n \nint main() {\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d\",&a[i].x,&a[i].y);\n        b[++coun]=a[i].x;b[++coun]=a[i].x-1;\n    }\n    b[++coun]=0;b[++coun]=INF;\n    sort(a+1,a+n+1,cmp);sort(b+1,b+coun+1);\n    ll ans=0;\n    for(int i=1;i<=n;i++){\n        int j=i;\n        while(j<n&&a[j+1].y==a[i].y)j++;\n        for(int k=i;k<=j;k++){\n            int l=query(1,a[k].x-1);\n            int r=query(a[k].x+1,k==j?INF:a[k+1].x-1);\n            ans+=1ll*(l+1)*(r+1);\n            //cout<<l+1<<\" \"<<r+1<<endl;\n            update(a[k].x);\n        }\n        i=j;\n    }\n    printf(\"%lld\\n\", ans);\n   //while(1)getchar();\n}\n \t\t \t\t  \t\t\t\t\t     \t \t\t  \t  \t\t\t\t",
    "ext": "cpp"
  },
  "57765931": {
    "code": "#include <bits/stdc++.h>\n#define ll long long\n//#define int long long\n#define D double\n#define F first\n#define S second\n#define sc scanf\n#define pr printf\n#define B break\n#define R return\n#define C continue\n#define pb push_back\n//#define double long double\n//#define sz size()\n#define P pair <ll,ll>\n#define pi acos(-1)\nusing namespace std;\nll mod=998244353;\nll inf=1e15;\nll n,m,k,q;\nll w[200003];\nll x[200003];\nll y[200003];\nbool vis[200003];\nmap <ll,vector<ll>> V;\nmap <ll,ll> H;\nll h;\nvoid up(ll x){\n    for (int i=x;i<=h;i+=(i&-i)){\n        w[i]++;\n    }\n}\nll get(ll x){\n    ll d1=0;\n    for (int i=x;i>0;i-=(i&-i)){\n        d1+=w[i];\n    }\n    R d1;\n}\nint main() {\n    //freopen(\"dull.in\",\"r\",stdin);\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >>n;\n    for (int i=1;i<=n;i++){\n        cin >>x[i]>>y[i];\n        H[x[i]]=0;\n    }\n    h=1;\n    for (auto pp:H){\n        H[pp.F]=h++;\n    }\n    for (int i=1;i<=n;i++){\n        x[i]=H[x[i]];\n        V[y[i]].pb(x[i]);\n    }\n    vector <ll> v;\n    for (auto pp:V){\n        sort(V[pp.F].begin(),V[pp.F].end());\n        v.pb(pp.F);\n    }\n    ll ans=0;\n    for (int i=v.size()-1;i>=0;i--){\n        ll y=v[i];\n        for (auto pp:V[y]){\n            if (vis[pp]) C;\n            vis[pp]=1;\n            up(pp);\n        }\n        ll sum=get(h);\n        ll pr=0;\n        for (auto pp:V[y]){\n            ll d1=get(pp);\n            ll d2=get(pr);\n            d2=d1-d2;\n            pr=pp;\n            ans+=d2*(sum-d1+1);\n        }\n    }\n    cout <<ans<<endl;\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57756413": {
    "code": "#include<bits/stdc++.h>\n#define md (l + r) / 2\nusing namespace std;\nint n;\nconst int mxn = (2e5) + 5;\npair<int,int>p[mxn];\nmap<int,int>com;\nvector<int>x[mxn];\nset<pair<int,int> >s;\n\nint st[mxn * 4];\nvoid update(int p, int l, int r, int i, int x)\n{\n    if(r < i || l > i )return;\n    if(l == r)\n    {\n        st[p] += x;\n        return;\n    }\n    if(i <= md)update(p * 2, l, md, i, x);\n    else update(p * 2 + 1, md + 1, r, i, x);\n    st[p] = st[p * 2] + st[p * 2 + 1];\n}\nint sum(int p, int l, int r, int i, int j)\n{\n    if(r < i || l > j)return 0;\n    if(l >= i && r <= j)return st[p];\n    return sum(p * 2, l, md, i, j) + sum(p * 2 + 1, md + 1, r, i, j);\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i = 0 ; i < n ; ++i)\n        scanf(\"%d%d\",&p[i].first, &p[i].second);\n    sort(p, p + n);\n\n    for(int i = 0 ; i < n ; ++i)\n        com[p[i].first] = i;\n\n    for(int i = 0 ; i < n ; ++i)\n        x[com[p[i].first]].push_back(p[i].second);\n\n    for(int i = 0 ; i < n ; ++i)\n        reverse(x[i].begin(), x[i].end());\n\n    for(int i = 0 ; i < n ; ++i)\n    {\n        if(!x[i].empty())\n        {\n            s.insert({x[i].back(), i});\n            x[i].pop_back();\n            update(1, 0, n - 1, i, 1);\n        }\n    }   \n    long long ans = 0;\n    while(!s.empty())\n    {\n        int nm = s.size();\n        int vl = s.begin()->first;\n        int l = 0;\n\n        while(!s.empty() && s.begin()->first == vl)\n        {\n            int i = s.begin()->second;\n            int cnt = sum(1, 0, n - 1, l, i);\n            nm = nm - cnt;\n            ans = ans + (1LL * cnt * (nm + 1));\n            s.erase(s.begin());\n            if(!x[i].empty())\n            {\n                s.insert({x[i].back(), i});\n                x[i].pop_back();\n            }\n            else\n                update(1, 0, n - 1, i, -1);\n            l = i + 1;\n        }\n    }\n    cout<<ans<<endl;\n}",
    "ext": "cpp"
  },
  "57741730": {
    "code": "#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n#define res register int\n#define ll long long\n#define lowbit(x) ((x)&-(x))\n//#define cccgift\n#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\nchar buf[1<<21],*p1=buf,*p2=buf;\nnamespace wode{\n    template<typename T>\n    inline void read(T &x)\n    {\n        static char ch;bool f=1;\n        for(x=0,ch=getchar();!isdigit(ch);ch=getchar()) if(ch=='-') f=0;\n        for(;isdigit(ch);x=(x<<1)+(x<<3)+(ch^48),ch=getchar());x=f?x:-x;\n    }\n    template<typename T>\n    void print(T x)\n    {\n        if (x<0) putchar('-'),x=-x;\n        if (x>=10) print(x/10);\n        putchar(x%10+'0');\n    }\n    template<typename T>\n    inline void print(T x,char ap) {print(x);if (ap) putchar(ap);}\n    template<typename T>\n    inline T max(T x,T y) {return x<y?y:x;}\n    template<typename T>\n    inline T min(T x,T y) {return x<y?x:y;}\n    template<typename T>\n    inline void chkmax(T &x,T y) {x=x<y?y:x;}\n    template<typename T>\n    inline void chkmin(T &x,T y) {x=x<y?x:y;}\n}\nusing wode::read;using wode::chkmin;using wode::chkmax;using wode::print;\nstruct node{\n\tint x,y;\n\tbool operator <(const node &b)const {return y>b.y||(y==b.y&&x<b.x);}\n} a[200002];\nint n,val[200002],nn,ans,c[200002],tot1,sum;\nll tot;\nbool vis[200002];\ninline void modify(int b) {for(;b<=nn;++c[b],b+=lowbit(b));}\ninline int query(int b) {if(b<0) return 0;int tot=0;for(;b;tot+=c[b],b-=lowbit(b));return tot;}\nint main()\n{\n\tread(n);\n\tfor(res i=1;i<=n;++i) read(a[i].x),read(a[i].y),val[i]=a[i].x;\n\tsort(a+1,a+1+n),sort(val+1,val+1+n),nn=unique(val+1,val+1+n)-val-1;\n\tfor(res i=1;i<=n;++i) a[i].x=lower_bound(val+1,val+1+nn,a[i].x)-val;\n\tfor(res i=1;i<=n;++i) {\n\t\ttot1=query(a[i].x-1)+1;\n\t\tif(a[i].y==a[i+1].y&&i<n) tot+=(ll)tot1*(query(a[i+1].x-1)-query(a[i].x)+1);\n\t\telse tot+=(ll)tot1*(sum-query(a[i].x)+1);\n\t\tif(!vis[a[i].x]) vis[a[i].x]=true,modify(a[i].x),++sum;\n\t}\n\tprint(tot,'\\n');\n\treturn 0;\n}\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do something instead of nothing and stay organized\n*/",
    "ext": "cpp"
  },
  "57727526": {
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\nconst int N = 1000005;\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n#define int long long int\n#define BINF 1000000000001\n#define M 1000000007\n#define double long double\n#define init(arr,val) memset(arr,val,sizeof(arr))\n#define MAXN 15000001\nconst int LG = 22;\n \n//number of unique number less than X\ntemplate<typename has_less>\nusing ordered_set = tree<has_less,null_type,less<has_less>,rb_tree_tag,tree_order_statistics_node_update>;\nordered_set<int>s;\n//sort decending of Y, if Y[i] == Y[i + 1] then larger X will be prior\nstruct comp {\n    bool operator()(const pair<int,int>& x, const pair<int,int>& y) const {\n        if (x.second != y.second)\n            return x.second > y.second;\n        return x.first > y.first;\n    }\n};\n//number of unique elements [l,r)\nint count(int l,int r){\n    return s.order_of_key(r) - s.order_of_key(l);\n}\npair<int,int>p[N];\n \n#undef int \nint main() {\n#define int long long int\nios_base::sync_with_stdio(false); \ncin.tie(0); \ncout.tie(0); \n    \n   int n;\n   cin >> n;\n   for(int i = 1; i <= n; i++){\n    cin >> p[i].F >> p[i].S;\n   }\n   p[0] = {BINF,BINF};\n   p[n + 1] = {0, 0};\n   sort(p, p + n + 2, comp());\n   int ans = 0;\n   for(int i = 1; i <= n; i++){\n    s.insert(p[i].F);\n    if(p[i].S == p[i + 1].S){\n        ans += count(p[i + 1].F + 1,p[i].F + 1) * count(p[i].F,BINF);\n        continue;\n    }\n    ans += count(1,p[i].F + 1) * count(p[i].F,BINF);\n   }\n   cout << ans << \"\\n\";\n \nreturn 0;\n}",
    "ext": "cpp"
  },
  "57711376": {
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll maxn=200010;\nconst ll INF=2147483647;\nstruct node\n{\n\tll x,y;\n}a[maxn];\nnode r[maxn];\nbool cmpy(node x,node y)\n{\n\tif(x.y == y.y)return x.x < y.x;\n\treturn x.y > y.y;\n}\nll n,ix[maxn],iy[maxn],totx,toty,cnt[maxn],tot,res;\nbool vis[maxn];\nll lowbit(ll x)\n{\n\treturn x & (-x);\n}\nvoid update(ll x)\n{\n\twhile(x <= n)\n\t{\n\t\tcnt[x]++;\n\t\tx += lowbit(x);\n\t}\n\treturn;\n}\nll qry(ll x)\n{\n\tll tem = 0;\n\twhile(x)\n\t{\n\t\ttem += cnt[x];\n\t\tx -= lowbit(x);\n\t}\n\treturn tem;\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i = 1;i <= n;i++)\n\t{\n\t\tcin>>a[i].x>>a[i].y;\n\t\tix[i] = a[i].x;\n\t\tiy[i] = a[i].y;\n\t}\n\tsort(ix + 1,ix + n + 1);\n\tsort(iy + 1,iy + n + 1);\n\ttotx = unique(ix + 1,ix + n + 1) - ix - 1;\n\ttoty = unique(iy + 1,iy + n + 1) - iy - 1;\n\tfor(int i = 1;i <= n;i++)\n\t{\n\t\ta[i].x = lower_bound(ix + 1,ix + totx + 1,a[i].x) - ix;\n\t\ta[i].y = lower_bound(iy + 1,iy + toty + 1,a[i].y) - iy;\n\t}\n\t//for(int i = 1;i <= n;i++)cout<<i<<\" \"<<a[i].x<<\" \"<<a[i].y<<endl;\n\tsort(a + 1,a + n + 1,cmpy);\n\tfor(int i = 1;i <= n;i++)\n\t{\n\t\tif(i < n && a[i].y == a[i + 1].y)\n\t\t{\n\t\t\tif(!vis[a[i].x])\n\t\t\t{\n\t\t\t\tupdate(a[i].x);\n\t\t\t\tvis[a[i].x] = 1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif(!vis[a[i].x])\n\t\t{\n\t\t\tupdate(a[i].x);\n\t\t\tvis[a[i].x] = 1;\n\t\t}\n\t\tll pos = i;\n\t\twhile(a[pos - 1].y == a[pos].y && pos > 1)pos--;\n\t\tll item = 0;\n\t\tfor(int j = pos;j <= i;j++)\n\t\t{\n\t\t\tres += 1ll * (qry(n) - qry(a[j].x - 1))*(qry(a[j].x) - qry(item));\n\t\t\t//cout<<j<<\" \"<<res<<\"\\n\";\n\t\t\titem = a[j].x;\n\t\t}\n\t}\n\tcout<<res;\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57611892": {
    "code": "#include <bits/stdc++.h>\n#include <bits/extc++.h>\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> oset;\n\nlong long triangle(long long x) {\n\treturn x*(x+1)/2;\n}\n\nint main() {\n\tint n; cin >> n;\n\t\n\tvector<pair<int,int>> points;\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpoints.emplace_back(-y,x);\n\t}\n\tsort(begin(points),end(points));\n\n\tvector<vector<int>> levels;\n\tint py = 0;\n\tfor (auto [y,x]: points) {\n\t\tif (y != py) levels.push_back({});\n\t\tlevels.back().push_back(x);\n\t\tpy = y;\n\t}\n\t\n\toset S;\n\tlong long res = 0;\n\tfor (auto xs: levels) {\n\t\tint px = -1;\n\t\tfor (int x: xs) {\n\t\t\tres -= triangle(S.order_of_key(x) - S.order_of_key(px+1));\n\t\t\tpx = x;\n\t\t\tS.insert(x);\n\t\t}\n\t\tres -= triangle(S.size() - S.order_of_key(px+1));\n\t\tres += triangle(S.size());\n\t}\n\tcout << res << endl;\n}\n\n",
    "ext": "cpp"
  },
  "57611736": {
    "code": "#include <bits/stdc++.h>\n#include <bits/extc++.h>\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> oset;\n\nlong long triangle(long long x) {\n\treturn x*(x+1)/2;\n}\n\nint main() {\n\tint n; cin >> n;\n\t\n\tmap<int,vector<int>,greater<int>> levels;\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tlevels[y].push_back(x);\n\t}\n\t\n\toset S;\n\tlong long res = 0;\n\tfor (auto [_,xs]: levels) {\n\t\tsort(begin(xs), end(xs));\n\t\tint px = -1;\n\t\tfor (int x: xs) {\n\t\t\tres -= triangle(S.order_of_key(x) - S.order_of_key(px+1));\n\t\t\tpx = x;\n\t\t\tS.insert(x);\n\t\t}\n\t\tres -= triangle(S.size() - S.order_of_key(px+1));\n\t\tres += triangle(S.size());\n\t}\n\tcout << res << endl;\n}\n\n",
    "ext": "cpp"
  },
  "57609827": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e5 + 7;\n\nint x[N];\n\nvector < int > y[N];\n\nint t[4 * N];\n\nvoid build(int v, int l, int r){\n    if(l == r){\n        t[v] = (x[l] > 0);\n    }\n    else{\n        int m = (r + l) >> 1;\n        build(v + v + 1, l, m);\n        build(v + v + 2, m + 1, r);\n        t[v] = t[v + v + 1] + t[v + v + 2];\n    }\n}\n\nvoid update(int v, int l, int r, int pos, int val){\n    if(pos == l && l == r){\n        t[v] = val;\n    }\n    else{\n        int m = (r + l) >> 1;\n        if(pos <= m){\n            update(v + v + 1, l, m, pos, val);\n        }\n        else{\n            update(v + v + 2, m + 1, r, pos, val);\n        }\n        t[v] = t[v + v + 1] + t[v + v + 2];\n    }\n}\n\nvoid update(int pos, int val){\n    update(0, 0, N - 1, pos, val);\n}\n\nint findSum(int v, int l, int r, int tl, int tr){\n    if(tl > tr){\n        return 0;\n    }\n    if(tl == l && tr == r){\n        return t[v];\n    }\n    int m = (r + l) >> 1;\n    int t1 = findSum(v + v + 1, l, m, tl, min(m, tr));\n    int t2 = findSum(v + v + 2, m + 1, r, max(m + 1, tl), tr);\n    return t1 + t2;\n}\n\nint findSum(int tl, int tr){\n    return findSum(0, 0, N - 1, tl, tr);\n}\n\nlong long value(int l, int r){\n    int to = findSum(l, r);\n    return to * (long long)(to + 1) / 2;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n\n    vector < pair < int, int > > xb, yb;\n    pair < int, int > a[n];\n\n    for(int i = 0; i < n; ++i){\n        cin >> a[i].first >> a[i].second;\n        xb.push_back({a[i].first, i});\n        yb.push_back({a[i].second, i});\n    }\n\n    sort(xb.begin(), xb.end());\n    sort(yb.begin(), yb.end());\n\n    int cnt = 0, to = -1;\n    for(auto x : xb){\n        cnt -= to == x.first;\n        a[x.second].first = cnt++;\n        to = x.first;\n    } cnt = 0, to = -1;\n    for(auto y : yb){\n        cnt -= to == y.first;\n        a[y.second].second = cnt++;\n        to = y.first;\n    }\n\n    for(int i = 0; i < n; ++i){\n        ++x[a[i].first];\n        y[a[i].second].push_back(a[i].first);\n    }\n\n    build(0, 0, N - 1);\n\n    queue < int > q;\n\n    long long ans = 0;\n    for(int i = 0; i < N; ++i){\n        while(q.empty() == false){\n            update(q.front(), 0);\n            q.pop();\n        }\n        sort(y[i].begin(), y[i].end());\n        int m = y[i].size();\n        long long sch = value(0, N - 1);\n        for(int j = 0; j < m; ++j){\n            int l = -1, r = y[i][j] - 1;\n            if(!j){\n                l = 0;\n            }\n            if(l == -1){\n                l = y[i][j - 1] + 1;\n            }\n            sch -= value(l, r);\n            --x[y[i][j]];\n            if(!x[y[i][j]]){\n                q.push(y[i][j]);\n            }\n        }\n        if(m - 1 >= 0){\n            sch -= value(y[i][m - 1] + 1, N - 1);\n        }\n        ans += sch;\n    }\n\n    cout << ans;\n}\n",
    "ext": "cpp"
  },
  "57605120": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pll;\ntypedef vector<bool> vb;\nconst ll oo = 0x3f3f3f3f3f3f3f3f;\nconst double eps = 1e-9;\n#define sz(c) ll((c).size())\n#define all(c) begin(c), end(c)\n#define FOR(i,a,b) for (ll i = (a); i < (b); i++)\n#define FORD(i,a,b) for (ll i = (b)-1; i >= (a); i--)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define xx first\n#define yy second\n#define TR(X) ({ if(1) cerr << \"TR: \" << (#X) << \" = \" << (X) << endl; })\n\nvoid compress(vl &i2x, map<ll,ll> &x2i) {\n\tsort(all(i2x));\n\ti2x.erase(unique(all(i2x)), end(i2x));\n\tFOR(i,0,sz(i2x)) x2i[i2x[i]] = i;\n}\n\nstruct bit {\n\tll n;\n\tvl a;\n\n\tbit(ll n): n(n), a(n+2) { }\n\t\n\tvoid add(ll i, ll v) {\n\t\tfor (i++; i <= n+1; i += i & -i) a[i] += v;\n\t}\n\t\n\tll get(ll i) {\n\t\tll res = 0;\n\t\tfor (; i; i -= i & -i) res += a[i];\n\t\treturn res;\n\t}\n};\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t\n\tll n; cin >> n;\n\tvector<pll> a(n);\n\tFOR(i,0,n) cin >> a[i].yy >> a[i].xx;\n\t\n\tvl i2x, j2y = {-oo,oo};\n\tFOR(i,0,n) i2x.pb(a[i].xx);\n\tFOR(i,0,n) j2y.pb(a[i].yy);\n\t\n\tmap<ll,ll> x2i, y2j;\n\tcompress(i2x,x2i);\n\tcompress(j2y,y2j);\n\t\n\tFOR(i,0,n) {\n\t\tll x, y;\n\t\ttie(x,y) = a[i];\n\t\ta[i] = {x2i[x], y2j[y]};\n\t}\n\tsort(all(a));\n\t\n\tll Y = sz(y2j)-1;\n\tbit B(Y+1);\n\n\tll j = n, res = 0;\n\twhile (j > 0) {\n\t\tll i = j-1;\n\t\twhile (i > 0 && a[j-1].xx == a[i-1].xx) i--;\n\t\t\n\t\tll m = j-i + 2;\n\t\tvl y(m);\n\t\ty[0] = 0, y[m-1] = Y;\n\n\t\tFOR(k,i,j) y[k-i+1] = a[k].yy;\n\t\t\n\t\tFOR(k,0,m-1) {\n\t\t\tll cnt = B.get(y[k+1]) - B.get(y[k]+1);\n\t\t\tres -= cnt*(cnt+1)/2;\n\t\t}\n\t\t\n\t\tFOR(k,i,j) {\n\t\t\tll y = a[k].yy;\n\t\t\tif (B.get(y+1)-B.get(y)) continue;\n\t\t\tB.add(y,1);\n\t\t}\n\t\t\n\t\tll cnt = B.get(Y);\n\t\tres += cnt*(cnt+1)/2;\n\n\t\tj = i;\n\t}\n\tcout << res << endl;\n}\n\n",
    "ext": "cpp"
  },
  "57601714": {
    "code": "//author Forsaken\n#define Hello the_cruel_world!\n#pragma GCC optimize(2)\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<utility>\n#include<cmath>\n#include<climits>\n#include<deque>\n#include<functional>\n#include<numeric>\n#define max(x,y) ((x) > (y) ? (x) : (y))\n#define min(x,y) ((x) < (y) ? (x) : (y))\n#define lowbit(x) ((x) & (-(x)))\n#define FRIN freopen(\"C:\\\\Users\\\\Administrator.MACHENI-KA32LTP\\\\Desktop\\\\1.in\", \"r\", stdin)\n#define FROUT freopen(\"C:\\\\Users\\\\Administrator.MACHENI-KA32LTP\\\\Desktop\\\\1.out\", \"w\", stdout)\n#define FAST ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define outd(x) printf(\"%d\\n\", x)\n#define outld(x) printf(\"%lld\\n\", x)\n#define memset0(arr) memset(arr, 0, sizeof(arr))\n#define il inline\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\nconst int maxn = 2e5;\nconst int INF = 0x7fffffff;\nconst int mod = 1e9 + 7;\nconst double eps = 1e-7;\nconst double Pi = acos(-1.0);\nil int read_int() {\n\tchar c;\n\tint ret = 0, sgn = 1;\n\tdo { c = getchar(); } while ((c < '0' || c > '9') && c != '-');\n\tif (c == '-') sgn = -1; else ret = c - '0';\n\twhile ((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + (c - '0');\n\treturn sgn * ret;\n}\nil ll read_ll() {\n\tchar c;\n\tll ret = 0, sgn = 1;\n\tdo { c = getchar(); } while ((c < '0' || c > '9') && c != '-');\n\tif (c == '-') sgn = -1; else ret = c - '0';\n\twhile ((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + (c - '0');\n\treturn sgn * ret;\n}\nil ll quick_pow(ll base, ll index, ll p) {\n\tll res = 1;\n\twhile (index) {\n\t\tif (index & 1)res = res * base % p;\n\t\tbase = base * base % p;\n\t\tindex >>= 1;\n\t}\n\treturn res;\n}\nstruct point {\n\tbool operator < (const point& rhs)const {\n\t\treturn y == rhs.y ? x < rhs.x : y > rhs.y;\n\t}\n\tpoint(int _x = 0, int _y = 0) {\n\t\tx = _x, y = _y;\n\t}\n\tint x, y;\n}arr[maxn + 5];\nint pos[maxn + 5], posy[maxn + 5], cnt[maxn + 5], c[maxn + 5], n, m, vx[maxn + 5];\nil void add(int x, int v) {\n\tfor (int i = x; i <= m; i += lowbit(i))c[i] += v;\n}\nil int sum(int x) {\n\tint ans = 0;\n\tfor (int i = x; i > 0; i -= lowbit(i))ans += c[i];\n\treturn ans;\n}\nll res;\nint main()\n{\n\tn = read_int();\n\tfor (int i = 1; i <= n; ++i) {\n\t\tarr[i].x = pos[i] = read_int();\n\t\tarr[i].y = posy[i] = read_int();\n\t}\n\tsort(pos + 1, pos + 1 + n);\n\tsort(posy + 1, posy + 1 + n);\n\tm = unique(pos + 1, pos + 1 + n) - pos - 1;\n\tint len = unique(posy + 1, posy + 1 + n) - posy - 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tarr[i].x = lower_bound(pos + 1, pos + 1 + m, arr[i].x) - pos;\n\t\tarr[i].y = lower_bound(posy + 1, posy + 1 + len, arr[i].y) - posy;\n\t}\n\tsort(arr + 1, arr + 1 + n);\n\tint up = m + 1;\n\tint now = 1, next = 1;\n\twhile (now <= n){\n\t\tint tot = 0;\n\t\twhile (arr[now].y == arr[next].y) {\n\t\t\tif (!cnt[arr[next].x])add(arr[next].x, 1);\n\t\t\tcnt[arr[next].x] = 1;\n\t\t\tvx[++tot] = arr[next].x;\n\t\t\tnext++;\n\t\t}\n\n\t\tvx[++tot] = m + 1;\n\n\t\tfor (int i = 1; i <= tot - 1; i++){\n\t\t\tint t1 = sum(vx[i] - 1);\n\t\t\tint t2 = sum(vx[i + 1] - 1) - sum(vx[i]);\n\t\t\tres += 1ll *(t1 + 1) * (t2 + 1);\n\t\t}\n\t\tnow = next;\n\t}\n\toutld(res);\n\t//system(\"pause\");\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57599861": {
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long int ll;\n\nconst int tope=1<<20;\nconst int first=1<<19;\nconst int limit=1000000;\n\nint counter[tope];\n\nvoid insert(int pos)\n{\n  //cout<<\"insert pos \"<<pos<<endl;\n  pos+=first;\n  counter[pos]=1;\n  while (pos>1) {\n    pos/=2;\n    counter[pos]=counter[2*pos]+counter[2*pos+1];\n  }\n}\n\nint counterbefore(int pos)\n{\n  //cout<<\"countbefore pos \"<<pos<<endl;\n  pos+=first;\n  int c=counter[pos];\n  while (pos>1) {\n    if (pos%2==1) c+=counter[pos-1];\n    pos/=2;\n  }\n  //cout<<\"c \"<<c<<endl;\n  return c;\n}\n\nint counterafter(int pos)\n{\n  int res=counterbefore(first-1)-counterbefore(pos-1);\n  //cout<<\"countafter pos \"<<pos<<\" res \"<<res<<endl;\n  return res;\n}\n\nint n;\npair<int,int> v[limit];\nmap<int,int> mapa;\nll sol;\n\nbool compare(pair<int,int> p1,pair<int,int> p2)\n{\n  if (p1.second!=p2.second)\n    return p1.second>p2.second;\n  return p1.first<p2.first;\n}\n\nint cc=1;\n\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin>>n;\n  for (int i=0;i<n;i++) {\n    cin>>v[i].first>>v[i].second;\n    mapa[v[i].first];\n  }\n  for (map<int,int>::iterator it=mapa.begin();it!=mapa.end();it++,cc++)\n    it->second=cc;\n  for (int i=0;i<n;i++)\n    v[i].first=mapa[v[i].first];\n  sort(v,v+n,compare);\n  for (int i=0;i<n;) {\n    //cout<<endl;\n    int j=i;\n    while (j<n-1 and v[j+1].second==v[i].second) j++;\n    //cout<<\"y \"<<v[i].second<<endl;\n    for (int k=i;k<=j;k++)\n      insert(v[k].first);\n    int left=0;\n    for (int k=i;k<=j;k++) {\n      int pos=v[k].first;\n      ll add=ll(counterbefore(pos)-counterbefore(left))*counterafter(pos);\n      //cout<<\"x \"<<v[k].first<<endl;\n      //cout<<\"add \"<<add<<endl;\n      sol+=add;\n      left=pos;\n    }\n    i=j+1;\n  }\n  cout<<sol<<endl;\n}\n",
    "ext": "cpp"
  },
  "57597752": {
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef pair<int,int> pii;\nconst int N=300000;\nconst db pi=acos(-1.0);\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define y first\n#define x second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define maxd 998244353\n#define eps 1e-8\nint n,val[N+10],t[N+10],nowx[N+10];\npii p[N+10];\nbool vis[N+10];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nbool cmp(pii p,pii q)\n{\n\tif (p.y!=q.y) return p.y>q.y;\n\telse return p.x<q.x;\n}\n\nvoid modify(int pos,int val)\n{\n\tint i;\n\tfor (i=pos;i<=N;i+=lowbit(i)) t[i]+=val;\n}\n\nll query(int pos)\n{\n\tll ans=0;int i;\n\tfor (i=pos;i;i-=lowbit(i)) ans+=t[i];\n\treturn ans;\n}\n\nll Q(int l,int r) {return query(r)-query(l-1);}\n\nint main()\n{\n\tn=read();\n\trep(i,1,n)\n\t{\n\t\tp[i].x=read();p[i].y=read();\n\t\tval[i]=p[i].x;\n\t}\n\tsort(val+1,val+1+n);\n\tint m=unique(val+1,val+1+n)-val-1;\n\trep(i,1,n)\n\t\tp[i].x=lower_bound(val+1,val+1+m,p[i].x)-val; \n\tsort(p+1,p+1+n,cmp);\n\tint i=1;ll ans=0;\n\twhile (i<=n)\n\t{\n\t\tint nowy=p[i].y,pre=i,tot=0;\n\t\twhile ((i<=n) && (p[i].y==nowy))\n\t\t{\n\t\t\tif (!vis[p[i].x]) modify(p[i].x,1);\n\t\t\tvis[p[i].x]=1;\n\t\t\tnowx[++tot]=p[i].x;i++;\n\t\t}\n\t\tnowx[tot+1]=N;\n\t\trep(j,1,tot)\n\t\t{\n\t\t\tll l=Q(1,nowx[j]-1),r=Q(nowx[j]+1,nowx[j+1]-1);\n\t\t\tans+=(l+1)*(r+1);\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n\t\n\n",
    "ext": "cpp"
  },
  "57580282": {
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n//#include<ext/rope>\n//using namespace __gnu_cxx\n//#include<ext/pb_ds/priority_queue.hpp>\n//using namespace __gnu_pbds;\n#define lowbit(x) (x&-x)\n#define pb(x) push_back(x)\n#define all(x) (x).begin(),(x).end()\n#define clr(a,b) memset(a,b,sizeof(a))\n#define caze(T) for(scanf(\"%d\",&T);T;T--)\n#define inf (1<<30)\n#define Endl ('\\n')\n#define fi first\n#define se second\n#define db double\n#define elif else if\n#define ldb long double\n#define ll long long\n#define pll pair<ll,ll>\n#define pli pair<ll,int>\n#define pii pair<int,int>\n#define ull unsigned long long\n#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)\narray<int,2>a[200020];\nint n,m;\nint t[200020];\nbool vis[200020];\nvoid add(int x,int v){for(x;x<=m+1;x+=lowbit(x))t[x]+=v;}\nint sum(int x){int ret=0;for(x;x;x-=lowbit(x))ret+=t[x];return ret;}\nint sum(int l,int r){return sum(r)-sum(l-1);}\nint sc[200020];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;++i)\n\t\tscanf(\"%d%d\",&a[i][0],&a[i][1]),sc[i+1]=a[i][0];\n\tsort(a,a+n,[](const array<int,2>&A,const array<int,2>&B)->bool{return A[1]>B[1]||A[1]==B[1]&&A[0]<B[0];});\n\tsort(sc,sc+n+1);\n\tm=unique(sc,sc+n+1)-sc+1;\n\tll ans=0;\n\tll cnt=1;\n\tint r=0;\n\tfor(int i=0;i<n;i=r)\n\t{\n\t\twhile(r<n&&a[r][1]==a[i][1]) ++r;\n\t\tfor(int j=i;j<r;++j)\n\t\t{\n\t\t\tint pos=lower_bound(sc,sc+m,a[j][0])-sc;\n\t\t\tif(!vis[pos])\n\t\t\t{\n\t\t\t\t++cnt;\n\t\t\t\tvis[pos]=1;\n\t\t\t\tadd(pos,1);\n\t\t\t}\n\t\t}\n\t\tint pre=0;\n\t\tfor(int j=i;j<r;++j)\n\t\t{\n\t\t\tint pos=lower_bound(sc,sc+m,a[j][0])-sc;\n\t\t\tll tp=sum(pos)-sum(pre);\n\t\t\tans+=(cnt-sum(pos))*tp;\n\t\t\tpre=pos;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}",
    "ext": "cpp"
  },
  "57561096": {
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid out(T x) { cout << x << endl; exit(0); }\n#define watch(x) cout << (#x) << \" is \" << (x) << endl\n\nconst int maxn = 1e5 + 5;\n\nmap<int,int> M, RM;\nvector<int> tree;\n\nvoid compress() {\n  int idx = 1;\n  for (auto p: RM) {\n    int x = p.first;\n    RM[x] = idx;\n    M[idx] = x;\n    idx++;\n  }\n}\n\nvoid build_tree() {\n  int N = M.size();\n  tree.resize(4*N);\n}\n\nstruct ordered_set {\n  void insert(int x) {\n    insert(1,1,M.size(),x);\n  }\n  void insert(int v, int tl, int tr, int x) {\n    if (tl==tr) {\n      tree[v] = 1;\n    } else {\n      int tm = (tl+tr)/2;\n      if (x <= M[tm]) {\n        insert(2*v, tl, tm, x);\n      } else {\n        insert(2*v+1, tm+1, tr, x);\n      }\n      tree[v] = tree[2*v] + tree[2*v + 1];\n    }\n  }\n  int find(int v, int tl, int tr, int x, int buf) {\n    if (tl==tr) {\n      return buf+1;\n    } else {\n      int tm = (tl+tr)/2;\n      if (x <= M[tm]) {\n        return find(2*v,tl,tm,x,buf);\n      } else {\n        return find(2*v+1,tm+1,tr,x,buf+tree[2*v]);\n      }\n    }\n  }\n  int ordered_key(int x) {\n    return find(1,1,M.size(),x,0) - 1;\n  }\n  int size() {\n    return tree[1];\n  }\n};\n\nll nc2(ll x) {\n  return x*(x-1)/2;\n}\n\nint n;\nvector<pair<int,int>> points;\nll ans = 0;\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);  cout.tie(0);\n  cin>>n;\n  for (int i=0; i<n; i++) {\n    int x,y; cin>>x>>y;\n    points.push_back({y,x});\n    RM[x] = 0; RM[y] = 0;\n  }\n\n  compress();\n  build_tree();\n\n  // oset contains all higher and current x-coordinates\n  ordered_set oset;\n  // sort points in descending order of y-coordinate\n  sort(points.rbegin(), points.rend());\n  for (int i=0, j=0; i<n; i=j) {\n    while (j<n && points[i].first == points[j].first) {\n      oset.insert(points[j].second);\n      j++;\n    }\n    ll size = oset.size();\n    // count all x-coord pairings\n    ans += nc2(size) + size;\n\n    // indices has all ordered_keys of this row's x-coordinates\n    // insert -1 and size so we can handle the previous x-coords outside the bounds\n    vector<int> indices = {-1, (int)size};\n    for (int k=i; k<j; k++) {\n      indices.push_back(oset.ordered_key(points[k].second));\n    }\n    sort(indices.begin(), indices.end());\n\n\n    // for all \"gaps\", remove all combinations because they were\n    // already counted higher up\n    for (int k=0; k+1<indices.size(); k++) {\n      ll gap = indices[k+1] - indices[k] - 1;\n      ans -= nc2(gap) + gap;\n    }\n  }\n\n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n",
    "ext": "cpp"
  },
  "57560944": {
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid out(T x) { cout << x << endl; exit(0); }\n#define watch(x) cout << (#x) << \" is \" << (x) << endl\n\nconst int maxn = 1e5 + 5;\n\nmap<int,int> M, RM;\nvector<int> tree;\n\nvoid compress() {\n  int idx = 1;\n  for (auto p: RM) {\n    int x = p.first;\n    RM[x] = idx;\n    M[idx] = x;\n    idx++;\n  }\n}\n\nvoid build_tree() {\n  int N = M.size();\n  tree.resize(4*N);\n}\n\nstruct ordered_set {\n  void insert(int x) {\n    insert(1,1,M.size(),x);\n  }\n  void insert(int v, int tl, int tr, int x) {\n    if (tl==tr) {\n      tree[v] = 1;\n    } else {\n      int tm = (tl+tr)/2;\n      if (x <= M[tm]) {\n        insert(2*v, tl, tm, x);\n      } else {\n        insert(2*v+1, tm+1, tr, x);\n      }\n      tree[v] = tree[2*v] + tree[2*v + 1];\n    }\n  }\n  int find(int v, int tl, int tr, int x, int buf) {\n    if (tl==tr) {\n      return buf+1;\n    } else {\n      int tm = (tl+tr)/2;\n      if (x <= M[tm]) {\n        return find(2*v,tl,tm,x,buf);\n      } else {\n        return find(2*v+1,tm+1,tr,x,buf+tree[2*v]);\n      }\n    }\n  }\n  int ordered_key(int x) {\n    return find(1,1,M.size(),x,0) - 1;\n  }\n  int size() {\n    return tree[1];\n  }\n};\n\nint n;\nvector<pair<int,int>> points;\nll ans = 0;\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);  cout.tie(0);\n  cin>>n;\n  for (int i=0; i<n; i++) {\n    int x,y; cin>>x>>y;\n    points.push_back({y,x});\n    RM[x] = 0; RM[y] = 0;\n  }\n  compress();\n  build_tree();\n  ordered_set oset;\n  sort(points.rbegin(), points.rend());\n  for (int i=0, j=0; i<n; i=j) {\n    while (j<n && points[i].first == points[j].first) {\n      oset.insert(points[j].second);\n      j++;\n    }\n    ll size = oset.size();\n    // watch(size);\n    ans += size*(size+1)/2;\n    vector<int> indices = {-1, (int)size};\n    for (int k=i; k<j; k++) {\n      indices.push_back(oset.ordered_key(points[k].second));\n    }\n    sort(indices.begin(), indices.end());\n    //  indices.resize(unique(indices.begin(), indices.end()) - indices.begin());\n    // cout<<\"indices: \";\n    // for (auto x: indices) cout<<x<<\" \";\n    // cout<<endl;\n    // watch(ans);\n    for (int k=0; k+1<indices.size(); k++) {\n      ll gap = indices[k+1] - indices[k] - 1;\n      ans -= gap*(gap+1)/2;\n    }\n    // watch(ans);\n    // cout<<endl;\n  }\n\n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n",
    "ext": "cpp"
  },
  "57553059": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 1 << 18;\n\nusing ll = long long;\n\nint tree[MAXN << 1];\n \nvoid update (int pos, int val) {\n\tfor (tree[pos += MAXN] = val; pos; pos >>= 1)\n\t\ttree[pos >> 1] = tree[pos] + tree[pos ^ 1];\n}\nint get (int l, int r) {\n\tl += MAXN;\n\tr += MAXN;\n\tint res = 0;\n\twhile (l < r) {\n\t\tif (l & 1) res += tree[l++];\n\t\tif (!(r & 1)) res += tree[r--];\n\t\tl >>= 1;\n\t\tr >>= 1;\n\t}\n\tif (l == r) res += tree[l];\n\treturn res;\n}\n\nint n;\nint x[MAXN], y[MAXN], id[MAXN];\n\nvector <int> tmp;\nmap <int, int> renum;\n\nvoid pre () {\n\tfor (int i = 0; i < n; i++) {\n\t\ttmp.push_back (x[i]);\n\t}\n\tsort (tmp.begin (), tmp.end ());\n\ttmp.erase (unique (tmp.begin (), tmp.end ()), tmp.end ());\n\tfor (int i = 0; i < (int) tmp.size (); i++) {\n\t\trenum[tmp[i]] = i + 1;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tx[i] = renum[x[i]];\n\t}\n}\n\nbool comp (int i, int j) {\n\tif (y[i] != y[j]) \n\t\treturn y[i] > y[j];\n\treturn x[i] < x[j];\n}\n\nint main () {\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tid[i] = i;\n\t}\n\n\tpre ();\n\tsort (id, id + n, comp);\n\n/*\tfor (int i = 0; i < n; i++) {\n\t\tcerr << x[id[i]] << ' ' << y[id[i]] << endl;\n\t}\n\tcerr << endl;\n*/\n\tll res = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint R = (i == n - 1 || y[id[i + 1]] != y[id[i]]) ? n + 1 : x[id[i + 1]] - 1;\n\t\tint l = get (0, x[id[i]] - 1);\n\t\tint r = get (x[id[i]] + 1, R);\n//\t\tcerr << l << ' ' << r << endl;\n\t\tres += 1ll * (l + 1) * (r + 1);\n\t\tupdate (x[id[i]], 1);\n\t}\n\n\tcout << res;\n\t\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57531383": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAX_N 200000\nusing ull = unsigned long long;\n\nint N;\nmap<int, int> compressed_x, compressed_y;\ntuple<int, int> inp[MAX_N + 1];\n\nint tree[MAX_N + 1];\nbool added[MAX_N + 1];\nvoid update(int index){\n  int add = 0;\n  if(!added[index]){\n    add = 1;\n    added[index] = true;\n  }\n  for(; index <= N; index += index&-index){\n    tree[index] += add;\n  }\n}\n\null sum(int index) {\n  ull sum = 0;\n  for (; index > 0; index -= index&-index ){\n    sum += tree[index];\n  }\n  return sum;\n}\n\null solve(){\n  ull total_combos = 0;\n  for(int i = 1; i + 1 <= N; i++){\n    int old_combo = total_combos;\n    if(get<1> (inp[i]) == get<1>(inp[i+1]))\n      total_combos += (sum(get<0>(inp[i])-1) + 1) * (sum(get<0>(inp[i+1])-1) - sum(get<0>(inp[i])) + 1);\n    else\n      total_combos += (sum(get<0>(inp[i])-1) + 1) * (sum(N) - sum(get<0>(inp[i])) + 1);\n    update(get<0>(inp[i]));\n  }\n\n  total_combos += (sum(get<0>(inp[N])-1) + 1) * (sum(N) - sum(get<0>(inp[N])) + 1);\n  return total_combos;\n}\n\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cin>>N;\n  int x,y;\n  for(int i = 1; i <= N; i++){\n    cin >> x >> y;\n    inp[i] = make_tuple(x,y);\n    if (compressed_x.find(get<0>(inp[i])) == compressed_x.end()) {\n      compressed_x[get<0>(inp[i])] = 0;\n    }\n    if(compressed_y.find(get<1>(inp[i])) == compressed_y.end()){\n      compressed_y[get<1>(inp[i])] = 0;\n    } \n  }\n  sort(inp + 1, inp + N + 1, [](auto one, auto two){\n\t\t\t       if (get<1>(one) == get<1>(two))\n\t\t\t\t return get<0>(one) < get<0>(two);\n\t\t\t       return get<1>(one) > get<1>(two); });\n\n  int index = 1;\n  for(auto iter = compressed_x.begin(); iter != compressed_x.end(); iter++){\n      compressed_x[iter->first] = index++;\n  }\n  index = 1;\n  for(auto iter = compressed_y.begin(); iter != compressed_y.end(); iter++){\n      compressed_y[iter->first] = index++;\n  }\n\n  \n  for(int i = 1; i <= N; i++){\n    inp[i] = make_tuple(compressed_x[get<0>(inp[i])], compressed_y[get<1>(inp[i])]);\n  }\n\n  memset(tree, 0, sizeof(tree));\n  memset(added, false, sizeof(added));\n\n  cout<<solve()<<endl;\n  return 0;\n}\n",
    "ext": "cpp"
  },
  "57528157": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAX_N 200000\nusing ull = unsigned long long;\n\nint N;\nmap<int, int> compressed_x, compressed_y;\ntuple<int, int> inp[MAX_N + 1];\n\nint tree[MAX_N + 1];\nbool added[MAX_N + 1];\nvoid update(int index){\n  int add = 0;\n  if(!added[index]){\n    add = 1;\n    added[index] = true;\n  }\n  for(; index <= N; index += index&-index){\n    tree[index] += add;\n  }\n}\n\null sum(int index) {\n  ull sum = 0;\n  for (; index > 0; index -= index&-index ){\n    sum += tree[index];\n  }\n  return sum;\n}\n\null solve(){\n  ull total_combos = 0;\n  for(int i = 1; i + 1 <= N; i++){\n    int old_combo = total_combos;\n    if(get<1> (inp[i]) == get<1>(inp[i+1]))\n      total_combos += (sum(get<0>(inp[i])-1) + 1) * (sum(get<0>(inp[i+1])-1) - sum(get<0>(inp[i])) + 1);\n    else\n      total_combos += (sum(get<0>(inp[i])-1) + 1) * (sum(N) - sum(get<0>(inp[i])) + 1);\n    update(get<0>(inp[i]));\n  }\n\n  total_combos += (sum(get<0>(inp[N])-1) + 1) * (sum(N) - sum(get<0>(inp[N])) + 1);\n  return total_combos;\n}\n\n\nint main(){\n  scanf(\"%d\", &N);\n  int x,y;\n  for(int i = 1; i <= N; i++){\n    scanf(\"%d %d\", &x, &y);\n    inp[i] = make_tuple(x,y);\n    if (compressed_x.find(get<0>(inp[i])) == compressed_x.end()) {\n      compressed_x[get<0>(inp[i])] = 0;\n    }\n    if(compressed_y.find(get<1>(inp[i])) == compressed_y.end()){\n      compressed_y[get<1>(inp[i])] = 0;\n    } \n  }\n  sort(inp + 1, inp + N + 1, [](auto one, auto two){\n\t\t\t       if (get<1>(one) == get<1>(two))\n\t\t\t\t return get<0>(one) < get<0>(two);\n\t\t\t       return get<1>(one) > get<1>(two); });\n\n  int index = 1;\n  for(auto iter = compressed_x.begin(); iter != compressed_x.end(); iter++){\n      compressed_x[iter->first] = index++;\n  }\n  index = 1;\n  for(auto iter = compressed_y.begin(); iter != compressed_y.end(); iter++){\n      compressed_y[iter->first] = index++;\n  }\n\n  \n  for(int i = 1; i <= N; i++){\n    inp[i] = make_tuple(compressed_x[get<0>(inp[i])], compressed_y[get<1>(inp[i])]);\n  }\n\n  memset(tree, 0, sizeof(tree));\n  memset(added, false, sizeof(added));\n\n  printf(\"%lld \\n\", solve());\n  return 0;\n}\n",
    "ext": "cpp"
  },
  "57510664": {
    "code": "#include <bits/stdc++.h>\n\n#define TOP 1000000000ll\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<vector<int> > ady_list;\n\nstruct Fenwick{\n    set<ll> s;\n    map<ll, ll> tree;\n    ll n;\n\n    Fenwick(ll n): n(n){}\n\n    void update(ll i){\n        if(i > 0 && s.count(i) == 0) {\n            s.insert(i);\n            while (i <= n) {\n                tree[i] += 1;\n                i += i & -i;\n            }\n        }\n    }\n\n    ll query(ll i){\n        ll sum = 0;\n        while(i > 0){\n            sum += tree[i];\n            i -= i & -i;\n        }\n        return sum;\n    }\n\n    ll count(){\n        return query(n);\n    }\n\n    ll from(ll i){\n        return count() - query(i - 1);\n    }\n\n};\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int t, n, m;\n    cin >> n;\n\n    vector<pair<ll, ll>> data(n);\n    for(auto &x:data)\n        cin >> x.second >> x.first;\n    sort(data.rbegin(), data.rend());\n\n    Fenwick ft(TOP);\n    ll last, ans = 0, count, sum;\n    int pos = 0, temp;\n    while(pos < n){\n        last = data[pos].first;\n        temp = pos;\n        while(temp < n && data[temp].first == last)\n            ft.update(data[temp++].second);\n        count = 0;\n        while(pos < temp) {\n            sum = ft.from(data[pos].second) - count;\n            count += sum;\n            sum *= ft.query(data[pos++].second);\n            ans += sum;\n        }\n    }\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}//RUL0",
    "ext": "cpp"
  },
  "57506783": {
    "code": "#pragma comment(linker, \"/STACK: 1024000000,1024000000\")\n#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define em emplace\n#define pii pair<int,int>\n#define de(x) cout << #x << \" = \" << x << endl\n#define dd(x) cout << #x << \" = \" << x << \" \" << endl\n#define clr(a,b) memset(a,b,sizeof(a))\n#define INF (0x3f3f3f3f)\n#define LINF ((long long)(0x3f3f3f3f3f3f3f3f))\n#define F first\n#define S second\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 2e5 + 25;\nint c[N];\n\nvoid add( int x, int v ) {\n\tfor ( ; x < N; x += x&-x )\n\t\tc[x] += v;\n}\nint ask( int x ) {\n\tint res = 0;\n\twhile ( x ) {\n\t\tres += c[x];\n\t\tx -= x&-x;\n\t}\n\treturn res;\n}\n\nint qry( int l, int r ) {\n\treturn ask(r)-ask(l-1);\n}\n\nll ans = 0;\nvector<int> x[N], y;\nint n, tt;\nmap<int,int> idx, idy, ctx;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor ( int i = 0, u, v; i < n; i ++ ) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tif ( !idy.count(v) ) {\n\t\t\tidy[v] = tt++;\n\t\t\ty.pb(v);\n\t\t}\n\t\tx[idy[v]].pb(u);\n\t\tctx[u] ++;\n\t}\n\t\n\ttt = 0;\n\tfor ( auto it : ctx ) {\n\t\tidx[it.F] = ++tt;\n\t\tadd( tt, 1 );\n\t}\n\t\n\tint pre;\n\tsort(y.begin(),y.end());\n\tfor ( auto v : y ) {\n\t\tsort( x[idy[v]].begin(), x[idy[v]].end() );\n\t\tpre = 1;\n\t\tfor ( auto u : x[idy[v]] ) {\n\t\t\tans += 1ll* qry( pre, idx[u] ) * qry( idx[u], tt );\n\t\t\tpre = idx[u] + 1;\n\t\t\tctx[u] --;\n\t\t\tif ( !ctx[u] ) {\n\t\t\t\tctx.erase(u);\n\t\t\t\tadd( idx[u], -1 );\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\t\t",
    "ext": "cpp"
  },
  "57489629": {
    "code": "#include <utility>\n#include <iostream>\n#include <random>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nusing pint  = pair<int, int>;\n\nint n;\nmap<int, vector<int>> y_class;\n\nstruct node{\n    int x, prior, num=1, size=1;\n    node *l=0, *r=0;\n    node (int _x) : x(_x), prior(rand()) {}\n} *treap;\n\nusing pnode = pair<node*, node*>;\n\n\nnode* find(node *v, int x) {\n    if(!v) return 0;\n    if(v->x > x) return find(v->l, x);\n    if(v->x < x) return find(v->r, x);\n    return v;\n}\n\nint less_than(node *v, int x) {\n    if(!v) return 0;\n    if(v->x > x) return less_than(v->l, x);\n    int res = 0;\n    if(v->x < x) {\n        res += less_than(v->r, x);\n        res ++;\n    }\n    if(v->l) res += v->l->size;\n    return res;\n}\n\nnode* merge(node *a, node *b) {\n    if(!a) return b;\n    if(!b) return a;\n    if(a->prior > b->prior) {\n        a->size += b->size;\n        a->r = merge(a->r, b);\n        return a;\n    } else {\n        b->size += a->size;\n        b->l = merge(a, b->l);\n        return b;\n    }\n}\n\npnode split(node *v, int x){\n    if(!v) return {0, 0};\n    if(v->x >= x){\n        int ols = v->l ? v->l->size : 0;\n        pnode p = split(v->l, x);\n        v->l = p.second;\n        v->size += (v->l ? v->l->size : 0) - ols;\n        return {p.first, v};\n    } else {\n        int ors = v->r ? v->r->size : 0;\n        pnode p = split(v->r, x);\n        v->r = p.first;\n        v->size += (v->r ? v->r->size : 0) - ors;\n        return {v, p.second};\n    }\n}\n\nnode* remove(node *v, int x) { // only remove existing objects\n    if(v->x == x) return merge(v->l, v->r);\n    if(v->x > x) v->l = remove(v->l, x);\n    else         v->r = remove(v->r, x);\n    v->size--;\n    return v;\n}\n\nnode* add_to_class(node *v, int x) {\n    node* u = find(v, x);\n    if(u) u->num++;\n    else {\n        pnode p = split(v, x);\n        v = merge(merge(p.first, new node(x)), p.second);\n    }\n    return v;\n}\n\nnode* remove_from_class(node *v, int x) {\n    node* u = find(v, x);\n    //if(!u) exit(1); // error\n    if(u->num > 1) u->num--;\n    else v = remove(v, x);\n    return v;\n}\n\nint main(){\n    cin >> n;\n    int x, y;\n    cin >> x >> y;\n    treap = new node(x);\n    y_class[y].push_back(x);\n    for(int i = 1; i < n; i++) {\n        cin >> x >> y;\n        y_class[y].push_back(x);\n        treap = add_to_class(treap, x);\n    }\n    uint64_t sum = 0;\n    for(auto it = y_class.begin(); it != y_class.end(); it++) {\n        sort(it->second.begin(), it->second.end());\n        uint64_t ltl = 0;\n        for(int i : it->second) {\n            uint64_t lti = less_than(treap, i);\n            sum += (lti - ltl + 1) * (treap->size - lti);\n            //cout << lti << ' ' << treap->size << ' ' << ltl << endl;\n            ltl = lti + 1;\n        }\n        for(int i : it->second) treap = remove_from_class(treap, i);\n    }\n    cout << sum << endl;\n}\n",
    "ext": "cpp"
  },
  "57486099": {
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define int long long\nint sz = 2e5;\n\nint fenv[300000];\nvoid modify(int v, int val)\n{\n    for(int i = v; i <= sz; i |= (i + 1))\n        fenv[i] += val;\n}\nint sum(int r)\n{\n    int res = 0;\n    for(int i = r; i >= 0; i = (i & (i + 1)) - 1)\n        res += fenv[i];\n    return res;\n}\n\nint get(int l, int r)\n{\n    return sum(r) - sum(l - 1);\n}\nint xs[300200];\n\nsigned main()\n{\n    cin.tie(0);\n    cout.tie(0);\n    ios_base::sync_with_stdio(0);\n    int n;\n    cin >> n;\n    vector<pair<int, int> > v;\n    vector<int>fakex;\n    for(int i = 0; i < n; ++i)\n    {\n        int a, b;\n        cin >> a >> b;\n        v.push_back({b, a});\n        fakex.push_back(a);\n    }\n    sort(fakex.begin(), fakex.end());\n    fakex.erase(unique(fakex.begin(), fakex.end()), fakex.end());\n    for(int i = 0; i < n; ++i)\n        v[i].second = -(lower_bound(fakex.begin(), fakex.end(), v[i].second) - fakex.begin());\n    sort(v.rbegin(), v.rend());\n    int ans = 0;\n    for(int i = 0; i < v.size(); ++i)\n    {\n        int r = 2e5;\n        if (i + 1 < v.size() && v[i + 1].first == v[i].first)\n            r = -v[i + 1].second - 1;\n        int l = -v[i].second;\n        int a1 = sum(l - 1);\n        int a2 = get(l + 1, r);\n        //cout << i << endl;\n        if (xs[l] == 0)\n            modify(l, 1);\n        xs[l] = 1;\n        //int k = a1 + a2 + 1;\n        //cout << a1 << \" COUNT \" << a2 << endl;\n        ans += a1 * a2;\n        ans += a1 + a2 + 1;\n    }\n    cout << ans;\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57464039": {
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#define rep(i, l, r) for (int i = (l); i <= (r); ++i)\n#define per(i, l, r) for (int i = (l); i >= (r); --i)\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::make_pair;\nusing std::pair;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned int ui;\n\nint _x[200100];\nstd::map<int, int> H;\n\nint low(int x) { return x & -x; }\nstruct B {\n    int siz;\n    int c[200100];\n    void add(int pos, int x) {\n        for (int i = pos; i <= siz; i += low(i)) c[i] += x;\n    };\n    int s(int pos) {\n        int ret = 0;\n        for (int i = pos; i > 0; i -= low(i)) ret += c[i];\n        return ret;\n    }\n    int q(int l, int r) { return l > r ? 0 : s(r) - s(l - 1); }\n} s1, s2;\nstruct P {\n    int x, y;\n    bool operator<(const P& rhs) const {\n        return (y == rhs.y ? x < rhs.x : y < rhs.y);\n    }\n} a[200100];\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    rep(i, 1, n) {\n        // cin >> x[i];\n        cin >> a[i].x >> a[i].y;\n        _x[i] = a[i].x;\n    }\n    std::sort(_x + 1, _x + 1 + n);\n    s1.siz = s2.siz = std::unique(_x + 1, _x + 1 + n) - (_x + 1);\n    rep(i, 1, s1.siz) {\n        H[_x[i]] = i, s2.add(i, 1);\n        // cerr << _x[i] << '-' << i << endl;\n    }\n    rep(i, 1, n) { a[i].x = H[a[i].x], s1.add(a[i].x, 1); }\n    // rep(i, 1, n) cerr << a[i].x << ' ';\n    // cerr << endl;\n    std::sort(a + 1, a + 1 + n);\n    int y = -1, l = 0, s = s1.siz, start = 1;\n    ll ans = 0;\n    rep(i, 1, n) {\n        if (y != a[i].y) {\n            rep(j, start, i - 1) {\n                s1.add(a[j].x, -1);\n                if (s1.q(a[j].x, a[j].x) == 0) s2.add(a[j].x, -1);\n            }\n            start = i;\n            y = a[i].y;\n            l = 1;\n        }\n        // cerr << l << ' ' << a[i].x << ' ' << s << ' ' << (ll)s2.q(l, a[i].x)\n        //      << ' ' << s2.q(a[i].x, s) << endl;\n\n        // cerr << (ll)s2.q(l, a[i].x) * s2.q(a[i].x, s) << endl;\n        ans += (ll)s2.q(l, a[i].x) * s2.q(a[i].x, s);\n        l = a[i].x + 1;\n    }\n    cout << ans;\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57461020": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nconst int N = 2e5 + 5;\n\nint BIT[N];\nint n , cnt[N] , x[N] , y[N] , cx , cy;\nvector < int > row[N];\nmap < int , int > compX , compY;\nvoid update(int x , int val)\n{\n    for( ; x <= cx ; x += x&-x) BIT[x] += val;\n}\nint query(int x)\n{\n    if(x < 0) return 0;\n    int sum = 0;\n    for( ; x ; x -= x&-x) sum += BIT[x];\n    return sum;\n}\nint query(int l , int r)\n{\n    return query(r) - query(l-1);\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i = 0 ; i < n ; i++)    scanf(\"%d%d\",&x[i],&y[i]) , compX[x[i]] , compY[y[i]];\n\n    cx = 0;\n    for(auto &r : compX)\n        r.second = ++cx;\n    cy = 0;\n    for(auto &r: compY)\n        r.second = ++cy;\n\n    for(int i = 0 ; i < n ; i++)    x[i] = compX[x[i]] , y[i] = compY[y[i]] , cnt[x[i]]++ , row[y[i]].push_back(x[i]);\n\n    for(int i = 1 ; i <= cx ; i++)  update(i,1);\n\n    ll ans = 0;\n    for(int r = 1 ; r <= cy ; r++)\n    {\n        sort(row[r].begin() , row[r].end());\n        ll sum = query(1 , row[r][0]);\n        for(int i = 0 ; i + 1 < row[r].size() ; i++)\n        {\n            ll temp = query(row[r][i] , row[r][i+1]) - 1;\n            ans += sum * temp;\n            sum += temp;\n        }\n        ans += sum * query(row[r].back() , cx);\n\n        for(auto e : row[r])\n        {\n            cnt[e]--;\n            if(cnt[e] == 0) update(e , -1);\n        }\n    }\n    printf(\"%I64d\\n\",ans);\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57458235": {
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n\n//#pragma GCC optimize (\"O3\")\n//#pragma GCC optimize (\"Ofast\")\n\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define LBS MAXN\n#define MOD ((long long)1e9+7) //1e9+9\n#define LEFT(i) (2*(i))\n#define RIGHT(i) (2*(i)+1)\n#define PAR(i) ((i)/2)\n#define MAXN ((int)1e5+5)\n\nusing namespace std;\nusing namespace __gnu_pbds;\nstruct comp;\n\ntypedef long long ll;\ntypedef double rat;\ntypedef long long bi;\ntypedef pair<int, int> ii;\ntypedef std::vector<ii> vii;\ntypedef std::map<int, int> mii;\ntypedef bitset<LBS> bis;\ntypedef pair<bis, int> bisi;\ntypedef std::vector<bis> vbs;\ntypedef std::vector<bisi> vbsi;\ntypedef set<bis, comp> sbs;\ntypedef tree<int, int, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordmap;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordset;\n\nstruct comp{\n  bool operator()(const bis &a, const bis &b)const{\n    for(int i=0; i<LBS; i++){\n      if(a[i]<b[i])\n        return true;\n      if(a[i]>b[i])\n        return false;\n    }\n    return false;\n  }\n};\n\nvoid vin(std::vector<int> &a){\n  for(int &x: a)\n    cin >> x;\n}\n\nvoid vout(std::vector<int> &a){\n  for(int x: a)\n    cout << x << \" \";\n  cout << endl;\n}\n\nint main(){\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int n; cin >> n;\n  vii p(n);\n  for(int i=0; i<n; i++)\n    cin >> p[i].F >> p[i].S;\n  sort(p.begin(), p.end(), [](const ii &a, const ii&b){\n    if(a.S==b.S)\n      return a.F<b.F;\n    return a.S>b.S;\n  });\n  ll cc=0;\n  ordset x;\n  // cerr << \"vkn\\n\";\n  for(int i=0; i<n; i++){\n    vector<int> tx;\n    int j;\n    for(j=i; j<n && p[i].S==p[j].S; j++)\n      tx.PB(p[j].F);\n    i=j-1;\n    sort(tx.begin(), tx.end());\n    // cerr << tx.size()<<\"\\n\";\n    for(int j=0; j<(int)tx.size(); j++){\n      x.insert(tx[j]);\n      int nb=x.order_of_key(tx[j])+1;\n      ll na;\n      if(j<(int)tx.size()-1)\n        na=x.order_of_key(tx[j+1])+1-nb;\n      else\n        na=x.size()+1-nb;\n      // cerr <<  nb << \" \"<<na<<\" \"<<tx[j]<<\"\\n\";\n      cc+=nb*na;\n      // cerr << cc <<\"\\n\";\n    }\n  }\n  cout << cc <<\"\\n\";\n}\n",
    "ext": "cpp"
  },
  "57380911": {
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = (a); i <= (b); i++)\n#define per(i, a, b) for(int i = (a); i >= (b); i--)\n#define ll long long\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define pii pair<int,int>\nusing namespace std;\nconst int N = 2e5+1000;\npii s[N];\nint n;\nint cmp(pii a, pii b) {\n    if(a.second!=b.second) return a.second>b.second;\n    return a.first < b.first;\n}\nint bit[2*N];\nint lb(int x) {return x&-x;}\nvoid add(int x) {\n    for(int i = x; i <= 4e5+1000; i += lb(i)) bit[i] += 1;\n}\nll que(int x) {\n    int ans = 0;\n    for(int i = x; i > 0; i -= lb(i)) ans += bit[i];\n    return ans;\n}\nbool flag[2*N];\nint main() {\n  //  freopen(\"a.txt\",\"r\",stdin);\n    ios::sync_with_stdio(0);\n    cin>>n;\n    vector<int>k;\n    rep(i, 1, n) {\n        cin>>s[i].first>>s[i].second;\n        k.pb(s[i].first);\n        k.pb(s[i].second);\n    }\n    sort(all(k));\n    k.erase(unique(all(k)),k.end());\n    sort(s+1,s+n+1,cmp);\n    ll ans = 0;\n    rep(i, 1, n) {\n        s[i].first = lower_bound(all(k),s[i].first)-k.begin()+1;\n        s[i].second = lower_bound(all(k),s[i].second)-k.begin()+1;\n    }\n    k.clear();\n    int lasty = -1;\n    rep(i, 1, n) {\n        int x = s[i].first;\n        int y = s[i].second;\n        if(y == lasty) {\n            if(!flag[x]) {\n                add(x);\n                flag[x] = 1;\n            }\n            k.pb(i);\n            continue;\n        }\n        else {\n            int lastx = 0;\n            for(auto p:k) {\n                ans += (que(s[p].first)-que(lastx))*(que(4e5+1000)-que(s[p].first-1));\n                lastx = s[p].first;\n            }\n            k.clear();\n            k.pb(i);\n            lasty = s[i].second;\n            if(!flag[x]) {\n                add(x);\n                flag[x] = 1;\n            }\n        }\n    }\n    int lastx = 0;\n    for(auto p:k) {\n        ans += (que(s[p].first)-que(lastx))*(que(4e5+1000)-que(s[p].first-1));\n        lastx = s[p].first;\n    }\n    cout<<ans;\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57380697": {
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = (a); i <= (b); i++)\n#define per(i, a, b) for(int i = (a); i >= (b); i--)\n#define ll long long\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define pii pair<int,int>\nusing namespace std;\nconst int N = 2e5+1000;\npii s[N];\nint n;\nint cmp(pii a, pii b) {\n    if(a.second!=b.second) return a.second>b.second;\n    return a.first < b.first;\n}\nint bit[2*N];\nint lb(int x) {return x&-x;}\nvoid add(int x) {\n    for(int i = x; i <= 4e5+1000; i += lb(i)) bit[i] += 1;\n}\nll que(int x) {\n    int ans = 0;\n    for(int i = x; i > 0; i -= lb(i)) ans += bit[i];\n    return ans;\n}\nbool flag[2*N];\nint main() {\n  //  freopen(\"a.txt\",\"r\",stdin);\n    ios::sync_with_stdio(0);\n    cin>>n;\n    vector<int>k;\n    rep(i, 1, n) {\n        cin>>s[i].first>>s[i].second;\n        k.pb(s[i].first);\n        k.pb(s[i].second);\n    }\n    sort(all(k));\n    k.erase(unique(all(k)),k.end());\n    sort(s+1,s+n+1,cmp);\n    ll ans = 0;\n    rep(i, 1, n) {\n        s[i].first = lower_bound(all(k),s[i].first)-k.begin()+1;\n        s[i].second = lower_bound(all(k),s[i].second)-k.begin()+1;\n    }\n    k.clear();\n    int lasty = -1;\n    rep(i, 1, n) {\n        int x = s[i].first;\n        int y = s[i].second;\n        if(y == lasty) {\n            if(!flag[x]) {\n                add(x);\n                flag[x] = 1;\n            }\n            k.pb(i);\n            continue;\n        }\n        else {\n            int lastx = 0;\n            for(auto p:k) {\n                ans += (que(s[p].first)-que(lastx))*(que(4e5+1000)-que(s[p].first-1));\n                lastx = s[p].first;\n            }\n            k.clear();\n            k.pb(i);\n            lasty = s[i].second;\n            if(!flag[x]) {\n                add(x);\n                flag[x] = 1;\n            }\n        }\n    }\n    int lastx = 0;\n    for(auto p:k) {\n        ans += (que(s[p].first)-que(lastx))*(que(4e5+1000)-que(s[p].first-1));\n        lastx = s[p].first;\n    }\n    cout<<ans;\n    return 0;\n}\n\n   \t\t \t  \t \t     \t\t\t    \t\t\t \t\t\t",
    "ext": "cpp"
  },
  "57377329": {
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst int N = 2e5 + 5;\nvector<int>vx, vy;\nvector<int>a[N];\nint x[N], y[N];\nint sum[N], flag[N];\nint lowbit(int x)\n{\n    return x & (-x);\n}\nint upd(int x, int k)\n{\n    while(x < N){\n        sum[x] += k;\n        x += lowbit(x);\n    }\n}\nint qry(int x)\n{\n    int ans = 0;\n    while(x){\n        ans += sum[x];\n        x -= lowbit(x);\n    }\n    return ans;\n}\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++){\n        scanf(\"%d %d\", &x[i], &y[i]);\n        vy.push_back(y[i]);\n        vx.push_back(x[i]);\n    }\n    sort(vy.begin(), vy.end());\n    sort(vx.begin(), vx.end());\n    vy.erase(unique(vy.begin(), vy.end()), vy.end());\n    vx.erase(unique(vx.begin(), vx.end()), vx.end());\n    for(int i = 1; i <= n; i++){\n        int py = lower_bound(vy.begin(), vy.end(), y[i]) - vy.begin() + 1;\n        int px = lower_bound(vx.begin(), vx.end(), x[i]) - vx.begin() + 1;\n        a[py].push_back(px);\n    }\n    LL ans = 0;\n    for(int i = N - 1; i >= 1; i--){\n        sort(a[i].begin(), a[i].end());\n        for(int j = 0; j < a[i].size(); j++){\n            int t = a[i][j];\n            if(!flag[t]){ \n                upd(t, 1);\n                flag[t] = 1;\n            }\n            int R, L;\n            L = qry(t);\n            if(j == a[i].size() - 1){\n                R = qry(N - 1) - qry(t - 1);\n            }\n            else{\n                R = qry(a[i][j + 1] - 1) - qry(t - 1);\n            }\n            ans += 1ll * L * R;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}",
    "ext": "cpp"
  },
  "57369022": {
    "code": "#include <iostream>\n#include <map>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N = 2e5 + 10;\nint x[N], y[N], v[N], cntx, cnty;\nint sum[N];\nint n;\nstruct node\n{\n    int x, y;\n} p[N];\nint lowbit(int x)\n{\n    return x & (-x);\n}\nvoid add(int x, int w)\n{\n    while (x <= n)\n    {\n        sum[x] += w;\n        x += lowbit(x);\n    }\n    return;\n}\nll query(int x)\n{\n    ll ans = 0;\n    while (x)\n    {\n        ans += sum[x];\n        x -= lowbit(x);\n    }\n    return ans;\n}\nbool cmp(node c, node d)\n{\n    if (c.y == d.y)\n        return c.x < d.x;\n    return c.y > d.y;\n}\nvoid prepare()\n{\n    sort(x + 1, x + 1 + n);\n    sort(y + 1, y + 1 + n);\n    cntx = unique(x + 1, x + 1 + n) - x - 1;\n    cnty = unique(y + 1, y + 1 + n) - y - 1;\n    for (int i = 1; i <= n; i++)\n    {\n        p[i].x = lower_bound(x + 1, x + 1 + cntx, p[i].x) - x;\n        p[i].y = lower_bound(y + 1, y + 1 + cnty, p[i].y) - y;\n        //cout << p[i].x << \" \" << p[i].y << endl;\n    }\n}\nvoid update(int x)\n{\n    if (!v[p[x].x])\n    {\n        add(p[x].x, 1);\n        v[p[x].x] = 1;\n    }\n}\nint main()\n{\n    ll ans = 0;\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++)\n    {\n        scanf(\"%d %d\", &p[i].x, &p[i].y);\n        x[i] = p[i].x;\n        y[i] = p[i].y;\n    }\n    prepare();\n    sort(1 + p, 1 + p + n, cmp);\n    int cnt = 1;\n    while (cnt <= n)\n    {\n        //cout << cnt << endl;\n        int std = p[cnt].y;\n        int l = cnt;\n        update(cnt);\n        while (cnt + 1 <= n && std == p[cnt + 1].y)\n            update(cnt + 1), cnt++;\n        //cout << cnt << endl;\n        int last = 0;\n        for (int i = l; i < cnt; i++)\n            ans += (query(p[i].x) - query(0)) * (query(p[i + 1].x - 1) - query(p[i].x - 1));\n        ans += (query(p[cnt].x) - query(0)) * (query(n) - query(p[cnt].x - 1));\n        cnt++;\n        //cout << ans << endl;\n    }\n    cout << ans << endl;\n}",
    "ext": "cpp"
  },
  "57363957": {
    "code": "#include<bits/stdc++.h>\nconst int MAXN = 2e5 + 5, INF = 0x3f3f3f3f, MOD = 1e9 + 7;\nusing namespace std;\n#define lson o<<1,l,m\n#define rson o<<1|1,m+1,r\n#define mid l + ((r-l)>>1)\ntypedef long long ll;\nstruct point {\n\tint x, y;\n\tbool operator <(const point &other)const {\n\t\tif (other.y == y)return x < other.x;\n\t\treturn y > other.y;\n\t}\n}points[MAXN];\nint n, X[MAXN], bit[MAXN], k;\nbool vis[MAXN];\nint ask(int x) {\n\tint ans = 0;\n\tfor (; x; x -= x & -x)ans += bit[x];\n\treturn ans;\n}\nint ask(int l, int r) {\n\treturn ask(r) - ask(l - 1);\n}\nvoid upd(int x, int v = 1) {\n\tfor (; x <= k; x += x & -x)bit[x] += v;\n}\nint main() {\n\tcin >> n;\n\tk = n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> points[i].x >> points[i].y;\n\t\tX[i] = points[i].x;\n\t}\n\tsort(points + 1, points + 1 + n);\n\tsort(X + 1, X + 1 + k);\n\tk = unique(X + 1, X + 1 + k) - X - 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tpoints[i].x = lower_bound(X + 1, X + 1 + k, points[i].x) - X;\n\t}\n\tll ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint a = ask(points[i].x - 1), b;\n\t\tif (i < n && points[i].y == points[i + 1].y)b = ask(points[i].x + 1, points[i + 1].x - 1);\n\t\telse b = ask(points[i].x + 1, k);\n\t\tans += 1LL * (a + 1)*(b + 1);\n\t\tif (!vis[points[i].x]) {\n\t\t\tvis[points[i].x] = 1;\n\t\t\tupd(points[i].x);\n\t\t}\n\t}\n\tcout << ans << '\\n';\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57355694": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define io_speed_up ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)\n#define rep(i,a,b) for (int i=a;i<=b;i++)\n#define per(i,a,b) for (int i=a;i>=b;i--)\n#define ms(a,b)  memset(a,b,sizeof a)\n#define sz(x) (int)x.size()\nusing ll = long long;\nconst int inf = 0x3f3f3f3f;\nconst int maxn = 2e5+5;\nconst int mod = 1e9+7;\nusing pii = pair<int,int>;\n#define x first\n#define y second\nint n;\npii a[maxn];\nbool cmp(pii &a,pii &b) \n{\n    if(a.y==b.y) return a.x<b.x;\n    return a.y>b.y;\n}\nint b[maxn],N;\nstruct BIT{\n    int s[maxn];\n    void init() {ms(s,0);}\n    int lowbit(int x) {return x&(-x);}\n    void add(int i) {\n        while(i<=N) {\n            s[i] ++;\n            i += lowbit(i);\n        }\n    }\n    int sum(int i) {\n        int ret=0;\n        while(i) {\n            ret += s[i];\n            i -= lowbit(i);\n        }\n        return ret;\n    }\n    int ask(int l,int r) {return sum(r)-sum(l-1);}\n}bt;\nbool exist[maxn];\nint hs[maxn];\nint main()\n{\n    io_speed_up;\n    cin>>n;\n    rep(i,1,n) {\n        cin>>a[i].x>>a[i].y;\n        b[i] = a[i].x;\n    }\n    sort(b+1,b+n+1);\n    N = unique(b+1,b+n+1) - (b+1);\n    sort(a+1,a+n+1,cmp);\n    rep(i,1,n) hs[i] = lower_bound(b+1,b+N+1,a[i].x) - b;\n    int l=1,r;\n    ll ans=0;\n    while(l<=n) {\n        r = l;\n        while(r+1<=n && a[r+1].y == a[l].y) r++;\n        rep(i,l,r) {\n            if(!exist[hs[i]]) bt.add(hs[i]),exist[hs[i]]=1;\n            int t1 = bt.ask(1,hs[i]);\n            int t2 = bt.ask(hs[i],(i<r)?hs[i+1]-1:N);\n            ans += 1LL*t1*t2;\n        }\n        l = r+1;\n    }\n    cout<<ans<<endl;\n    return 0;\n}",
    "ext": "cpp"
  },
  "57349809": {
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> PI;\nconst int maxn=2e5+5;\nint X[maxn],xn;\nint bit[maxn],N;\nPI P[maxn];\nbool vis[maxn];\nint find(int x)\n{\n\treturn lower_bound(X,X+xn,x)-X+1;\n}\nvoid add(int x)\n{\n\twhile(x<=xn+1){\n\t\tbit[x]++;\n\t\tx+=x&(-x);\n\t}\n}\nint sum(int x)\n{\n\tint re=0;\n\twhile(x>0){\n\t\tre+=bit[x];\n\t\tx-=x&(-x);\n\t}\n\treturn re;\n}\nbool cmp(PI A,PI B)\n{\n\treturn A.se==B.se?A.fi<B.fi:A.se>B.se;\n}\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tP[i]=PI(a,b);\n\t\tX[i]=a;\n\t\t//Y[i]=b;\n\t}\n\tsort(X,X+N);\n\t//sort(Y+1,Y+1+N);\n\txn=unique(X,X+N)-X;\n\t//yn=unique(Y+1,Y+1+N)-Y-1;\n\tsort(P,P+N,cmp);\n\tLL ans=0;\n\tint cnt;\n\tfor(int i=0;i<N;i+=cnt){\n\t\tcnt=0;\n\t\tfor(int j=i;j<N;j++){\n\t\t\tif(P[j].se==P[i].se){\n\t\t\t\tcnt++;\n\t\t\t\tint pos=find(P[j].fi);\n\t\t\t\tif(!vis[pos])\n\t\t\t\t\tadd(pos+1);\n\t\t\t\tvis[pos]=1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tfor(int j=0;j<cnt;j++){\n\t\t\tPI tem=P[i+j];\n\t\t\tint pos=find(tem.fi);\n\t\t\tint l=sum(pos)+1;\n\t\t\tif(j)\n\t\t\t\tl-=sum(find(P[i+j-1].fi))+1;\n\t\t\tint r=sum(xn+1)-sum(pos);\n\t\t\tans+=1LL*r*l;\n\t\t}\t\n\t}\n\tprintf(\"%I64d\\n\",ans);\n}",
    "ext": "cpp"
  },
  "57324660": {
    "code": "    #include <bits/stdc++.h>\n    using namespace std; \n    using ll = long long;\n    struct SumSegmentTree {\n    private:\n    vector<int> v; // vettore che contiene l'albero\n    vector<int> u; // vettore di update\n    int n; //numero nodi interni\n    const int NULL_VALUE = 0; //zero dell'operazione\n    public:\n    SumSegmentTree(int num) {\n        v.resize((1 << (int)(ceil(log2(num))+1))-1, NULL_VALUE);//completo bilanciato\n        u.resize(v.size(), NULL_VALUE);\n        n = v.size() / 2;\n    }\n\n    SumSegmentTree(vector<int> &source) {\n        v.resize((1 << (int)(ceil(log2(source.size()))+1))-1, NULL_VALUE);//completo bilanciato\n        u.resize(v.size(), NULL_VALUE);\n        n = v.size() / 2;\n        for (int i = 0; i < source.size(); i++) {\n            v[i + n] = source[i];\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            updateNode(i);\n        }\n    }\n    private:\n    int left(int i) {\n        return i*2+1;\n    }\n\n    int right(int i) {\n        return i*2+2;\n    }\n\n    int parent(int i) {\n        return (i - 1) / 2;\n    }\n\n    int mergeValues(int v1, int v2) {\n        return v1 + v2;\n    }\n\n    void updateNode(int i) {\n        v[i] = mergeValues(v[left(i)], v[right(i)]);\n    }\n\n    void lazyUpdate(int i) {\n        if (u[i] != 0) {\n            v[i] += u[i];\n            if (i < v.size() / 2) {\n                u[left(i)] += u[i] / 2;\n                u[right(i)] += u[i] / 2;\n            }\n            u[i] = 0;\n        }\n    }\n\n    int rangeQuery(int i, int l, int r, int a, int b) {\n        lazyUpdate(i); //Aggiornamento in lettura\n\n        if (l >= a && r <= b) {\n            return v[i];\n        }\n        if (r < a || l > b) {\n            return NULL_VALUE;\n        }\n        int m = (l + r) / 2;\n        return mergeValues(rangeQuery(left(i), l, m, a, b), rangeQuery(right(i), m + 1, r, a, b));\n    }\n\n    void updateToRoot(int i) {\n        updateNode(i);\n        if (i != 0) {\n            updateToRoot(parent(i));\n        }\n    }\n\n    void rangeAdd(int i, int a, int b, int l, int r, int off) {\n        lazyUpdate(i);\n\n        if (l >= a && r <= b) {\n            u[i] += off * (r - l + 1);\n            lazyUpdate(i);\n\n        } else if (!(r < a || l > b)) { //overlap parziale\n            int m = (l + r) / 2;\n            rangeAdd(left(i), a, b, l , m, off);\n            rangeAdd(right(i), a, b, m + 1, r, off);\n            updateNode(i);\n        }\n    }\n\n    public:\n\n    int rangeSum(int a, int b) {\n        if(b < a)\n            return 0;\n        return rangeQuery(0, 0, n, a, b);\n    }\n\n    void update(int index, int value) {\n        int i = n + index;\n        v[i] = value;\n        updateToRoot(parent(i));\n    }\n\n    void rangeUpdate(int a, int b, int offset) {\n        rangeAdd(0, a, b, 0, n, offset);\n    }\n\n    void print() {\n        int i = 0;\n        int livNum = 1;\n        while (i < v.size()) {\n            for (int j = 0; j < livNum; j++) {\n                cout << v[i] << \"(\" << u[i] << \")\" << \" \";\n                i++;\n            }\n            livNum *= 2;\n            cout << \"\\n\";\n        }\n    }\n};\n\nstruct ppair{\n    int first;\n    int second;\n    const bool operator<(const ppair &other){\n        if(first != other.first){\n            return first < other.first;\n        }else{\n            return second > other.second;\n        }\n    }\n};\n\nsigned main() { \n    int n;\n    cin>>n;\n    vector<ppair> v(n);\n    vector<int> c(n);\n    map<int, int> m;\n    for(auto &p : v){\n        cin>>p.second;\n        cin>>p.first;\n    }\n\n    for(int i = 0; i< n; i++){\n        c[i]=v[i].second;\n    }\n    sort(c.begin(), c.end());\n    vector<int> x(2*1e5+5);\n    SumSegmentTree st(x);\n    int nx = 1;\n    int old = -1;\n    for(int i = 0; i < n; i++){\n        if(c[i] == old){\n            continue;\n        }\n        m[c[i]] = nx++;\n        old = c[i];\n    }\n    \n    sort(v.begin(), v.end(), [](ppair a, ppair b){\n        if(a.first != b.first){\n            return a.first > b.first;\n        }else{\n            return a.second < b.second;\n        }\n    });\n    for(auto p : v){\n        //cout<<m[p.second]<<\" \"<<p.first<<\"\\n\";\n    }\n    ll sol = 0;\n    ll prev = 0;\n    ll sprev = 0;\n    ll tmpsprev =0;\n    for(int i = 0; i < n; i++){\n        ll tmp = 0;\n        tmpsprev = 0;\n        if(i > 0 && v[i].first != v[i-1].first){\n            prev = 0;\n            sprev = 0;\n            tmp += st.rangeSum(0, m[v[i].second]-1) * (ll)st.rangeSum(m[v[i].second]+1, 2*1e5+2);\n            tmpsprev += st.rangeSum(0, m[v[i].second]-1);\n\n        }\n        if(i > 0 && v[i].first == v[i-1].first){\n            tmpsprev += st.rangeSum(m[v[i-1].second]+1, m[v[i].second]-1);\n            tmp += st.rangeSum(m[v[i-1].second]+1, m[v[i].second]-1)* (ll)st.rangeSum(m[v[i].second]+1, 2*1e5+2);\n        }\n        if(st.rangeSum(m[v[i].second], m[v[i].second])){\n            tmp -= prev;\n            tmp -= sprev;\n        }\n        st.update(m[v[i].second], 1);\n        \n        tmp += st.rangeSum(0, 2*1e5+2);\n        sprev += tmpsprev;\n        //cout<<tmp<<endl;\n        sol += tmp;\n        prev++;\n    }\n\n    cout<<sol;\n}",
    "ext": "cpp"
  },
  "57315192": {
    "code": "#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <set>\n#define pii pair<int, int>\n#define lson rt << 1\n#define rson rt << 1 | 1\nusing namespace std;\nconst int maxn = 200005;\nint n, x[maxn<<2];\nlong long res=0;\npii node[maxn];\nset<int> kind;\nbool cmp(pii a, pii b){\n    if(a.second == b.second) return a.first < b.first;\n    return a.second > b.second;\n}\n\nvoid pushup(int rt){\n    x[rt] = x[lson] + x[rson];\n}\n\nvoid build(int l,int r, int rt){\n    if(l == r) {\n        x[rt] = 0;\n        return;\n    }\n    int m = (l+r) >> 1;\n    build(l, m, lson);\n    build(m+1, r, rson);\n    pushup(rt);\n}\n\nvoid update(int p, int add, int l, int r, int rt){\n    if(l == r){\n        x[rt] = add;\n        return;\n    }\n    int m = (l+r)>>1;\n    if(p <= m) update(p, add, l, m, lson);\n    else update(p, add, m+1, r, rson);\n    pushup(rt);\n}\n\nint query(int L, int R, int l, int r, int rt){\n    if(L <= l && R >= r) return x[rt];\n    int res = 0;\n    int m = (l+r) >> 1;\n    if(L <= m) res += query(L, R, l, m, lson);\n    if(R > m) res += query(L, R, m+1, r, rson);\n    return res;\n}\n\nint main(){\n    //freopen(\"case.txt\", \"r\", stdin);\n    scanf(\"%d\", &n);\n    for(int i=0; i<n; i++) {\n        scanf(\"%d%d\", &node[i].first, &node[i].second);\n        x[i] = node[i].first;\n    }\n    sort(x, x+n);\n    int cnt = unique(x, x+n) - x;\n    for(int i=0; i<n; i++){\n        node[i].first = lower_bound(x, x+cnt, node[i].first) - x + 1;\n    }\n    build(1, n, 1);\n    sort(node, node+n, cmp);\n    int i=0;\n    vector<int> point;\n    while(i < n){\n        int t=node[i].second;\n        point.push_back(1);\n        long long sum=0;\n        while(i < n && node[i].second == t){\n            int k = node[i].first;\n            point.push_back(k-1);\n            point.push_back(k+1);\n            if(kind.find(k) == kind.end()) {\n                kind.insert(k);\n                update(k, 1, 1, n, 1);\n                int k=n<<2;\n            }\n            i++;\n        }\n        point.push_back(n);\n        sum = query(1, n, 1, n, 1);\n        sum = sum*(sum+1) >> 1;\n        for(int j=0; j<point.size(); j+=2){\n            int l = point[j], r = point[j+1];\n            if(l <= r){\n                t = query(l, r, 1, n, 1);\n                sum -= 1ll*t*(t+1) >> 1;\n            }\n        }\n        res += sum;\n        point.clear();\n    }\n    printf(\"%I64d\", res);\n    return 0;\n}",
    "ext": "cpp"
  },
  "57313902": {
    "code": "// clang-format off\n#define protected public\nusing iii  = int;\nusing yeee = iii;\n\n#ifdef LOCAL\n    const iii DEBUG = 0;\n#else\n    const iii DEBUG = -1;\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing namespace chrono;\n\n#if 1\n    #include <ext/pb_ds/assoc_container.hpp>\n    #include <ext/pb_ds/detail/standard_policies.hpp>\n    using namespace __gnu_pbds; template<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>; template<typename T1, typename T2> using hash_map = gp_hash_table<T1, T2>;\n#endif\n\n#define DBG(x) if(DEBUG >= x)\n#define FOR(i, lo, hi) for(ll i = ll(lo); i < ll(hi); ++i)\n#define ROF(i, hi, lo) for(ll i = ll(hi); i >= (ll)(lo); --i)\n#define ALL(x) (x).begin(), (x).end()\n#define len(x) ll((x).size())\n#define PB push_back\n\n#if 1\n    #define DOUT(...) DOUTg(#__VA_ARGS__, __VA_ARGS__)\n    template <typename T1> void DOUTf(ostringstream &os, int names_i, vector<string> &names, T1 &&val) { os << names[names_i] << \" = \" << val; } template <typename T1, typename... Ts> void DOUTf(ostringstream &os, int names_i, vector<string> &names, T1 &&val, Ts &&... vals) { os << names[names_i] << \" = \" << val << \" | \"; DOUTf(os, names_i + 1, names, vals...); } template <typename... Ts> string DOUTg(string names, Ts &&... vals) { string special = \"()[]{}<>'\\\"\\\\\"; vector<string> vnames; vnames.PB(\"\"); vector<char> stak; for(char c : names) { bool inside_string = !stak.empty() && (stak.back() == '\\'' || stak.back() == '\\\"'); if(c == '\\n') c = ' '; if(c == ' ' && (vnames.back().empty() || (!inside_string && vnames.back().back() == ' '))) continue; if(stak.empty() && c == ',') { if(!vnames.back().empty() && vnames.back().back() == ' ') vnames.back().pop_back(); vnames.PB(\"\"); continue; } vnames.back().PB(c); if(!stak.empty() && stak.back() == '\\\\') { stak.pop_back(); continue; } size_t p = special.find(c); bool closing = p < 8 && p % 2; if(p == string::npos) continue; if(p == special.size() - 1) { stak.PB(c); continue; } if(stak.empty()) { if(!closing) stak.PB(c); continue; } if(inside_string) { if(c == stak.back()) stak.pop_back(); continue; } if(closing) { if(stak.back() == special[p - 1]) stak.pop_back(); continue; } stak.PB(c); } ostringstream os; DOUTf(os, 0, vnames, vals...); return os.str(); }\n    template <template <typename...> class Container, typename T, size_t DIMENSION> struct MultiDimensional { using internal = MultiDimensional<Container, T, DIMENSION - 1>; using type = Container<typename internal::type>; template <typename... Args> static type Generate(T def, const size_t size, Args... sizes) { return type(size, internal::Generate(def, sizes...)); } }; template <template <typename...> class Container, typename T> struct MultiDimensional<Container, T, 1> { using internal = T; using type = Container<T>; static type Generate(T def, const size_t size) { return type(size, def); } }; template <typename T, typename... Args> auto make_vector(T def, Args... sizes) -> typename MultiDimensional<std::vector, T, sizeof...(sizes)>::type { return MultiDimensional<std::vector, T, sizeof...(sizes)>::Generate( def, sizes...); }\n#endif\n/*get*/ template <typename T> T get() { T x; cin >> x; return x; } /*pair*/ template <typename T1, typename T2> ostream &operator<<(ostream &out, const pair<T1, T2> &cont) { out << \"(\" << cont.first << \", \" << cont.second << \")\"; return out; } /*vector*/ template <typename T, typename Alloc> ostream &operator<<(ostream &out, const vector<T, Alloc> &cont) { for(auto it = cont.begin(); it != cont.end(); ++it) out << (it == cont.begin() ? \"\" : \" \") << *it; return out; } /*deque*/ template <typename T, typename Alloc> ostream &operator<<(ostream &out, const deque<T, Alloc> &cont) { for(auto it = cont.begin(); it != cont.end(); ++it) out << (it == cont.begin() ? \"\" : \" \") << *it; return out; } /*set*/ template <typename T, typename Compare, typename Alloc> ostream &operator<<(ostream &out, const set<T, Compare, Alloc> &cont) { out << \"{\"; for(auto it = cont.begin(); it != cont.end(); ++it) out << (it == cont.begin() ? \"\" : \", \") << *it; out << \"}\"; return out; } /*multiset*/ template <typename T, typename Compare, typename Alloc> ostream &operator<<(ostream &out, const multiset<T, Compare, Alloc> &cont) { out << \"{\"; for(auto it = cont.begin(); it != cont.end(); ++it) out << (it == cont.begin() ? \"\" : \", \") << *it; out << \"}\"; return out; } /*map*/ template <typename Key, typename T, typename Compare, typename Alloc> ostream &operator<<(ostream &out, const map<Key, T, Compare, Alloc> &cont) { out << \"{\"; for(auto it = cont.begin(); it != cont.end(); ++it) out << (it == cont.begin() ? \"\" : \", \") << it->first << \":\" << it->second; out << \"}\"; return out; } /*multimap*/ template <typename Key, typename T, typename Compare, typename Alloc> ostream &operator<<(ostream &out, const multimap<Key, T, Compare, Alloc> &cont) { out << \"{\"; for(auto it = cont.begin(); it != cont.end(); ++it) out << (it == cont.begin() ? \"\" : \", \") << it->first << \":\" << it->second; out << \"}\"; return out; } /*vectorND*/ template <typename T> ostream &operator<<(ostream &out, vector<vector<T>> cont) { for(auto it = cont.begin(); it != cont.end(); ++it) out << *it << \"\\n\"; return out; }\nusing ll = long long; using lll = long long; using ull = unsigned long long; using ld = long double; using pll = pair<ll, ll>; using vb = vector<bool>; using vvb = vector<vb>; using vll = vector<ll>; using vvll = vector<vll>; using vpll = vector<pll>; using point = complex<ld>;\nld get_time() { return ld(duration_cast<nanoseconds>(high_resolution_clock::now().time_since_epoch()).count()) / 1e9; } ll sign(ld x) { return (x > 0) - (x < 0); } ll fmod(ll x, ll mod) { if(!mod) return x; if(abs(x) >= mod) x %= mod; if(x < 0) x += mod; return x; } ll pow(ll x, ll exp, ll mod) { ll res = 1, y = x; while(exp) { if(!mod) { if(exp & 1) res = res * y; y = y * y; } else { if(exp & 1) res = fmod(res * y, mod); y = fmod(y * y, mod); } exp >>= 1; } return res; }\nld START_TIME = get_time(); mt19937_64 rand_mt64(chrono::steady_clock::now().time_since_epoch().count()); mt19937 rand_mt(chrono::steady_clock::now().time_since_epoch().count()); const long long INFll = ll(1.1e18) - 1; const int INFi = ll(1.1e9) - 1; ll INF = sizeof(ll) == sizeof(int) ? ll(INFi) : ll(INFll); char newl = '\\n';\nvoid main_init(string input_file = \"\", string output_file = \"\", bool fast_cio = true) { srand(unsigned(time(0))); if(fast_cio) { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); } DBG(0 && input_file != \"\") freopen(input_file.c_str(), \"r\", stdin); DBG(0 && output_file != \"\") freopen(output_file.c_str(), \"w\", stdout); }\n// clang-format on\n\nstruct Intervalac {\n    ll N;\n    vll val;\n    vpll bound;\n\n    Intervalac(ll n) {\n        N = 1;\n        while(N < n)\n            N *= 2;\n        N *= 2;\n\n        val.resize(N, 0);\n\n        bound.resize(N);\n        FOR(i, 0, N / 2)\n            bound[N / 2 + i] = {i, i + 1};\n        ROF(i, N / 2 - 1, 0)\n            bound[i] = {bound[i * 2].first, bound[i * 2 + 1].second};\n    }\n\n    void update(ll curr, ll d) {\n        curr += N / 2;\n        if(val[curr])\n            return;\n        while(curr) {\n            val[curr] += d;\n            curr /= 2;\n        }\n    }\n\n    ll get(ll curr, ll lo, ll hi) {\n        if(bound[curr].first >= hi || bound[curr].second <= lo)\n            return 0;\n        else if(bound[curr].first >= lo && bound[curr].second <= hi)\n            return val[curr];\n        else\n            return get(curr * 2, lo, hi) + get(curr * 2 + 1, lo, hi);\n    }\n};\n\nyeee main() {\n    main_init();\n    //\n\n    ll N;\n    cin >> N;\n\n    vpll V(N);\n    set<ll> xs;\n    FOR(i, 0, N) {\n        cin >> V[i].first >> V[i].second;\n        xs.insert(V[i].first);\n    }\n\n    V.PB({0, 0});\n    xs.insert(0);\n    ll M = len(xs);\n    map<ll, ll> mxs;\n    for(ll x : xs) {\n        ll l = len(mxs);\n        mxs[x] = l;\n    }\n    FOR(i, 0, len(V))\n        V[i].first = mxs[V[i].first];\n\n    sort(ALL(V), [](pll &a, pll &b) {\n        return a.second != b.second ? a.second > b.second : a.first < b.first;\n    });\n\n    set<ll> add;\n    ll prev_y = V[0].second;\n    Intervalac I(M);\n    ll res = 0;\n    FOR(i, 0, len(V)) {\n        ll cx, cy;\n        tie(cx, cy) = V[i];\n\n        if(cy != prev_y) {\n            map<ll, ll> seg;\n            seg[0] = M;\n            for(ll x : add) {\n                if(x >= seg.begin()->first) {\n                    auto it = --(seg.upper_bound(x));\n                    if(it->second > x) {\n                        pll p = *it;\n                        seg.erase(it);\n                        vpll ns = {{p.first, x}, {x + 1, p.second}};\n                        for(pll s : ns) {\n                            if(s.first >= s.second)\n                                continue;\n                            seg[s.first] = s.second;\n                        }\n                    }\n                }\n                I.update(x, 1);\n            }\n            add.clear();\n\n            ll r = 0;\n            ll l = I.get(1, 0, M);\n            r += l * (l + 1) / 2;\n            for(pll p : seg) {\n                l = I.get(1, p.first, p.second);\n                r -= l * (l + 1) / 2;\n            }\n            res += r;\n\n            prev_y = cy;\n            DBG(2) cout << DOUT(cy, r, res) << endl;\n        }\n\n        add.insert(cx);\n    }\n\n    cout << res << endl;\n}\n",
    "ext": "cpp"
  },
  "57304710": {
    "code": "#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <map>\n#define pii pair<int ,int>\n#define lson rt << 1\n#define rson rt << 1|1\nusing namespace std;\nconst int maxn = 2*1e5+10;\nint n, x[maxn << 2];\nvector<int> point;\npii node[maxn];\nmap<int, int> mp;\nlong long ans = 0;\nbool cmp(pii a, pii b){\n    if(a.second == b.second) return a.first < b.first;\n    return a.second > b.second;\n}\n\nvoid pushup(int rt){\n    x[rt] = x[lson] + x[rson];\n}\n\nvoid build(int l, int r, int rt){\n    if(l == r) {\n        x[rt] = 0;\n        return;\n    }\n    int m = (l+r)>>1;\n    build(l, m, lson);\n    build(m+1, r, rson);\n    pushup(rt);\n}\n\nvoid update(int p, int add, int l, int r, int rt){\n    if(l == r){\n        x[rt] = add;\n        return;\n    }\n    int m = (l+r) >> 1;\n    if(p <= m) update(p, add, l, m, lson);\n    else update(p, add, m+1, r, rson);\n    pushup(rt);\n}\n\nint query(int L, int R, int l, int r, int rt){\n    if(L <= l && R >= r) return x[rt];\n    int m = (l+r) >> 1;\n    int res = 0;\n    if(L <= m) res += query(L, R, l, m, lson);\n    if(R > m) res += query(L, R, m+1, r, rson);\n    return res;\n}\n\nint main(){\n//    freopen(\"case.txt\", \"r\", stdin);\n    scanf(\"%d\", &n);\n    for(int i=0; i<n; i++){\n        scanf(\"%d%d\", &node[i].first, &node[i].second);\n        x[i] = node[i].first;\n    }\n    sort(x, x+n);\n    int cnt = unique(x, x+n) - x;\n    for(int i=0; i<n; i++){\n        node[i].first = lower_bound(x, x+cnt, node[i].first) - x + 1;\n    }\n    sort(node, node+n, cmp);\n    build(1, n, 1);\n    cnt = 0;\n    int len = 0;\n    long long sum = 0;\n    while(cnt < n){\n        point.push_back(1);\n        int t = node[cnt].second;\n        while(cnt < n && node[cnt].second == t){\n            point.push_back(node[cnt].first - 1);\n            point.push_back(node[cnt].first + 1);\n            if(mp.find(node[cnt].first) == mp.end()) {\n                update(node[cnt].first, 1, 1, n, 1);\n                mp[node[cnt].first] = 1;\n            }\n            cnt++;\n        }\n        point.push_back(n);\n        sum = query(1, n, 1, n, 1);\n        sum = sum*(sum+1)/2;\n        for(int i=0; i<point.size(); i+=2){\n            int l = point[i], r = point[i+1];\n            if(l <= r) {\n                t = query(l, r, 1, n, 1);\n                sum -= 1LL*t*(t+1)/2;\n            }\n        }\n        ans += sum;\n        point.clear();\n\n\n//        update(node[cnt].first, 1, 1, n, 1);\n//        point.push_back(node[cnt].first);\n//        if(cnt == n-1 || node[cnt].second != node[cnt+1].second){\n//            len = query(1, n, 1, n, 1);\n//            int l = 1, r;\n//            for(int i=0; i<=point.size(); i++){\n//                r = i < point.size() ? point[i] - 1 : n;\n//                if(l <= r) {\n//                    int t = query(l, r, 1, n, 1);\n//                    sum += t*(t+1)/2;\n//                }\n//                l = r+2;\n//            }\n//            ans += len*(len+1)/2 - sum;\n//            point.clear();\n//            sum = 0;\n//        }\n//        cnt++;\n    }\n    printf(\"%I64d\\n\", ans);\n    return 0;\n}",
    "ext": "cpp"
  },
  "57304465": {
    "code": "\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <time.h>\n#include <map>\n#include <set>\n#define mem(a,x) memset(a,x,sizeof(a))\n#define gi(x) scanf(\"%d\",&x)\n#define gi2(x,y) scanf(\"%d%d\",&x,&y)\n#define gi3(x,y,z) scanf(\"%d%d%d\",&x,&y,&z)\n#define gll(x) scanf(\"%lld\",&x)\n#define gll2(x,y) scanf(\"%lld%lld\",&x,&y)\nusing namespace std;\nconst double eps=1e-8;\ntypedef long long ll;\nconst int MAXN=200005;\nconst ll mod=1e9+7;\nconst int inf=0x3f3f3f3f;\nint n;\nstruct Node{\n    int x,y;\n}node[MAXN];\nstruct Tree{\n    int val;\n    int l,r;\n}tree[MAXN<<2];\nbool cmp(Node a,Node b){\n    if(a.y==b.y)return a.x<b.x;\n    return a.y>b.y;\n}\nmap<int,int>ms;\n\nvector<int>x,y,ans,up;\nint maxx,maxy;\nvoid build(int l,int r,int i){\n    tree[i].l=l;\n    tree[i].r=r;\n    tree[i].val=0;\n    if(l==r){\n        return;\n    }\n    int mid=(l+r)/2;\n    build(l,mid,i<<1);\n    build(mid+1,r,i<<1|1);\n}\nint query(int l,int r,int i){\n    if(tree[i].l>=l&&tree[i].r<=r){\n        return tree[i].val;\n    }\n    int mid=(tree[i].l+tree[i].r)/2;\n    int ans=0;\n    if(l<=mid)ans=query(l, r, i<<1);\n    if(r>=mid+1)ans+=query(l, r, i<<1|1);\n    return ans;\n}\nvoid update(int x,int i){\n    if(tree[i].l==tree[i].r){\n        tree[i].val=1;\n        return;\n    }\n    int mid=(tree[i].l+tree[i].r)/2;\n    if(x<=mid){\n        update(x, i<<1);\n    }\n    else update(x,i<<1|1);\n    tree[i].val=tree[i<<1].val+tree[i<<1|1].val;\n    return ;\n}\nint book[MAXN];\n\nint main(){\n\n    gi(n);\n    for(int i=1;i<=n;i++){\n        gi2(node[i].x,node[i].y);\n        x.push_back(node[i].x);\n        y.push_back(node[i].y);\n    }\n    sort(x.begin(),x.end());\n    x.erase(unique(x.begin(),x.end()), x.end());\n    for(int i=0;i<x.size();i++){\n        ms[x[i]]=i+1;\n    }\n    for(int i=1;i<=n;i++){\n        node[i].x=ms[node[i].x];\n    }\n    sort(y.begin(),y.end());ms.clear();\n    y.erase(unique(y.begin(),y.end()), y.end());\n    for(int i=0;i<y.size();i++){\n        ms[y[i]]=i+1;\n    }\n    for(int i=1;i<=n;i++){\n        node[i].y=ms[node[i].y];\n    }\n    maxx=x.size();maxy=y.size();\n    build(1,maxx,1);\n    sort(node+1,node+n+1,cmp);\n    int i=1;\n    ll cnt=0;\n    ll res=0;\n    while(i<=n){\n        ans.push_back(1);\n        int t=node[i].y;\n        while(i<=n&&node[i].y==t){\n            int x=book[node[i].x]++;\n            if(x==0){\n                cnt++;\n                up.push_back(node[i].x);\n            }\n            ans.push_back(node[i].x-1);\n            ans.push_back(node[i].x+1);\n            i++;\n        }\n        ans.push_back(maxx);\n        ll sum=cnt*(cnt+1)/2;\n        for(int i=0;i<ans.size();i+=2){\n            int l=ans[i],r=ans[i+1];\n            if(l<=r){\n                int y=query(l, r, 1);\n                sum-=1ll*y*(y+1)/2;\n            }\n        }\n        res+=sum;\n        for(int i=0;i<up.size();i++){\n            int t=up[i];\n            update(t, 1);\n        }\n        ans.clear();\n        up.clear();\n    }\n    printf(\"%lld\\n\",res);\n\n\n    return 0;\n}\n\t   \t\t \t   \t       \t  \t \t \t\t \t\t",
    "ext": "cpp"
  },
  "57290052": {
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\n#define PII pair<int,int>\n#define VI vector<int>\n#define VII vector<PII>\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define sz(x) ((int)(x).size())\n#define for0(i, n) for(int i=0;i<n;++i)\n#define for1(i, n) for(int i=1;i<=n;++i)\n#define rfor0(i, n) for(int i=n-1;i>=0;i--)\n#define rfor1(i, n) for(int i=n;i>=1;i--)\n#define all(it, obj) for(auto it=(obj).begin();it!=(obj).end();++it)\n#define all_(_, it, obj) for(auto it=_;it!=(obj).end();++it)\n#define rall(it, obj) for(auto it=(obj).rbegin();it!=(obj).rend();++it)\n#define rall_(_, it, obj) for(auto it=_;it!=(obj).rend();++it)\nusing namespace std;\ntypedef long long LL;\n#define N 200005\nint n;\nstruct seg_tree {\n\tint ar[N*4];\n\tvoid init ( int now, int l, int r ) { memset(ar, 0, sizeof(ar)); }\n\tvoid pull ( int now ) {\n\t\tar[now] = ar[now*2] + ar[now*2+1];\n\t}\n\tvoid set ( int now, int l, int r, int pos, int v ) {\n\t\tif ( l==r ) {\n\t\t\tar[now] = v;\n\t\t\treturn ;\n\t\t}\n\t\tint m = (l+r)/2;\n\t\tif ( pos <= m ) {\n\t\t\tset(now*2, l, m, pos, v);\n\t\t}\n\t\telse {\n\t\t\tset(now*2+1, m+1, r, pos, v);\n\t\t}\n\t\tpull(now);\n\t}\n\tint query ( int now, int l, int r, int ql, int qr ) {\n\t\tif ( qr<l || r<ql ) {\n\t\t\treturn (0);\n\t\t}\n\t\tif ( ql<=l and r<=qr ) {\n\t\t\treturn (ar[now]);\n\t\t}\n\t\tint m = (l+r)/2;\n\t\tint a = query(now*2, l, m, ql, qr);\n\t\tint b = query(now*2+1, m+1, r, ql, qr);\n\t\treturn (a+b);\n\t}\n} seg;\nint main ()\n{\n\tscanf(\"%d\",&n);\n\tmap<int, int> diffx, x_idx;\n\tmap<int, vector<int> > diffy;\n\t\n\tdiffx[0] = 1; \t\t\t\t// left-most\n\tdiffx[1000000001] = 1;\t\t// right-most\n\tfor0(i, n){\n\t\tint x, y; scanf(\"%d%d\",&x,&y);\n\t\tdiffx[x] = 1;\n\t\tif ( diffy.find(y) == diffy.end() ) {\n\t\t\tdiffy[y].push_back(0);\n\t\t}\n\t\tdiffy[y].PB(x);\n\t}\n\tall(it, diffy) {\n\t\tit->S.PB(1000000001);\n\t}\n\tint idx = 0;\n\tall(it, diffx) {\n\t\tx_idx[it->F] = idx++;\n\t}\n\tint distinct = sz(diffx);\n\tseg.init(1, 0, distinct-1);\n\tLL ans = 0;\n\trall(B, diffy) {\n\t\tsort(B->S.begin(), B->S.end());\n\t\tint m = sz(B->S); // 0 = 0, m-1 = INF\n\t\tfor ( int i=1; i<m-1; ++i ) {\n\t\t\tseg.set(1, 0, distinct-1, x_idx[B->S[i]], 1);\n\t\t}\n\t\tfor ( int i=1; i<m-1; ++i ) {\n\t\t\tLL a = seg.query(1, 0, distinct-1, x_idx[B->S[i-1]], x_idx[B->S[i]]);\n\t\t\tif ( i != 1 ) {\n\t\t\t\ta--;\n\t\t\t}\n\t\t\tLL b = seg.query(1, 0, distinct-1, x_idx[B->S[i]], x_idx[B->S[m-1]]);\n\t\t\tans += a*b;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn (0);\n}\n",
    "ext": "cpp"
  },
  "57283683": {
    "code": "#ifdef EKLAVYA\n#include \"/mnt/code/OJ/lib/cpp/prettyprint.hpp\"\n#include <iostream>\n#endif\n\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\n\nint segtree_size(int n) {\n    // 2^(ceil(lg(n)) + 1) - 1\n    n -= 1;\n    n |= n >> 1;\n    n |= n >> 2;\n    n |= n >> 4;\n    n |= n >> 8;\n    n |= n >> 16;\n    return 2 * n + 1;\n}\n\ntemplate<class M, class F>\nclass SegTree {\n// M is a monoid\n// F is an endomorphism\npublic:\n    typedef M value_type;\n    typedef F func_type;\n\n    static void identity_check() {\n        if(!F().is_identity()) {\n            fprintf(stderr, \"SegTree: endomorphism's default constructor is not identity\\n\");\n            std::exit(1);\n        }\n    }\n\nprivate:\n    int n;\n    std::vector<M> values;\n    std::vector<F> pends;\n\npublic:\n    explicit SegTree(int _n):\n        n(_n), values(segtree_size(n)), pends(values.size()) {identity_check();}\n    explicit SegTree(int _n, const M& x):\n        n(_n), values(segtree_size(n)), pends(values.size()) {identity_check(); assign(x);}\n    explicit SegTree(int _n, const M* a):\n        n(_n), values(segtree_size(n)), pends(values.size()) {identity_check(); assign(a);}\n    explicit SegTree(const std::vector<M>& v):\n        n(v.size()), values(segtree_size(v.size())), pends(values.size()) {identity_check(); assign(v);}\n\nprivate:\n    void assign_values(int root, int first, int last, const M* a) {\n        // root has the node number, first and last have the array indices.\n        if(first == last) {\n            values[root] = a[first];\n        }\n        else {\n            int left = 2 * root + 1;\n            int mid = (first + last) / 2;\n            assign_values(left, first, mid, a);\n            assign_values(left+1, mid+1, last, a);\n            values[root] = M(values[left], values[left+1]);\n        }\n    }\n\n    void assign_values(int root, int first, int last, const M& x) {\n        // root has the node number, first and last have the array indices.\n        if(first == last) {\n            values[root] = x;\n        }\n        else {\n            int left = 2 * root + 1;\n            int mid = (first + last) / 2;\n            assign_values(left, first, mid, x);\n            assign_values(left+1, mid+1, last, x);\n            values[root] = M(values[left], values[left+1]);\n        }\n    }\n\npublic:\n    void assign(const M* a) {\n        pends.assign(values.size(), F());\n        assign_values(0, 0, n-1, a);\n    }\n\n    void assign(const M& x) {\n        pends.assign(values.size(), F());\n        assign_values(0, 0, n-1, x);\n    }\n\n    void assign(const std::vector<M>& v) {\n        if(v.size() < n) {\n            fprintf(stderr, \"SegTree: vector input to assign is too short\\n\");\n            std::exit(3);\n        }\n        assign(v.data);\n    }\n\nprivate:\n    void print(int root, int first, int last, FILE* fp, int level) const {\n        for(int i=0; i<level; ++i) {\n            fprintf(fp, \"  \");\n        }\n        fprintf(fp, \"%d[%d-%d]: \", root, first, last);\n        values[root].print(fp);\n        if(!pends[root].is_identity()) {\n            fprintf(fp, \": \");\n            pends[root].print(fp);\n        }\n        fprintf(fp, \"\\n\");\n        if(first != last) {\n            int left = 2 * root + 1;\n            int mid = (first + last) / 2;\n            print(left, first, mid, fp, level+1);\n            print(left+1, mid+1, last, fp, level+1);\n        }\n    }\n\npublic:\n    void print(FILE* fp) const {\n        print(0, 0, n-1, fp, 0);\n    }\n\nprivate:\n    void propagate(int root, int first, int last) {\n        if(!pends[root].is_identity()) {\n            values[root] = pends[root](values[root]);\n            if(first != last)\n            {\n                int left = 2 * root + 1;\n                pends[left] = F(pends[root], pends[left]);\n                pends[left+1] = F(pends[root], pends[left+1]);\n            }\n            pends[root] = F();\n        }\n    }\n\n    M query(int root, int first, int last, int i, int j) {\n        if(i>last || j<first) {\n            return M();\n        }\n        propagate(root, first, last);\n        if(i<=first && last<=j) {\n            return values[root];\n        }\n        else {\n            int left = 2 * root + 1;\n            int mid = (first + last) / 2;\n            return M(query(left, first, mid, i, j), query(left+1, mid+1, last, i, j));\n        }\n    }\n\npublic:\n    M query(int i, int j) {\n        return query(0, 0, n-1, i, j);\n    }\n\nprivate:\n    void update(int root, int first, int last, int i, int j, const F& f) {\n        if(i>last || j<first) {\n            propagate(root, first, last);\n        }\n        else if(i<=first && last<=j) {\n            pends[root] = F(f, pends[root]);\n            propagate(root, first, last);\n        }\n        else {\n            propagate(root, first, last);\n            int left = 2 * root + 1;\n            int mid = (first + last)/2;\n            update(left, first, mid, i, j, f);\n            update(left+1, mid+1, last, i, j, f);\n            values[root] = M(values[left], values[left+1]);\n        }\n    }\n\npublic:\n    void update(int i, int j, const F& f) {\n        update(0, 0, n-1, i, j, f);\n    }\n};\n\n\ntypedef long long lli;\ntypedef pair<int, int> iipair;\n\nconst int MAXN = 200000;\nint x[MAXN], y[MAXN];\n\nvector<int> coord_compress(int* a, int n) {\n    vector<int> v(a, a+n);\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    for(int i=0; i<n; ++i) {\n        a[i] = lower_bound(v.begin(), v.end(), a[i]) - v.begin();\n    }\n    return v;\n}\n\nclass ZPlus {\npublic:\n    int x;\n\n    explicit ZPlus(int _x=0): x(_x) {}\n    ZPlus(const ZPlus& a, const ZPlus& b): x(a.x + b.x) {}\n    bool is_identity() {return x == 0;}\n    ZPlus operator()(const ZPlus& a) const {\n        return ZPlus(x + a.x);\n    }\n    int get() const {return x;}\n\n    void print(FILE* fp) const {\n        fprintf(fp, \"%d\", x);\n    }\n};\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for(int i=0; i<n; ++i) {\n        scanf(\"%d%d\", x+i, y+i);\n    }\n\n    // coordinate compress points and sort them by (y, x)\n    vector<int> x_expand_list = coord_compress(x, n);\n    vector<int> y_expand_list = coord_compress(y, n);\n    int xsize = x_expand_list.size();\n    vector<iipair> points;\n    points.reserve(n);\n    for(int i=0; i<n; ++i) {\n        points.emplace_back(y[i], x[i]);\n    }\n    sort(points.begin(), points.end());\n    for(int i=0; i<n; ++i) {\n        y[i] = points[i].first;\n        x[i] = points[i].second;\n    }\n\n    // save distinct x-coords to segtree\n    vector<int> xfreq(xsize, 0);\n    SegTree<ZPlus, ZPlus> segTree(xsize);\n    for(int i=0; i<n; ++i) {\n        if(xfreq[x[i]] == 0) {\n            segTree.update(x[i], x[i], ZPlus(1));\n        }\n        xfreq[x[i]]++;\n    }\n    // cerr << \"xfreq: \" << xfreq << endl;\n\n    lli result = 0;\n    for(int i=0; i<n; ++i) {\n        int prev_pivot_x = -1;\n        if(i >= 1 && y[i-1] == y[i]) {\n            prev_pivot_x = x[i-1];\n        }\n        result += lli(segTree.query(prev_pivot_x+1, x[i]).get()) * lli(segTree.query(x[i], xsize).get());\n\n        xfreq[x[i]]--;\n        if(xfreq[x[i]] == 0) {\n            segTree.update(x[i], x[i], ZPlus(-1));\n        }\n    }\n\n    printf(\"%lld\\n\", result);\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57283389": {
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=2e5+10;\nstruct node{\n    int x,y;\n    bool operator<(const node &p)const{\n        return y==p.y?x<p.x:y>p.y;\n    }\n}num[N];\n\nint X[N];\n\nbool vis[N];\nint tree[N];\nint up;\n\nint sum(int x)\n{\n    int res=0;\n    while(x){\n        res+=tree[x];\n        x-=x&-x;\n    }\n    return res;\n}\n\n void update(int x)\n{\n    while(x<=up){\n        tree[x]+=1;\n        x+=x&-x;\n    }\n}\n\nint q_sum(int x,int y)\n{\n    return sum(y)-sum(x-1);\n}\n\n\nint vx[N];\n\nint main()\n{\n\n    int n;\n    scanf(\"%d\",&n);\n\n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d\",&num[i].x,&num[i].y);\n        X[i]=num[i].x;\n    }\n    sort(X+1,X+1+n);\n\n    int cnt=unique(X+1,X+1+n)-(X+1);\n\n    ///\u79bb\u6563\u5316x\u503c\n    for(int i=1;i<=n;i++){\n        num[i].x=lower_bound(X+1,X+1+cnt,num[i].x)-X;\n    }\n\n    sort(num+1,num+1+n);\n    LL ans=0;\n    up=cnt+1;\n\n    ///now\u5f53\u524d\u626b\u63cf\u7ebf\u7684\u7b2c\u4e00\u4e2a\u70b9\uff0cnext\u5f53\u524d\u626b\u63cf\u7ebf\u7684\u5176\u4ed6\u70b9\n    int now=1,next=1;\n\n    while(now<=n)\n    {\n        int tot=0;\n        while(num[now].y==num[next].y){\n                if(!vis[num[next].x]) ///\u5df2\u7ecf\u52a0\u8fc7\u4e86\uff0c\u5c31\u4e0d\u7528\u518d\u52a0\u4e86\n            update(num[next].x);\n            vis[num[next].x]=1;\n            vx[++tot]=num[next].x;\n            next++;\n        }\n\n        vx[++tot]=cnt+1;\n\n        for(int i=1;i<=tot-1;i++)\n        {\n            ///\u8ba1\u7b97\u4ee5\u5f53\u524d\u65b0\u70b9\u4e3a\u7ed3\u675f\u7684\u5de6\uff0c\u53f3\u5206\u522b\u6709\u591a\u5c11\u4e2a\u65e7\u70b9\n            int t1=q_sum(1,vx[i]-1);\n            int t2=q_sum(vx[i]+1,vx[i+1]-1);\n            ans+=1LL*(t1+1)*(t2+1);\n        }\n        now=next;\n\n    }\n\n    printf(\"%I64d\\n\",ans);\n\n\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57276000": {
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\nconst ll mod = 1e9 + 7;\n#define pival 3.14159265359\n#define pll pair<ll,ll>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define pqq priority_queue\n#define all(a) a.begin(), a.end()\n#define sz(a) (ll)(a.size())\n#define ordered_set tree <ll, null_type,less<ll>, rb_tree_tag, tree_order_statistics_node_update>\n//K-th smallest\n//cout << k << \"kth smallest: \" << *A.find_by_order(k - 1) << endl;\n//NO OF ELEMENTS < X\n//cout << \"No of elements less than \" << X << \" are \" << A.order_of_key(X) << endl;\nll power(ll x, ll y, ll p)\n{ \n    ll res = 1;  \n    x = x % p;\n    while (y > 0) { \n        if (y & 1) res = (res * x) % p; \n        y = y >> 1;\n        x = (x * x) % p;   \n    } \n    return res; \n}\nint main()\n{\n\tios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n \tll n, x, y;\n \tcin >> n;\n \tmap <ll,vector<ll>> ym;\n \tmap <ll,ll> xm;\n \tordered_set xs;\n \tset <ll> ys;\n \twhile (n--) {\n \t\tcin >> x >> y;\n\t\tym[y].pb(x);\n\t\tys.insert(y);\n\t\txm[x]++;\n\t\txs.insert(x);\n \t}   \n \tll ans = 0;\n \tfor (auto it : ys) {\n \t\tll cury = it;\n \t\tsort(all(ym[cury]));\n \t\tans += ((sz(xs) + 1) * sz(xs)) / 2;\n \t\tll prev = 0;\n \t\tfor (ll i = 0; i < sz(ym[cury]); i++) {\n \t\t\tll curx = ym[cury][i];\n \t\t\tll temp = xs.order_of_key(curx);\n \t\t\tll les = temp - prev;\n \t\t\tans -= ((les + 1) * les) / 2;\n \t\t\tprev = temp + 1;\n \t\t}\n \t\tll les = sz(xs) - prev;\n\t\tans -= ((les + 1) * les) / 2;\n \t\tfor (ll i = 0; i < sz(ym[cury]); i++) {\n \t\t\tll curx = ym[cury][i];\n \t\t\txm[curx]--;\n \t\t\tif (xm[curx] == 0)\n \t\t\t\txs.erase(xs.find(curx));\n \t\t}\n \t}\n \tcout << ans << endl;\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57266311": {
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <cstdlib>\n#include <ctime>\n#include <map>\nusing namespace std;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing qi = queue<int>;\nnamespace SegmentTree {\n\tstruct Node {\n\t\tint l, r, w = 0, lazy = 0;\n\t};\n\tNode* node;\n\tint* originalData;\n\n\tvoid _build(int l, int r, int idx) {\n\t\tnode[idx].l = l;\n\t\tnode[idx].r = r;\n\t\tif (l == r) {\n\t\t\tnode[idx].w = originalData[l];\n\t\t}\n\t\telse {\n\t\t\tint m = (l + r) >> 1;\n\t\t\t_build(l, m, idx << 1);\n\t\t\t_build(m + 1, r, (idx << 1) + 1);\n\t\t\tnode[idx].w = node[idx << 1].w + node[(idx << 1) + 1].w;\n\t\t}\n\t}\n\n\tvoid build(int* aa, int n) {\n\t\tnode = new Node[4 * n + 1];\n\t\toriginalData = aa;\n\t\t_build(1, n, 1);\n\t}\n\n\tvoid pushDown(int idx) {\n\t\tif (node[idx].lazy) {\n\t\t\tif (node[idx].l != node[idx].r) {\n\t\t\t\tnode[idx << 1].lazy += node[idx].lazy;\n\t\t\t\tnode[idx << 1].w += (node[idx << 1].r - node[idx << 1].l + 1) * node[idx].lazy;\n\t\t\t\tnode[(idx << 1) + 1].lazy += node[idx].lazy;\n\t\t\t\tnode[(idx << 1) + 1].w += (node[(idx << 1) + 1].r - node[(idx << 1) + 1].l + 1) * node[idx].lazy;\n\t\t\t}\n\t\t\tnode[idx].lazy = 0;\n\t\t}\n\t}\n\n\tint ql, qr;\n\tint _query(int idx) {\n\t\tpushDown(idx);\n\t\tif (node[idx].l >= ql && node[idx].r <= qr)\n\t\t\treturn node[idx].w;\n\t\tint mid = (node[idx].l + node[idx].r) >> 1;\n\t\tint tmp = 0;\n\t\tif (ql <= mid)\n\t\t\ttmp += _query(idx << 1);\n\t\tif (qr > mid)\n\t\t\ttmp += _query((idx << 1) + 1);\n\t\treturn tmp;\n\t}\n\n\tint query(int l, int r) {\n\t\tql = l, qr = r;\n\t\treturn _query(1);\n\t}\n\n\tint cl, cr, delta;\n\tvoid _change(int idx) {\n\t\tif (node[idx].l >= cl && node[idx].r <= cr) {\n\t\t\tnode[idx].lazy += delta;\n\t\t\tnode[idx].w += (node[idx].r - node[idx].l + 1) * delta;\n\t\t\treturn;\n\t\t}\n\t\tint mid = (node[idx].l + node[idx].r) >> 1;\n\t\tif (cl <= mid)\n\t\t\t_change(idx << 1);\n\t\tif (cr > mid)\n\t\t\t_change((idx << 1) + 1);\n\t\tnode[idx].w = node[idx << 1].w + node[(idx << 1) + 1].w;\n\t}\n\n\tvoid change(int l, int r, int _delta) {\n\t\tcl = l, cr = r;\n\t\tdelta = _delta;\n\t\t_change(1);\n\t}\n}\nusing SegmentTree::build;\nusing SegmentTree::query;\nusing SegmentTree::change;\n\nint n;\nstruct P {\n\tint x, y;\n\tbool operator< (const P& other) { return y < other.y || y == other.y && x < other.x; }\n} p[200001];\nint originx[200001];\nint a[200001];\nint pass[200001];\n\nint main() {\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> p[i].x >> p[i].y;\n\t}\n\tsort(p + 1, p + n + 1);\n\tmap<int, int> m1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\toriginx[i] = p[i].x;\n\t}\n\tsort(originx + 1, originx + n + 1);\n\tint ii = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (m1.count(originx[i]) == 0)\n\t\t\t++ii;\n\t\tm1[originx[i]] = ii;\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\t++a[m1[originx[i]]];\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tpass[i] = a[i] ? 1 : 0;\n\tbuild(pass, n);\n\tull ans = 0;\n\tint cury, lastx;\n\tint idx = 1;\n\twhile (idx <= n) {\n\t\tull tmp = query(1, n);\n\t\tans += tmp * (tmp + 1) / 2;\n\t\tcury = p[idx].y;\n\t\tlastx = 1;\n\t\tint xx;\n\t\twhile (idx <= n && p[idx].y == cury) {\n\t\t\txx = m1[p[idx].x];\n\t\t\tif (xx - 1 >= lastx) {\n\t\t\t\tull tmp = query(lastx, xx - 1);\n\t\t\t\tans -= tmp * (tmp + 1) / 2;\n\t\t\t}\n\t\t\tlastx = xx + 1;\n\t\t\t--a[xx];\n\t\t\tif (a[xx] == 0) {\n\t\t\t\tchange(xx, xx, -1);\n\t\t\t}\n\t\t\t++idx;\n\t\t}\n\t\tif (n >= lastx) {\n\t\t\tull tmp = query(lastx, n);\n\t\t\tans -= tmp * (tmp + 1) / 2;\n\t\t}\n\t}\n\tcout << ans << '\\n';\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57263324": {
    "code": "#!/usr/bin/env pypy\nfrom __future__ import division, print_function\n\nimport operator as op\nimport os\nimport sys\nfrom __builtin__ import xrange as range\nfrom bisect import bisect_left, bisect_right, insort\nfrom cStringIO import StringIO\nfrom functools import reduce\nfrom future_builtins import ascii, filter, hex, map, oct, zip\nfrom io import IOBase\nfrom itertools import chain, repeat, starmap\n\nimport __pypy__\n\n\ndef main():\n    n = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(n)]\n    order = mergesort(list(range(n)), key=lambda x: (-points[x][1], points[x][0]))\n\n    seen = SortedList()\n    cnt, i = 0, 0\n    while i < n:\n        y = points[order[i]][1]\n        row = []\n        while i < n and points[order[i]][1] == y:\n            x = points[order[i]][0]\n            row.append(x)\n            if x not in seen:\n                seen.add(x)\n            i += 1\n\n        prev = -1\n        for xi in row:\n            lo = seen.bisect_left(xi) - seen.bisect_right(prev)\n            hi = len(seen) - seen.bisect_right(xi)\n            cnt += (lo + 1) * (hi + 1)\n            prev = xi\n\n    print(cnt)\n\n\ndef mergesort(A, key=lambda x: x, reverse=False):\n    B, C = A[:], [key(a) for a in A]\n\n    n = len(A)\n    for i in range(0, n - 1, 2):\n        if C[A[i]] > C[A[i ^ 1]]:\n            A[i], A[i ^ 1] = A[i ^ 1], A[i]\n\n    width = 2\n    while width < n:\n        for i in range(0, n, 2 * width):\n            R1, R2 = min(i + width, n), min(i + 2 * width, n)\n            j, k = R1, i\n            while i < R1 and j < R2:\n                if C[A[i]] > C[A[j]]:\n                    B[k] = A[j]\n                    j += 1\n                else:\n                    B[k] = A[i]\n                    i += 1\n                k += 1\n            while i < R1:\n                B[k] = A[i]\n                k += 1\n                i += 1\n            while k < R2:\n                B[k] = A[k]\n                k += 1\n        A, B = B, A\n        width *= 2\n\n    if reverse:\n        A.reverse()\n    return A\n\n\nclass SortedList():\n    \"\"\"Sorted list is a sorted mutable sequence.\"\"\"\n\n    def __init__(self, iterable=None, load=500):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        self._len = 0\n        self._load = load\n        self._lists = []\n        self._maxes = []\n        self._index = []\n        self._offset = 0\n        if iterable is not None:\n            self.update(iterable)\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        if _maxes:\n            pos = bisect_right(_maxes, value)\n            if pos == len(_maxes):\n                pos -= 1\n                _lists[pos].append(value)\n                _maxes[pos] = value\n            else:\n                insort(_lists[pos], value)\n            self._expand(pos)\n        else:\n            _lists.append([value])\n            _maxes.append(value)\n        self._len += 1\n\n    def _expand(self, pos):\n        \"\"\"Split sublists with length greater than double the load-factor.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _index = self._index\n\n        if len(_lists[pos]) > (_load << 1):\n            _maxes = self._maxes\n            _lists_pos = _lists[pos]\n            half = _lists_pos[_load:]\n            del _lists_pos[_load:]\n            _maxes[pos] = _lists_pos[-1]\n            _lists.insert(pos + 1, half)\n            _maxes.insert(pos + 1, half[-1])\n            del _index[:]\n        else:\n            if _index:\n                child = self._offset + pos\n                while child:\n                    _index[child] += 1\n                    child = (child - 1) >> 1\n                _index[0] += 1\n\n    def update(self, iterable):\n        \"\"\"Update sorted list by adding all values from `iterable`.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        values = sorted(iterable)\n\n        if _maxes:\n            if len(values) * 4 >= self._len:\n                values.extend(chain.from_iterable(_lists))\n                values.sort()\n                self.clear()\n            else:\n                _add = self.add\n                for val in values:\n                    _add(val)\n                return\n\n        _load = self._load\n        _lists.extend(values[pos:(pos + _load)] for pos in range(0, len(values), _load))\n        _maxes.extend(sublist[-1] for sublist in _lists)\n        self._len = len(values)\n        del self._index[:]\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _maxes = self._maxes\n        pos = bisect_left(_maxes, value)\n        if pos == len(_maxes):\n            return False\n\n        idx = bisect_left(self._lists[pos], value)\n        return self._lists[pos][idx] == value\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _maxes = self._maxes\n        pos = bisect_left(_maxes, value)\n        if pos == len(_maxes):\n            return\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n        if _lists[pos][idx] == value:\n            self._delete(pos, idx)\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        _index = self._index\n\n        _lists_pos = _lists[pos]\n        del _lists_pos[idx]\n        self._len -= 1\n\n        len_lists_pos = len(_lists_pos)\n        if len_lists_pos > (self._load >> 1):\n            _maxes[pos] = _lists_pos[-1]\n\n            if _index:\n                child = self._offset + pos\n                while child > 0:\n                    _index[child] -= 1\n                    child = (child - 1) >> 1\n                _index[0] -= 1\n        elif len(_lists) > 1:\n            if not pos:\n                pos += 1\n            prev = pos - 1\n            _lists[prev].extend(_lists[pos])\n            _maxes[prev] = _lists[prev][-1]\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n            self._expand(prev)\n        elif len_lists_pos:\n            _maxes[pos] = _lists_pos[-1]\n        else:\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n\n    def _loc(self, pos, idx):\n        \"\"\"Convert an index pair (lists index, sublist index) into a single\n        index number that corresponds to the position of the value in the\n        sorted list.\"\"\"\n        if not pos:\n            return idx\n\n        _index = self._index\n        if not _index:\n            self._build_index()\n        total = 0\n        pos += self._offset\n        while pos:\n            if not pos & 1:\n                total += _index[pos - 1]\n            pos = (pos - 1) >> 1\n        return total + idx\n\n    def _pos(self, idx):\n        \"\"\"Convert an index into an index pair (lists index, sublist index)\n        that can be used to access the corresponding lists position.\"\"\"\n        if idx < 0:\n            last_len = len(self._lists[-1])\n            if (-idx) <= last_len:\n                return len(self._lists) - 1, last_len + idx\n            idx += self._len\n            if idx < 0:\n                raise IndexError('list index out of range')\n        elif idx >= self._len:\n            raise IndexError('list index out of range')\n\n        if idx < len(self._lists[0]):\n            return 0, idx\n\n        _index = self._index\n        if not _index:\n            self._build_index()\n\n        pos = 0\n        child = 1\n        len_index = len(_index)\n        while child < len_index:\n            index_child = _index[child]\n            if idx < index_child:\n                pos = child\n            else:\n                idx -= index_child\n                pos = child + 1\n            child = (pos << 1) + 1\n        return (pos - self._offset, idx)\n\n    def _build_index(self):\n        \"\"\"Build a positional index for indexing the sorted list.\"\"\"\n        row0 = list(map(len, self._lists))\n        if len(row0) == 1:\n            self._index[:] = row0\n            self._offset = 0\n            return\n\n        head = iter(row0)\n        tail = iter(head)\n        row1 = list(starmap(op.add, zip(head, tail)))\n        if len(row0) & 1:\n            row1.append(row0[-1])\n        if len(row1) == 1:\n            self._index[:] = row1 + row0\n            self._offset = 1\n            return\n\n        size = 1 << (len(row1) - 1).bit_length()\n        row1.extend(repeat(0, size - len(row1)))\n        tree = [row0, row1]\n        while len(tree[-1]) > 1:\n            head = iter(tree[-1])\n            tail = iter(head)\n            row = list(starmap(op.add, zip(head, tail)))\n            tree.append(row)\n        reduce(list.__iadd__, reversed(tree), self._index)\n        self._offset = size * 2 - 1\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._pos(index)\n        self._delete(pos, idx)\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        _lists = self._lists\n\n        if self._len:\n            if index == 0:\n                return _lists[0][0]\n            elif index == -1:\n                return _lists[-1][-1]\n        else:\n            raise IndexError('list index out of range')\n\n        if 0 <= index < len(_lists[0]):\n            return _lists[0][index]\n\n        len_last = len(_lists[-1])\n        if -len_last < index < 0:\n            return _lists[-1][len_last + index]\n\n        pos, idx = self._pos(index)\n        return _lists[pos][idx]\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return chain.from_iterable(self._lists)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return chain.from_iterable(map(reversed, reversed(self._lists)))\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def bisect_left(self, value):\n        \"\"\"Return an index to insert `value` in the sorted list.\"\"\"\n        pos = bisect_left(self._maxes, value)\n        return self._len if pos == len(self._maxes) else self._loc(pos, bisect_left(self._lists[pos], value))\n\n    def bisect_right(self, value):\n        \"\"\"Return an index to insert `value` in the sorted list.\"\"\"\n        pos = bisect_right(self._maxes, value)\n        return self._len if pos == len(self._maxes) else self._loc(pos, bisect_right(self._lists[pos], value))\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        _maxes = self._maxes\n        if not _maxes:\n            return 0\n\n        pos_left = bisect_left(_maxes, value)\n        if pos_left == len(_maxes):\n            return 0\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n        pos_right = bisect_right(_maxes, value)\n        if pos_right == len(_maxes):\n            return self._len - self._loc(pos_left, idx_left)\n\n        idx_right = bisect_right(_lists[pos_right], value)\n        if pos_left == pos_right:\n            return idx_right - idx_left\n\n        right = self._loc(pos_right, idx_right)\n        left = self._loc(pos_left, idx_left)\n        return right - left\n\n    def __copy__(self):\n        \"\"\"Return a shallow copy of the sorted list.\"\"\"\n        return self.__class__(self)\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        if not self._len:\n            raise IndexError('pop index out of range')\n\n        _lists = self._lists\n        if 0 <= index < len(_lists[0]):\n            val = _lists[0][index]\n            self._delete(0, index)\n            return val\n\n        len_last = len(_lists[-1])\n        if -len_last < index < 0:\n            pos = len(_lists) - 1\n            loc = len_last + index\n            val = _lists[pos][loc]\n            self._delete(pos, loc)\n            return val\n\n        pos, idx = self._pos(index)\n        val = _lists[pos][idx]\n        self._delete(pos, idx)\n        return val\n\n    def index(self, value, start=0, stop=None):\n        \"\"\"Return first index of value in sorted list.\"\"\"\n        _len = self._len\n        if start < 0:\n            start += _len\n        if start < 0:\n            start = 0\n        if stop is None:\n            stop = _len\n        if stop < 0:\n            stop += _len\n        if stop > _len:\n            stop = _len\n\n        if stop <= start:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _maxes = self._maxes\n        pos_left = bisect_left(_maxes, value)\n        if pos_left == len(_maxes):\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n        if _lists[pos_left][idx_left] != value:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        stop -= 1\n        left = self._loc(pos_left, idx_left)\n        if start <= left:\n            if left <= stop:\n                return left\n        else:\n            if start <= self.bisect_right(value) - 1:\n                return start\n        raise ValueError('{0!r} is not in list'.format(value))\n\n    def __add__(self, other):\n        \"\"\"Return new sorted list containing all values in both sequences.\"\"\"\n        values = reduce(list.__iadd__, self._lists, [])\n        values.extend(other)\n        return self.__class__(values)\n\n    __radd__ = __add__\n\n    def __iadd__(self, other):\n        \"\"\"Update sorted list with values from `other`.\"\"\"\n        self.update(other)\n        return self\n\n    def __mul__(self, num):\n        \"\"\"Return new sorted list with `num` shallow copies of values.\"\"\"\n        values = reduce(list.__iadd__, self._lists, []) * num\n        return self.__class__(values)\n\n    __rmul__ = __mul__\n\n    def __imul__(self, num):\n        \"\"\"Update the sorted list with `num` shallow copies of values.\"\"\"\n        values = reduce(list.__iadd__, self._lists, []) * num\n        self.clear()\n        self.update(values)\n        return self\n\n    def __make_cmp(seq_op):\n        \"Make comparator method.\"\n\n        def comparer(self, other):\n            \"Compare method for sorted list and sequence.\"\n            self_len = self._len\n            len_other = len(other)\n            if self_len != len_other:\n                if seq_op is op.eq:\n                    return False\n                if seq_op is op.ne:\n                    return True\n\n            for alpha, beta in zip(self, other):\n                if alpha != beta:\n                    return seq_op(alpha, beta)\n            return seq_op(self_len, len_other)\n\n        comparer.__name__ = '__{0}__'.format(seq_op.__name__)\n        return comparer\n\n    __eq__ = __make_cmp(op.eq)\n    __ne__ = __make_cmp(op.ne)\n    __lt__ = __make_cmp(op.lt)\n    __gt__ = __make_cmp(op.gt)\n    __le__ = __make_cmp(op.le)\n    __ge__ = __make_cmp(op.ge)\n    __make_cmp = staticmethod(__make_cmp)\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(reduce(list.__iadd__, self._lists, []))\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastI(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = StringIO()\n        self.newlines = 0\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(\"\\n\") + (not b)\n            ptr = self._buffer.tell()\n            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)\n        self.newlines -= 1\n        return self._buffer.readline()\n\n\nclass FastO(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = __pypy__.builders.StringBuilder()\n        self.write = lambda s: self._buffer.append(s)\n\n    def flush(self):\n        os.write(self._fd, self._buffer.build())\n        self._buffer = __pypy__.builders.StringBuilder()\n\n\ndef print(*args, **kwargs):\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nsys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
    "ext": ""
  },
  "57263005": {
    "code": "#!/usr/bin/env pypy\nfrom __future__ import division, print_function\n\nimport operator as op\nimport os\nimport sys\nfrom __builtin__ import xrange as range\nfrom bisect import bisect_left, bisect_right, insort\nfrom cStringIO import StringIO\nfrom functools import reduce\nfrom future_builtins import ascii, filter, hex, map, oct, zip\nfrom io import IOBase\nfrom itertools import chain, repeat, starmap\n\nimport __pypy__\n\n\ndef main():\n    n = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(n)]\n    order = sorted(range(n), key=lambda x: (-points[x][1], points[x][0]))\n\n    seen = SortedList()\n    cnt, i = 0, 0\n    while i < n:\n        y = points[order[i]][1]\n        row = []\n        while i < n and points[order[i]][1] == y:\n            x = points[order[i]][0]\n            row.append(x)\n            if x not in seen:\n                seen.add(x)\n            i += 1\n\n        prev = -1\n        for xi in row:\n            lo = seen.bisect_left(xi) - seen.bisect_right(prev)\n            hi = len(seen) - seen.bisect_right(xi)\n            cnt += (lo + 1) * (hi + 1)\n            prev = xi\n\n    print(cnt)\n\n\nclass SortedList():\n    \"\"\"Sorted list is a sorted mutable sequence.\"\"\"\n\n    def __init__(self, iterable=None, load=500):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        self._len = 0\n        self._load = load\n        self._lists = []\n        self._maxes = []\n        self._index = []\n        self._offset = 0\n        if iterable is not None:\n            self.update(iterable)\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        if _maxes:\n            pos = bisect_right(_maxes, value)\n            if pos == len(_maxes):\n                pos -= 1\n                _lists[pos].append(value)\n                _maxes[pos] = value\n            else:\n                insort(_lists[pos], value)\n            self._expand(pos)\n        else:\n            _lists.append([value])\n            _maxes.append(value)\n        self._len += 1\n\n    def _expand(self, pos):\n        \"\"\"Split sublists with length greater than double the load-factor.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _index = self._index\n\n        if len(_lists[pos]) > (_load << 1):\n            _maxes = self._maxes\n            _lists_pos = _lists[pos]\n            half = _lists_pos[_load:]\n            del _lists_pos[_load:]\n            _maxes[pos] = _lists_pos[-1]\n            _lists.insert(pos + 1, half)\n            _maxes.insert(pos + 1, half[-1])\n            del _index[:]\n        else:\n            if _index:\n                child = self._offset + pos\n                while child:\n                    _index[child] += 1\n                    child = (child - 1) >> 1\n                _index[0] += 1\n\n    def update(self, iterable):\n        \"\"\"Update sorted list by adding all values from `iterable`.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        values = sorted(iterable)\n\n        if _maxes:\n            if len(values) * 4 >= self._len:\n                values.extend(chain.from_iterable(_lists))\n                values.sort()\n                self.clear()\n            else:\n                _add = self.add\n                for val in values:\n                    _add(val)\n                return\n\n        _load = self._load\n        _lists.extend(values[pos:(pos + _load)] for pos in range(0, len(values), _load))\n        _maxes.extend(sublist[-1] for sublist in _lists)\n        self._len = len(values)\n        del self._index[:]\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _maxes = self._maxes\n        pos = bisect_left(_maxes, value)\n        if pos == len(_maxes):\n            return False\n\n        idx = bisect_left(self._lists[pos], value)\n        return self._lists[pos][idx] == value\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _maxes = self._maxes\n        pos = bisect_left(_maxes, value)\n        if pos == len(_maxes):\n            return\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n        if _lists[pos][idx] == value:\n            self._delete(pos, idx)\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        _index = self._index\n\n        _lists_pos = _lists[pos]\n        del _lists_pos[idx]\n        self._len -= 1\n\n        len_lists_pos = len(_lists_pos)\n        if len_lists_pos > (self._load >> 1):\n            _maxes[pos] = _lists_pos[-1]\n\n            if _index:\n                child = self._offset + pos\n                while child > 0:\n                    _index[child] -= 1\n                    child = (child - 1) >> 1\n                _index[0] -= 1\n        elif len(_lists) > 1:\n            if not pos:\n                pos += 1\n            prev = pos - 1\n            _lists[prev].extend(_lists[pos])\n            _maxes[prev] = _lists[prev][-1]\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n            self._expand(prev)\n        elif len_lists_pos:\n            _maxes[pos] = _lists_pos[-1]\n        else:\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n\n    def _loc(self, pos, idx):\n        \"\"\"Convert an index pair (lists index, sublist index) into a single\n        index number that corresponds to the position of the value in the\n        sorted list.\"\"\"\n        if not pos:\n            return idx\n\n        _index = self._index\n        if not _index:\n            self._build_index()\n        total = 0\n        pos += self._offset\n        while pos:\n            if not pos & 1:\n                total += _index[pos - 1]\n            pos = (pos - 1) >> 1\n        return total + idx\n\n    def _pos(self, idx):\n        \"\"\"Convert an index into an index pair (lists index, sublist index)\n        that can be used to access the corresponding lists position.\"\"\"\n        if idx < 0:\n            last_len = len(self._lists[-1])\n            if (-idx) <= last_len:\n                return len(self._lists) - 1, last_len + idx\n            idx += self._len\n            if idx < 0:\n                raise IndexError('list index out of range')\n        elif idx >= self._len:\n            raise IndexError('list index out of range')\n\n        if idx < len(self._lists[0]):\n            return 0, idx\n\n        _index = self._index\n        if not _index:\n            self._build_index()\n\n        pos = 0\n        child = 1\n        len_index = len(_index)\n        while child < len_index:\n            index_child = _index[child]\n            if idx < index_child:\n                pos = child\n            else:\n                idx -= index_child\n                pos = child + 1\n            child = (pos << 1) + 1\n        return (pos - self._offset, idx)\n\n    def _build_index(self):\n        \"\"\"Build a positional index for indexing the sorted list.\"\"\"\n        row0 = list(map(len, self._lists))\n        if len(row0) == 1:\n            self._index[:] = row0\n            self._offset = 0\n            return\n\n        head = iter(row0)\n        tail = iter(head)\n        row1 = list(starmap(op.add, zip(head, tail)))\n        if len(row0) & 1:\n            row1.append(row0[-1])\n        if len(row1) == 1:\n            self._index[:] = row1 + row0\n            self._offset = 1\n            return\n\n        size = 1 << (len(row1) - 1).bit_length()\n        row1.extend(repeat(0, size - len(row1)))\n        tree = [row0, row1]\n        while len(tree[-1]) > 1:\n            head = iter(tree[-1])\n            tail = iter(head)\n            row = list(starmap(op.add, zip(head, tail)))\n            tree.append(row)\n        reduce(list.__iadd__, reversed(tree), self._index)\n        self._offset = size * 2 - 1\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._pos(index)\n        self._delete(pos, idx)\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        _lists = self._lists\n\n        if self._len:\n            if index == 0:\n                return _lists[0][0]\n            elif index == -1:\n                return _lists[-1][-1]\n        else:\n            raise IndexError('list index out of range')\n\n        if 0 <= index < len(_lists[0]):\n            return _lists[0][index]\n\n        len_last = len(_lists[-1])\n        if -len_last < index < 0:\n            return _lists[-1][len_last + index]\n\n        pos, idx = self._pos(index)\n        return _lists[pos][idx]\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return chain.from_iterable(self._lists)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return chain.from_iterable(map(reversed, reversed(self._lists)))\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def bisect_left(self, value):\n        \"\"\"Return an index to insert `value` in the sorted list.\"\"\"\n        pos = bisect_left(self._maxes, value)\n        return self._len if pos == len(self._maxes) else self._loc(pos, bisect_left(self._lists[pos], value))\n\n    def bisect_right(self, value):\n        \"\"\"Return an index to insert `value` in the sorted list.\"\"\"\n        pos = bisect_right(self._maxes, value)\n        return self._len if pos == len(self._maxes) else self._loc(pos, bisect_right(self._lists[pos], value))\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        _maxes = self._maxes\n        if not _maxes:\n            return 0\n\n        pos_left = bisect_left(_maxes, value)\n        if pos_left == len(_maxes):\n            return 0\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n        pos_right = bisect_right(_maxes, value)\n        if pos_right == len(_maxes):\n            return self._len - self._loc(pos_left, idx_left)\n\n        idx_right = bisect_right(_lists[pos_right], value)\n        if pos_left == pos_right:\n            return idx_right - idx_left\n\n        right = self._loc(pos_right, idx_right)\n        left = self._loc(pos_left, idx_left)\n        return right - left\n\n    def __copy__(self):\n        \"\"\"Return a shallow copy of the sorted list.\"\"\"\n        return self.__class__(self)\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        if not self._len:\n            raise IndexError('pop index out of range')\n\n        _lists = self._lists\n        if 0 <= index < len(_lists[0]):\n            val = _lists[0][index]\n            self._delete(0, index)\n            return val\n\n        len_last = len(_lists[-1])\n        if -len_last < index < 0:\n            pos = len(_lists) - 1\n            loc = len_last + index\n            val = _lists[pos][loc]\n            self._delete(pos, loc)\n            return val\n\n        pos, idx = self._pos(index)\n        val = _lists[pos][idx]\n        self._delete(pos, idx)\n        return val\n\n    def index(self, value, start=0, stop=None):\n        \"\"\"Return first index of value in sorted list.\"\"\"\n        _len = self._len\n        if start < 0:\n            start += _len\n        if start < 0:\n            start = 0\n        if stop is None:\n            stop = _len\n        if stop < 0:\n            stop += _len\n        if stop > _len:\n            stop = _len\n\n        if stop <= start:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _maxes = self._maxes\n        pos_left = bisect_left(_maxes, value)\n        if pos_left == len(_maxes):\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n        if _lists[pos_left][idx_left] != value:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        stop -= 1\n        left = self._loc(pos_left, idx_left)\n        if start <= left:\n            if left <= stop:\n                return left\n        else:\n            if start <= self.bisect_right(value) - 1:\n                return start\n        raise ValueError('{0!r} is not in list'.format(value))\n\n    def __add__(self, other):\n        \"\"\"Return new sorted list containing all values in both sequences.\"\"\"\n        values = reduce(list.__iadd__, self._lists, [])\n        values.extend(other)\n        return self.__class__(values)\n\n    __radd__ = __add__\n\n    def __iadd__(self, other):\n        \"\"\"Update sorted list with values from `other`.\"\"\"\n        self.update(other)\n        return self\n\n    def __mul__(self, num):\n        \"\"\"Return new sorted list with `num` shallow copies of values.\"\"\"\n        values = reduce(list.__iadd__, self._lists, []) * num\n        return self.__class__(values)\n\n    __rmul__ = __mul__\n\n    def __imul__(self, num):\n        \"\"\"Update the sorted list with `num` shallow copies of values.\"\"\"\n        values = reduce(list.__iadd__, self._lists, []) * num\n        self.clear()\n        self.update(values)\n        return self\n\n    def __make_cmp(seq_op):\n        \"Make comparator method.\"\n\n        def comparer(self, other):\n            \"Compare method for sorted list and sequence.\"\n            self_len = self._len\n            len_other = len(other)\n            if self_len != len_other:\n                if seq_op is op.eq:\n                    return False\n                if seq_op is op.ne:\n                    return True\n\n            for alpha, beta in zip(self, other):\n                if alpha != beta:\n                    return seq_op(alpha, beta)\n            return seq_op(self_len, len_other)\n\n        comparer.__name__ = '__{0}__'.format(seq_op.__name__)\n        return comparer\n\n    __eq__ = __make_cmp(op.eq)\n    __ne__ = __make_cmp(op.ne)\n    __lt__ = __make_cmp(op.lt)\n    __gt__ = __make_cmp(op.gt)\n    __le__ = __make_cmp(op.le)\n    __ge__ = __make_cmp(op.ge)\n    __make_cmp = staticmethod(__make_cmp)\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(reduce(list.__iadd__, self._lists, []))\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastI(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = StringIO()\n        self.newlines = 0\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(\"\\n\") + (not b)\n            ptr = self._buffer.tell()\n            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)\n        self.newlines -= 1\n        return self._buffer.readline()\n\n\nclass FastO(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = __pypy__.builders.StringBuilder()\n        self.write = lambda s: self._buffer.append(s)\n\n    def flush(self):\n        os.write(self._fd, self._buffer.build())\n        self._buffer = __pypy__.builders.StringBuilder()\n\n\ndef print(*args, **kwargs):\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nsys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
    "ext": ""
  },
  "57233495": {
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int maxn = int(2e5) + 5;\nint C[maxn], n;\nint lowbit(int x) { return x & -x; }\nint sum(int x) { int ret = 0; while (x > 0) { ret += C[x]; x -= lowbit(x); } return ret; }\nvoid add(int x, int d = 1) { while (x <= n) { C[x] += d; x += lowbit(x); } }\nint gs(int l, int r) { return sum(r) - sum(l - 1); }\nint gc(int i) { return gs(i, i); }\n\nlong long f(long long a) { return (1 + a) * a / 2; } \n\nstruct P { int x, y; } a[maxn];\n\nbool cmp(const P &a, const P &b) { return a.x < b.x || a.x == b.x && a.y < b.y; }\nbool dmp(const P &a, const P &b) { return a.y > b.y || a.y == b.y && a.x < b.x; }\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d%d\", &a[i].x, &a[i].y);\n\tsort(a, a + n, cmp);\n\tint mark = 1;\n\tfor (int i = 0; i < n - 1; i++)\n\t\ta[i].x = a[i].x == a[i + 1].x ? mark : mark++;\n\ta[n - 1].x = mark;\n\tsort(a, a + n, dmp);\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; )\n\t{\n\t\tint l = 1;\n\t\tdo\n\t\t{\n\t\t\tans -= f(gs(l, a[i].x - 1));\n\t\t\tif (gc(a[i].x) == 0)\n\t\t\t\tadd(a[i].x);\n\t\t\tl = a[i].x + 1;\n\t\t} while (++i < n && a[i].y == a[i - 1].y);\n\t\tif (l <= n)\n\t\t\tans -= f(gs(l, n));\n\t\tans += f(sum(n));\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57205508": {
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nconst int MAXN = 1e5  * 2 + 5;\n\nstruct point\n{\n    int x, y;\n\n    bool operator<(point other) const\n    {\n        return y < other.y || (y == other.y && x < other.x);\n    }\n};\n\nint n, k, K;\npoint a[MAXN];\nvector <point> v[MAXN];\nvector <int> xses;\nmap <int, int> mp;\n\nvoid read_input()\n{\n    scanf(\"%d\", &n);\n\n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%d %d\", &a[i].x, &a[i].y);\n        xses.push_back(a[i].x);\n        xses.push_back(a[i].x - 1);\n        xses.push_back(a[i].x + 1);\n    }\n    sort(a, a + n);\n\n    v[0].push_back(a[0]);\n    for(int i = 1; i < n; i++)\n    {\n        if(a[i].y != a[i - 1].y)\n        {\n            k++;\n        }\n        v[k].push_back(a[i]);\n    }\n    sort(xses.begin(), xses.end());\n    vector <int>::iterator it = unique(xses.begin(), xses.end());\n    xses.resize(distance(xses.begin(), it));\n\n    for(int i = 0; i < xses.size(); i++)\n    {\n        mp[xses[i]] = i + 1;\n    }\n    K = xses.size() - 1;\n}\n\nset <int> s;\nint tree[MAXN * 3 + 5];\n\nvoid update(int ind)\n{\n    for(int i = ind; i <= K; i += (i & -i))\n    {\n        tree[i]++;\n    }\n}\n\nint query(int ind)\n{\n    int ans = 0;\n    for(int i = ind; i > 0; i -= (i & -i))\n    {\n        ans += tree[i];\n    }\n    return ans;\n}\n\nint query(int l, int r)\n{\n    if(l > r) return 0;\n    return query(r) - query(l - 1);\n}\n\nlong long solve(int r)\n{\n    long long ans = 0;\n    for(int z = r; z >= 0; z--)\n    {\n        int mn = 0;\n        for(int i = 0; i < v[z].size(); i++)\n        {\n            if(!s.count(v[z][i].x))\n            {\n                s.insert(v[z][i].x);\n                update(mp[v[z][i].x]);\n            }\n        }\n        for(int i = 0; i < v[z].size(); i++)\n        {\n            int fromL = query(mp[mn], mp[v[z][i].x - 1]) + 1;\n            int fromR = query(mp[v[z][i].x + 1], K) + 1;\n            //printf(\"%d %d\\n\", fromL, fromR, mp[mn]);\n            ans += 1LL * fromL * fromR;\n            mn = v[z][i].x + 1;\n        }\n    }\n\n\n    return ans;\n}\n\nint main()\n{\n    read_input();\n    printf(\"%lld\\n\", solve(k));\n\n    return 0;\n}\n\n/*\n5\n3 6\n5 10\n4 3\n2 1\n1 3\n\n19\n*/\n\n/*\n4\n1 1\n1 5\n5 1\n5 5\n*/\n",
    "ext": "cpp"
  },
  "57204321": {
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nconst int MAXN = 1e5  * 2 + 5;\n\nstruct point\n{\n    int x, y;\n\n    bool operator<(point other) const\n    {\n        return y < other.y || (y == other.y && x < other.x);\n    }\n};\n\nint n, k, K;\npoint a[MAXN];\nvector <point> v[MAXN];\nvector <int> xses;\nmap <int, int> mp;\n\nvoid read_input()\n{\n    scanf(\"%d\", &n);\n\n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%d %d\", &a[i].x, &a[i].y);\n        xses.push_back(a[i].x);\n        xses.push_back(a[i].x - 1);\n        xses.push_back(a[i].x + 1);\n    }\n    sort(a, a + n);\n\n    v[0].push_back(a[0]);\n    for(int i = 1; i < n; i++)\n    {\n        if(a[i].y != a[i - 1].y)\n        {\n            k++;\n        }\n        v[k].push_back(a[i]);\n    }\n    sort(xses.begin(), xses.end());\n    vector <int>::iterator it = unique(xses.begin(), xses.end());\n    xses.resize(distance(xses.begin(), it));\n\n    for(int i = 0; i < xses.size(); i++)\n    {\n        mp[xses[i]] = i + 1;\n    }\n    K = xses.size() - 1;\n}\n\nset <int> s;\nint tree[MAXN * 3 + 5];\n\nvoid update(int ind)\n{\n    for(int i = ind; i <= K; i += (i & -i))\n    {\n        tree[i]++;\n    }\n}\n\nint query(int ind)\n{\n    int ans = 0;\n    for(int i = ind; i > 0; i -= (i & -i))\n    {\n        ans += tree[i];\n    }\n    return ans;\n}\n\nint query(int l, int r)\n{\n    if(l > r) return 0;\n    return query(r) - query(l - 1);\n}\n\nlong long solve(int r)\n{\n    if(r == -1) return 0;\n\n    long long ans = 0;\n    int mn = 0;\n    for(int i = 0; i < v[r].size(); i++)\n    {\n        if(!s.count(v[r][i].x))\n        {\n            s.insert(v[r][i].x);\n            update(mp[v[r][i].x]);\n        }\n    }\n    for(int i = 0; i < v[r].size(); i++)\n    {\n        int fromL = query(mp[mn], mp[v[r][i].x - 1]) + 1;\n        int fromR = query(mp[v[r][i].x + 1], K) + 1;\n        //printf(\"%d %d\\n\", fromL, fromR, mp[mn]);\n        ans += 1LL * fromL * fromR;\n        mn = v[r][i].x + 1;\n    }\n    ans += solve(r - 1);\n    return ans;\n}\n\nint main()\n{\n    read_input();\n    printf(\"%lld\\n\", solve(k));\n\n    return 0;\n}\n\n/*\n5\n3 6\n5 10\n4 3\n2 1\n1 3\n\n19\n*/\n\n/*\n4\n1 1\n1 5\n5 1\n5 5\n*/\n",
    "ext": "cpp"
  },
  "57201423": {
    "code": "#include <iostream>\n#include <unordered_map>\n#include <utility>\n#include <vector>\n#include <map>\n#include <algorithm>\n//#include<bits/stdc++.h>\nusing namespace std;\n//1=true 0=false\nstruct BIT{\n    int *tree;\n    int len;\n    BIT(const vector<int> &input, int len){\n        this->len=len+1;\n        tree=new int[this->len]{0};\n        //memset(tree,0,this->len*4);\n        for (int i=0;i<len;i++){\n            tree[i+1]+=input[i];\n            //cout<<tree[i+1]<<\"\\n\";\n            int next=getNext(i+1);\n            while(next<this->len){\n                tree[next]+=input[i];\n                next=getNext(next);\n            }\n        }\n    }\n    //get sum of first n elements\n    int getSum(int n){\n        int sum=tree[n];\n        int i=getParent(n);\n        while(i!=0){\n            sum+=tree[i];\n            i=getParent(i);\n        }\n        return sum;\n    }\n    //change value of index x by \"change\" (0...len-1) <- indices\n    void changeIndex(int n, int change){\n        n++;\n        tree[n]+=change;\n        int next=getNext(n);\n        while(next<len){\n            tree[next]+=change;\n            next=getNext(next);\n        }\n    }\n    int getNext(int node){\n        return node+(node&(-node));\n    }\n    int getParent(int node){\n        return node-(node&(-node));\n    }\n};\nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    int n;\n    cin>>n;\n    vector<pair<int, int>> coords(n); //y then x\n    map<int, int> m;//x coord, count\n    unordered_map<int, int> pos; //sorted x coords\n    for (int i=0;i<n;i++){\n        int x;\n        int y;\n        cin>>x>>y;\n        if (m.count(x)){\n            m[x]++;\n        }\n        else{\n            m.insert({x,1});\n        }\n        coords[i]=make_pair(y,x);\n    }\n    int counter=0;\n    for (const auto &k : m){\n        pos.insert({k.first,counter});\n        counter++;\n    }\n    vector<int> v(counter,1);\n    BIT bit(v,counter);\n    sort(coords.begin(),coords.end());\n    int total=counter;\n  //  cout<<total<<\"\\n\";\n    long long ans=0;\n    int last=0;\n    int lastY=0;\n    for (int i=0;i<n;i++) {\n        int curr = coords[i].second; //current base point\n        m[curr]--;\n        if (!m[curr]) {\n       //     cout<<\"hi\"<<\"\\n\";\n            bit.changeIndex(pos[curr], -1);\n            total--;\n        }\n        long long left;\n        long long right;\n        if (coords[i].first ==lastY){\n            left=1+bit.getSum(pos[curr])-bit.getSum(pos[coords[i-1].second]+1);\n        //   cout<<bit.getSum(pos[curr])<<\" \"<<bit.getSum(pos[coords[i-1].second]+1)<<\"\\n\";\n        }\n        else {\n            left = 1+ bit.getSum(pos[curr]);\n        }\n        right = 1+total - bit.getSum(pos[curr] + 1);\n   //     cout<<1+total<<\" \"<<bit.getSum(pos[curr]+1)<<\" \"<<pos[curr]<<\"\\n\";\n    //    cout<<left*right<<\" \"<<curr<<\" \"<<coords[i].first<<\" \"<<total<<\"\\n\";\n        ans += left * right;\n        lastY=coords[i].first;\n    }\n    cout<<ans<<\"\\n\";\n}",
    "ext": "cpp"
  },
  "57198465": {
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef tree<ll, null_type, less<ll>, rb_tree_tag,\n             tree_order_statistics_node_update>\n    boxx;\n\nll n;\nmap<ll,vector<ll> > mp;\nint main()\n{\n        ios_base::sync_with_stdio(false);\n        cin.tie(NULL); cout.tie(NULL);\n        cin >> n;\n        boxx S;\n        S.clear();\n        ll ans =0;\n        for(ll i=1;i<=n;i++){\n                ll u,v;\n                cin >>u>>v;\n                mp[-v].pb(u);\n        }\n        for(auto &i : mp){\n                for(auto &j: i.second) S.insert(j);\n                ll last_el = -1e14;\n                sort(i.second.begin(), i.second.end());\n                //cout << i.first << \" >>>>>>>>>>>>\\n\\n\";\n                for(auto &j : i.second) {\n\n                        ll sz = S.size();\n                        ll id = S.order_of_key(j);\n                        ll id2 = S.order_of_key(last_el);\n                        if(last_el == -1e14) id2--;\n                        //cout << last_el << \" \" << id2 << \" \" << id  << endl;\n                        ans += (id - id2) * (sz - id);\n                        last_el = j;\n                }\n        }\n        cout << ans << endl;\n        return 0;\n}\n",
    "ext": "cpp"
  },
  "57195999": {
    "code": "#include <bits/stdc++.h>\n     \n        using namespace std;\n        typedef long long ll;\n        typedef vector<ll> vl ;\n     \n        #define mp make_pair\n        #define pb push_back\n        #define f first\n        #define s second\n        #define all(v) (v).begin(),(v).end()\n     \n     \n        const int MOD = 1000000007;\n        const int N = 1000005;\n        const double PI =4*atan(1);\n        const double eps = 1e-7;\n \n        ll n,m,k;\n        pair<ll,ll> p[N];\n        set<ll> ss;\n        map<ll,ll> maa;\n        ll tree[N];\n        map<ll,vl> point;\n        set<ll> sss;\n        set<ll> sl;\n        bool vis[N];\n        void update(ll x){\n            for(;x<=1000000;x+=(x)&(-x)){\n                tree[x]++;\n            }\n        }\n\n        ll get(ll x){\n            ll to = 0;\n            for(;x>0;x-=(x)&(-x)){\n                to+=tree[x];\n            }\n            return to;\n        }\n\n \n        int main(){\n            ios::sync_with_stdio(0);\n            //freopen(\"easy.txt\",\"r\",stdin);\n            cin >> n;\n            for(int i=0;i<n;i++){\n                ll x,y;\n                cin >> x >> y;\n                ss.insert(x);\n                ss.insert(y);\n                p[i]=mp(x,y);\n            }\n            ll cnt=1;\n            for(auto t:ss){\n                maa[t]=cnt++;\n            }\n            for(int i=0;i<n;i++){\n                ll x=p[i].f;\n                ll y=p[i].s;\n                x=maa[x];\n                y=maa[y];\n                p[i]=mp(x,y);\n                point[-y].pb(x);\n            }\n            for(auto t:point){\n                sort(all(point[t.f]));\n            }\n            ll ans=0;\n            ll res=0;\n            for(auto t:point){\n                ll x=0;\n                ll bef=0;\n                for(auto u:t.s){\n                    ll y=get(u-1)-get(bef);\n                    //cout << u << \" \" << bef << \" \" << endl;\n                    bef=u;\n                    x+=(y*(y+1)) /2;\n                }\n                ll y=get(1000000)-get(bef);\n                x+=(y*(y+1)) /2;\n                for(auto u:t.s){\n                    if(vis[u])continue;\n                    vis[u]=1;\n                    update(u);\n                    res++;\n                }\n                //cout << res << endl;\n                ans+=(res*(res+1) )/2 -x; \n            }\n            for(auto t:sl){\n                ll x=get(1000000)-get(t-1);\n                ans+=(x*(x+1))/2;\n            }\n            cout << ans;\n\n\n\n\n            return 0;\n        }",
    "ext": "cpp"
  },
  "57194352": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\n\nconst int maxn = 200010;\nconst int maxd = 2*maxn;\n\nint n;\nint X[maxn], Y[maxn];\nvector<int> uniques;\nunordered_map<int, int> compressed;\n\nll ans;\nvector<int> layers[maxd];\nint cnt[maxd]; // how many points at this x\nint ft[maxd]; // x-th is 1 if cnt[x] > 0\n\nvoid update(int p, int v) {\n\twhile (p < maxd) {\n\t\tft[p] += v;\n\t\tp += p & -p;\n\t}\n}\n\nint query(int p) {\n\tint res = 0;\n\twhile (p > 0) {\n\t\tres += ft[p];\n\t\tp -= p & -p;\n\t}\n\treturn res;\n}\n\nint query(int l, int r) {\n\tif (l > r) return 0;\n\treturn query(r) - query(l-1);\n}\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; ++i) {\n    \tcin >> X[i] >> Y[i];\n    \tuniques.push_back(X[i]);\n    \tuniques.push_back(Y[i]);\n    }\n    sort(uniques.begin(), uniques.end());\n    int uidx = 0;\n    for (int i = 0; i < (int)uniques.size(); ++i) {\n    \tif (i == 0 || uniques[i] != uniques[i-1]) {\n    \t\tcompressed[uniques[i]] = ++uidx;\n    \t}\n    }\n    for (int i = 1; i <= n; ++i) {\n    \tX[i] = compressed[X[i]];\n    \tY[i] = compressed[Y[i]];\n    \tlayers[Y[i]].push_back(X[i]);\n    \t// cout << \"i=\" << i << \" x=\" << X[i] << \" y=\" << Y[i] << endl;\n    }\n  \tans = 0;\n  \tmemset(cnt, 0, sizeof(cnt));\n  \tmemset(ft, 0, sizeof(ft));\n  \tfor (int y = maxd-1; y >= 0; --y) {\n  \t\tsort(layers[y].begin(), layers[y].end());\n  \t\t// if (layers[y].size() > 0) cout << \"y=\" << y << endl;\n  \t\tfor (int i = layers[y].size()-1; i >= 0; --i) {\n  \t\t\tint x = layers[y][i];\n  \t\t\t// bigger x, bigger or equal y\n  \t\t\tll numr = query(x+1, maxd-1);\n  \t\t\t// with x between current and the one to the left, bigger y\n  \t\t\tll numl = query(i == 0 ? 1 : layers[y][i-1]+1, x-1); \n  \t\t\t// cout << \"x=\" << x << \" numr=\" << numr << \" numl=\" << numl << \" choices=\" << (numr+1)*(numl+1) << endl;\n  \t\t\tans += (numr+1) * (numl+1);\n  \t\t\tif (cnt[x] == 0) {\n  \t\t\t\t++cnt[x];\n  \t\t\t\tupdate(x, 1);\n  \t\t\t}\n  \t\t}\n  \t}\n  \tcout << ans << endl;\n}\n",
    "ext": "cpp"
  },
  "57194317": {
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\n#define ll long long\nconst int maxn = 2e5+9;\nconst int inf = 1e9+9;\nint C[3*maxn], tot;\nstruct node{\n\tint x, y;\n\toperator < (const node& b)const{\n\t\treturn y==b.y?x<b.x:y>b.y;\n\t}\n};\nmap<int, int>H;\nvector<int>tmp;\nnode a[maxn];\nint ask(int p){\n\tint re=0;\n\twhile(p>=1){\n\t\tre+=C[p];\n\t\tp-=p&(-p);\n\t}\n\treturn re;\n}\nvoid add(int p, int x){\n\twhile(p<=tot){\n\t\tC[p]+=x;\n\t\tp+=p&(-p);\n\t}\n}\nll cnt(int L, int R){\n\tif(L>R)\treturn 0;\n\treturn ask(H[R])-ask(H[L-1]);\n}\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i=1; i<=n; ++i){\n\t\tscanf(\"%d%d\", &a[i].x, &a[i].y);\n\t\ttmp.push_back(a[i].x-1);\n\t\ttmp.push_back(a[i].x);\n\t\ttmp.push_back(a[i].x+1);\n\t}\n\ttmp.push_back(-inf);\n\ttmp.push_back(inf);\n\tsort(tmp.begin(), tmp.end());\n\ttmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());\n\ttot=tmp.size();\n\tfor(int i=0; i<tmp.size(); ++i){\n\t\tH[tmp[i]]=i+1;\n\t}\n//\tmap<int, int>::iterator it;\n//\tfor(it=H.begin(); it!=H.end(); it++){\n//\t\tprintf(\"*%d %d\\n\", it->first, it->second);\n//\t}\n\tsort(a+1, a+1+n);\n\ta[n+1].y=inf;\n\ta[0].y=inf;\n\tll ans=0;\n\tfor(int i=1; i<=n; ++i){\n\t\tif(0==cnt(a[i].x, a[i].x)){\n\t\t\tadd(H[a[i].x], 1);\n\t\t}\n\t\tif(a[i].y!=a[i+1].y){\n\t\t\tll t=cnt(-inf, inf);\n\t\t\tans+=t*(t+1)/2;\n\t\t\tt=cnt(a[i].x+1, inf);\n\t\t\tans-=t*(t+1)/2;\n\t\t}\n\t\tll pre;\n\t\tif(a[i-1].y!=a[i].y){\n\t\t\tpre=-inf;\n\t\t}\n\t\telse{\n\t\t\tpre=a[i-1].x+1;\n\t\t}\n\t\tll t=cnt(pre, a[i].x-1);\n\t\tans-=t*(t+1)/2; \n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57193569": {
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstdio>\ntypedef long long ll;\nstruct Coord{\n    int x, y;\n    Coord(int x, int y):x(x), y(y){}\n};\n\nstruct Xrecord{\n    int x;\n    int point_num;\n    Xrecord(int x):x(x), point_num(1){}\n};\nstruct Yrecord{\n    int y;\n    std::vector<int> xcoords;\n    Yrecord(int y):y(y){}\n};\n\nstruct BIT\n{\n    std::vector<int> sum;\n    BIT(int len){\n        sum = std::vector<int>(len);\n        for(int i = 0; i < len; i++){\n            sum[i] = (i+1) & -(i+1);        // lowbit\n        }\n    }\n    int rangeSum(int l, int r){\n        return posSum(r) - posSum(l-1);\n    }\n    void add(int pos, int val){\n        for(; pos < sum.size(); pos |= pos+1){\n            sum[pos] += val;\n        }\n    }\nprivate:\n    int posSum(int pos){\n        int ans = 0;\n        for(; pos >= 0; pos = (pos & (pos+1)) - 1){\n            ans += sum[pos];\n        }\n        return ans;\n    }\n};\n\n\nll solve(std::vector<Xrecord> &xrecords, std::vector<Yrecord> &yrecords){\n    ll res = 0;\n    BIT bit = BIT(xrecords.size());\n    for(int i = 0; i < yrecords.size(); i++){\n        int prev_pos = -1;\n        for(int x : yrecords[i].xcoords){\n            auto it = std::lower_bound(xrecords.begin(), xrecords.end(), x, [](const Xrecord& a, const int& b){\n                return a.x < b;\n            });\n            ll left_range = bit.rangeSum(prev_pos + 1, it - xrecords.begin());\n            ll right_range = bit.rangeSum(it - xrecords.begin(), xrecords.size() - 1);\n            res += left_range * right_range;\n            prev_pos = it - xrecords.begin();\n            (*it).point_num--;\n            if((*it).point_num == 0){\n                bit.add(prev_pos, -1);\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n\n    std::vector<Xrecord> x_records;\n    std::vector<Yrecord> y_records;\n    std::vector<Coord> coords;\n    for(int i = 0; i < n; i++){\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        coords.push_back(Coord(x, y));\n    }\n    std::sort(coords.begin(), coords.end(), [](const Coord& a, const Coord& b){\n        return a.x < b.x;\n    });\n    x_records.push_back(Xrecord(coords[0].x));\n    for(int i = 1; i < n; i++){\n        if(coords[i].x == coords[i-1].x) x_records.back().point_num++;\n        else{\n            x_records.push_back(Xrecord(coords[i].x));\n        }\n    }\n\n    std::sort(coords.begin(), coords.end(), [](const Coord& a, const Coord& b){\n        return a.y < b.y || a.y == b.y && a.x < b.x;\n    });\n    y_records.push_back(Yrecord(coords[0].y));\n    y_records[0].xcoords.push_back(coords[0].x);\n    for(int i = 1; i < n; i++){\n        if(coords[i].y != coords[i-1].y) y_records.push_back(Yrecord(coords[i].y));\n        y_records.back().xcoords.push_back(coords[i].x);\n    }\n    \n    ll res = solve(x_records, y_records);\n    std::cout << res << std::endl;\n\n    return 0;\n}",
    "ext": "cpp"
  },
  "57190954": {
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstdio>\ntypedef long long ll;\nstruct Coord{\n    int x, y;\n    Coord(int x, int y):x(x), y(y){}\n};\n\nstruct Xrecord{\n    int x;\n    int point_num;\n    Xrecord(int x):x(x), point_num(1){}\n};\nstruct Yrecord{\n    int y;\n    std::vector<int> xcoords;\n    Yrecord(int y):y(y){}\n};\n\nstruct SegTree{\n    int *l = nullptr;\n    int *r = nullptr;\n    int *val = nullptr;\n    SegTree(){}\n    SegTree(SegTree&& other){\n        l = other.l;    r = other.r;    val = other.val;\n        other.l = other.r = other.val = nullptr;\n    }\n    SegTree(int len){\n        if(len <= 0) return;\n        l = new int[4 * len];\n        r = new int[4 * len];\n        val = new int[4 * len];\n    }\n    ~SegTree(){\n        if(l) delete[] l;\n        if(r) delete[] r;\n        if(val) delete[] val;\n    }\n    inline int min(){return l[0];}\n    inline int max(){return r[0];}\n    int query(int left, int right, int node = 0){\n        if(left > right) return 0;\n\n        int res = 0;\n        if(left <= l[node] && right >= r[node]){ // totally included\n            if(l[node] < r[node])\n                res = val[node];\n            else res = int(val[node] > 0);\n        }else if(left > r[node] || right < l[node]){    // no intersection\n            res = 0;\n        }else{  // partly intersected\n            //if(l[node] < r[node]){    // always satisfied\n                if(left <= r[2*node+1] && right >= l[2*node+1]){\n                    res += query(left, right, 2*node+1);\n                }\n                if(left <= r[2*node+2] && right >= l[2*node+2]){\n                    res += query(left, right, 2*node+2);\n                }\n            //}\n        }\n        return res; \n    }\n    int decrease(int element, int node = 0){\n        int dec = 0;\n        if(l[node] == r[node]){\n            if(l[node] == element){\n                val[node]--;\n                if(!val[node]) dec = 1;\n            }\n        }else{\n            if(element <= r[2*node+1] && element >= l[2*node+1]){\n                dec = decrease(element, 2*node+1);\n            }else if(element <= r[2*node+2] && element >= l[2*node+2]){\n                dec = decrease(element, 2*node+2);\n            }\n            val[node] -= dec;\n        }\n        return dec;\n    }\n};\n\nint InitNode(SegTree& tree, int index, const std::vector<Xrecord>& xcoords, int l, int r){\n    tree.l[index] = xcoords[l].x;  tree.r[index] = xcoords[r].x;\n    if(l == r){\n        tree.val[index] = xcoords[l].point_num;\n        return 1;\n    }else{\n        //left child\n        tree.val[index] = InitNode(tree, 2*index+1, xcoords, l, (l+r) / 2);\n        //right child\n        tree.val[index] += InitNode(tree, 2*index+2, xcoords, (l+r) / 2 + 1, r);\n        return tree.val[index];\n    }\n}\n\nSegTree InitSegTree(const std::vector<Xrecord>& xcoords){\n    SegTree tree = SegTree(xcoords.size());\n    InitNode(tree, 0, xcoords, 0, xcoords.size() - 1);\n    return tree;\n}\n\nll solve(SegTree &x_tree, std::vector<Yrecord> &yrecords){\n    ll res = 0;\n    for(int i = 0; i < yrecords.size(); i++){\n        int prev_pos = x_tree.min();\n        for(int x : yrecords[i].xcoords){\n            ll left_range = x_tree.query(prev_pos, x);\n            ll right_range = x_tree.query(x, x_tree.max());\n            res += left_range * right_range;\n            prev_pos = x + 1;\n            x_tree.decrease(x);\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n\n    std::vector<Xrecord> x_records;\n    std::vector<Yrecord> y_records;\n    std::vector<Coord> coords;\n    for(int i = 0; i < n; i++){\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        coords.push_back(Coord(x, y));\n    }\n    std::sort(coords.begin(), coords.end(), [](const Coord& a, const Coord& b){\n        return a.x < b.x;\n    });\n    x_records.push_back(Xrecord(coords[0].x));\n    for(int i = 1; i < n; i++){\n        if(coords[i].x == coords[i-1].x) x_records.back().point_num++;\n        else{\n            x_records.push_back(Xrecord(coords[i].x));\n        }\n    }\n    SegTree x_tree = InitSegTree(x_records);\n\n    std::sort(coords.begin(), coords.end(), [](const Coord& a, const Coord& b){\n        return a.y < b.y || a.y == b.y && a.x < b.x;\n    });\n    y_records.push_back(Yrecord(coords[0].y));\n    y_records[0].xcoords.push_back(coords[0].x);\n    for(int i = 1; i < n; i++){\n        if(coords[i].y != coords[i-1].y) y_records.push_back(Yrecord(coords[i].y));\n        y_records.back().xcoords.push_back(coords[i].x);\n    }\n    \n    ll res = solve(x_tree, y_records);\n    std::cout << res << std::endl;\n\n    return 0;\n}",
    "ext": "cpp"
  },
  "57189182": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=200005;\nint c[maxn],n;\nint a[maxn],b[maxn];\nvector<int>v[maxn];\nint lowbit(int x)\n{\n    return x&(-x);\n}\nvoid add(int x,int v)\n{\n    while(x<=n)\n    {\n        c[x]+=v;\n        x+=lowbit(x);\n    }\n}\nint sum(int x)\n{\n    int ans=0;\n    while(x)\n    {\n        ans+=c[x];\n        x-=lowbit(x);\n    }\n    return ans;\n}\nvoid compress(vector<int>&vec)\n{\n    sort(vec.begin(),vec.end());\n    vec.erase(unique(vec.begin(),vec.end()),vec.end());\n}\nint main()\n{\n    memset(c,0,sizeof(c));\n    cin>>n;\n    vector<int>vx,vy;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&a[i],&b[i]);\n        vx.push_back(a[i]);\n        vy.push_back(b[i]);\n    }\n    compress(vx);\n    compress(vy);\n    for(int i=1;i<=n;i++)\n    {\n        a[i]=lower_bound(vx.begin(),vx.end(),a[i])-vx.begin()+1;\n        b[i]=lower_bound(vy.begin(),vy.end(),b[i])-vy.begin()+1;\n        v[b[i]].push_back(a[i]);\n    }\n    long long ans=0;\n    for(int i=n;i>=1;i--)\n    {\n        sort(v[i].begin(),v[i].end());\n        for(int j=0;j<v[i].size();j++)\n        {\n            int t=v[i][j];\n            if( sum(t)-sum(t-1))continue;\n            add(t,1);\n        }\n        int pre=0;\n        for(int j=0;j<v[i].size();j++)\n        {\n            int t=v[i][j];\n            ans+=1ll*(sum(t)-sum(pre))*(sum(n)-sum(t-1));\n            pre=t;\n        }\n    }\n    cout<<ans<<endl;\n}\n",
    "ext": "cpp"
  },
  "57187538": {
    "code": "// by Balloons\n#include <cstdio>\n#include <cstring>\n#include <set>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#define mpr make_pair\n#define debug() puts(\"okkkkkkkk\")\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n\nusing namespace std;\n\ntypedef long long LL;\n#define int LL\n\nconst int inf = 1 << 30;\nconst int maxn=2e5+5;\n\nint n,nn;\nstruct points{int x,y;}po[maxn];\nint ap[maxn],bp[maxn]; \nvector<int>line[maxn];\nint mp[maxn];\nint que[maxn],fr=0;\nset<int>S; \n\nint tree[maxn],v[maxn],vis[maxn];\n\nvoid add(int x){\n\tif(vis[x])return ;\n\tvis[x]=1;\n\tfor(int i=x;i<=nn+1;i+=(i&(-i)))++ tree[i];\n}\n\nint qu(int x){int res=0;for(;x;x-=(x&(-x)))res+=tree[x];return res;}\nint query(int x,int y){return qu(y)-qu(x-1);}\n\nint cmp(points a,points b){\n\tif(a.y==b.y)return a.x<b.x;\n\treturn a.y>b.y;\n}\n\nsigned main(){\n\tscanf(\"%I64d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%I64d%I64d\",&po[i].x,&po[i].y),ap[i]=po[i].x;\n\tsort(ap+1,ap+n+1);\n\tnn=unique(ap+1,ap+n+1)-(ap+1);\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tpo[i].x=lower_bound(ap+1,ap+nn+1,po[i].x)-(ap);\n\t\n\tsort(po+1,po+n+1,cmp);\n\t\n\tint ans=0;\n\tint be=1,cur=1;\n\t\n\tfor(;be<=n;){\n\t\tint tp=0;\n\t\twhile(po[cur].y==po[be].y){\n\t\t\tadd(po[cur].x);\n\t\t\tv[++tp]=po[cur].x;\n\t\t\t++ cur;\n\t\t}\n\t\tv[++tp]=nn+1;\n\t\tfor(int i=1;i<=tp-1;i++){\n\t\t\tint curl=query(1,v[i]-1),curr=query(v[i]+1,v[i+1]-1);\n\t\t\tans+=1ll*(curl+1)*(curr+1);\n\t\t}\n\t\tbe=cur;\n\t}\n\tprintf(\"%I64d\\n\",ans);\n\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57186641": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 200005;\nint n, x[N], y[N], bit[N];\nvector<int> v[N];\nvoid compress(vector<int>& x)\n{\n    sort(x.begin(), x.end());\n    x.erase(unique(x.begin(), x.end()), x.end());\n}\nint lowbit(int x) { return x & -x; }\nvoid add(int i, int x)\n{\n    while (i <= n) { bit[i] += x; i += lowbit(i); }\n}\nint sum(int i)\n{\n    int ans = 0;\n    while (i) { ans += bit[i]; i -= lowbit(i); }\n    return ans;\n}\nint main()\n{\n    while (cin >> n)\n    {\n        memset(bit, 0, sizeof bit);\n        for (int i = 1; i <= n; i++) v[i].clear();\n        vector<int> vx, vy;\n        for (int i = 1; i <= n; i++)\n        {\n            cin >> x[i] >> y[i];\n            vx.push_back(x[i]); vy.push_back(y[i]);\n        }\n        compress(vx); compress(vy);\n        for (int i = 1; i <= n; i++)\n        {\n            x[i] = lower_bound(vx.begin(), vx.end(), x[i]) - vx.begin() + 1;\n            y[i] = lower_bound(vy.begin(), vy.end(), y[i]) - vy.begin() + 1;\n            v[y[i]].push_back(x[i]);\n        }\n        ll ans = 0;\n        for (int i = n; i >= 1; i--)\n        {\n            sort(v[i].begin(), v[i].end());\n            for (int j = 0; j < v[i].size(); j++)\n            {\n                int t = v[i][j];\n                if (sum(t) - sum(t - 1)) continue;\n                add(t, 1);\n            }\n            int prev = 0;\n            for (int j = 0; j < v[i].size(); j++)\n            {\n                int t = v[i][j];\n                //cout<<sum(t - 1) - sum(prev) + 1<<\" \"<<(sum(n) - sum(t) + 1)<<endl;\n                ans += 1ll * (sum(t) - sum(prev)) * (sum(n) - sum(t-1));\n                //cout<<ans<<endl;\n                prev = t;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n",
    "ext": "cpp"
  }
}
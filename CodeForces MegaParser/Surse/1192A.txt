{
  "58090082": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int mxN=1.5e5, mxM=2*mxN+2, INF=2e9, dx[8]={-1, -1, 0, 1, 1, 1, 0, -1}, dy[8]={0, 1, 1, 1, 0, -1, -1, -1};\nint n, t, m, x[mxM], yl[mxM], yr[mxM], ans[mxN], p[mxN+mxM], adj[mxN][8], d[13];\narray<int, 2> a[mxN];\narray<int, 3> b[mxN];\nmap<int, vector<array<int, 2>>> mp;\nvector<int> v[mxN+mxM];\nset<int> s;\nbool ia[mxN], vis[mxN], c1[mxN], c2[mxN];\n\nvoid fk() {\n\tcout << \"NO\";\n\texit(0);\n}\n \nint dfs(int u=0) {\n\tint s=1;\n\tvis[u]=1;\n\tfor(int k=0; k<8; ++k)\n\t\tif(adj[u][k]<n&&!vis[adj[u][k]])\n\t\t\ts+=dfs(adj[u][k]);\n\treturn s;\n}\n \nint fc(int x, int y) {\n\tint p=lower_bound(b, b+n, array<int, 3>{x, y})-b;\n\tif(p<n&&b[p][0]==x&&b[p][1]==y)\n\t\treturn b[p][2];\n\tauto it=lower_bound(mp[x].begin(), mp[x].end(), array<int, 2>{y+1, 0});\n\treturn it==mp[x].begin()||yr[(*--it)[1]]<y?-1:(*it)[1]+n;\n}\n\nvoid upd(int u, bool b1, bool b2) {\n\tif(ia[u])\n\t\treturn;\n\tif(c1[u]&&c2[u])\n\t\ts.erase(u);\n\tif(b1&&b2)\n\t\ts.insert(u);\n\tc1[u]=b1;\n\tc2[u]=b2;\n}\n\nint find(int x) {\n\treturn x^p[x]?p[x]=find(p[x]):x;\n}\n\nvoid calc(int u) {\n\tfor(int i=1; i<13; ++i)\n\t\td[i]=d[i-1]+(adj[u][i%8]<n&&!ia[adj[u][i%8]]);\n\tfor(int i=0; i<6; i+=2) {\n\t\tif(d[i+8]-d[i+7])\n\t\t\tcontinue;\n\t\tfor(int j=i+2; j<8; j+=2) {\n\t\t\tif(!(d[j]-d[j-1])&&d[j-1]-d[i]&&d[i+7]-d[j]&&find(adj[u][i])==find(adj[u][j])) {\n\t\t\t\tupd(u, c1[u], 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tupd(u, c1[u], 1);\n}\n \nvoid join(int x, int y) {\n\tif((x=find(x))==(y=find(y)))\n\t\treturn;\n\tif(y==find(n))\n\t\tswap(x, y);\n\tif(x==find(n))\n\t\tfor(int a : v[y])\n\t\t\tupd(a, 1, c2[a]);\n\tif(v[x].size()<v[y].size())\n\t\tswap(x, y);\n\tp[y]=x;\n\tfor(int a : v[y])\n\t\tcalc(a);\n\tv[x].insert(v[x].end(), v[y].begin(), v[y].end());\n}\n \nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n \n\tcin >> n >> t;\n\tfor(int i=0; i<n; ++i) {\n\t\tcin >> a[i][0] >> a[i][1];\n\t\tb[i]={a[i][0], a[i][1], i};\n\t}\n\tsort(b, b+n);\n\tauto ns=[](int xi, int yli, int yri) {\n\t\tx[m]=xi;\n\t\tyl[m]=yli;\n\t\tyr[m]=yri;\n\t\tmp[xi].push_back({yli, m});\n\t\t++m;\n\t};\n\tns(b[0][0]-1, -INF, INF);\n\tns(b[n-1][0]+1, -INF, INF);\n\tfor(int i=0, j=0; i<n; ) {\n\t\tfor(; j<n&&b[j][0]==b[i][0]; ++j);\n\t\tint l=-INF;\n\t\tfor(; i<j; l=b[i++][1]+1)\n\t\t\tif(l<b[i][1])\n\t\t\t\tns(b[i][0], l, b[i][1]-1);\n\t\tns(b[j-1][0], l, INF);\n\t}\n\tfor(auto &a : mp)\n\t\tsort(a.second.begin(), a.second.end());\n\tfor(int i=0; i<n; ++i) {\n\t\tfor(int k=0; k<8; ++k) {\n\t\t\tadj[i][k]=fc(a[i][0]+dx[k], a[i][1]+dy[k]);\n\t\t\tif(adj[i][k]<0)\n\t\t\t\tfk();\n\t\t\tif(k&1^1) {\n\t\t\t\tv[adj[i][k]].push_back(i);\n\t\t\t\tif(adj[i][k]==n)\n\t\t\t\t\tupd(i, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tif(dfs()<n)\n\t\tfk();\n\tiota(p, p+n+m, 0);\n\tfor(int i=0; i<m; ++i) {\n\t\tfor(int k=0; k<8; k+=2) {\n\t\t\tint j=fc(x[i]+dx[k], yl[i]+dy[k]);\n\t\t\tif(j>=n)\n\t\t\t\tjoin(i+n, j);\n\t\t}\n\t}\n\tfor(int i=0; i<n; ++i)\n\t\tcalc(i);\n\tfor(int i=n-1; ~i; --i) {\n\t\tans[i]=*--s.end();\n\t\ts.erase(ans[i]);\n\t\tia[ans[i]]=1;\n\t\tfor(int k=0; k<8; k+=2)\n\t\t\tif(adj[ans[i]][k]>=n||ia[adj[ans[i]][k]])\n\t\t\t\tjoin(ans[i], adj[ans[i]][k]);\n\t\tfor(int k=0; k<8; ++k)\n\t\t\tif(adj[ans[i]][k]<n)\n\t\t\t\tcalc(adj[ans[i]][k]);\n\t}\n\tcout << \"YES\\n\";\n\tfor(int i=0; i<n; ++i)\n\t\tcout << ans[i]+1 << \"\\n\";\n}",
    "ext": "cpp"
  },
  "58085217": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nvoid unique(vector<T> &u) {\n  sort(u.begin(), u.end());\n  u.resize(unique(u.begin(), u.end()) - u.begin());\n}\n\n#define range(i, m, n) for(int i = m; i < n; i++)\n#define husk(i, m, n) for(int i = m; i > n; i--)\n\ntemplate <typename T>\nvoid debug_out(T t) {\n  cerr << t;\n}\n\ntemplate <typename A, typename B>\nvoid debug_out(pair<A, B> u) {\n  cerr << \"(\" << u.first << \" \" << u.second << \")\";\n}\n\ntemplate <typename T>\nvoid debug_out(vector<T> t) {\n  int sz = t.size();\n  for(int i = 0; i < sz; i++) {\n    debug_out(t[i]);\n    if(i != sz - 1) cerr << \", \";\n  }\n}\n\ntemplate <typename T>\nvoid debug_out(vector<vector<T>> t) {\n  int sz = t.size();\n  for(int i = 0; i < sz; i++) {\n    debug_out(t[i]);\n    if(i != sz - 1) cerr << endl;\n  }\n}\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\" << endl, debug_out(__VA_ARGS__), cerr << endl;\n\nclass dsu {\n public:\n  vector<int> p;\n  int n;\n\n  dsu(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n  }\n\n  inline int get(int x) {\n    return (x == p[x] ? x : (p[x] = get(p[x])));\n  }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      return true;\n    }\n    return false;\n  }\n};\n\nstruct point {\n  int x, y, id = -1;\n  point(){};\n  point(int _x, int _y) : x(_x), y(_y) {};\n  bool operator < (const point &a) const {\n    return id > a.id;\n  }\n  bool operator == (const point &a) const {\n    return x == a.x && y == a.y;\n  }\n};\n\nvoid debug_out(point a) {\n  cerr << \"(\" << a.x << \" \" << a.y << \")\";\n}\n\nvector<int> dx = {0, 1, 1, 1, 0, -1, -1, -1};\nvector<int> dy = {1, 1, 0, -1, -1, -1, 0, 1};\n\npoint sp(point a, int id) {\n  return point(a.x + dx[id], a.y + dy[id]);\n}\n\nlong long dis(point a) {\n  return 1LL * a.x * INT_MAX + a.y;\n}\n\nint n, t;\n\nint main() {\n  scanf(\"%d%d\", &n, &t);\n  vector<point> a(n);\n  range(i, 0, n) {\n    scanf(\"%d%d\", &a[i].x, &a[i].y);\n    a[i].id = i;\n  }\n  sort(a.begin(), a.end(), [&](point u, point v){return make_pair(u.x, u.y) < make_pair(v.x, v.y);});\n  vector<vector<int>> edges(n, vector<int>(8, -1));\n  dsu ss(n);\n  int l = 0, r = 0;\n  range(i, 0, n) {\n    if(i < n - 1 && a[i].x == a[i + 1].x && a[i].y == a[i + 1].y - 1) {\n      edges[a[i].id][0] = a[i + 1].id;\n      edges[a[i + 1].id][4] = a[i].id;\n      ss.unite(a[i].id, a[i + 1].id);\n    }\n    while(r < n && make_pair(a[r].x, a[r].y) <= make_pair(a[i].x + 1, a[i].y + 1)) r++;\n    while(l < n && make_pair(a[l].x, a[l].y) < make_pair(a[i].x + 1, a[i].y - 1)) l++;\n    range(j, l, r) {\n      int dif = a[j].y - a[i].y;\n      int id;\n      if(!dif) id = 2;\n      else id = (dif > 0 ? 1 : 3);\n      edges[a[i].id][id] = a[j].id;\n      edges[a[j].id][(id + 4) % 8] = a[i].id;\n      ss.unite(a[i].id, a[j].id);\n    }\n  }\n  range(i, 0, n) if(ss.get(i) != ss.get(0)) {\n    printf(\"NO\");\n    return 0;\n  }\n  sort(a.begin(), a.end());\n  reverse(a.begin(), a.end());\n  printf(\"YES\\n\");\n  dsu st(4 * n + 1);\n  auto it = max_element(a.begin(), a.end(), [&](point a, point b){return a.y < b.y;});\n  st.unite(4 * n, 4 * it -> id);\n  vector<point> cur;\n  for(auto u : a) {\n    for(int i = 0; i < 8; i += 2) {\n      if(~edges[u.id][i]) continue;\n      point cc = sp(u, i);\n      cc.id = 4 * u.id + i / 2;\n      cur.push_back(cc);\n    }\n    for(int i = 1; i < 8; i += 2) {\n      if(edges[u.id][i - 1] == -1 && edges[u.id][i] == -1 && edges[u.id][(i + 1) % 8] == -1) st.unite(4 * u.id + i / 2, 4 * u.id + ((i + 1) % 8) / 2);\n    }\n  }\n  sort(cur.begin(), cur.end(), [&](point u, point v){return make_pair(u.x, u.y) < make_pair(v.x, v.y);});\n  l = 0;\n  range(i, 0, (int) cur.size()) {\n    point u = cur[i];\n    if(i < (int) cur.size() - 1 && make_pair(cur[i + 1].x, cur[i + 1].y) <= make_pair(u.x, u.y + 1)) st.unite(cur[i + 1].id, u.id);\n    while(l < (int) cur.size() && make_pair(cur[l].x, cur[l].y) < make_pair(u.x + 1, u.y)) l++;\n    if(cur[l].x == u.x + 1 && cur[l].y == u.y) st.unite(cur[l].id, u.id);\n  }\n  vector<int> alive(n, 1);\n  int iter = 0;\n  vector<int> pp(4 * n + 1);\n  auto valid = [&] (point v) {\n    iter++;\n    bool ok = false;\n    range(i, 0, 8) {\n      if(~edges[v.id][i] && alive[edges[v.id][i]]) {\n        int xs = 8;\n        i++;\n        if(i == 8) i = 0;\n        vector<int> pc;\n        while(xs--) {\n          if(~edges[v.id][i] && alive[edges[v.id][i]]) {\n            for(auto j : pc) {\n              if(pp[j] == iter) return false;\n            }\n            for(auto j : pc) pp[j] = iter;\n            pc.clear();\n          } else if(i % 2 == 0) {\n            pc.push_back(st.get(4 * v.id + i / 2));\n            ok |= st.get(4 * v.id + i / 2) == st.get(4 * n);\n          }\n          i++;\n          if(i == 8) i = 0;\n        }\n        break;\n      }\n      ok |= i == 7;\n    }\n    return ok;\n  };\n  set<point> pos;\n  range(i, 0, n) if(valid(a[i])) pos.insert(a[i]);\n  vector<vector<int>> in(4 * n + 1);\n  range(i, 0, 4 * n + 1) in[st.get(i)].push_back(i);\n  vector<int> res;\n  int cnt = 0;\n  vector<int> ap(n);\n  while(pos.size()) {\n    cnt++;\n    res.push_back(pos.begin() -> id);\n    point cc = *pos.begin();\n    pos.erase(pos.begin());\n    alive[cc.id] = 0;\n    vector<int> id, _id;\n    range(i, 0, 8) {\n      if(~edges[cc.id][i] && alive[edges[cc.id][i]]) id.push_back(edges[cc.id][i]);\n    }\n    for(int i = 0; i < 8; i += 2) {\n      if(edges[cc.id][i] == -1 || !alive[edges[cc.id][i]]) {\n        if(st.get(4 * n) != st.get(4 * cc.id + i / 2)) _id.push_back(st.get(4 * cc.id + i / 2));\n      }\n    }\n    unique(_id);\n    for(auto i : _id) {\n      for(auto j : in[i]) id.push_back(j / 4);\n    }\n    unique(id);\n    for(int i = 0; i < 8; i += 2) {\n      if(edges[cc.id][i] == -1 || !alive[edges[cc.id][i]]) {\n        st.unite(4 * cc.id + i / 2, 4 * n);\n      }\n    }\n    for(int i = 0; i < 8; i += 2) {\n      if(~edges[cc.id][i] && alive[edges[cc.id][i]]) {\n        int v = edges[cc.id][i];\n        st.unite(4 * v + ((i + 4) % 8) / 2, 4 * n);\n      }\n    }\n    for(auto i : id) {\n      if(ap[i] == cnt) continue;\n      ap[i] = cnt;\n      if(alive[i] && valid(a[i])) pos.insert(a[i]);\n      else pos.erase(a[i]);\n    }\n  }\n  reverse(res.begin(), res.end());\n  for(auto i : res) printf(\"%d\\n\", i + 1);\n  return 0;\n}\n",
    "ext": "cpp"
  },
  "57994251": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nvoid unique(vector<T> &u) {\n  sort(u.begin(), u.end());\n  u.resize(unique(u.begin(), u.end()) - u.begin());\n}\n\n#define range(i, m, n) for(int i = m; i < n; i++)\n#define husk(i, m, n) for(int i = m; i > n; i--)\n\nclass dsu {\n public:\n  vector<int> p;\n  int n;\n\n  dsu(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n  }\n\n  inline int get(int x) {\n    return (x == p[x] ? x : (p[x] = get(p[x])));\n  }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      return true;\n    }\n    return false;\n  }\n};\n\nstruct point {\n  int x, y, id = -1;\n  point(){};\n  point(int _x, int _y) : x(_x), y(_y) {};\n  bool operator < (const point &a) const {\n    return id > a.id;\n  }\n  bool operator == (const point &a) const {\n    return x == a.x && y == a.y;\n  }\n};\n\nvector<int> dx = {0, 1, 1, 1, 0, -1, -1, -1};\nvector<int> dy = {1, 1, 0, -1, -1, -1, 0, 1};\n\npoint sp(point a, int id) {\n  return point(a.x + dx[id], a.y + dy[id]);\n}\n\nlong long dis(point a) {\n  return 1LL * a.x * INT_MAX + a.y;\n}\n\nint n, t;\n\nint main() {\n  scanf(\"%d%d\", &n, &t);\n  vector<point> a(n);\n  range(i, 0, n) {\n    scanf(\"%d%d\", &a[i].x, &a[i].y);\n    a[i].id = i;\n  }\n  sort(a.begin(), a.end(), [&](point u, point v){return make_pair(u.x, u.y) < make_pair(v.x, v.y);});\n  vector<vector<int>> edges(n, vector<int>(8, -1));\n  dsu ss(n);\n  int l = 0, r = 0;\n  range(i, 0, n) {\n    if(i < n - 1 && a[i].x == a[i + 1].x && a[i].y == a[i + 1].y - 1) {\n      edges[a[i].id][0] = a[i + 1].id;\n      edges[a[i + 1].id][4] = a[i].id;\n      ss.unite(a[i].id, a[i + 1].id);\n    }\n    while(r < n && make_pair(a[r].x, a[r].y) <= make_pair(a[i].x + 1, a[i].y + 1)) r++;\n    while(l < n && make_pair(a[l].x, a[l].y) < make_pair(a[i].x + 1, a[i].y - 1)) l++;\n    range(j, l, r) {\n      int dif = a[j].y - a[i].y;\n      int id;\n      if(!dif) id = 2;\n      else id = (dif > 0 ? 1 : 3);\n      edges[a[i].id][id] = a[j].id;\n      edges[a[j].id][(id + 4) % 8] = a[i].id;\n      ss.unite(a[i].id, a[j].id);\n    }\n  }\n  range(i, 0, n) if(ss.get(i) != ss.get(0)) {\n    printf(\"NO\");\n    return 0;\n  }\n  sort(a.begin(), a.end());\n  reverse(a.begin(), a.end());\n  printf(\"YES\\n\");\n  dsu st(4 * n + 1);\n  auto it = max_element(a.begin(), a.end(), [&](point a, point b){return a.y < b.y;});\n  st.unite(4 * n, 4 * it -> id);\n  unordered_map<long long, vector<int>> dog;\n  for(auto u : a) {\n    for(int i = 0; i < 8; i += 2) {\n      int v = edges[u.id][i];\n      if(v == -1) dog[dis(sp(u, i))].push_back(4 * u.id + i / 2);\n    }\n  }\n  for(auto u : a) {\n    vector<int> xs(8);\n    range(i, 0, 8) xs[i] = edges[u.id][i] >= 0;\n    for(int i = 1; i < 8; i += 2) {\n      if(!xs[i] && !xs[i - 1] && !xs[(i + 1) % 8]) st.unite(4 * u.id + i / 2, 4 * u.id + ((i + 1) % 8) / 2);\n    }\n  }\n  for(auto u : dog) {\n    point cc = point(u.first / INT_MAX, u.first % INT_MAX);\n    vector<int> id = u.second;\n    for(auto i : id) st.unite(i, id.front());\n    for(int i = 0; i < 8; i += 2) {\n      if(dog.count(dis(sp(cc, i)))) st.unite(id[0], dog[dis(sp(cc, i))][0]);\n    }\n  }\n  vector<int> alive(n, 1);\n  int iter = 0;\n  vector<int> pp(4 * n + 1);\n  auto valid = [&] (point v) {\n    iter++;\n    bool ok = false;\n    range(i, 0, 8) {\n      if(~edges[v.id][i] && alive[edges[v.id][i]]) {\n        int xs = 8;\n        i++;\n        if(i == 8) i = 0;\n        vector<int> pc;\n        while(xs--) {\n          if(~edges[v.id][i] && alive[edges[v.id][i]]) {\n            for(auto j : pc) {\n              if(pp[j] == iter) return false;\n            }\n            for(auto j : pc) pp[j] = iter;\n            pc.clear();\n          } else if(i % 2 == 0) {\n            pc.push_back(st.get(4 * v.id + i / 2));\n            ok |= st.get(4 * v.id + i / 2) == st.get(4 * n);\n          }\n          i++;\n          if(i == 8) i = 0;\n        }\n        break;\n      }\n      ok |= i == 7;\n    }\n    return ok;\n  };\n  set<point> pos;\n  range(i, 0, n) if(valid(a[i])) pos.insert(a[i]);\n  vector<vector<int>> in(4 * n + 1);\n  range(i, 0, 4 * n + 1) in[st.get(i)].push_back(i);\n  vector<int> res;\n  int cnt = 0;\n  vector<int> ap(n);\n  while(pos.size()) {\n    cnt++;\n    res.push_back(pos.begin() -> id);\n    point cc = *pos.begin();\n    pos.erase(pos.begin());\n    alive[cc.id] = 0;\n    vector<int> id, _id;\n    range(i, 0, 8) {\n      if(~edges[cc.id][i] && alive[edges[cc.id][i]]) id.push_back(edges[cc.id][i]);\n    }\n    for(int i = 0; i < 8; i += 2) {\n      if(edges[cc.id][i] == -1 || !alive[edges[cc.id][i]]) {\n        if(st.get(4 * n) != st.get(4 * cc.id + i / 2)) _id.push_back(st.get(4 * cc.id + i / 2));\n      }\n    }\n    unique(_id);\n    for(auto i : _id) {\n      for(auto j : in[i]) id.push_back(j / 4);\n    }\n    unique(id);\n    for(int i = 0; i < 8; i += 2) {\n      if(edges[cc.id][i] == -1 || !alive[edges[cc.id][i]]) {\n        st.unite(4 * cc.id + i / 2, 4 * n);\n      }\n    }\n    for(int i = 0; i < 8; i += 2) {\n      if(~edges[cc.id][i] && alive[edges[cc.id][i]]) {\n        int v = edges[cc.id][i];\n        st.unite(4 * v + ((i + 4) % 8) / 2, 4 * n);\n      }\n    }\n    for(auto i : id) {\n      if(ap[i] == cnt) continue;\n      ap[i] = cnt;\n      if(alive[i] && valid(a[i])) pos.insert(a[i]);\n      else pos.erase(a[i]);\n    }\n  }\n  reverse(res.begin(), res.end());\n  for(auto i : res) printf(\"%d\\n\", i + 1);\n  return 0;\n}\n",
    "ext": "cpp"
  },
  "57994116": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nvoid unique(vector<T> &u) {\n  sort(u.begin(), u.end());\n  u.resize(unique(u.begin(), u.end()) - u.begin());\n}\n\n#define range(i, m, n) for(int i = m; i < n; i++)\n#define husk(i, m, n) for(int i = m; i > n; i--)\n\ntemplate <typename T>\nvoid debug_out(T t) {\n  cerr << t;\n}\n\ntemplate <typename A, typename B>\nvoid debug_out(pair<A, B> u) {\n  cerr << \"(\" << u.first << \" \" << u.second << \")\";\n}\n\ntemplate <typename T>\nvoid debug_out(vector<T> t) {\n  int sz = t.size();\n  for(int i = 0; i < sz; i++) {\n    debug_out(t[i]);\n    if(i != sz - 1) cerr << \", \";\n  }\n}\n\ntemplate <typename T>\nvoid debug_out(vector<vector<T>> t) {\n  int sz = t.size();\n  for(int i = 0; i < sz; i++) {\n    debug_out(t[i]);\n    if(i != sz - 1) cerr << endl;\n  }\n}\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\" << endl, debug_out(__VA_ARGS__), cerr << endl;\n\n\nclass dsu {\n public:\n  vector<int> p;\n  int n;\n\n  dsu(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n  }\n\n  inline int get(int x) {\n    return (x == p[x] ? x : (p[x] = get(p[x])));\n  }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      return true;\n    }\n    return false;\n  }\n};\n\nstruct point {\n  int x, y, id = -1;\n  point(){};\n  point(int _x, int _y) : x(_x), y(_y) {};\n  bool operator < (const point &a) const {\n    return id > a.id;\n  }\n  bool operator == (const point &a) const {\n    return x == a.x && y == a.y;\n  }\n};\n\nvector<int> dx = {0, 1, 1, 1, 0, -1, -1, -1};\nvector<int> dy = {1, 1, 0, -1, -1, -1, 0, 1};\n\npoint sp(point a, int id) {\n  return point(a.x + dx[id], a.y + dy[id]);\n}\n\nlong long dis(point a) {\n  return 1LL * a.x * INT_MAX + a.y;\n}\n\nint n, t;\n\nint main() {\n  scanf(\"%d%d\", &n, &t);\n  vector<point> a(n);\n  range(i, 0, n) {\n    scanf(\"%d%d\", &a[i].x, &a[i].y);\n    a[i].id = i;\n  }\n  sort(a.begin(), a.end(), [&](point u, point v){return make_pair(u.x, u.y) < make_pair(v.x, v.y);});\n  vector<vector<int>> edges(n, vector<int>(8, -1));\n  dsu ss(n);\n  int l = 0, r = 0;\n  range(i, 0, n) {\n    if(i < n - 1 && a[i].x == a[i + 1].x && a[i].y == a[i + 1].y - 1) {\n      edges[a[i].id][0] = a[i + 1].id;\n      edges[a[i + 1].id][4] = a[i].id;\n      ss.unite(a[i].id, a[i + 1].id);\n    }\n    while(r < n && make_pair(a[r].x, a[r].y) <= make_pair(a[i].x + 1, a[i].y + 1)) r++;\n    while(l < n && make_pair(a[l].x, a[l].y) < make_pair(a[i].x + 1, a[i].y - 1)) l++;\n    range(j, l, r) {\n      int dif = a[j].y - a[i].y;\n      int id;\n      if(!dif) id = 2;\n      else id = (dif > 0 ? 1 : 3);\n      edges[a[i].id][id] = a[j].id;\n      edges[a[j].id][(id + 4) % 8] = a[i].id;\n      ss.unite(a[i].id, a[j].id);\n    }\n  }\n  range(i, 0, n) if(ss.get(i) != ss.get(0)) {\n    printf(\"NO\");\n    return 0;\n  }\n  sort(a.begin(), a.end());\n  reverse(a.begin(), a.end());\n  printf(\"YES\\n\");\n  dsu st(4 * n + 1);\n  auto it = max_element(a.begin(), a.end(), [&](point a, point b){return a.y < b.y;});\n  st.unite(4 * n, 4 * it -> id);\n  unordered_map<long long, vector<int>> dog;\n  for(auto u : a) {\n    for(int i = 0; i < 8; i += 2) {\n      int v = edges[u.id][i];\n      if(v == -1) dog[dis(sp(u, i))].push_back(4 * u.id + i / 2);\n    }\n  }\n  for(auto u : a) {\n    vector<int> xs(8);\n    range(i, 0, 8) xs[i] = edges[u.id][i] >= 0;\n    for(int i = 1; i < 8; i += 2) {\n      if(!xs[i] && !xs[i - 1] && !xs[(i + 1) % 8]) st.unite(4 * u.id + i / 2, 4 * u.id + ((i + 1) % 8) / 2);\n    }\n  }\n  for(auto u : dog) {\n    point cc = point(u.first / INT_MAX, u.first % INT_MAX);\n    vector<int> id = u.second;\n    for(auto i : id) st.unite(i, id.front());\n    for(int i = 0; i < 8; i += 2) {\n      if(dog.count(dis(sp(cc, i)))) st.unite(id[0], dog[dis(sp(cc, i))][0]);\n    }\n  }\n  vector<int> alive(n, 1);\n  int iter = 0;\n  vector<int> pp(4 * n + 1);\n  auto valid = [&] (point v) {\n    iter++;\n    bool ok = false;\n    range(i, 0, 8) {\n      if(~edges[v.id][i] && alive[edges[v.id][i]]) {\n        int xs = 8;\n        i++;\n        if(i == 8) i = 0;\n        vector<int> pc;\n        while(xs--) {\n          if(~edges[v.id][i] && alive[edges[v.id][i]]) {\n            for(auto j : pc) {\n              if(pp[j] == iter) return false;\n            }\n            for(auto j : pc) pp[j] = iter;\n            pc.clear();\n          } else if(i % 2 == 0) {\n            pc.push_back(st.get(4 * v.id + i / 2));\n            ok |= st.get(4 * v.id + i / 2) == st.get(4 * n);\n          }\n          i++;\n          if(i == 8) i = 0;\n        }\n        break;\n      }\n      ok |= i == 7;\n    }\n    return ok;\n  };\n  set<point> pos;\n  range(i, 0, n) if(valid(a[i])) pos.insert(a[i]);\n  vector<vector<int>> in(4 * n + 1);\n  range(i, 0, 4 * n + 1) in[st.get(i)].push_back(i);\n  vector<int> res;\n  int cnt = 0;\n  vector<int> ap(n);\n  while(pos.size()) {\n    cnt++;\n    res.push_back(pos.begin() -> id);\n    point cc = *pos.begin();\n    pos.erase(pos.begin());\n    alive[cc.id] = 0;\n    vector<int> id, _id;\n    range(i, 0, 8) {\n      if(~edges[cc.id][i] && alive[edges[cc.id][i]]) id.push_back(edges[cc.id][i]);\n    }\n    for(int i = 0; i < 8; i += 2) {\n      if(edges[cc.id][i] == -1 || !alive[edges[cc.id][i]]) {\n        if(st.get(4 * n) != st.get(4 * cc.id + i / 2)) _id.push_back(st.get(4 * cc.id + i / 2));\n      }\n    }\n    unique(_id);\n    for(auto i : _id) {\n      for(auto j : in[i]) id.push_back(j / 4);\n    }\n    unique(id);\n    for(int i = 0; i < 8; i += 2) {\n      if(edges[cc.id][i] == -1 || !alive[edges[cc.id][i]]) {\n        st.unite(4 * cc.id + i / 2, 4 * n);\n      }\n    }\n    for(int i = 0; i < 8; i += 2) {\n      if(~edges[cc.id][i] && alive[edges[cc.id][i]]) {\n        int v = edges[cc.id][i];\n        st.unite(4 * v + ((i + 4) % 8) / 2, 4 * n);\n      }\n    }\n    for(auto i : id) {\n      if(ap[i] == cnt) continue;\n      ap[i] = cnt;\n      if(alive[i] && valid(a[i])) pos.insert(a[i]);\n      else pos.erase(a[i]);\n    }\n  }\n  reverse(res.begin(), res.end());\n  for(auto i : res) printf(\"%d\\n\", i + 1);\n  return 0;\n}\n",
    "ext": "cpp"
  },
  "57965911": {
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n \nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define st first\n#define nd second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n \n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n \ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n \ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n \ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n \n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n \nusing ll = long long;\nusing vi = vector<int>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vll = vector<ll>;\nusing ld = long double;\n \nconst int kMaxN = 2e5;\nconst int kMaxVert = 5e5;\nconst int M = 1.02e9;\n \nconst int dr[] = {-1, -1, -1, 0, 1, 1,  1,  0};\nconst int dc[] = {-1,  0,  1, 1, 1, 0, -1, -1};\nmap<int, vector<tuple<int, int, int>>> intvs;\nconst int kNumDirs = 8;\n \nvector<pii> cells;\nmap<pii, int> cell_mapping;\nbool vis[kMaxN];\nvi adj[kMaxVert];\n \nint fu_parent[kMaxVert];\n//~ vi fu_elems[kMaxVert];\n \nint n;\nint outside_vert;\nset<int> avail_verts;\nset<int> quarantine_verts;\nvector<bool> is_free;\n \nint FuFind(int v) {\n  if (v == fu_parent[v]) { return v; }\n  return fu_parent[v] = FuFind(fu_parent[v]);\n}\n \nvoid FuUnion(int a, int b) {\n  a = FuFind(a); b = FuFind(b);\n  if (a == b) { return; }\n  fu_parent[a] = b;\n  //~ if (SZ(fu_elems[a]) > SZ(fu_elems[b])) { swap(a, b); }\n  \n  //~ for (int x : {a, b}) {\n    //~ if (x == FuFind(outside_vert)) {\n      //~ const int y = x ^ a ^ b;\n      //~ for (int s : fu_elems[y]) {\n        //~ avail_verts.insert(s);\n      //~ }\n    //~ }\n  //~ }\n  \n  //~ fu_parent[a] = b;\n  //~ for (int x : fu_elems[a]) {\n    //~ fu_elems[b].PB(x);\n  //~ }\n  //~ fu_elems[a].clear();\n}\n \nint GetByID(int r, int c) {\n  auto &I = intvs[c];\n  assert(!I.empty());\n  auto iter = prev(upper_bound(ALL(I),\n      tuple<int,int,int>(r, M + 100, -1)));\n  return get<2>(*iter);\n}\n \nbool MakesDisconnected(int v) {\n  assert(v < n);\n  bool is_adj[10];\n  memset(is_adj, 0, sizeof(is_adj));\n  \n  for (int i = 0; i < 8; ++i) {\n    const int nr = cells[v].st + dr[i];\n    const int nc = cells[v].nd + dc[i];\n    //~ debug(v, nr, nc);\n    const pii np{nr, nc};\n    auto iter = cell_mapping.find(np);\n    if (iter == cell_mapping.end()) { continue; }\n    const int s = iter->nd;\n    is_adj[i] = !is_free[s];\n  }\n  \n  set<int> comp_ids;\n  for (int i = 0; i < 8; ++i) {\n    const int j = (i + 1) % 8;\n    if (is_adj[i] && !is_adj[j]) {\n      if (j % 2 == 0 && is_adj[j + 1]) { continue; }\n      debug(v, i, j);\n      const int nr = cells[v].st + dr[j];\n      const int nc = cells[v].nd + dc[j];\n      const int cid = FuFind(GetByID(nr, nc));\n      if (comp_ids.count(cid)) { return true; }\n      comp_ids.insert(cid);\n    }\n  }\n  return false;\n}\n \n \ninline void AddEdge(int u, int v) {\n  debug(u, v);\n  adj[u].PB(v); adj[v].PB(u);\n}\n \nvoid Dfs(int v) {\n  vis[v] = true;\n  for (int i = 0; i < kNumDirs; ++i) {\n    const int nr = cells[v].st + dr[i];\n    const int nc = cells[v].nd + dc[i];\n    const pii np{nr, nc};\n    auto iter = cell_mapping.find(np);\n    if (iter != cell_mapping.end()) {\n      const int s = iter->nd;\n      if (!vis[s]) { Dfs(s); }\n    }\n  }\n}\n \nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  \n  int tidx;\n  cin >> n >> tidx;\n  cells.resize(n);\n  for (auto &[r, c] : cells) { cin >> r >> c; }\n  for (int i = 0; i < n; ++i) {\n    cell_mapping[cells[i]] = i;\n  }\n  \n  Dfs(0);\n  for (int i = 0; i < n; ++i) {\n    if (!vis[i]) {\n      cout << \"NO\\n\";\n      return 0;\n    }\n  }\n  \n  int min_c = M, max_c = -M;\n  map<int, vector<pii>> cell_cols;\n  for (int i = 0; i < n; ++i) {\n    mini(min_c, cells[i].nd);\n    maxi(max_c, cells[i].nd);\n    cell_cols[cells[i].nd].emplace_back(cells[i].st, i);\n  }\n  \n  assert(max_c - min_c <= n);\n  \n  int cur_id = n;\n  \n  for (int col = min_c; col <= max_c; ++col) {\n    vector<pii> rows = cell_cols[col];\n    assert(!rows.empty());\n    sort(ALL(rows));\n    \n    int last_r = -M;\n    \n    for (auto &&[r, idx] : rows) {\n      if (last_r < r - 1) {\n        intvs[col].emplace_back(last_r + 1, r, cur_id++);\n      }\n      intvs[col].emplace_back(r, r + 1, idx);\n      last_r = r;\n    }\n    intvs[col].emplace_back(last_r + 1, M, cur_id++);\n  }\n  \n  intvs[min_c - 1].emplace_back(-M, M, cur_id++);\n  intvs[max_c + 1].emplace_back(-M, M, cur_id++);\n  const int nverts = cur_id;\n  \n  for (int col = min_c; col <= max_c; ++col) {\n    const auto &I = intvs[col];\n    const int sz = SZ(I);\n    for (int i = 1; i < sz; ++i) {\n      AddEdge(get<2>(I[i - 1]), get<2>(I[i]));\n    }\n  }\n  \n  for (int col = min_c; col <= max_c + 1; ++col) {\n    int aptr = 0, bptr = 0;\n    const auto &A = intvs[col - 1];\n    const auto &B = intvs[col];\n    while (aptr < SZ(A) && bptr < SZ(B)) {\n      const auto [al, ar, aidx] = A[aptr];\n      const auto [bl, br, bidx] = B[bptr];\n      if (ar <= bl) { ++aptr; continue; }\n      if (br <= al) { ++bptr; continue; }\n      AddEdge(aidx, bidx);\n      if (ar < br) { ++aptr; } else { ++bptr; }\n    }\n  }\n  \n  debug(nverts);\n  outside_vert = nverts - 1;\n  iota(fu_parent, fu_parent + nverts, 0);\n  //~ for (int i = 0; i < nverts; ++i) {\n    //~ fu_elems[i].PB(i);\n  //~ }\n  for (int i = n; i < nverts; ++i) {\n    for (int j : adj[i]) {\n      if (j > i) {\n        FuUnion(i, j);\n      }\n    }\n  }\n  \n  vector<bool> is_deleted(nverts);\n  avail_verts.insert(outside_vert);\n  \n  is_free.resize(nverts);\n  for (int i = n; i < nverts; ++i) {\n    is_free[i] = true;\n  }\n  \n  vi answer;\n  while (SZ(answer) < n) {\n    if (avail_verts.empty()) {\n      debug(answer);\n      debug(vi(ALL(quarantine_verts)));\n    }\n    assert(!avail_verts.empty());\n    const int v = *avail_verts.rbegin();\n    avail_verts.erase(v);\n    debug(v);\n    \n    if (v < n && MakesDisconnected(v)) {\n      quarantine_verts.insert(v);\n      continue;\n    } else {\n      is_free[v] = is_deleted[v] = true;\n      if (v < n) { answer.PB(v); }\n      for (int s : adj[v]) {\n        if (!is_deleted[s]) { avail_verts.insert(s); }\n        quarantine_verts.erase(s);\n        if (is_free[s]) {\n          FuUnion(v, s);\n        }\n      }\n      \n      if (v < n) {\n        for (int ddr : {-1, 1}) {\n          for (int ddc : {-1, 1}) {\n            bool any_free = false;\n            const int nrow = GetByID(cells[v].st + ddr, cells[v].nd);\n            any_free |= is_free[nrow];\n            const int ncol = GetByID(cells[v].st, cells[v].nd + ddc);\n            any_free |= is_free[ncol];\n            if (!any_free) { continue; }\n            \n            pii np{cells[v].st + ddr, cells[v].nd + ddc};\n            auto iter = cell_mapping.find(np);\n            if (iter != cell_mapping.end()) {\n              const int s = iter->nd;\n              if (!is_deleted[s]) {\n                avail_verts.insert(s); quarantine_verts.erase(s);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  reverse(ALL(answer));\n  cout << \"YES\\n\";\n  for (int x : answer) { cout << x + 1 << \"\\n\"; }\n}\n",
    "ext": "cpp"
  },
  "57956709": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(x) ((int) ((x).size()))\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll mul = 2000100100LL;\n\nint n, m, outs;\nll pos[9 * 150000];\nbool sc[9 * 150000];\nunordered_map<ll, int> pti;\n\nbool isPoint(ll p) {\n  return pti.find(p) != pti.end();\n}\n\nll point(int i, int j) {\n  return i + j * mul;\n}\n\nint getX(ll p) {\n  return p % mul;\n}\n\nint getY(ll p) {\n  return p / mul;\n}\n\nint par[9 * 150000];\nvector<int> ot[9 * 150000];\npriority_queue<int> pq;\n\nvoid init(int n) {\n  for (int i = 0; i < n; i++)\n    par[i] = i;\n}\n\nint findSet(int i) {\n  return i == par[i] ? i : (par[i] = findSet(par[i]));\n}\n\nbool inSameSet(int i, int j) {\n  return findSet(i) == findSet(j);\n}\n\nvoid unionSet(int i, int j) {\n  i = findSet(i);\n  j = findSet(j);\n  if (i == j)\n    return;\n  if (sz(ot[j]) < sz(ot[i]))\n    swap(ot[j], ot[i]);\n  for (int k : ot[i])\n    ot[j].push_back(k);\n  par[i] = j;\n}\n\nvoid toPQ(int i) {\n  i = findSet(i);\n  for (int j : ot[i])\n    pq.push(j);\n  ot[i].clear();\n}\n\nvoid removeS(int i) {\n  sc[i] = false;\n  for (int dx = -1; dx < 2; dx += 2) {\n    ll p = point(getX(pos[i]) + dx, getY(pos[i]));\n    if (isPoint(p) && !sc[pti[p]])\n      unionSet(i, pti[p]);\n    if (inSameSet(pti[p], outs))\n      toPQ(pti[p]);\n  }\n  for (int dy = -1; dy < 2; dy += 2) {\n    ll p = point(getX(pos[i]), getY(pos[i]) + dy);\n    if (isPoint(p) && !sc[pti[p]])\n      unionSet(i, pti[p]);\n    if (inSameSet(pti[p], outs))\n      toPQ(pti[p]);\n  }\n  if (inSameSet(i, outs))\n    toPQ(i);\n}\n\nint ddx[8] = {1, 1, 0, -1, -1, -1, 0, 1}, ddy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nbool canRemove(int i) {\n  bool canReachOutside = false;\n  for (int jj = 0; jj < 8; jj++) {\n    int j = pti[point(getX(pos[i]) + ddx[jj], getY(pos[i]) + ddy[jj])];\n    if (!sc[j]) {\n      if (inSameSet(j, outs) && (ddx[jj] == 0 || ddy[jj] == 0))\n        canReachOutside = true;\n      continue;\n    }\n    for (int kk = (jj + 1) % 8; kk != jj; kk = (kk + 1) % 8) {\n      if (ddx[kk] != 0 && ddy[kk] != 0)\n        continue;\n      int k = pti[point(getX(pos[i]) + ddx[kk], getY(pos[i]) + ddy[kk])];\n      if (sc[k])\n        continue;\n      for (int ll = (kk + 1) % 8; ll != jj; ll = (ll + 1) % 8) {\n        int l = pti[point(getX(pos[i]) + ddx[ll], getY(pos[i]) + ddy[ll])];\n        if (!sc[l])\n          continue;\n        for (int oo = (ll + 1) % 8; oo != jj; oo = (oo + 1) % 8) {\n          if (ddx[oo] != 0 && ddy[oo] != 0)\n            continue;\n          int o = pti[point(getX(pos[i]) + ddx[oo], getY(pos[i]) + ddy[oo])];\n          if (sc[o])\n            continue;\n          if (inSameSet(k, o))\n            return false;\n        }\n      }\n    }\n  }\n  return canReachOutside;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  cin >> n;\n  int tt;\n  cin >> tt;\n  int r, c;\n  for (int i = 0; i < n; i++) {\n    cin >> r >> c;\n    r += 1000000100;\n    c += 1000000100;\n    pos[i] = point(r, c);\n    pti[pos[i]] = i;\n    sc[i] = true;\n  }\n  init(n);\n  m = n;\n  int minx = mul;\n  for (int i = 0; i < n; i++)\n    for (int dx = -1; dx < 2; dx++)\n      for (int dy = -1; dy < 2; dy++) {\n        ll p = point(getX(pos[i]) + dx, getY(pos[i]) + dy);\n        if (isPoint(p) && sc[pti[p]])\n          unionSet(i, pti[p]);\n        else if (!isPoint(p))\n          pos[m] = p, pti[p] = m++;\n        if (dx == 0 || dy == 0)\n          ot[pti[p]].push_back(i);\n        if (getX(p) < minx)\n          minx = getX(p), outs = m - 1;\n      }\n  for (int i = 0; i < n; i++)\n    if (!inSameSet(0, i)) {\n      cout << \"NO\\n\";\n      return 0;\n    }\n  init(m);\n  for (int i = n; i < m; i++)\n    removeS(i);\n  vector<int> res;\n  for (int i = 0; i < n; i++)\n    pq.push(i);\n  while (!pq.empty()) {\n    while (!pq.empty() && (!sc[pq.top()] || !canRemove(pq.top())))\n      pq.pop();\n    if (pq.empty())\n      break;\n    int i = pq.top();\n    pq.pop();\n    removeS(i);\n    res.push_back(i);\n    for (int dx = -1; dx < 2; dx++)\n      for (int dy = -1; dy < 2; dy++) {\n        ll p = point(getX(pos[i]) + dx, getY(pos[i]) + dy);\n        if (sc[pti[p]])\n          pq.push(pti[p]);\n      }\n  }\n  cout << \"YES\\n\";\n  for (int i = sz(res) - 1; i >= 0; i--)\n    cout << res[i] + 1 << \"\\n\";\n}\n",
    "ext": "cpp"
  },
  "57913906": {
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=150005,f2[8]={-1,-1,-1,0,1,1,1,0},f1[8]={-1,0,1,1,1,0,-1,-1};\ntypedef pair<int,int>pii;\nint n,i,j,x,y,r[N],c[N],adj[N*9][8],nn,tmpp[N],ans[N],col[N*9],ccnt;\nmap<pii,int>s,s2;\nunordered_map<int,pii>xx,yy;\nbool b1[N*9],b2[N*9],ins[N],bb[N*9];\ninline void upd(pii&a,int b){a.first=min(a.first,b);a.second=max(a.second,b);}\nvoid dfs(int u){b1[u]=1;for(int i:adj[u])if(i && i<=n && !b1[i])dfs(i);}\nset<int>S;\ninline void calc(int x){\n\tint old=ins[x],i,j;static int a[4];static bool b[8];\n\tfor(i=0;i<4;++i)a[i]=adj[x][i*2+1],a[i]=b1[a[i]]?-1:(b2[a[i]]?0:col[a[i]]);\n\tfor(i=0;i<8;++i)b[i]=b1[adj[x][i]];\n\tins[x]=!a[0] || !a[1] || !a[2] || !a[3];\n\tfor(i=0;i<4 && ins[x];++i)if(j=i*2+2,a[i]>=0 && a[i+1&3]>=0 && a[i]==a[i+1&3] && b[j&7] && \n\t\t(b[j+2&7] || b[j+3&7] || b[j+4&7] || b[j+5&7] || b[j+6&7]))ins[x]=0;\n\tif(ins[x] && a[0]>=0 && a[2]>=0 && a[0]==a[2] && (b1[adj[x][0]] || b1[adj[x][7]] || b1[adj[x][6]]) && \n\t\t(b1[adj[x][2]] || b1[adj[x][3]] || b1[adj[x][4]]))ins[x]=0;\n\tif(ins[x] && a[1]>=0 && a[3]>=0 && a[1]==a[3] && (b1[adj[x][0]] || b1[adj[x][1]] || b1[adj[x][2]]) && \n\t\t(b1[adj[x][4]] || b1[adj[x][5]] || b1[adj[x][6]]))ins[x]=0;\n\tif(ins[x]!=old){if(ins[x])S.insert(x);else S.erase(x);}\n}\nvoid dfss(int x){\n\tb2[x]=1;\n\tfor(int i=1,y;i<8;i+=2)if(y=adj[x][i],!b1[y] && !b2[y])dfss(y);\n\tfor(int y:adj[x])if(b1[y] && !bb[y])bb[y]=1,tmpp[++*tmpp]=y;\n}\nvoid dfs2(int x){col[x]=ccnt;for(int i=1;i<8;i+=2)if(!b1[adj[x][i]] && !col[adj[x][i]])dfs2(adj[x][i]);}\ninline void del(int x){\n\tb1[x]=0;*tmpp=0;dfss(x);\n\tfor(int i=1;i<=*tmpp;++i)calc(tmpp[i]),bb[tmpp[i]]=0;\n}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>n>>i;for(i=1;i<=n;++i)cin>>r[i]>>c[i],s[pii(r[i],c[i])]=i;nn=n;\n\tfor(i=1;i<=n;++i)for(j=0;j<8;++j){\n\t\tx=r[i]+f1[j],y=c[i]-f2[j];\n\t\tauto it=s.find(pii(x,y));\n\t\tif(it!=s.end())adj[i][j]=it->second;else{\n\t\t\tauto u=s2.insert(make_pair(pii(x,y),0));\n\t\t\tif(u.second){\n\t\t\t\tu.first->second=++nn;\n\t\t\t\tauto v=xx.insert(make_pair(x,pii(y,y)));\n\t\t\t\tif(!v.second)upd(v.first->second,y);\n\t\t\t\tauto w=yy.insert(make_pair(y,pii(x,x)));\n\t\t\t\tif(!w.second)upd(w.first->second,x);\n\t\t\t}\n\t\t\tadj[i][j]=u.first->second;adj[u.first->second][j^4]=i;\n\t\t}\n\t}\n\tdfs(1);\n\tfor(i=1;i<=n;++i)if(!b1[i])return cout<<\"NO\\n\",0;\n\tcout<<\"YES\\n\";\n\tfor(auto u:s2){\n\t\tx=u.first.first,y=u.first.second;\n\t\tpii a=xx[x],b=yy[y];\n\t\tif(a.first==y || a.second==y || b.first==x || b.second==x)b2[u.second]=1;\n\t\tauto v=s2.find(pii(x-1,y));\n\t\tif(v!=s2.end())adj[u.second][7]=v->second,adj[v->second][3]=u.second;\n\t\tauto w=s2.find(pii(x,y+1));\n\t\tif(w!=s2.end())adj[u.second][1]=w->second,adj[w->second][5]=u.second;\n\t}\n\tfor(i=n+1;i<=nn;++i)if(b2[i])dfss(i);for(i=n+1;i<=nn;++i)if(!b2[i] && !col[i])++ccnt,dfs2(i);\n\tfor(i=1;i<=*tmpp;++i)calc(tmpp[i]),bb[tmpp[i]]=0;\n\tfor(i=1;i<=n;++i)del(ans[i]=*S.rbegin()),S.erase(ans[i]);\n\tfor(;--i;)cout<<ans[i]<<'\\n';\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57894740": {
    "code": "#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<map>\n#include<queue>\n#define N_ 1510000\n#define pii pair<int,int>\nusing namespace std;\n \nint dx[8] = { -1,-1,-1,0,1,1,1,0 }, dy[8] = { 1,0,-1,-1,-1,0,1,1 };\n \nint UF[N_];\nmap<pii, int>Map, Map2;\n \nint n;\n \nstruct point {\n\tint x, y;\n}P[N_];\n \nvector<int>E[N_], G[N_];\n \nint Num[N_], cnt;\nset<pii>Set;\n \nvoid DFS(int a) {\n\tNum[a] = ++cnt;\n\tfor (auto &x : E[a]) {\n\t\tif (!Num[x]) DFS(x);\n\t}\n}\n \n \nint vis[N_], blocked[N_], pos[N_], w[N_][9];\nint BN[N_], ReNum[N_], Q[N_], head, tail;\n \nint Find(int a) {\n\tif (a == UF[a])return a;\n\treturn UF[a] = Find(UF[a]);\n}\nvoid Merge(int a, int b) {\n\ta = Find(a), b = Find(b);\n\tif (a != b)UF[a] = b;\n}\n \npriority_queue<int>PQ;\nvoid BFS() {\n\twhile (head < tail) {\n\t\tint x = Q[++head];\n\t\tfor (auto &t : G[x]) {\n\t\t\tif (vis[t])continue;\n\t\t\tif (!blocked[t]) {\n\t\t\t\tQ[++tail] = t;\n\t\t\t\tvis[t] = 1;\n\t\t\t}\n\t\t\telse if (!pos[t]) {\n\t\t\t\tpos[t] = 1;\n\t\t\t\tPQ.push(ReNum[t]);\n\t\t\t}\n\t\t}\n\t}\n}\n \nint main() {\n\tint i, j, sub;\n\tscanf(\"%d%d\", &n, &sub);\n\tfor (i = 1; i <= n; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x,&y);\n\t\tP[i] = { x,y };\n\t\tMap[{x, y}] = i;\n\t\tSet.insert({ x,y });\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tint tx = P[i].x + dx[j], ty = P[i].y + dy[j];\n\t\t\tSet.insert({ tx,ty });\n\t\t\tif (Map.count({ tx,ty })) {\n\t\t\t\tE[i].push_back(Map[{tx, ty}]);\n\t\t\t}\n\t\t}\n\t}\n\tDFS(1);\n\tif (cnt != n) {\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tint c = 0;\n\tfor (auto &t : Set) {\n\t\tMap2[t] = ++c;\n\t}\n\tfor (auto &t : Set) {\n\t\tint a = Map2[t];\n\t\tfor (j = 1; j < 8; j+=2) {\n\t\t\tint tx = t.first + dx[j], ty = t.second + dy[j];\n\t\t\tif (Map2.count({ tx, ty })) {\n\t\t\t\tG[a].push_back(Map2[{tx, ty}]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tint tx = P[i].x + dx[j], ty = P[i].y + dy[j];\n\t\t\tw[i][j] = Map2[{tx, ty}];\n\t\t}\n\t}\n \n\tfor (i = 1; i <= n; i++) {\n\t\tBN[i] = Map2[{P[i].x, P[i].y}];\n\t\tReNum[BN[i]] = i;\n\t\tblocked[BN[i]] = 1;\n\t}\n \n\tfor (i = 1; i <= c; i++)UF[i] = i;\n\tfor (i = 1; i <= c; i++){\n\t\tfor (auto &x : G[i]) {\n\t\t\tif (!blocked[i] && !blocked[x])Merge(i, x);\n\t\t}\n\t}\n\tQ[++tail] = 1;\n\tvis[1] = 1;\n\tBFS();\n\tvector<int>Res;\n\twhile (!PQ.empty()) {\n\t\tint a = PQ.top();\n\t\tPQ.pop();\n\t\tint x = BN[a], ck = 0;\n\t\tif (!pos[x] || !blocked[x])continue;\n\t\tint pv = -1;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tint t = w[a][i];\n\t\t\tif (blocked[t])pv = i;\n\t\t}\n\t\tif (pv != -1) {\n\t\t\tint TP[9], cc = 0;\n\t\t\tfor (i = 0; i < 8; i++)TP[i] = 0;\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tint t = w[a][(pv+i)%8];\n\t\t\t\tif (blocked[t]) cc++;\n\t\t\t\telse TP[(pv+i)%8] = cc;\n\t\t\t}\n\t\t\tfor (i = 1; i < 8; i += 2) {\n\t\t\t\tfor (int j = i+2; j < 8; j += 2) {\n\t\t\t\t\tint t1 = w[a][i], t2 = w[a][j];\n\t\t\t\t\tif (!blocked[t1] && !blocked[t2] && TP[i] != TP[j] && Find(t1) == Find(t2))ck = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ck)continue;\n\t\t}\n \n\t\tRes.push_back(a);\n\t\tblocked[x] = 0;\n\t\tQ[++tail] = x;\n\t\tvis[x] = 1;\n\t\tBFS();\n\t\tfor (auto &z : G[x]) {\n\t\t\tif (!blocked[z])Merge(x, z);\n\t\t}\n\t\tfor (auto &z : E[a]) {\n\t\t\tPQ.push(z);\n\t\t}\n\t}\n\tputs(\"YES\");\n\treverse(Res.begin(), Res.end());\n\tfor (auto &t : Res)printf(\"%d\\n\", t);\n}\n",
    "ext": "cpp"
  },
  "57871306": {
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=150005,f2[8]={-1,-1,-1,0,1,1,1,0},f1[8]={-1,0,1,1,1,0,-1,-1};\ntypedef pair<int,int>pii;\nint n,i,j,x,y,r[N],c[N],adj[N*9][8],nn,tmpp[N],ans[N],col[N*9],ccnt;\nmap<pii,int>s,s2;\nunordered_map<int,pii>xx,yy;\nbool b1[N*9],b2[N*9],ins[N],bb[N*9];\ninline void upd(pii&a,int b){a.first=min(a.first,b);a.second=max(a.second,b);}\nvoid dfs(int u){b1[u]=1;for(int i:adj[u])if(i && i<=n && !b1[i])dfs(i);}\nset<int>S;\ninline void calc(int x){\n\tint old=ins[x],i,j;static int a[4];static bool b[8];\n\tfor(i=0;i<4;++i)a[i]=adj[x][i*2+1],a[i]=b1[a[i]]?-1:(b2[a[i]]?0:col[a[i]]);\n\tfor(i=0;i<8;++i)b[i]=b1[adj[x][i]];\n\tins[x]=!a[0] || !a[1] || !a[2] || !a[3];\n\tfor(i=0;i<4 && ins[x];++i)if(j=i*2+2,a[i]>=0 && a[i+1&3]>=0 && a[i]==a[i+1&3] && b[j&7] && \n\t\t(b[j+2&7] || b[j+3&7] || b[j+4&7] || b[j+5&7] || b[j+6&7]))ins[x]=0;\n\tif(ins[x] && a[0]>=0 && a[2]>=0 && a[0]==a[2] && (b1[adj[x][0]] || b1[adj[x][7]] || b1[adj[x][6]]) && \n\t\t(b1[adj[x][2]] || b1[adj[x][3]] || b1[adj[x][4]]))ins[x]=0;\n\tif(ins[x] && a[1]>=0 && a[3]>=0 && a[1]==a[3] && (b1[adj[x][0]] || b1[adj[x][1]] || b1[adj[x][2]]) && \n\t\t(b1[adj[x][4]] || b1[adj[x][5]] || b1[adj[x][6]]))ins[x]=0;\n\tif(ins[x]!=old){if(ins[x])S.insert(x);else S.erase(x);}\n}\nvoid dfss(int x){\n\tb2[x]=1;\n\tfor(int i=1,y;i<8;i+=2)if(y=adj[x][i],!b1[y] && !b2[y])dfss(y);\n\tfor(int y:adj[x])if(b1[y] && !bb[y])bb[y]=1,tmpp[++*tmpp]=y;\n}\nvoid dfs2(int x){col[x]=ccnt;for(int i=1;i<8;i+=2)if(!b1[adj[x][i]] && !col[adj[x][i]])dfs2(adj[x][i]);}\ninline void del(int x){\n\tb1[x]=0;*tmpp=0;dfss(x);\n\tfor(int i=1;i<=*tmpp;++i)calc(tmpp[i]),bb[tmpp[i]]=0;\n}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>n>>i;for(i=1;i<=n;++i)cin>>r[i]>>c[i],s[pii(r[i],c[i])]=i;nn=n;\n\tfor(i=1;i<=n;++i)for(j=0;j<8;++j){\n\t\tx=r[i]+f1[j],y=c[i]-f2[j];\n\t\tauto it=s.find(pii(x,y));\n\t\tif(it!=s.end())adj[i][j]=it->second;else{\n\t\t\tauto u=s2.insert(make_pair(pii(x,y),0));\n\t\t\tif(u.second){\n\t\t\t\tu.first->second=++nn;\n\t\t\t\tauto v=xx.insert(make_pair(x,pii(y,y)));\n\t\t\t\tif(!v.second)upd(v.first->second,y);\n\t\t\t\tauto w=yy.insert(make_pair(y,pii(x,x)));\n\t\t\t\tif(!w.second)upd(w.first->second,x);\n\t\t\t}\n\t\t\tadj[i][j]=u.first->second;adj[u.first->second][j^4]=i;\n\t\t}\n\t}\n\tdfs(1);\n\tfor(i=1;i<=n;++i)if(!b1[i])return cout<<\"NO\\n\",0;\n\tcout<<\"YES\\n\";\n\tfor(auto u:s2){\n\t\tx=u.first.first,y=u.first.second;\n\t\tpii a=xx[x],b=yy[y];\n\t\tif(a.first==y || a.second==y || b.first==x || b.second==x)b2[u.second]=1;\n\t\tauto v=s2.find(pii(x-1,y));\n\t\tif(v!=s2.end())adj[u.second][7]=v->second,adj[v->second][3]=u.second;\n\t\tauto w=s2.find(pii(x,y+1));\n\t\tif(w!=s2.end())adj[u.second][1]=w->second,adj[w->second][5]=u.second;\n\t}\n\tfor(i=n+1;i<=nn;++i)if(b2[i])dfss(i);for(i=n+1;i<=nn;++i)if(!b2[i] && !col[i])++ccnt,dfs2(i);\n\tfor(i=1;i<=*tmpp;++i)calc(tmpp[i]),bb[tmpp[i]]=0;\n\tfor(i=1;i<=n;++i)del(ans[i]=*S.rbegin()),S.erase(ans[i]);\n\tfor(;--i;)cout<<ans[i]<<'\\n';\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57860114": {
    "code": "#include <bits/stdc++.h>\n\n//#pragma GCC optimize (\"O3\")\n//#pragma GCC optimize (\"Ofast\")\n\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define LBS 20\n#define MOD ((long long)1e9+7) //1e9+9\n#define LEFT(i) (2*(i))\n#define RIGHT(i) (2*(i)+1)\n#define PAR(i) ((i)/2)\n#define MAX 1000000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double rat;\ntypedef long long bi;\ntypedef pair<ll, ll> ii;\ntypedef pair<ii, pair<int, int> > iiii;\ntypedef std::vector<ii> vii;\ntypedef std::map<int, int> mii;\ntypedef bitset<LBS> bis;\ntypedef std::vector<bis> vbs;\ntypedef priority_queue<int> pqi;\n\nvoid vin(std::vector<int> &a){\n  for(auto &x: a)\n    cin >> x;\n}\n\nvoid vout(std::vector<int> &a){\n  for(auto x: a)\n    cout << x << \" \";\n  cout << endl;\n}\n\nstd::vector<set<int> > pqp, pqb;\n\nstruct UF{\n  std::vector<int> p;\n  UF(int n){\n    p.resize(n);\n    pqb.resize(n);\n    pqp.resize(n);\n    iota(p.begin(), p.end(), 0);\n  }\n  int root(int a){\n    if(a==p[a]) return a;\n    return (p[a]=root(p[a]));\n  }\n  bool find(int a, int b) { return root(a)==root(b); }\n  void connect(int a, int b) {\n    a=root(a);\n    b=root(b);\n    if(a==b)\n      return;\n    if(pqp[a].size()<pqp[b].size())\n      swap(a, b);\n    p[b]=a;\n    for(auto x: pqp[b])\n      pqp[a].insert(x);\n    pqp[b].clear();\n  }\n};\n\nstd::vector<ii> nei{MP(-1, 0), MP(-1, 1), MP(0, 1), MP(1, 1), MP(1, 0), MP(1, -1), MP(0, -1), MP(-1, -1)};\n\nstd::vector<iiii> s;\n\nint indexb(ll x, ll y){\n  auto it = lower_bound(s.begin(), s.end(), MP(MP(x, y), MP(-1, -1)));\n  if(it==s.end())\n    return -1;\n  if(it->F==MP(x,y) && it->S.S)\n    return it-s.begin();\n  return -1;\n}\n\nint indexp(ll x, ll y){\n  auto it = lower_bound(s.begin(), s.end(), MP(MP(x, y), MP(-1, -1)));\n  if(it==s.end())\n    return 0;\n  if(it->F==MP(x,y) && it->S.S)\n    return -1;\n  return it-s.begin();\n}\n\n\nint main(){\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int n, tin;\n  cin >> n >> tin;\n  s.resize(n);\n  ll xmi=MAX, xma=-MAX, ymi=MAX, yma=-MAX;\n  for(int i=0; i<n; i++){\n    cin >> s[i].F.F >> s[i].F.S;\n    s[i].S.F=i; s[i].S.S=1;\n    xmi=min(xmi, s[i].F.F);\n    xma=max(xma, s[i].F.F);\n    ymi=min(ymi, s[i].F.S);\n    yma=max(yma, s[i].F.S);\n  }\n  if(xma-xmi>n || yma-ymi>n){\n    cout << \"NO\\n\";\n    return 0;\n  }\n  sort(s.begin(), s.end());\n  UF buf(n);\n  for(int i=0; i<n; i++){\n    int j=indexb(s[i].F.F+1, s[i].F.S);\n    if(j!=-1)\n      buf.connect(i, j);\n    j=indexb(s[i].F.F, s[i].F.S+1);\n    if(j!=-1)\n      buf.connect(i, j);\n    j=indexb(s[i].F.F+1, s[i].F.S+1);\n    if(j!=-1)\n      buf.connect(i, j);\n    j=indexb(s[i].F.F+1, s[i].F.S-1);\n    if(j!=-1)\n      buf.connect(i, j);\n  }\n  for(int i=1; i<n; i++)\n    if(!buf.find(0, i)){\n      cout << \"NO\\n\"; cerr << \"bufno\\n\";\n      return 0;\n    }\n  cerr << \"bufsi\\n\";\n  UF puf(n);\n  for(int i=0; i<n; i++){\n    if(i>0 && s[i].F.F==s[i-1].F.F){\n      if(s[i].F.F==xmi && s[i].F.S>s[i-1].F.S+1)\n        puf.connect(i,0);\n      for(int j=s[i-1].F.S+1; j<s[i].F.S; j++){\n        int k=indexp(s[i-1].F.F+1, j);\n        if(k==-1)\n          continue;\n        puf.connect(i,k);\n        if(s[k].F.S<j)\n          break;\n        j=s[k].F.S;\n      }\n    } else {\n      puf.connect(i, 0);\n      for(int j=s[(i+n-1)%n].F.S+1; j<=yma; j++){\n        int k=indexp(s[(i+n-1)%n].F.F+1, j);\n        if(k==-1)\n          continue;\n        puf.connect(i,k);\n        if(s[k].F.S<j)\n          break;\n        j=s[k].F.S;\n      }\n      for(int j=ymi; j<s[i].F.S; j++){\n        int k=indexp(s[i].F.F+1, j);\n        if(k==-1)\n          continue;\n        puf.connect(i,k);\n        if(s[k].F.S<j)\n          break;\n        j=s[k].F.S;\n      }\n    }\n  }\n  // for(int i=0; i<n; i++)\n  //   cout << s[i].S.F<<\" \";\n  // cout << \"\\n\";\n  // vout(puf.p);\n  std::vector<int> ord(n, -1);\n  std::vector<int> is(n);\n  pqi pqm;\n  for(int i=0; i<n; i++){\n    is[s[i].S.F]=i;\n    pqm.push(i);\n  }\n  int o=n-1;\n  int ccfo=0;\n  while (!pqm.empty()) {\n    int i=pqm.top(); pqm.pop();\n    ccfo++;\n    // cerr << i << \"\\n\";\n    auto b=s[is[i]];\n    int ip=indexb(b.F.F, b.F.S);\n    if(ip==-1)\n      continue;\n    int co=0;\n\n    for(int j=0; j<8; j+=2){\n      int p=indexp(b.F.F+nei[j].F, b.F.S+nei[j].S);\n      if(p!=-1 && puf.find(p, 0))\n        co=1;\n      else if(p!=-1)\n        pqp[puf.root(p)].emplace(ip);\n      else\n        pqb[indexb(b.F.F+nei[j].F, b.F.S+nei[j].S)].emplace(ip);\n    }\n\n    if(co){\n      std::vector<int> bw;\n      // cerr << \"co\\n\";\n      for(int j=0; j<8; j++){\n        int x=b.F.F+nei[j].F, y=b.F.S+nei[j].S;\n        int a=indexp(x, y);\n        if(a==-1){\n          a=indexb(x,y);\n          pqb[a].emplace(ip);\n          continue;\n        }\n        x=b.F.F+nei[(j+1)%8].F, y=b.F.S+nei[(j+1)%8].S;\n        if(indexb(x, y)==-1)\n          continue;\n        if(j%2){\n          x=b.F.F+nei[(j+7)%8].F, y=b.F.S+nei[(j+7)%8].S;\n          if(indexp(x, y)==-1)\n            continue;\n        }\n        bw.PB(a);\n      }\n      for(int i=0; i<(int)bw.size(); i++)\n        for(int j=i+1; j<(int)bw.size(); j++)\n          if(puf.find(bw[i], bw[j])){\n            co=0;\n            break;\n          }\n    }\n    int ch=0;\n    if(co){\n      // cerr << \"co2\\n\";\n      s[is[i]].S.S=0;\n      if(indexb(b.F.F-1, b.F.S)==-1 && !puf.find(indexp(b.F.F-1, b.F.S), ip)){\n        ch++; puf.connect(indexp(b.F.F-1, b.F.S), ip);\n      }\n      if(indexb(b.F.F+1, b.F.S)==-1 && !puf.find(indexp(b.F.F+1, b.F.S), ip)){\n        ch++; puf.connect(indexp(b.F.F+1, b.F.S), ip);\n      }\n      if(indexb(b.F.F, b.F.S-1)==-1 && !puf.find(indexp(b.F.F, b.F.S-1), ip)){\n        ch++; puf.connect(indexp(b.F.F, b.F.S-1), ip);\n      }\n      if(indexb(b.F.F, b.F.S+1)==-1 && !puf.find(indexp(b.F.F, b.F.S+1), ip)){\n        ch++; puf.connect(indexp(b.F.F, b.F.S+1), ip);\n      }\n      ord[i]=o--;\n      // next[prev[i]]=next[i];\n      // if(next[i]!=-1)\n      //   prev[next[i]]=prev[i];\n      if(i==69)\n        cerr << \"helloworld\\n\";\n      for(auto x: pqp[puf.root(ip)])\n        pqm.emplace(s[x].S.F);\n      pqp[puf.root(ip)].clear();\n      for(auto x: pqb[ip])\n        pqm.emplace(s[x].S.F);\n      pqb[ip].clear();\n    }\n    // if(tin==1){\n    //   if(o==-1)\n    //     break;\n    //   if(co){\n    //     for(auto x: nei)\n    //       if(indexb(b.F.F+x.F, b.F.S+x.S)!=-1){\n    //         i=prev[s[indexb(b.F.F+x.F, b.F.S+x.S)].S.F];\n    //         break;\n    //       }\n    //   }\n    //   else if(next[i]==-1)\n    //     i=n;\n    //   continue;\n    // }\n    // if(co && ch)\n    //   i=n;\n    // else if(co){\n    //   int ne=i;\n    //   for(auto x: nei)\n    //     if(indexb(b.F.F+x.F, b.F.S+x.S)!=-1)\n    //       ne=max(ne, prev[s[indexb(b.F.F+x.F, b.F.S+x.S)].S.F]);\n    //   i=ne;\n    // }\n  }\n\n  cerr << ccfo << \"\\n\";\n  assert(o==-1);\n  cout << \"YES\\n\";\n  std::vector<int> out(n);\n  for(int i=0; i<n; i++){\n    assert(ord[i]!=-1);\n    out[ord[i]]=i+1;\n  }\n  vout(out);\n}\n",
    "ext": "cpp"
  },
  "57859305": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 150150;\nconst int M = 9 * N;\nconst int dx[] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dy[] = {-1, 0, 1, 1, 1, 0, -1, -1};\n\nint n, m;\npair<int, int> a[N];\npair<int, int> ps[M];\nint id[N], revId[M];\nint p[M];\nbool visit[N];\nint g[M][8];\nbool goOut[M], inQ[N];\npriority_queue<int> q;\n\nint getp(int v) {\n   if (p[v] != v) {\n      p[v] = getp(p[v]);\n   }\n   return p[v];\n}\n\nvoid mrg(int v, int u) {\n   v = getp(v);\n   u = getp(u);\n   p[v] = u;\n}\n\nvoid dfs(int v) {\n   if (revId[v] == -1) return;\n   if (visit[revId[v]]) return;\n   visit[revId[v]] = true;\n   for (int u : g[v]) {\n      dfs(u);\n   }\n}\n\nvoid dfsGo(int v) {\n   if (v == -1) return;\n   if (goOut[v]) return;\n   goOut[v] = true;\n   if (revId[v] != -1) {\n      if (!inQ[revId[v]]) {\n         inQ[revId[v]] = true;\n         q.push(revId[v]);\n      }\n      return;\n   }\n   for (int d = 1; d < 8; d += 2){\n      dfsGo(g[v][d]);\n   }\n}\n\nbool isImp(int v) {\n   v = id[v];\n   int deg = 0;\n   for (int d = 0; d < 8; ++d) {\n      deg += (revId[g[v][d]] != -1);\n   }\n   for (int x = 1; x < 8; x += 2) {\n      for (int y = x + 2; y < 8; y += 2) {\n         if (getp(g[v][x]) != getp(g[v][y])) continue;\n         int mdeg = 0;\n         for (int z = x + 1; z < y; ++z) {\n            mdeg += (revId[g[v][z]] != -1);\n         }\n         if (0 < mdeg && mdeg < deg) {\n            return true;\n         }\n      }\n   }\n   return false;\n}\n\nint main() {\n   ios_base::sync_with_stdio(false);\n   int t;\n   cin >> n >> t;\n   for (int i = 0; i < n; ++i) {\n      cin >> a[i].first >> a[i].second;\n      ps[m++] = a[i];\n      for (int d = 0; d < 8; ++d) {\n         ps[m++] = {a[i].first + dx[d], a[i].second + dy[d]};\n      }\n   }\n   sort(ps, ps + m);\n   m = unique(ps, ps + m) - ps;\n   fill(revId, revId + m, -1);\n   for (int i = 0; i < n; ++i) {\n      id[i] = lower_bound(ps, ps + m, a[i]) - ps;\n      revId[id[i]] = i;\n   }\n   for (int i = 0; i < m; ++i) {\n      for (int d = 0; d < 8; ++d) {\n         pair<int, int> np = {ps[i].first + dx[d], ps[i].second + dy[d]};\n         int j = lower_bound(ps, ps + m, np) - ps;\n         if (j < m && ps[j] == np) {\n            g[i][d] = j;\n         } else {\n            g[i][d] = -1;\n         }\n      }\n   }\n   dfs(id[0]);\n   for (int i = 0; i < n; ++i) {\n      if (!visit[i]) {\n         cout << \"NO\\n\";\n         return 0;\n      }\n   }\n   iota(p, p + m, 0);\n   for (int i = 0; i < m; ++i) if (revId[i] == -1) {\n      for (int d = 1; d < 8; d += 2) {\n         int j = g[i][d];\n         if (j == -1) continue;\n         if (revId[j] == -1) {\n            mrg(i, j);\n         }\n      }\n   }\n   dfsGo(0);\n   deque<int> ans;\n   while (!q.empty()) {\n      int v = q.top();\n      q.pop();\n      inQ[v] = false;\n      if (isImp(v)) continue;\n      ans.push_front(v);\n      v = id[v];\n      revId[v] = -1;\n      for (int d = 1; d < 8; d += 2) {\n         int u = g[v][d];\n         if (revId[u] == -1) {\n            mrg(v, u);\n         }\n      }\n      goOut[v] = false;\n      dfsGo(v);\n      for (int u : g[v]) {\n         if (revId[u] != -1 && goOut[u] && !inQ[revId[u]]) {\n            inQ[revId[u]] = true;\n            q.push(revId[u]);\n         }\n      }\n   }\n   cout << \"YES\\n\";\n   for (int v : ans) {\n      cout << v + 1 << \"\\n\";\n   }\n}\n",
    "ext": "cpp"
  },
  "57846069": {
    "code": "/*input\n13 2\n4 6\n3 5\n3 4\n3 3\n4 2\n5 2\n6 2\n7 3\n7 4\n7 5\n6 6\n5 4\n5 5\n\n\n\n8 2\n3 5\n5 3\n3 3\n5 5\n2 4\n6 4\n4 2\n4 4\n \n8 2\n0 2\n1 2\n1 0\n0 0\n2 1\n2 0\n0 1\n2 2\n*/\n \n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <queue>\n \nusing namespace std;\n \nusing pii = pair<int, int>;\n#define r first\n#define c second\n \nconst int dr[8] = {-1, -1, 0, 1, 1, 1, 0, -1}, dc[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int MAXN = 150007, MAXV = MAXN * 9, INF = 1e9 + 7;\nconst int EXT = -1, ALIVE = 1, IN = 0;\nint G[MAXV][8], type[MAXV], T, N, V, P[MAXV], inComp[MAXV];\npii C[MAXV], orC[MAXN];\nbool peri[MAXV], inq[MAXV];\npriority_queue<int> pq;\nvector<int> ans;\nbool vis[MAXV];\n \nbool comp(int i, int j) { return C[i] < C[j]; }\n \nint search(pii p)\n{\n\tint lo = 1, hi = V;\n\twhile (lo < hi) {\n\t\tint mid = (lo + hi) >> 1;\n\t\tif (C[P[mid]] < p) lo = mid + 1;\n\t\telse hi = mid;\n\t}\n\tif (C[P[lo]] == p) return P[lo];\n\treturn 0;\n}\n \nint calc(int u)\n{\n\tint cnt = 0;\n\tvector<int> vec;\n\tfor (int d = 0; d < 8; d += 2) {\n\t\tcnt += ((type[G[u][d]] == EXT) && (type[G[u][(d + 1) & 7]] != EXT || type[G[u][(d + 2) & 7]] != EXT));\n\t\tif (type[G[u][d]] == IN && (type[G[u][(d + 1) & 7]] == ALIVE || type[G[u][(d + 2) & 7]] == ALIVE)) {\n\t\t\tvec.push_back(inComp[G[u][d]]);\n\t\t}\n\t}\n\n\tsort(vec.begin(), vec.end());\n\tfor (int i = 1; i < (int) vec.size(); ++i) {\n\t\tif (vec[i - 1] == vec[i]) return INF;\n\t}\n\n\treturn cnt;\n}\n \nvoid dfs(int u)\n{\n\tvis[u] = 1;\n\tfor (int d = 0; d < 8; ++d) {\n\t\tint v = G[u][d];\n\t\tif (!vis[v] && type[v] == ALIVE) dfs(v);\n\t}\n}\n \nvoid fillExt(int u)\n{\n\ttype[u] = EXT;\n \n\tfor (int d = 0; d < 8; d += 2) {\n\t\tif (type[G[u][d]] == ALIVE) {\n\t\t\tperi[G[u][d]] = 1;\n\t\t\tif (!inq[G[u][d]] && calc(G[u][d]) <= 1) {\n\t\t\t\tinq[G[u][d]] = 1;\n\t\t\t\tpq.push(G[u][d]);\t\n\t\t\t}\n\t\t} else if (type[G[u][d]] == IN) {\n\t\t\tfillExt(G[u][d]);\n\t\t}\n\t}\n \n\tfor (int d = 0; d < 8; ++d) {\n\t\tif (type[G[u][d]] == ALIVE && peri[G[u][d]] && !inq[G[u][d]] && calc(G[u][d]) <= 1) {\n\t\t\tinq[G[u][d]] = 1;\n\t\t\tpq.push(G[u][d]);\n\t\t}\n\t}\n}\n\nvoid fillIn(int u)\n{\n\tfor (int d = 0; d < 8; d += 2) {\n\t\tif (type[G[u][d]] == IN && inComp[G[u][d]] == 0) {\n\t\t\tinComp[G[u][d]] = inComp[u];\n\t\t\tfillIn(G[u][d]);\n\t\t}\n\t}\n}\n \nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> N >> T; V = N;\n\tfor (int i = 1; i <= N; ++i) cin >> C[i].r >> C[i].c;\n\tfor (int i = 0; i < N; ++i) orC[i] = C[i + 1];\n\tsort(orC, orC + N); orC[N] = {INF, INF};\n \n\tvector<pair<int, int>> all(N * 8);\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfor (int d = 0; d < 8; ++d) {\n\t\t\tall[(i - 1) * 8 + d] = {C[i].r + dr[d], C[i].c + dc[d]};\n\t\t}\n\t}\n\tsort(all.begin(), all.end());\n\tall.erase(unique(all.begin(), all.end()), all.end());\n\tfor (auto a : all) {\n\t\tif (*lower_bound(orC, orC + N, a) != a) {\n\t\t\tC[++V] = a;\n\t\t}\n\t}\n \n\tfor (int u = 1; u <= V; ++u) P[u] = u;\n\t// for (int u = 1; u <= V; ++u) cout << C[u].r << ' ' << C[u].c << endl;\n\tsort(P + 1, P + V + 1, comp);\n \n\tfor (int u = 1; u <= V; ++u) {\n\t\tfor (int d = 0; d < 8; ++d) {\n\t\t\tG[u][d] = search({C[u].r + dr[d], C[u].c + dc[d]});\n\t\t}\n\t}\n \n\ttype[0] = EXT;\n\tfor (int u = 1; u <= N; ++u) type[u] = ALIVE;\n\tfor (int u = N + 1; u <= V; ++u) type[u] = IN;\n\tfor (int u = N + 1; u <= V; ++u) {\n\t\tif (inComp[u] == 0) {\n\t\t\tinComp[u] = u;\n\t\t\tfillIn(u);\n\t\t}\n\t}\n \n\tdfs(1);\n\tfor (int u = 1; u <= N; ++u) if (!vis[u]) return cout << \"NO\" << endl, 0;\n \n\tfillExt(N + 1);\n\tans.reserve(N);\n\twhile (!pq.empty()) {\n\t\tint u = pq.top(); pq.pop();\n\t\tassert(type[u] == ALIVE && peri[u]);\n\t\tif (calc(u) > 1) {\n\t\t\tinq[u] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tans.push_back(u);\n\t\tfillExt(u);\n\t}\n \n\tassert((int) ans.size() == N);\n\tcout << \"YES\\n\";\n\tfor (int i = (int) ans.size() - 1; i >= 0; --i) {\n\t\tcout << ans[i] << '\\n';\n\t}\n}",
    "ext": "cpp"
  },
  "57820815": {
    "code": "#include <iostream>\n#include <iomanip>\n#include <tchar.h>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <set>\n#include <map>\n#include <chrono>\n\nusing namespace std;\nusing namespace std::chrono;\n\nvoid dump_assert(char* expr, char* file, unsigned int line) {\n\tcout << \"Assertion failed: \" << expr << \", \" << file << \":\" << line << endl;\n\texit(0);\n}\n\n#define assert(expression) (void)(                                                       \\\n          (!!(expression)) ||                                                              \\\n            (dump_assert(#expression,  __FILE__, (unsigned)(__LINE__)), 0) \\\n        )\n\n\ntypedef long long ll;\n\nstruct Building {\n\tint x;\n\tint y;\n\tint next[8];\n\tint loop_id[4];\n};\n\nint n;\nint step;\nBuilding b[150000];\nint res[150000];\n\nbool vis[150000] = {0};\nint q[150000];\n\nbool connected[150000] = {0};\n\nint dx[] = {1, 1, 0, -1, -1, -1, 0, 1};\nint dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nset<int> range;\n\nvoid dumpB(int p) {\n\tBuilding& bp = b[p];\n\tcout << \"b[\" << p << \"]=(\"  << bp.x << \", \"  << bp.y << \") (\" << bp.loop_id[0] << \",\"  << bp.loop_id[1] << \",\" << bp.loop_id[2] << \",\" << bp.loop_id[3] << \n\t\t\"), nxt=(\" << bp.next[0] << \",\" << bp.next[1] << \",\" << bp.next[2] << \",\" << bp.next[3] << \",\" <<\n\t\t\t      bp.next[4] << \",\" << bp.next[5] << \",\" << bp.next[6] << \",\" << bp.next[7] << \")\" << endl;\n}\n\nbool hasOtherSements(int p, int edir, int ldir) {\n        int dist = (edir - ldir) & 7;\n\tif (dist <= 1 || ((dist == 2) && ((edir & 1) == 0)))\n\t\treturn false;\n\tBuilding& bld = b[p];\n\tint inner_side = ((edir + 2) & 7) >> 1;\n\tint lid = bld.loop_id[inner_side];\n\tif (lid == 0)\n\t\treturn false;\n\tint sd = ((ldir + 2) & 7) >> 1;\n\tint ed = ((edir + 1) & 7) >> 1;\n\tfor (int d = sd; d != ed; d = (d + 1) & 3) \n\t\tif (bld.loop_id[d] == lid)\n\t\t\treturn true;\n\treturn false;\n}\n\nbool canRemove(int p) {\n\tint odir = 3;\n\twhile (odir >= 0 && b[p].loop_id[odir] != 1) odir--;\n\tif (odir < 0)\n\t\treturn false; // internal point\n\tint sdir = ((odir << 1) + 7) & 7;\n\tint cnt = 9;\n\twhile (b[p].next[sdir] < 0 && --cnt > 0) \n\t\tsdir = (sdir + 7) & 7;\n\tif (cnt == 0)\n\t\treturn true; // single point \n\tint edir = sdir;\n\tdo {\t\n\t\tint ldir = (edir + 1) & 7;\n\t\twhile (b[p].next[ldir] < 0)\n\t\t\tldir = (ldir + 1) & 7;\n\t\tif (hasOtherSements(p, edir, ldir))\n\t\t\treturn false;\n\t\tedir = ldir;\t\n\t\tint nxt;\n\t\twhile (b[p].next[nxt = (edir + 1) & 7] >= 0)\n\t\t\tedir = nxt;\n\t} while\t(edir != sdir);\n\treturn true;\t\n}\n\nint getClusterSize(int sp) {\n\tint first = 0;\n\tint last = 1;\n\tmemset(vis, 0, n);\n\tq[0] = sp;\n\tvis[sp] = true;\n\twhile (first < last && last < n) {\n\t\tint p = q[first++];\n\t\tfor (int d = 0; d < 8; ++d) {\n\t\t\tint np = b[p].next[d];\n\t\t\tif (np >= 0 && !vis[np]) {\n\t\t\t\tvis[np] = true;\n\t\t\t\tq[last++] = np;\n\t\t\t}\n\t\t}\n\t}\n\treturn last;\n}\n\nvoid updateLoopId(int p, int edir, int ldir, int lid) {\n\tint sd = ((edir + 2) & 7) >> 1;\n\tint ed = ((ldir + 1) & 7) >> 1;\n\n\tint d = sd;\n\tdo {\n\t\tb[p].loop_id[d] = lid;\n\t\td = (d + 1) & 3;\n\t} while (d != ed);\n\n\tif (canRemove(p))\n\t\trange.insert(p);\n\telse\n\t\trange.erase(p);\n}\n\nvoid updateRange(int sp, int outdir, int lid) {\n\n        int cnt = 9;\n\tint edir = outdir;\n\twhile (b[sp].next[edir] < 0 && --cnt > 0) {\n\t\tedir = (edir + 7) & 7;\n\t}\n\tif (cnt == 0) { //signle point\t\n\t\tupdateLoopId(sp, 1, 1, 1);\n\t\treturn;\n\t} \n\tint p = sp;\n\tdo {\n\t\tint ldir = (edir + 2) & 7;\n\t\twhile (b[p].next[ldir] < 0) \n\t\t\tldir = (ldir + 1) & 7;\n\n\t\tupdateLoopId(p, edir, ldir, lid);\n\t        p = b[p].next[ldir];\n\t\tedir = (ldir + 4) & 7;\t\t\n\t} while (b[p].loop_id[((edir + 2) & 7) >> 1] != lid);\t\n}\n\n\nvoid removeNode(int p) {\n\tassert(canRemove(p));\n\n        range.erase(p);\n\n\tfor (int d= 0; d < 8; ++d)  {\n\t\tint pn = b[p].next[d];\n\t\tif (pn >= 0) {\n\t\t\tb[pn].next[(d + 4) & 7] = -1;\n\t\t}\n\t}\n\n\tint odir = 3;\n\twhile (odir >= 0 && b[p].loop_id[odir] != 1) odir--;\n\tassert(odir >= 0); //  point is not internal\n\n\tint cnt = 9;\n        int ed = (odir * 2 + 7) & 7;\n\twhile (b[p].next[ed] < 0 && --cnt > 0)\n\t\ted = (ed + 7) & 7;\n\n\tif (cnt == 0) {\n\t\treturn; //this is last point\n\t}\n\t\n\tint sp = b[p].next[ed];\n\tupdateRange(sp, (ed + 4) & 7, 1);\t\n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n\thigh_resolution_clock::time_point startTime = high_resolution_clock::now();\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n        int t;\n        cin >> n >> t;\n        assert(n <= 150000);\n\n\tmap<pair<int, int>, int> points;\n\tint start = 0;\n        for (int i = 0; i < n; ++i) {\n\t\tmemset(b[i].loop_id, 0, sizeof(b[i].loop_id));\n\t\tcin >> b[i].x >> b[i].y;\n\t\tpoints[make_pair(b[i].x, b[i].y)] = i + 1;\n\t\tif (b[i].x > b[start].x)\n\t\t\tstart = i;\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int d= 0; d < 8; ++d) {\n\t\t\tb[i].next[d] = points[make_pair(b[i].x + dx[d], b[i].y + dy[d])] - 1;\n\t\t}\n\t}\n\n\tint csize = getClusterSize(0);\n\tif (csize < n) {\n\t\tcout << \"NO\" << endl;\n\t\treturn 0;\n\t}\n\t// mark outer loop\n\tupdateRange(start, 0, 1);\n\n\t// mark internal loops (gaps)\n\tint lastLoopId = 2;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int d = 0; d < 3; ++d) {\n\t\t\tif (b[i].loop_id[d] == 0 && b[i].next[2 * d] < 0) {\n\t\t\t\tupdateRange(i, 2 * d, lastLoopId++);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tassert(!range.empty());\n\t\tint p = *(range.rbegin());\n\t\tres[i] = p + 1;\n\t\tremoveNode(p);\n\t}\n\n\tcout << \"YES\" << endl;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcout << res[i] << endl;\n\t}\t\n\n\thigh_resolution_clock::time_point endTime = high_resolution_clock::now();\n\tauto duration = duration_cast<milliseconds>(endTime - startTime).count();\n\tcerr << \"execution time \" << duration << \" ms\" <<endl; \n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57818148": {
    "code": "#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<map>\n#include<queue>\n#define N_ 1510000\n#define pii pair<int,int>\nusing namespace std;\n \nint dx[8] = { -1,-1,-1,0,1,1,1,0 }, dy[8] = { 1,0,-1,-1,-1,0,1,1 };\n \nint UF[N_];\nmap<pii, int>Map, Map2;\n \nint n;\n \nstruct point {\n\tint x, y;\n}P[N_];\n \nvector<int>E[N_], G[N_];\n \nint Num[N_], cnt;\nset<pii>Set;\n \nvoid DFS(int a) {\n\tNum[a] = ++cnt;\n\tfor (auto &x : E[a]) {\n\t\tif (!Num[x]) DFS(x);\n\t}\n}\n \n \nint vis[N_], blocked[N_], pos[N_], w[N_][9];\nint BN[N_], ReNum[N_], Q[N_], head, tail;\n \nint Find(int a) {\n\tif (a == UF[a])return a;\n\treturn UF[a] = Find(UF[a]);\n}\nvoid Merge(int a, int b) {\n\ta = Find(a), b = Find(b);\n\tif (a != b)UF[a] = b;\n}\n \npriority_queue<int>PQ;\nvoid BFS() {\n\twhile (head < tail) {\n\t\tint x = Q[++head];\n\t\tfor (auto &t : G[x]) {\n\t\t\tif (vis[t])continue;\n\t\t\tif (!blocked[t]) {\n\t\t\t\tQ[++tail] = t;\n\t\t\t\tvis[t] = 1;\n\t\t\t}\n\t\t\telse if (!pos[t]) {\n\t\t\t\tpos[t] = 1;\n\t\t\t\tPQ.push(ReNum[t]);\n\t\t\t}\n\t\t}\n\t}\n}\n \nint main() {\n\tint i, j, sub;\n\tscanf(\"%d%d\", &n, &sub);\n\tfor (i = 1; i <= n; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x,&y);\n\t\tP[i] = { x,y };\n\t\tMap[{x, y}] = i;\n\t\tSet.insert({ x,y });\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tint tx = P[i].x + dx[j], ty = P[i].y + dy[j];\n\t\t\tSet.insert({ tx,ty });\n\t\t\tif (Map.count({ tx,ty })) {\n\t\t\t\tE[i].push_back(Map[{tx, ty}]);\n\t\t\t}\n\t\t}\n\t}\n\tDFS(1);\n\tif (cnt != n) {\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tint c = 0;\n\tfor (auto &t : Set) {\n\t\tMap2[t] = ++c;\n\t}\n\tfor (auto &t : Set) {\n\t\tint a = Map2[t];\n\t\tfor (j = 1; j < 8; j+=2) {\n\t\t\tint tx = t.first + dx[j], ty = t.second + dy[j];\n\t\t\tif (Map2.count({ tx, ty })) {\n\t\t\t\tG[a].push_back(Map2[{tx, ty}]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tint tx = P[i].x + dx[j], ty = P[i].y + dy[j];\n\t\t\tw[i][j] = Map2[{tx, ty}];\n\t\t}\n\t}\n \n\tfor (i = 1; i <= n; i++) {\n\t\tBN[i] = Map2[{P[i].x, P[i].y}];\n\t\tReNum[BN[i]] = i;\n\t\tblocked[BN[i]] = 1;\n\t}\n \n\tfor (i = 1; i <= c; i++)UF[i] = i;\n\tfor (i = 1; i <= c; i++){\n\t\tfor (auto &x : G[i]) {\n\t\t\tif (!blocked[i] && !blocked[x])Merge(i, x);\n\t\t}\n\t}\n\tQ[++tail] = 1;\n\tvis[1] = 1;\n\tBFS();\n\tvector<int>Res;\n\twhile (!PQ.empty()) {\n\t\tint a = PQ.top();\n\t\tPQ.pop();\n\t\tint x = BN[a], ck = 0;\n\t\tif (!pos[x] || !blocked[x])continue;\n\t\tint pv = -1;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tint t = w[a][i];\n\t\t\tif (blocked[t])pv = i;\n\t\t}\n\t\tif (pv != -1) {\n\t\t\tint TP[9], cc = 0;\n\t\t\tfor (i = 0; i < 8; i++)TP[i] = 0;\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tint t = w[a][(pv+i)%8];\n\t\t\t\tif (blocked[t]) cc++;\n\t\t\t\telse TP[(pv+i)%8] = cc;\n\t\t\t}\n\t\t\tfor (i = 1; i < 8; i += 2) {\n\t\t\t\tfor (int j = i+2; j < 8; j += 2) {\n\t\t\t\t\tint t1 = w[a][i], t2 = w[a][j];\n\t\t\t\t\tif (!blocked[t1] && !blocked[t2] && TP[i] != TP[j] && Find(t1) == Find(t2))ck = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ck)continue;\n\t\t}\n \n\t\tRes.push_back(a);\n\t\tblocked[x] = 0;\n\t\tQ[++tail] = x;\n\t\tvis[x] = 1;\n\t\tBFS();\n\t\tfor (auto &z : G[x]) {\n\t\t\tif (!blocked[z])Merge(x, z);\n\t\t}\n\t\tfor (auto &z : E[a]) {\n\t\t\tPQ.push(z);\n\t\t}\n\t}\n\tputs(\"YES\");\n\treverse(Res.begin(), Res.end());\n\tfor (auto &t : Res)printf(\"%d\\n\", t);\n}",
    "ext": "cpp"
  },
  "57810636": {
    "code": "#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<map>\n#include<queue>\n#define N_ 1510000\n#define pii pair<int,int>\nusing namespace std;\n\nint dx[8] = { -1,-1,-1,0,1,1,1,0 }, dy[8] = { 1,0,-1,-1,-1,0,1,1 };\n\nint UF[N_];\nmap<pii, int>Map, Map2;\n\nint n;\n\nstruct point {\n\tint x, y;\n}P[N_];\n\nvector<int>E[N_], G[N_];\n\nint Num[N_], cnt;\nset<pii>Set;\n\nvoid DFS(int a) {\n\tNum[a] = ++cnt;\n\tfor (auto &x : E[a]) {\n\t\tif (!Num[x]) DFS(x);\n\t}\n}\n\n\nint vis[N_], blocked[N_], pos[N_], w[N_][9];\nint BN[N_], ReNum[N_], Q[N_], head, tail;\n\nint Find(int a) {\n\tif (a == UF[a])return a;\n\treturn UF[a] = Find(UF[a]);\n}\nvoid Merge(int a, int b) {\n\ta = Find(a), b = Find(b);\n\tif (a != b)UF[a] = b;\n}\n\npriority_queue<int>PQ;\nvoid BFS() {\n\twhile (head < tail) {\n\t\tint x = Q[++head];\n\t\tfor (auto &t : G[x]) {\n\t\t\tif (vis[t])continue;\n\t\t\tif (!blocked[t]) {\n\t\t\t\tQ[++tail] = t;\n\t\t\t\tvis[t] = 1;\n\t\t\t}\n\t\t\telse if (!pos[t]) {\n\t\t\t\tpos[t] = 1;\n\t\t\t\tPQ.push(ReNum[t]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint i, j, sub;\n\tscanf(\"%d%d\", &n, &sub);\n\tfor (i = 1; i <= n; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x,&y);\n\t\tP[i] = { x,y };\n\t\tMap[{x, y}] = i;\n\t\tSet.insert({ x,y });\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tint tx = P[i].x + dx[j], ty = P[i].y + dy[j];\n\t\t\tSet.insert({ tx,ty });\n\t\t\tif (Map.count({ tx,ty })) {\n\t\t\t\tE[i].push_back(Map[{tx, ty}]);\n\t\t\t}\n\t\t}\n\t}\n\tDFS(1);\n\tif (cnt != n) {\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tint c = 0;\n\tfor (auto &t : Set) {\n\t\tMap2[t] = ++c;\n\t}\n\tfor (auto &t : Set) {\n\t\tint a = Map2[t];\n\t\tfor (j = 1; j < 8; j+=2) {\n\t\t\tint tx = t.first + dx[j], ty = t.second + dy[j];\n\t\t\tif (Map2.count({ tx, ty })) {\n\t\t\t\tG[a].push_back(Map2[{tx, ty}]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tint tx = P[i].x + dx[j], ty = P[i].y + dy[j];\n\t\t\tw[i][j] = Map2[{tx, ty}];\n\t\t}\n\t}\n\n\tfor (i = 1; i <= n; i++) {\n\t\tBN[i] = Map2[{P[i].x, P[i].y}];\n\t\tReNum[BN[i]] = i;\n\t\tblocked[BN[i]] = 1;\n\t}\n\n\tfor (i = 1; i <= c; i++)UF[i] = i;\n\tfor (i = 1; i <= c; i++){\n\t\tfor (auto &x : G[i]) {\n\t\t\tif (!blocked[i] && !blocked[x])Merge(i, x);\n\t\t}\n\t}\n\tQ[++tail] = 1;\n\tvis[1] = 1;\n\tBFS();\n\tvector<int>Res;\n\twhile (!PQ.empty()) {\n\t\tint a = PQ.top();\n\t\tPQ.pop();\n\t\tint x = BN[a], ck = 0;\n\t\tif (!pos[x] || !blocked[x])continue;\n\t\tint pv = -1;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tint t = w[a][i];\n\t\t\tif (blocked[t])pv = i;\n\t\t}\n\t\tif (pv != -1) {\n\t\t\tint TP[9], cc = 0;\n\t\t\tfor (i = 0; i < 8; i++)TP[i] = 0;\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tint t = w[a][(pv+i)%8];\n\t\t\t\tif (blocked[t]) cc++;\n\t\t\t\telse TP[(pv+i)%8] = cc;\n\t\t\t}\n\t\t\tfor (i = 1; i < 8; i += 2) {\n\t\t\t\tfor (int j = i+2; j < 8; j += 2) {\n\t\t\t\t\tint t1 = w[a][i], t2 = w[a][j];\n\t\t\t\t\tif (!blocked[t1] && !blocked[t2] && TP[i] != TP[j] && Find(t1) == Find(t2))ck = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ck)continue;\n\t\t}\n\n\t\tRes.push_back(a);\n\t\tblocked[x] = 0;\n\t\tQ[++tail] = x;\n\t\tvis[x] = 1;\n\t\tBFS();\n\t\tfor (auto &z : G[x]) {\n\t\t\tif (!blocked[z])Merge(x, z);\n\t\t}\n\t\tfor (auto &z : E[a]) {\n\t\t\tPQ.push(z);\n\t\t}\n\t}\n\tputs(\"YES\");\n\treverse(Res.begin(), Res.end());\n\tfor (auto &t : Res)printf(\"%d\\n\", t);\n}",
    "ext": "cpp"
  },
  "57810620": {
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;  \nint gcd(int a,int b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXFLAT=150000;\nconst int MAXCELL=9*MAXFLAT;\nconst int DX[]={-1,-1,-1,0,+1,+1,+1,0},DY[]={-1,0,+1,+1,+1,0,-1,-1};\nstruct P { int x,y; P() {} P(int x,int y):x(x),y(y) {} };\nbool operator<(const P &a,const P &b) { if(a.x!=b.x) return a.x<b.x; return a.y<b.y; }\nbool operator==(const P &a,const P &b) { return a.x==b.x&&a.y==b.y; }\n\nint nflat,subtask;\nP flat[MAXFLAT];\nint ans[MAXFLAT];\n\nP cell[MAXCELL]; int ncell;\nvector<int> adj8[MAXCELL],adj4[MAXCELL];\nint flatid[MAXCELL],cellid[MAXFLAT];\n\nint comp[MAXCELL],ncomp; // 8-connected components of empty cells\nint outsidecomp;\nvector<int> cells[MAXCELL];\n\nint q[MAXCELL],qhead,qtail;\n\nbool isreachable[MAXFLAT],isarticulation[MAXFLAT],isavailable[MAXFLAT];\nset<int> available;\n\nvoid recalc(int fid) {\n\t//printf(\"recalc(%d)\\n\",fid);\n\tint at=cellid[fid];\n\tisreachable[fid]=false; REPSZ(i,adj4[at]) { int to=adj4[at][i]; if(comp[to]==outsidecomp) isreachable[fid]=true; }\n\tisarticulation[fid]=false;\n\tREPSZ(i,adj8[at]) {\n\t\tint fst=adj8[at][i]; if(comp[fst]!=-1) continue;\n\t\tint last=-1; bool added=false; vector<int> seen; REPSZ(j,adj8[at]) { int to=adj8[at][(i+j+1)%SZ(adj8[at])]; if(last!=comp[to]) last=comp[to],added=false; if((i+j+1)%2==1&&!added&&last!=-1) seen.PB(last),added=true; }\n\t\t//printf(\"seen:\"); REPSZ(j,seen) printf(\" %d\",seen[j]); puts(\"\");\n\t\tREPSZ(j,seen) FORSZ(k,j+1,seen) if(seen[j]==seen[k]) isarticulation[fid]=true;\n\t\tbreak;\n\t}\n\t//printf(\"recalc(%d) -> %s %s\\n\",fid,isreachable[fid]?\"reachable\":\"no\",isarticulation[fid]?\"articulation\":\"ok\");\n\tif((isreachable[fid]&&!isarticulation[fid])!=isavailable[fid]) { isavailable[fid]=!isavailable[fid]; if(isavailable[fid]) available.insert(fid); else available.erase(fid); }\n}\n\nvoid mergecomp(int a,int b) {\n\tif(SZ(cells[a])<SZ(cells[b])) swap(a,b);\n\tif(b==outsidecomp) swap(a,b);\n\tREPSZ(i,cells[b]) { int at=cells[b][i]; comp[at]=a; cells[a].PB(at); }\n\tREPSZ(i,cells[b]) { int at=cells[b][i]; REPSZ(j,adj8[at]) { int to=adj8[at][j]; if(comp[to]!=-1) continue; assert(flatid[to]!=-1); recalc(flatid[to]); } }\n\tcells[b].clear();\n}\n\nbool solve() {\n\tncell=0; REP(i,nflat) FORE(dx,-1,+1) FORE(dy,-1,+1) cell[ncell++]=P(flat[i].x+dx,flat[i].y+dy);\n\tsort(cell,cell+ncell); ncell=unique(cell,cell+ncell)-cell;\n\t//printf(\"cell:\"); REP(i,ncell) printf(\" (%d,%d)\",cell[i].x,cell[i].y); puts(\"\");\n\t\n\tREP(i,ncell) { adj4[i].clear(),adj8[i].clear(); REP(k,8) { P pj=P(cell[i].x+DX[k],cell[i].y+DY[k]); int j=lower_bound(cell,cell+ncell,pj)-cell; if(j>=ncell||!(cell[j]==pj)) continue; adj8[i].PB(j); if(DX[k]==0||DY[k]==0) adj4[i].PB(j); } }\n\t//REP(i,ncell) { printf(\"adj4[%d]:\",i); REPSZ(j,adj4[i]) printf(\" %d\",adj4[i][j]); puts(\"\"); }\n\t//REP(i,ncell) { printf(\"adj8[%d]:\",i); REPSZ(j,adj8[i]) printf(\" %d\",adj8[i][j]); puts(\"\"); }\n\t\n\tREP(i,ncell) flatid[i]=-1; REP(i,nflat) cellid[i]=lower_bound(cell,cell+ncell,flat[i])-cell,flatid[cellid[i]]=i;\n\tncomp=0; REP(i,ncell) comp[i]=flatid[i]==-1?-1:-2;\n\tREP(i,ncell) if(comp[i]==-2) { comp[i]=ncomp++; qhead=qtail=0; q[qhead++]=i; while(qtail<qhead) { int at=q[qtail++]; REPSZ(j,adj8[at]) { int to=adj8[at][j]; if(comp[to]==-2) comp[to]=comp[at],q[qhead++]=to; } } }\n\tif(ncomp>=2) return false;\n\tncomp=0; REP(i,ncell) comp[i]=flatid[i]==-1?-2:-1;\n\tREP(i,ncell) if(comp[i]==-2) { comp[i]=ncomp++; qhead=qtail=0; q[qhead++]=i; while(qtail<qhead) { int at=q[qtail++]; REPSZ(j,adj4[at]) { int to=adj4[at][j]; if(comp[to]==-2) comp[to]=comp[at],q[qhead++]=to; } } }\n\tREP(i,ncomp) cells[i].clear(); REP(i,ncell) if(comp[i]!=-1) cells[comp[i]].PB(i);\n\tassert(ncell>=1&&flatid[0]==-1); outsidecomp=comp[0];\n\t\n\t\n\tavailable.clear();\n\tREP(i,nflat) isavailable[i]=false,recalc(i);\n\tREP(i,nflat) {\n\t\tassert(SZ(available)>=1);\n\t\tint fid=*available.rbegin(),at=cellid[fid]; available.erase(fid); ans[nflat-i-1]=fid;\n\t\t//printf(\"at=%d (fid=%d)\\n\",at,fid);\n\t\tREPSZ(j,adj4[at]) { int to=adj4[at][j]; if(comp[to]==-1) continue; comp[at]=comp[to],cells[comp[at]].PB(at); break; } assert(comp[at]!=-1);\n\t\tREPSZ(j,adj8[at]) { int to=adj8[at][j]; if(comp[to]!=-1) continue; assert(flatid[to]!=-1); recalc(flatid[to]); }\n\t\tREPSZ(j,adj4[at]) { int to=adj4[at][j]; if(comp[to]==-1||comp[to]==comp[at]) continue; mergecomp(comp[at],comp[to]); }\n\t}\n\treturn true;\n}\n\nvoid run() {\n\tscanf(\"%d%d\",&nflat,&subtask);\n\tREP(i,nflat) scanf(\"%d%d\",&flat[i].x,&flat[i].y);\n\tif(!solve()) { printf(\"NO\\n\"); return; }\n\tprintf(\"YES\\n\"); REP(i,nflat) printf(\"%d\\n\",ans[i]+1);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57806500": {
    "code": "#include <bits/stdc++.h>\n#define sz(v) ((int)(v).size())\nusing namespace std;\nconst int MAXN = 150005;\nusing lint = long long;\nusing pi = pair<int, int>;\nconst int dx[8] = {1, 0, -1, 0, -1, -1, 1, 1};\nconst int dy[8] = {0, 1, 0, -1, -1, 1, -1, 1};\n \nstruct AGISEOKHWAN{\n\tint pa[MAXN];\n\tvoid init(int n){\n\t\tiota(pa, pa + n + 1, 0);\n\t}\n\tint find(int x){\n\t\treturn pa[x] = (pa[x] == x ? x : find(pa[x]));\n\t}\n\tbool uni(int p, int q){\n\t\tp = find(p); q = find(q);\n\t\tif(p == q) return 0;\n\t\tpa[q] = p; return 1;\n\t}\n}AGISEOKHWAN;\n \nstruct point{\n\tint x, y, idx;\n\tbool operator<(const point &p)const{\n\t\treturn pi(x, y) < pi(p.x, p.y);\n\t}\n}a[MAXN];\n \nstruct node{\n\tint x, y, fs;\n};\n \nvector<node> disj[MAXN * 4];\n \nint n;\nbool vis[MAXN];\n \npi dual_edge[MAXN][4];\nint prec[MAXN][8];\nint faces;\nint outer_area;\nint V[MAXN], E[MAXN], F[MAXN];\n  \nint getV(int x){\n\tint msk = 0;\n\tfor(int j=0; j<8; j++){\n\t\tint pos = prec[x][j];\n\t\tif(pos != -1 && !vis[pos]){\n\t\t\tif(dx[j] <= 0 && dy[j] <= 0) msk |= 1;\n\t\t\tif(dx[j] <= 0 && dy[j] >= 0) msk |= 2;\n\t\t\tif(dx[j] >= 0 && dy[j] >= 0) msk |= 4;\n\t\t\tif(dx[j] >= 0 && dy[j] <= 0) msk |= 8;\n\t\t}\n\t}\n\tmsk ^= 15;\n\tint remVtx = 0;\n\tfor(int i=0; i<4; i++){\n\t\tif((msk >> i) & 1) remVtx++;\n\t}\n\treturn remVtx;\n}\n \nint getE(int x){\n\tint remEdg = 4;\n\tfor(int i=0; i<4; i++){\n\t\tint pos = prec[x][i];\n\t\tif(pos != -1 && !vis[pos]){\n\t\t\tremEdg--;\n\t\t}\n\t}\n\treturn remEdg;\n}\n\nint rev[MAXN];\nset<int> s[MAXN];\npriority_queue<pi> pq;\nbool chk[MAXN];\n\nvoid enq(int x){\n\tif(chk[x] && !vis[x]){\n\t\tpq.emplace(V[x] - E[x] + F[x], a[x].idx);\n\t}\n}\n\nint getF(int x){\n\ts[x].clear();\n\tfor(int i=0; i<4; i++){\n\t\tint pos = prec[x][i];\n\t\tif(pos != -1 && !vis[pos]){\n\t\t\tcontinue;\n\t\t}\n\t\telse{\n\t\t\ts[x].insert(dual_edge[x][i].first);\n\t\t\ts[x].insert(dual_edge[x][i].second);\n\t\t}\n\t}\n\tif(s[x].find(outer_area) != s[x].end()) chk[x] = 1;\n\treturn max(sz(s[x]) - 1, 0);\n}\n \nvoid uni(int x, int y){\n\tif(x == y) return;\n\tif(disj[x].size() < disj[y].size()) swap(x, y);\n\tif(outer_area == y){\n\t\touter_area = x;\n\t\tfor(auto &i : disj[x]){\n\t\t\tF[i.x] = getF(i.x);\n\t\t\tenq(i.x);\n\t\t}\n\t}\n\tfor(auto &i : disj[y]){\n\t\tdisj[x].push_back(i);\n\t\tif(i.fs == 0){\n\t\t\tdual_edge[i.x][i.y].first = x;\n\t\t}\n\t\telse{\n\t\t\tdual_edge[i.x][i.y].second = x;\n\t\t}\n\t}\n\tfor(auto &i : disj[y]){\n\t\tF[i.x] = getF(i.x);\n\t\tenq(i.x);\n\t}\n\tdisj[y].clear();\n}\n \nvoid relax(int x){\n\tfor(int i=0; i<4; i++){\n\t\tint pos = prec[x][i];\n\t\tif(pos != -1 && !vis[pos]){\n\t\t\tcontinue;\n\t\t}\n\t\telse{\n\t\t\tuni(dual_edge[x][i].first, dual_edge[x][i].second);\n\t\t}\n\t}\n\tfor(int j=0; j<8; j++){\n\t\tint pos = prec[x][j];\n\t\tif(pos != -1 && !vis[pos]){\n\t\t\tV[pos] = getV(pos);\n\t\t\tE[pos] = getE(pos);\n\t\t\tF[pos] = getF(pos);\n\t\t\tenq(pos);\n\t\t}\n\t}\n}\n \nvoid solve(){\n\tvector<int> seq;\n\tfor(int i=0; i<n; i++){\n\t\tV[i] = getV(i);\n\t\tE[i] = getE(i);\n\t\tF[i] = getF(i);\n\t}\n\tfor(int i=0; i<n; i++) enq(i);\n\tfor(int i=0; i<n-1; i++){\n\t\tpi ret(-1e9, -1e9);\n\t\twhile(!pq.empty()){\n\t\t\tauto x = pq.top(); pq.pop();\n\t\t\tint y = rev[x.second];\n\t\t\tif(vis[y] || V[y] - E[y] + F[y] != 0 || V[y] - E[y] + F[y] != x.first) continue;\n\t\t\tret = pi(x.second, y);\n\t\t\tbreak;\n\t\t}\n\t\tassert(ret.first > 0);\n\t\tvis[ret.second] = 1;\n\t\tseq.push_back(ret.first);\n\t\trelax(ret.second);\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tif(!vis[i]) seq.push_back(a[i].idx);\n\t}\n\tputs(\"YES\");\n\treverse(seq.begin(), seq.end());\n\tfor(auto &i : seq) printf(\"%d\\n\", i);\n}\n \nvector<pi> dual_vtx;\nint gph[MAXN * 4][4];\nint fce[MAXN * 4][4];\n \nint main(){\n\tscanf(\"%d %*d\",&n);\n\tfor(int i=0; i<n; i++){\n\t\tscanf(\"%d %d\",&a[i].x,&a[i].y);\n\t\ta[i].idx = i + 1;\n\t\tfor(int j=0; j<2; j++){\n\t\t\tfor(int k=0; k<2; k++){\n\t\t\t\tdual_vtx.emplace_back(a[i].x + j, a[i].y + k);\n\t\t\t}\n\t\t}\n\t}\n\tsort(dual_vtx.begin(), dual_vtx.end());\n\tdual_vtx.resize(unique(dual_vtx.begin(), dual_vtx.end()) - dual_vtx.begin());\n\tsort(a, a + n);\n\tint comp = n;\n\tAGISEOKHWAN.init(n);\n\tfor(int i=0; i<n; i++){\n\t\trev[a[i].idx] = i;\n\t\tfor(int j=0; j<8; j++){\n\t\t\tint pos = lower_bound(a, a + n, (point){a[i].x + dx[j], a[i].y + dy[j], -1}) - a;\n\t\t\tif(pos < n && pi(a[i].x + dx[j], a[i].y + dy[j]) == pi(a[pos].x, a[pos].y)){\n\t\t\t\tprec[i][j] = pos;\n\t\t\t\tcomp -= AGISEOKHWAN.uni(i, pos);\n\t\t\t}\n\t\t\telse prec[i][j] = -1;\n\t\t}\n\t}\n\tif(comp != 1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tmemset(gph, -1, sizeof(gph));\n\tmemset(fce, -1, sizeof(fce));\n\tauto add_edge = [&](int sx, int sy, int ex, int ey, int dir1, int dir2){\n\t\tauto l = lower_bound(dual_vtx.begin(), dual_vtx.end(), pi(sx, sy)) - dual_vtx.begin();\n\t\tauto r = lower_bound(dual_vtx.begin(), dual_vtx.end(), pi(ex, ey)) - dual_vtx.begin();\n\t\tgph[l][dir1] = r;\n\t\tgph[r][dir2] = l;\n\t};\n\tfor(int i=0; i<n; i++){\n\t\tadd_edge(a[i].x, a[i].y, a[i].x + 1, a[i].y, 0, 2);\n\t\tadd_edge(a[i].x, a[i].y, a[i].x, a[i].y + 1, 1, 3);\n\t\tadd_edge(a[i].x + 1, a[i].y + 1, a[i].x + 1, a[i].y, 3, 1);\n\t\tadd_edge(a[i].x + 1, a[i].y + 1, a[i].x, a[i].y + 1, 2, 0);\n\t}\n\tauto getPos = [&](pi p){\n\t\tint pos = lower_bound(dual_vtx.begin(), dual_vtx.end(), p) - dual_vtx.begin();\n\t\treturn pos;\n\t};\n\tauto getNext = [&](int pos, int d){\n\t\tauto p = dual_vtx[pos];\n\t\tp.first += dx[d];\n\t\tp.second += dy[d];\n\t\treturn getPos(p);\n\t};\n\tfor(int i=0; i<dual_vtx.size(); i++){\n\t\tfor(int j=0; j<4; j++){\n\t\t\tif(gph[i][j] != -1 && fce[i][j] == -1){\n\t\t\t\tfaces++;\n\t\t\t\tint px = i, py = j;\n\t\t\t\twhile(fce[px][py] == -1){\n\t\t\t\t\tfce[px][py] = faces;\n\t\t\t\t\tpx = getNext(px, py);\n\t\t\t\t\tpy ^= 2;\n\t\t\t\t\tpy = (py + 1) % 4;\n\t\t\t\t\twhile(gph[px][py] == -1) py = (py + 1) % 4;\n\t\t\t\t}\n\t\t\t\tassert(px == i && py == j);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tint ll = getPos(pi(a[i].x, a[i].y));\n\t\tint lr = getPos(pi(a[i].x, a[i].y + 1));\n\t\tint rl = getPos(pi(a[i].x + 1, a[i].y));\n\t\tint rr = getPos(pi(a[i].x + 1, a[i].y + 1));\n\t\tdual_edge[i][0] = pi(fce[rl][1], fce[rr][3]);\n\t\tdual_edge[i][1] = pi(fce[rr][2], fce[lr][0]);\n\t\tdual_edge[i][2] = pi(fce[lr][3], fce[ll][1]);\n\t\tdual_edge[i][3] = pi(fce[ll][0], fce[rl][2]);\n\t\tfor(int j=0; j<4; j++){\n\t\t\tdisj[dual_edge[i][j].first].push_back({i, j, 0});\n\t\t\tdisj[dual_edge[i][j].second].push_back({i, j, 1});\n\t\t}\n\t}\n\touter_area = fce[0][0];\n\tsolve();\n}\n\n",
    "ext": "cpp"
  },
  "57799730": {
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 1.5e5 + 10, V = 10 * N;\n\nbool seen[N], is_building[V];\nmap<pii, int> all_cells;\npriority_queue<int> pq;\nint rx[V], ry[V];\nvector<int> node_list[V], cyc_nb[V];\nint par[V], sz[V];\nbool is_free[V];\nint cx[8] = {1, 0, -1, -1, -1, 0, 1, 1};\nint cy[8] = {1, 1, 1, 0, -1, -1, -1, 0};\n\nint get_root(int u);\nvoid merge(int u, int v, bool ch);\nbool check_outside(int x, int y, set<pii> &s);\nbool check(int i);\nint dfs(int u);\n\nint main() {\n\tfast_cin();\n\tint n, t;\n\tcin >> n >> t;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> rx[i] >> ry[i];\n\t\tall_cells[{rx[i], ry[i]}] = i;\n\t\tis_building[i] = true;\n\t\tfor (int d = 0; d < 8; ++d) {\n\t\t\tall_cells[{rx[i] + cx[d], ry[i] + cy[d]}];\n\t\t}\n\t}\n\tint m = n, leftmost = 1;\n\tfor (auto &i : all_cells) {\n\t\tif (!i.second) {\n\t\t\ti.second = ++m;\n\t\t}\n\t\ttie(rx[i.second], ry[i.second]) = i.first;\n\t\tif (rx[i.second] < rx[leftmost]) {\n\t\t\tleftmost = i.second;\n\t\t}\n\t}\n\tis_free[leftmost] = true;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tsz[i] = 1;\n\t\tpar[i] = i;\n\t\tnode_list[i] = {i};\n\t\tfor (int d = 0; d < 8; ++d) {\n\t\t\tint x = rx[i] + cx[d];\n\t\t\tint y = ry[i] + cy[d];\n\t\t\tcyc_nb[i].pb(all_cells[{x, y}]);\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tfor (int d = 1; d < 8; d += 2) {\n\t\t\tint j = cyc_nb[i][d];\n\t\t\tif (j and !is_building[i] and !is_building[j]) {\n\t\t\t\tmerge(i, j, false);\n\t\t\t}\n\t\t}\n\t}\n\tif (dfs(1) != n) {\n\t\tcout << \"NO\\n\";\n\t\treturn 0;\n\t}\n\tmemset(seen, 0, sizeof(seen));\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (check(i)) {\n\t\t\tseen[i] = true;\n\t\t\tpq.push(i);\n\t\t}\n\t}\n\tvector<int> ans;\n\twhile (!pq.empty()) {\n\t\tint u = pq.top();\n\t\tpq.pop();\n\t\tif (!check(u)) {\n\t\t\tseen[u] = false;\n\t\t\tcontinue;\n\t\t}\n\t\tans.pb(u);\n\t\tis_building[u] = false;\n\t\tfor (int d = 1; d < 8; d += 2) {\n\t\t\tint v = cyc_nb[u][d];\n\t\t\tif (!is_building[v]) {\n\t\t\t\tmerge(u, v, true);\n\t\t\t}\n\t\t}\n\t\tfor (int d = 0; d < 8; ++d) {\n\t\t\tint v = cyc_nb[u][d];\n\t\t\tif (is_building[v] and !seen[v] and check(v)) {\n\t\t\t\tseen[v] = true;\n\t\t\t\tpq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tif (ans.size() == n) {\n\t\tcout << \"YES\\n\";\n\t\treverse(ans.begin(), ans.end());\n\t\tfor (auto &i : ans) {\n\t\t\tcout << i << '\\n';\n\t\t}\n\t} else {\n\t\tcout << \"NO\\n\";\n\t}\n}\n\nint get_root(int u) {\n\tif (par[u] != u) {\n\t\tpar[u] = get_root(par[u]);\n\t}\n\treturn par[u];\n}\n\nvoid merge(int u, int v, bool ch) {\n\tu = get_root(u);\n\tv = get_root(v);\n\tif (u == v) {\n\t\treturn;\n\t}\n\tif (is_free[v]) {\n\t\tswap(u, v);\n\t}\n\tif (is_free[u] and !is_free[v]) {\n\t\tfor (auto &i : node_list[v]) {\n\t\t\tis_free[i] = true;\n\t\t\tif (ch) {\n\t\t\t\tfor (auto &j : cyc_nb[i]) {\n\t\t\t\t\tif (is_building[j] and !seen[j] and check(j)) {\n\t\t\t\t\t\tseen[j] = true;\n\t\t\t\t\t\tpq.push(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (sz[u] < sz[v]) {\n\t\tswap(u, v);\n\t}\n\tsz[u] += sz[v];\n\tpar[v] = par[u];\n\tfor (auto &i : node_list[v]) {\n\t\tnode_list[u].pb(i);\n\t}\n\tnode_list[v].clear();\n}\n\nbool check(int i) {\n\tbool free = false;\n\tfor (int d = 1; d < 8; d += 2) {\n\t\tif (is_free[cyc_nb[i][d]]) {\n\t\t\tfree = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!free) {\n\t\treturn false;\n\t}\n\tfor (int d1 = 1; d1 < 8; d1 += 2) {\n\t\tfor (int d2 = (d1 + 2); d2 < 8; d2 += 2) {\n\t\t\tint u = cyc_nb[i][d1], v = cyc_nb[i][d2];\n\t\t\tif (is_building[u] or get_root(u) != get_root(v)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool b1 = false, b2 = false;\n\t\t\tfor (int j = (d1 + 1); j < d2; ++j) {\n\t\t\t\tif (is_building[cyc_nb[i][j]]) {\n\t\t\t\t\tb1 = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = (d2 + 1) % 8; j != d1; j = (j + 1) % 8) {\n\t\t\t\tif (is_building[cyc_nb[i][j]]) {\n\t\t\t\t\tb2 = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b1 and b2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint dfs(int u) {\n\tif (seen[u]) {\n\t\treturn 0;\n\t}\n\tseen[u] = true;\n\tint ans = 1;\n\tfor (auto &v : cyc_nb[u]) {\n\t\tif (is_building[v]) {\n\t\t\tans += dfs(v);\n\t\t}\n\t}\n\treturn ans;\n}",
    "ext": "cpp"
  }
}
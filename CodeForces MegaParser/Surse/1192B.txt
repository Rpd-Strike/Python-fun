{
  "58161010": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define range(i, m, n) for(int i = m; i < n; i++)\n#define husk(i, m, n) for(int i = m; i > n; i--)\n\ntemplate <typename T>\nvoid debug_out(T t) {\n  cerr << t;\n}\n\ntemplate <typename A, typename B>\nvoid debug_out(pair<A, B> u) {\n  cerr << \"(\" << u.first << \" \" << u.second << \")\";\n}\n\ntemplate <typename T>\nvoid debug_out(vector<T> t) {\n  int sz = t.size();\n  for(int i = 0; i < sz; i++) {\n    debug_out(t[i]);\n    if(i != sz - 1) cerr << \", \";\n  }\n}\n\ntemplate <typename T>\nvoid debug_out(vector<vector<T>> t) {\n  int sz = t.size();\n  for(int i = 0; i < sz; i++) {\n    debug_out(t[i]);\n    if(i != sz - 1) cerr << endl;\n  }\n}\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\" << endl, debug_out(__VA_ARGS__), cerr << endl;\n\nclass node {\n  public:\n  int id;\n  node* l;\n  node* r;\n  node* p;\n  bool rev;\n  int sz;\n  // declare extra variables:\n  long long val;\n  long long root_val;\n  long long sval;\n  long long sum;\n  long long route;\n  long long add;\n  long long r_sum;\n  long long r_route;\n  long long r_add;\n  multiset<long long> light;\n\n  node(int _id) {\n    id = _id;\n    l = r = p = NULL;\n    rev = false;\n    sz = 1;\n    // init extra variables:\n    val = 0;\n    root_val = 0;\n    sum = 0;\n    route = 0;\n    add = 0;\n    r_sum = 0;\n    r_route = 0;\n    r_add = 0;\n    sval = 0;\n    light.insert(0LL);\n  }\n\n  void unsafe_reverse() {\n    rev ^= 1;\n    swap(l, r);\n    pull();\n  }\n\n  // apply changes:\n  void unsafe_apply(long long v, long long rv) {\n    if(v) {\n      sum += v;\n      add += v;\n      route += v;\n    }\n    if(rv) {\n      r_sum += rv;\n      r_add += rv;\n      r_route += rv;\n    }\n  }\n\n  void push() {\n    if (rev) {\n      if (l != NULL) {\n        l->unsafe_reverse();\n      }\n      if (r != NULL) {\n        r->unsafe_reverse();\n      }\n      rev = 0;\n    }\n    // now push everything else:\n    if(add || r_add) {\n      if(r != NULL) {\n        r->unsafe_apply(add, r_add);\n      }\n      if(l != NULL) {\n        l->unsafe_apply(add, r_add);\n      }\n      add = 0;\n      r_add = 0;\n    }\n  }\n\n  void pull() {\n    sz = 1;\n    // now init from self:\n    root_val = val;\n    sval = val;\n    route = sum + *prev(light.end());\n    r_route = r_sum + *prev(light.end());\n    if (l != NULL) {\n      l->p = this;\n      sz += l->sz;\n      // now pull from l:\n      sval += l->sval;\n      root_val = l->root_val;\n      route = max(route, l->route);\n      r_route = max(r_route, l->r_route);\n    }\n    if (r != NULL) {\n      r->p = this;\n      sz += r->sz;\n      // now pull from r:\n      sval += r->sval;\n      route = max(route, r->route);\n      r_route = max(r_route, r->r_route);\n    }\n  }\n};\n\nnamespace splay_tree {\n  bool is_bst_root(node* v) {\n    if (v == NULL) {\n      return false;\n    }\n    return (v->p == NULL || (v->p->l != v && v->p->r != v));\n  }\n\n  void rotate(node* v) {\n    node* u = v->p;\n    assert(u != NULL);\n    u->push();\n    v->push();\n    if (v == u->l) {\n      u->l = v->r;\n      v->r = u;\n    } else {\n      u->r = v->l;\n      v->l = u;\n    }\n    v->p = u->p;\n    if (v->p != NULL) {\n      if (v->p->l == u) {\n        v->p->l = v;\n      }\n      if (v->p->r == u) {\n        v->p->r = v;\n      }\n    }\n    u->pull();\n    v->pull();\n  }\n\n  void splay(node* v) {\n    if (v == NULL) {\n      return;\n    }\n    node* c = v;\n    vector<node*> st;\n    st.push_back(c);\n    while(!is_bst_root(c)) {\n      c = c->p;\n      st.push_back(c);\n    }\n    reverse(st.begin(), st.end());\n    for(node* a : st) a->push();\n    while (!is_bst_root(v)) {\n      node* u = v->p;\n      if (!is_bst_root(u)) {\n        if ((u->l == v) ^ (u->p->l == u)) {\n          rotate(v);\n        } else {\n          rotate(u);\n        }\n      }\n      rotate(v);\n    }\n  }\n\n  template<typename... T>\n  void apply(node* v, T... args) {\n    splay(v);\n    v->unsafe_apply(args...);\n  }\n}\n\nusing namespace splay_tree;\n\ntemplate<bool rooted>\nclass link_cut_tree {\n  public:\n  int n;\n  vector<node*> nodes;\n\n  link_cut_tree(int _n) : n(_n) {\n    nodes.resize(n);\n    for (int i = 0; i < n; i++) {\n      nodes[i] = new node(i);\n    }\n  }\n\n  void expose(node* v) {\n    node* r = NULL;\n    node* u = v;\n    while (u != NULL) {\n      splay(u);\n      u->push();\n      if(u->r != NULL) {\n        u->unsafe_apply(0, -u->r->sval);\n        u->r->unsafe_apply(-(u->sum + u->r->root_val), 0);\n        u->light.insert(u->r->route + u->r->root_val);\n        u->r = NULL;\n      }\n      u->push();\n      if(r != NULL) {\n        u->unsafe_apply(0, r->r_sum + r->sum + r->root_val);\n        auto it = u->light.find(r->route + r->root_val);\n        r->unsafe_apply(u->sum + r->root_val, 0);\n        assert(it != u->light.end());\n        u->light.erase(it);\n      }\n      u->push();\n      u->r = r;\n      u->pull();\n      r = u;\n      u = u->p;\n    }\n    splay(v);\n    assert(v->p == NULL);\n  }\n\n  bool link(int i, int j) { // for rooted: (x, parent[x])\n    if (i == j) {\n      return false;\n    }\n    node* v = nodes[i];\n    node* u = nodes[j];\n    splay(v);\n    assert(v->p == NULL && v->l == NULL); // must be a root\n    expose(u);\n    if (v->p != NULL) {\n      return false;\n    }\n    v->p = u;\n    u->light.insert(v->root_val + v->route);\n    u->pull();\n    return true;\n  }\n\n  template<typename... T>\n  void apply(int i, T... args) {\n    node* v = nodes[i];\n    splay_tree::apply(v, args...);\n  }\n};\n\nint n, q;\nlong long w;\n\nconst int N = 444444;\nlong long tree[N], lazy[N], pos[N];\n\nvoid build(int v, int l, int r, const vector<long long> &a, const vector<int> &p) {\n  if(l == r) {\n    tree[v] = a[l];\n    pos[v] = p[l];\n    return;\n  }\n  int y = (l + r) >> 1;\n  build(2 * v + 1, l, y, a, p);\n  build(2 * v + 2, y + 1, r, a, p);\n  tree[v] = max(tree[2 * v + 1], tree[2 * v + 2]);\n  pos[v] = (tree[2 * v + 1] > tree[2 * v + 2] ? pos[2 * v + 1] : pos[2 * v + 2]);\n}\n\nvoid modify(int v, int l, int r, int ll, int rr, int c) {\n  if(ll <= l && r <= rr) {\n    tree[v] += c;\n    lazy[v] += c;\n    return;\n  }\n  tree[2 * v + 1] += lazy[v]; lazy[2 * v + 1] += lazy[v];\n  tree[2 * v + 2] += lazy[v]; lazy[2 * v + 2] += lazy[v];\n  lazy[v] = 0;\n  int y = (l + r) >> 1;\n  if(y < rr) modify(2 * v + 2, y + 1, r, ll, rr, c);\n  if(y >= ll) modify(2 * v + 1, l, y, ll, rr, c);\n  tree[v] = max(tree[2 * v + 1], tree[2 * v + 2]);\n  pos[v] = (tree[2 * v + 1] > tree[2 * v + 2] ? pos[2 * v + 1] : pos[2 * v + 2]);\n}\n\nstruct edge {\n  int u, v;\n  long long c;\n  edge(){};\n  edge(int _u, int _v, long long _c) : u(_u), v(_v), c(_c) {};\n};\n\nint main() {\n  cin >> n >> q >> w;\n  vector<edge> edges;\n  vector<vector<int>> g(n);\n  vector<int> in(n);\n  vector<int> out(n);\n  vector<long long> dep(n);\n  vector<int> ord;\n  vector<int> par(n);\n  vector<long long> cost(n);\n  range(i, 0, n - 1) {\n    int u, v;\n    long long c;\n    scanf(\"%d%d%lld\", &u, &v, &c);\n    u--;\n    v--;\n    g[u].push_back(edges.size());\n    edges.emplace_back(u, v, c);\n    g[v].push_back(edges.size());\n    edges.emplace_back(v, u, c);\n  }\n  function<void(int, int, long long)> dfs = [&] (int v, int p, long long c) {\n    par[v] = p;\n    cost[v] = c;\n    if(~p) {\n      dep[v] = dep[p] + c;\n    }\n    in[v] = ord.size();\n    ord.push_back(v);\n    for(auto id : g[v]) {\n      int u = edges[id].v;\n      if(u == p) continue;\n      long long _c = edges[id].c;\n      dfs(u, v, _c);\n    }\n    out[v] = ord.size() - 1;\n  };\n  dfs(0, -1, 0);\n  link_cut_tree<true> st(n);\n  range(i, 0, n) st.nodes[i]->val = st.nodes[i]->root_val = cost[i];\n  function<void(int)> link = [&] (int v) {\n    for(auto i : g[v]) {\n      int u = edges[i].v;\n      if(u == par[v]) continue;\n      link(u);\n      st.link(u, v);\n    }\n  };\n  link(0);\n  vector<long long> _dep(n);\n  range(i, 0, n) _dep[i] = dep[ord[i]];\n  swap(_dep, dep);\n  build(0, 0, n - 1, dep, ord);\n  long long last = 0;\n  while(q--) {\n    vector<int> bug(n);\n    int id;\n    long long e;\n    scanf(\"%d%lld\", &id, &e);\n    id = (last + id) % (n - 1);\n    e = (last + e) % w;\n    id *= 2;\n    int u = edges[id].u, v = edges[id].v;\n    if(v == par[u]) swap(u, v);\n    long long dif = e - cost[v];\n    cost[v] = e;\n    st.expose(st.nodes[v]);\n    st.nodes[v]->root_val = st.nodes[v]->val = e;\n    st.nodes[v]->sval += dif;\n    if(st.nodes[v]->l != NULL) {\n      st.nodes[v]->root_val = st.nodes[v]->l->root_val;\n      node* c = st.nodes[v]->l;\n      c->unsafe_apply(0, dif);\n      while(c->r != NULL) c = c->r;\n      splay(c);\n    }\n    st.nodes[v]->unsafe_apply(dif, 0);\n    if(st.nodes[v]->p) {\n      st.nodes[v]->p->push();\n      st.nodes[v]->p->pull();\n    }\n    modify(0, 0, n - 1, in[v], out[v], dif);\n    int p = pos[0];\n    st.expose(st.nodes[p]);\n    printf(\"%lld\\n\", st.nodes[p]->r_route);\n    last = st.nodes[p]->r_route;\n  }\n  return 0;\n}\n",
    "ext": "cpp"
  },
  "58142563": {
    "code": "#pragma GCC optimize(\"O3\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nvector<set<pair<int, ll>>> adj;\nvector<tuple<int, int, ll>> edges;\n\nstruct segtree {\n    int n;\n    vector<ll> seg;\n    vector<ll> off;\n\n    void build(int l, int r, int pos, vector<ll> &initial) {\n        if (l == r - 1) {\n            seg[pos] = initial[l];\n        } else {\n            int m = (l + r) / 2;\n            build(l, m, 2 * pos + 0, initial);\n            build(m, r, 2 * pos + 1, initial);\n            seg[pos] = max(seg[2 * pos + 0], seg[2 * pos + 1]);\n        }\n    }\n\n    void update(int l, int r, int pos, int a, int b, ll val) {\n        if (a <= l && b >= r) {\n            seg[pos] += val;\n            off[pos] += val;\n        } else if (l < b && r > a) {\n            seg[2 * pos + 0] += off[pos];\n            seg[2 * pos + 1] += off[pos];\n            off[2 * pos + 0] += off[pos];\n            off[2 * pos + 1] += off[pos];\n            off[pos] = 0;\n\n            int m = (l + r) / 2;\n            update(l, m, 2 * pos + 0, a, b, val);\n            update(m, r, 2 * pos + 1, a, b, val);\n            seg[pos] = max(seg[2 * pos + 0], seg[2 * pos + 1]);\n        }\n    }\n\n    ll query(int l, int r, int pos, int a, int b) {\n        if (a <= l && b >= r) {\n            return seg[pos];\n        } else if (l < b && r > a) {\n            seg[2 * pos + 0] += off[pos];\n            seg[2 * pos + 1] += off[pos];\n            off[2 * pos + 0] += off[pos];\n            off[2 * pos + 1] += off[pos];\n            off[pos] = 0;\n\n            int m = (l + r) / 2;\n            return max(query(l, m, 2 * pos + 0, a, b), query(m, r, 2 * pos + 1, a, b));\n        } else {\n            return -1;\n        }\n    }\n\n    void build(vector<ll> &initial) {\n        n = initial.size();\n        seg.resize(4 * n);\n        off.assign(4 * n, 0);\n        build(0, n, 1, initial);\n    }\n\n    void update(int a, int b, ll val) {\n        update(0, n, 1, a, b, val);\n    }\n\n    ll query(int a, int b) {\n        return query(0, n, 1, a, b);\n    }\n};\n\nstruct discover {\n    vector<ll> initial;\n    unordered_map<int, int> inid, outid;\n    unordered_map<int, int> side;\n\n    int proc(int cur, int parent, ll depth, int id, int color) {\n        int origid = id++;\n        initial[origid] = depth;\n        inid[cur] = origid;\n        side[cur] = color;\n        for (auto &e : adj[cur]) {\n            if (e.first != parent) {\n                id = proc(e.first, cur, depth + e.second, id, (parent < 0 ? e.first : color));\n            }\n        }\n        outid[cur] = id;\n        return id;\n    }\n\n    void proc(int cur, int n) {\n        initial.resize(n);\n        proc(cur, -1, 0, 0, -1);\n    }\n};\n\nstruct centroids {\n    vector<pair<int, vector<pair<pair<int, ll>, int>>>> results;\n\n    int proc(int cur, int parent, int n) {\n        int sum = 1;\n        int largest = 0;\n        vector<pair<pair<int, ll>, int>> temp;\n        pair<int, ll> todo;\n        for (auto &e : adj[cur]) {\n            if (e.first != parent) {\n                int val = proc(e.first, cur, n);\n                sum += val;\n                largest = max(largest, val);\n                temp.emplace_back(e, val);\n            } else {\n                todo = e;\n            }\n        }\n        if (parent >= 0) {\n            largest = max(largest, n - sum);\n            temp.emplace_back(todo, n - sum);\n        }\n        if (largest <= n / 2) {\n            results.emplace_back(cur, temp);\n        }\n        return sum;\n    }\n\n    void proc(int cur, int n) {\n        proc(cur, -1, n);\n    }\n};\n\nstruct stage {\n    centroids fc;\n    vector<discover> discs;\n    vector<segtree> segs;\n    vector<int> children;\n    vector<ll> extra;\n    unordered_map<int, int> childmap;\n    set<pair<ll, int>> cache;\n};\n\nvector<stage> stages;\n\nint decomp(int cur, int n, int id, int parentid) {\n    int origid = id++;\n\n    stages[origid].fc.proc(cur, n);\n    auto centroid = stages[origid].fc.results.back();\n    \n    stages[origid].discs.resize(centroid.second.size());\n    stages[origid].segs.resize(centroid.second.size());\n    stages[origid].children.resize(centroid.second.size());\n    stages[origid].extra.resize(centroid.second.size());\n    for (int i = 0; i < centroid.second.size(); i++) {\n        adj[centroid.second[i].first.first].erase(pair<int, ll>(centroid.first, centroid.second[i].first.second));\n\n        stages[origid].discs[i].proc(centroid.second[i].first.first, centroid.second[i].second);\n        stages[origid].segs[i].build(stages[origid].discs[i].initial);\n        stages[origid].children[i] = id;\n        stages[origid].extra[i] = centroid.second[i].first.second;\n\n        //if (centroid.second[i].second > 1) {\n            stages[origid].cache.emplace(stages[origid].segs[i].query(0, centroid.second[i].second) + centroid.second[i].first.second, i);\n            id = decomp(centroid.second[i].first.first, centroid.second[i].second, id, origid);\n        //} else {\n        //    id++;\n        //}\n        for (auto &e : stages[origid].discs[i].inid) {\n            stages[origid].childmap[e.first] = i;\n        }\n    }\n\n    return id;\n}\n\nll calc(int cur) {\n    if (!stages[cur].cache.empty()) {\n        ll temp = calc(stages[cur].children[stages[cur].cache.rbegin()->second]);\n        ll own = 0;\n        auto it = stages[cur].cache.rbegin();\n        for (int k = 0; k < min((int) stages[cur].cache.size(), 2); k++) {\n            own += (*it++).first;\n        }\n        return max(temp, own);\n    }\n    return 0;\n}\n\nvoid modify(int cur, int a, int b, ll val) {\n    auto ita = stages[cur].childmap.find(a);\n    auto itb = stages[cur].childmap.find(b);\n\n    if (ita != stages[cur].childmap.end() && itb != stages[cur].childmap.end() && ita->second == itb->second) {\n        modify(stages[cur].children[ita->second], a, b, val);\n    }\n    \n    int side, lower;\n    if (itb == stages[cur].childmap.end()) {\n        side = ita->second;\n        lower = a;\n    } else if (ita == stages[cur].childmap.end()) {\n        side = itb->second;\n        lower = b;\n    } else if (ita->second == itb->second) {\n        side = ita->second;\n        lower = (stages[cur].discs[side].inid[a] < stages[cur].discs[side].inid[b] ? b : a);\n    } else {\n        return;\n    }\n    \n    ll before = stages[cur].segs[side].query(0, 100000);\n    stages[cur].segs[side].update(stages[cur].discs[side].inid[lower], stages[cur].discs[side].outid[lower], val);\n    ll after = stages[cur].segs[side].query(0, 100000);\n    if (before != after) {\n        stages[cur].cache.erase(pair<ll, int>(before + stages[cur].extra[side], side));\n        stages[cur].cache.insert(pair<ll, int>(after + stages[cur].extra[side], side));\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    ll w;\n    cin >> n >> q >> w;\n\n    adj.resize(n);\n    for (int i = 1; i < n; i++) {\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        a--; b--;\n\n        adj[a].emplace(b, c);\n        adj[b].emplace(a, c);\n        edges.emplace_back(a, b, c);\n    }\n\n    stages.resize(n);\n    decomp(0, n, 0, -1);\n    //cout << calc(0) << endl;\n\n    ll last = 0;\n    for (int j = 0; j < q; j++) {\n        int d;\n        ll e;\n        cin >> d >> e;\n        d = (d + last) % (n - 1);\n        e = (e + last) % w;\n\n        modify(0, get<0>(edges[d]), get<1>(edges[d]), e - get<2>(edges[d]));\n        get<2>(edges[d]) = e;\n\n        last = calc(0);\n        \n        cout << last << \"\\n\";\n    }\n\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "58137653": {
    "code": "#pragma GCC optimize(\"O3\")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\n \nvector<set<pair<int, ll>>> adj;\nvector<array<ll,3>> edges;\n \nstruct segtree {\n    int n;\n    vector<ll> seg;\n    vector<ll> off;\n \n    void build(int l, int r, int pos, vector<ll> &initial) {\n        if (l == r - 1) {\n            seg[pos] = initial[l];\n        } else {\n            int m = (l + r) / 2;\n            build(l, m, 2 * pos + 0, initial);\n            build(m, r, 2 * pos + 1, initial);\n            seg[pos] = max(seg[2 * pos + 0], seg[2 * pos + 1]);\n        }\n    }\n \n    void update(int l, int r, int pos, int a, int b, ll val) {\n        if (a <= l && b >= r) {\n            seg[pos] += val;\n            off[pos] += val;\n        } else if (l < b && r > a) {\n        \tif (off[pos]) {\n                seg[2 * pos + 0] += off[pos];\n\t            seg[2 * pos + 1] += off[pos];\n\t            off[2 * pos + 0] += off[pos];\n\t            off[2 * pos + 1] += off[pos];\n\t            off[pos] = 0;\n        \t} \n            int m = (l + r) / 2;\n            update(l, m, 2 * pos + 0, a, b, val);\n            update(m, r, 2 * pos + 1, a, b, val);\n            seg[pos] = max(seg[2 * pos + 0], seg[2 * pos + 1]);\n        }\n    }\n \n    ll query(int l, int r, int pos, int a, int b) {\n        if (a <= l && b >= r) {\n            return seg[pos];\n        } else if (l < b && r > a) {\n        \tif (off[pos]) {\n\t            seg[2 * pos + 0] += off[pos];\n\t            seg[2 * pos + 1] += off[pos];\n\t            off[2 * pos + 0] += off[pos];\n\t            off[2 * pos + 1] += off[pos];\n\t            off[pos] = 0;\n \t\t\t}\n            int m = (l + r) / 2;\n            return max(query(l, m, 2 * pos + 0, a, b), query(m, r, 2 * pos + 1, a, b));\n        } else {\n            return -1;\n        }\n    }\n \n    void build(vector<ll> &initial) {\n        n = initial.size();\n        seg.resize(4 * n);\n        off.assign(4 * n, 0);\n        build(0, n, 1, initial);\n    }\n \n    void update(int a, int b, ll val) {\n        update(0, n, 1, a, b, val);\n    }\n \n    ll query(int a, int b) {\n        return query(0, n, 1, a, b);\n    }\n};\n \nstruct discover {\n    vector<ll> initial;\n    unordered_map<int, int> inid, outid;\n    unordered_map<int, int> side;\n \n    int proc(int cur, int parent, ll depth, int id, int color) {\n        int origid = id++;\n        initial[origid] = depth;\n        inid[cur] = origid;\n        side[cur] = color;\n        for (auto &e : adj[cur]) {\n            if (e.first != parent) {\n                id = proc(e.first, cur, depth + e.second, id, (parent < 0 ? e.first : color));\n            }\n        }\n        outid[cur] = id;\n        return id;\n    }\n \n    void proc(int cur, int n) {\n        initial.resize(n);\n        proc(cur, -1, 0, 0, -1);\n    }\n};\n \nstruct centroids {\n    pair<int, vector<pair<pair<int, ll>, int>>> results;\n \n    int proc(int cur, int parent, int n) {\n        int sum = 1;\n        int largest = 0;\n        vector<pair<pair<int, ll>, int>> temp;\n        pair<int, ll> todo;\n        for (auto &e : adj[cur]) {\n            if (e.first != parent) {\n                int val = proc(e.first, cur, n);\n                sum += val;\n                largest = max(largest, val);\n                temp.emplace_back(e, val);\n            } else {\n                todo = e;\n            }\n        }\n        if (parent >= 0) {\n            largest = max(largest, n - sum);\n            temp.emplace_back(todo, n - sum);\n        }\n        if (largest <= n / 2) {\n            results = make_pair(cur, temp);\n        }\n        return sum;\n    }\n \n    void proc(int cur, int n) {\n        proc(cur, -1, n);\n    }\n};\n \nstruct stage {\n    centroids fc;\n    vector<discover> discs;\n    vector<segtree> segs;\n    vector<int> children;\n    vector<ll> extra;\n    map<int, int> childmap;\n    multiset<pair<ll, int>> cache;\n};\n \nvector<stage> stages;\n \nint decomp(int cur, int n, int id, int parentid) {\n    int origid = id++;\n \n    stages[origid].fc.proc(cur, n);\n    auto centroid = stages[origid].fc.results;\n    \n    stages[origid].discs.resize(centroid.second.size());\n    stages[origid].segs.resize(centroid.second.size());\n    stages[origid].children.resize(centroid.second.size());\n    stages[origid].extra.resize(centroid.second.size());\n    for (int i = 0; i < centroid.second.size(); i++) {\n        adj[centroid.second[i].first.first].erase(pair<int, ll>(centroid.first, centroid.second[i].first.second));\n \n        stages[origid].discs[i].proc(centroid.second[i].first.first, centroid.second[i].second);\n        stages[origid].segs[i].build(stages[origid].discs[i].initial);\n        stages[origid].children[i] = id;\n        stages[origid].extra[i] = centroid.second[i].first.second;\n        stages[origid].cache.emplace(stages[origid].segs[i].query(0, centroid.second[i].second) + centroid.second[i].first.second, i);\n        id = decomp(centroid.second[i].first.first, centroid.second[i].second, id, origid);\n        for (auto &e : stages[origid].discs[i].inid) {\n            stages[origid].childmap[e.first] = i;\n        }\n    }\n \n    return id;\n}\n \nll calc(int cur) {\n    if (!stages[cur].cache.empty()) {\n        ll temp = calc(stages[cur].children[stages[cur].cache.rbegin()->second]);\n        ll own = 0;\n        auto it = stages[cur].cache.rbegin();\n        for (int k = 0; k < min((int) stages[cur].cache.size(), 2); k++) {\n            own += (*it++).first;\n        }\n        return max(temp, own);\n    }\n    return 0;\n}\n \nvoid modify(int cur, int a, int b, ll val) {\n    auto ita = stages[cur].childmap.find(a);\n    auto itb = stages[cur].childmap.find(b);\n \n    if (ita != stages[cur].childmap.end() && itb != stages[cur].childmap.end() && ita->second == itb->second) {\n        modify(stages[cur].children[ita->second], a, b, val);\n    }\n    \n    int side, lower;\n    if (itb == stages[cur].childmap.end()) {\n        side = ita->second;\n        lower = a;\n    } else if (ita == stages[cur].childmap.end()) {\n        side = itb->second;\n        lower = b;\n    } else if (ita->second == itb->second) {\n        side = ita->second;\n        lower = (stages[cur].discs[side].inid[a] < stages[cur].discs[side].inid[b] ? b : a);\n    } else {\n        return;\n    }\n    \n    ll before = stages[cur].segs[side].query(0, 100000);\n    stages[cur].segs[side].update(stages[cur].discs[side].inid[lower], stages[cur].discs[side].outid[lower], val);\n    ll after = stages[cur].segs[side].query(0, 100000);\n    if (before != after) {\n        stages[cur].cache.erase(pair<ll, int>(before + stages[cur].extra[side], side));\n        stages[cur].cache.insert(pair<ll, int>(after + stages[cur].extra[side], side));\n    }\n}\n \nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n \n    int n, q;\n    ll w;\n    cin >> n >> q >> w;\n \n    adj.resize(n);\n    for (int i = 1; i < n; i++) {\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        a--; b--;\n \n        adj[a].emplace(b, c);\n        adj[b].emplace(a, c);\n        edges.push_back({a, b, c});\n    }\n \n    stages.resize(n);\n    decomp(0, n, 0, -1);\n    //cout << calc(0) << endl;\n \n    ll last = 0;\n    for (int j = 0; j < q; j++) {\n        int d;\n        ll e;\n        cin >> d >> e;\n        d = (d + last) % (n - 1);\n        e = (e + last) % w;\n \n        modify(0, edges[d][0], edges[d][1], e - edges[d][2]);\n        edges[d][2] = e;\n \n        last = calc(0);\n        \n        cout << last << \"\\n\";\n    }\n \n    return 0;\n}\n\t\t\t\t\t\t  \t \t\t \t \t \t\t\t\t\t\t \t\t    \t",
    "ext": "cpp"
  },
  "58137331": {
    "code": "#include <stdio.h>\n#include <vector>\n#include <utility>\n\n#define iii std::pair<long long,std::pair<int,int>>\n#define ii std::pair<int,long long>\n#define ll long long\n#define il std::pair<long long, long long>\n#define MAXN 100100\n#define left(i) (i<<1)\n#define right(i) ((i<<1)+1)\n\n\nll lz[MAXN*4]{};\nil seg[MAXN*4]{};\nint ss[MAXN*4]{};\n\nvoid prop(int id, int l, int r){\n  if(lz[id]){\n    if(l < r-1){\n      seg[left(id)].first += lz[id];\n      seg[left(id)].second -= lz[id];\n      seg[right(id)].first += lz[id];\n      seg[right(id)].second -= lz[id];\n      lz[left(id)] += lz[id];\n      lz[right(id)] += lz[id];\n    };\n    lz[id] = 0;\n  };  \n};\n\nvoid set(int id, int l, int r, int x, long long val, int f){\n  if(l >= r)return;\n  prop(id,l,r);\n  if(l == r-1 && l == x){\n    if(f){\n     seg[id].first = val;   \n     ss[id] = f;\n    }else seg[id].second = val-2*seg[id].first;\n  }else{\n    int m = (l+r)/2;  \n    if(x < m){\n      set(left(id),l,m,x,val,f);  \n    }else{\n      set(right(id),m,r,x,val,f);  \n    };\n    if(seg[left(id)].first > seg[right(id)].first){\n      seg[id].first = seg[left(id)].first;  \n      ss[id] = ss[left(id)];\n    }else{\n      seg[id].first = seg[right(id)].first;  \n      ss[id] = ss[right(id)];\n    };\n    seg[id].second = std::max(seg[left(id)].second,seg[right(id)].second);\n  };\n};\n\nii getMx(int id, int l, int r, int a, int b, bool f){\n  if(a >= r || b <= l || a >= b)return {-1,-1};\n  //printf(\"%d %d\\n\",l,r);\n  prop(id,l,r);  \n  if(l >= a && r <= b){\n    if(f)return {ss[id],seg[id].first};  \n    else{\n      //printf(\"%d %d %lld\\n\",l,r,seg[id].second);\n      return {0,seg[id].second};\n    }; \n  }else{\n    int m = (l+r)/2;  \n    ii aa = getMx(left(id),l,m,a,b,f);\n    ii bb = getMx(right(id),m,r,a,b,f);\n    if(aa.second > bb.second)return aa;\n    else return bb;\n  };\n};\n\nvoid add(int id, int l, int r, int a, int b, long long val){\n  prop(id,l,r);\n  if(a >= r || b <= l)return;\n  if(l >= a && r <= b){\n    lz[id] += val;\n    seg[id].first += lz[id];\n    seg[id].second -= lz[id];\n    //prop(id,l,r);\n    return;\n  }else{\n    int m = (l+r)/2;  \n    add(left(id),l,m,a,b,val);\n    add(right(id),m,r,a,b,val);\n  };\n  if(seg[left(id)].first > seg[right(id)].first){\n    seg[id].first = seg[left(id)].first;  \n    ss[id] = ss[left(id)];\n  }else{\n    seg[id].first = seg[right(id)].first;  \n    ss[id] = ss[right(id)];\n  };\n  seg[id].second = std::max(seg[left(id)].second,seg[right(id)].second);\n};\n\nint nxt[MAXN];\nint in[MAXN];\nint out[MAXN];\nint par[MAXN];\nint sz[MAXN];\nll depth[MAXN];\nll mdepth[MAXN];\nstd::vector<iii> edg;\nstd::vector<ii> adj[MAXN];\nlong long qry(int idx, ll val){\n  //for(int i = 1;i<=10;i++){\n    //printf(\"%d: %lld\\n\",i,getMx(1,0,MAXN,in[i],in[i]+1,1).second);  \n  //};\n  //printf(\"Querry\\n\");\n  int fs = edg[idx].second.first;\n  int sc = edg[idx].second.second;\n  ll dif = val - edg[idx].first;\n  edg[idx].first = val;\n  if(in[fs] > in[sc]){\n    std::swap(fs,sc);\n  };\n  ll mx = 0;\n  //printf(\"%lld\\n\",dif);\n  add(1,0,MAXN,in[sc],out[sc],dif);\n  while(true){\n    //printf(\"%d\\n\",sc);\n    sc = nxt[sc];\n    //printf(\"%d\\n\",sc);\n    if(sc == 1)break;\n    int nt = par[sc];\n    //printf(\"%d %d %d\\n\",nt,in[adj[nt][1].first],out[nt]);\n    //printf(\"%d\\n\",adj[nt].size());\n    //printf(\"%d\\n\",nt);\n    il tmp = getMx(1,0,MAXN,in[adj[nt][1].first],out[nt],1);\n    //printf(\"%lld %d %d\\n\",tmp.second,tmp.first,in[nt]);\n    set(1,0,MAXN,in[nt],tmp.second,0);\n    sc = par[sc];\n  };\n  il tmp = getMx(1,0,MAXN,in[1],out[1],1);\n  int akt = tmp.first;\n  //printf(\"akt: %d\\n\",tmp.first);\n  //printf(\"akt: %lld\\n\",tmp.second);\n  while(true){\n    il nx = getMx(1,0,MAXN,in[nxt[akt]],in[akt],0);\n    //printf(\"%d %lld %d %d\\n\",in[akt],nx.second,in[nxt[akt]],nx.first);\n    mx = std::max(mx,nx.second);\n    akt = nxt[akt];\n    if(akt == 1)break;\n    int nt = par[akt];\n    ll tt = getMx(1,0,MAXN,in[nt],in[nt]+1,1).second;\n    //printf(\"%lld\\n\",tt);\n    nx = getMx(1,0,MAXN,in[nt],in[akt],1);\n    //printf(\"nx: %lld %d %d\\n\",nx.second,in[nt],in[akt]);\n    mx = std::max(mx,nx.second-2*tt);\n    nx = getMx(1,0,MAXN,out[akt],out[nt],1);\n    //printf(\"nx: %lld %d %d\\n\",nx.second,out[akt],out[nt]);\n    mx = std::max(mx,nx.second-2*tt);\n    //printf(\"mx: %lld\\n\",mx);\n    akt = par[akt];\n  };\n  return mx + tmp.second;\n};\nvoid dfs1(int v, int p = 0){\n  sz[v] = 1;\n  for(auto& i:adj[v]){\n    if(i.first != p){\n      dfs1(i.first,v);\n      sz[v] += sz[i.first];\n      if(sz[i.first] > sz[adj[v][0].first])std::swap(adj[v][0],i);\n    }\n  };\n};\nint t = 0;\nvoid dfs2(int v, int p = 0){\n  in[v] = t++;\n  par[v] = p;\n  ll mx =0;\n  mdepth[v] = depth[v];\n  int cnt=0;\n  int dd=-1;\n  for(auto& i:adj[v]){\n    if(i.first != p){\n      depth[i.first] = depth[v] + i.second;\n      if(i.first == adj[v][0].first)nxt[i.first] = nxt[v];\n      else nxt[i.first] = i.first;\n      dfs2(i.first,v);  \n      mdepth[v] = std::max(mdepth[i.first],mdepth[v]);\n      if(i.first != adj[v][0].first)mx = std::max(mx,mdepth[i.first]);\n    }else dd = cnt;\n    cnt++;\n  };\n  if(dd != -1){\n    adj[v].erase(adj[v].begin() + dd);\n  };\n  set(1,0,MAXN,in[v],depth[v],v);\n  set(1,0,MAXN,in[v],mx,0);\n  out[v] = t;\n};\n\nint main(void){\n  nxt[1] = 1;\n  int n,q;\n  ll w;\n  scanf(\"%d %d %lld\",&n,&q,&w);\n  int a,b;\n  ll c;\n  for(int i = 0;i<n-1;i++){\n    scanf(\"%d %d %lld\",&a,&b,&c);\n    adj[a].push_back({b,c});\n    adj[b].push_back({a,c});\n    edg.push_back({c,{a,b}});\n  };\n  dfs1(1);\n  dfs2(1);\n  /*for(int i = 1;i<=n;i++){\n    printf(\"%d %d %d\\n\",in[i],out[i],nxt[i]);  \n  };*/\n  ll d;\n  ll e;\n  ll last = 0;\n  for(int i = 0;i<q;i++){\n    scanf(\"%lld %lld\",&d,&e);\n    d = (d+last)%(n-1);\n    e = (e+last)%w;\n    //printf(\"%lld %lld\\n\",d,e);\n    last = qry(d,e);\n    //printf(\"Baum!!!:\\n\");\n   /* for(auto &i: edg){\n      printf(\"%d %d %lld\\n\",i.second.first,i.second.second,i.first);  \n    };\n    printf(\"\\n\\n\");\n    */\n    printf(\"%lld\\n\",last);\n    //return 0;\n  };\n  return 0;\n};\n\n\n\n\n",
    "ext": "cpp"
  },
  "58135611": {
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"Ofast\")\n\nusing namespace std;\n\nint _n;\nconst int N=100005;\nvector<set<pair<int,int>>> v(N);\nvector<int> g[N];\nvector<int> centroid_depth(N);\nvector<pair<int,int>> edges;\nvector<long long> weights;\nunordered_map<int,long long> dist[N];\nunordered_map<int,int> depth[N];\nunordered_map<int,int> up[N];\nunordered_map<int,int> sub[N];\nunordered_map<int,int> tin[N];\nunordered_map<int,int> tout[N];\nvector<int> sz(N);\nvector<int> dad(N);\nvector<long long> tree[N];\nvector<long long> lazy[N];\nint time_id;\nvector<int> centroid_size(N);\nmultiset<long long> best[N];\nvector<long long> old(N);\n\nvoid push(int idx,int centroid)\n{\n    tree[centroid][2*idx]+=lazy[centroid][idx];\n    lazy[centroid][2*idx]+=lazy[centroid][idx];\n    tree[centroid][2*idx+1]+=lazy[centroid][idx];\n    lazy[centroid][2*idx+1]+=lazy[centroid][idx];\n    lazy[centroid][idx]=0;\n}\n\nvoid update(int idx,int l,int r,int ql,int qr,long long val,int centroid)\n{\n    if(ql>qr) return;\n    if(l==ql&&r==qr)\n    {\n        tree[centroid][idx]+=val;\n        lazy[centroid][idx]+=val;\n    }\n    else\n    {\n        if(lazy[centroid][idx]!=0) push(idx,centroid);\n        int m=(l+r)/2;\n        update(2*idx,l,m,ql,min(qr,m),val,centroid);\n        update(2*idx+1,m+1,r,max(ql,m+1),qr,val,centroid);\n        tree[centroid][idx]=max(tree[centroid][2*idx],tree[centroid][2*idx+1]);\n    }\n}\n\nlong long query(int idx,int l,int r,int ql,int qr,int centroid)\n{\n    if(ql>qr) return 0;\n    if(l==ql&&r==qr) return tree[centroid][idx];\n    if(lazy[centroid][idx]!=0) push(idx,centroid);\n    int m=(l+r)/2;\n    return max(query(2*idx,l,m,ql,min(qr,m),centroid),query(2*idx+1,m+1,r,max(ql,m+1),qr,centroid));\n}\n\nint dfs_ini(int a,int p)\n{\n    sz[a]=1;\n    for(pair<int,int> t:v[a])\n    {\n        int to=t.first;\n        if(to!=p) sz[a]+=dfs_ini(to,a);\n    }\n    return sz[a];\n}\n\nint get_centroid(int a,int p,int n)\n{\n    for(pair<int,int> t:v[a])\n    {\n        int to=t.first;\n        if(to!=p&&sz[to]>n/2) return get_centroid(to,a,n);\n    }\n    return a;\n}\n\nvoid dfs(int a,int p,int centroid,int sub_id,int n)\n{\n    if(a==centroid)\n    {\n        dist[centroid].insert({a,0});\n        depth[centroid].insert({a,0});\n    }\n    else\n    {\n        dist[centroid].insert({a,dist[centroid][p]+weights[up[centroid][a]]});\n        depth[centroid].insert({a,depth[centroid][p]+1});\n    }\n    sub[centroid].insert({a,sub_id});\n    tin[centroid].insert({a,time_id++});\n    update(1,1,n,tin[centroid][a],tin[centroid][a],dist[centroid][a],centroid);\n    for(pair<int,int> t:v[a])\n    {\n        int to=t.first;\n        if(to==p) continue;\n        up[centroid].insert({to,t.second});\n        dfs(to,a,centroid,(a==centroid?to:sub_id),n);\n    }\n    tout[centroid].insert({a,time_id-1});\n}\n\nlong long best_two(int centroid)\n{\n    if(best[centroid].empty()) return 0;\n    multiset<long long>::reverse_iterator it=best[centroid].rbegin();\n    long long now=*(it++);\n    if(it!=best[centroid].rend()) now+=(*it);\n    return now;\n}\n\nvoid build(int a,int p)\n{\n    int n=dfs_ini(a,p);\n    int centroid=get_centroid(a,p,n);\n    centroid_size[centroid]=n;\n    dad[centroid]=p;\n    tree[centroid].resize(4*n,0);\n    lazy[centroid].resize(4*n,0);\n    time_id=1;\n    dist[centroid].reserve(n);\n    depth[centroid].reserve(n);\n    up[centroid].reserve(n);\n    sub[centroid].reserve(n);\n    tin[centroid].reserve(n);\n    tout[centroid].reserve(n);\n    dfs(centroid,-1,centroid,-1,n);\n    for(pair<int,int> t:v[centroid])\n    {\n        int to=t.first;\n        best[centroid].insert(query(1,1,n,tin[centroid][to],tout[centroid][to],centroid));\n        v[to].erase({centroid,t.second});\n        build(to,centroid);\n    }\n    old[centroid]=best_two(centroid);\n    update(1,1,_n,centroid,centroid,old[centroid],0);\n}\n\nvoid ini_centroid(int a,int p=-1)\n{\n    if(p!=-1) centroid_depth[a]=centroid_depth[p]+1;\n    for(int to:g[a]) if(to!=p) ini_centroid(to,a);\n}\n\nvoid update_centroid(int centroid,int a,int b,long long d,long long e)\n{\n    if(depth[centroid][a]>depth[centroid][b]) swap(a,b);\n    best[centroid].erase(best[centroid].find(query(1,1,centroid_size[centroid],tin[centroid][sub[centroid][b]],tout[centroid][sub[centroid][b]],centroid)));\n    update(1,1,centroid_size[centroid],tin[centroid][b],tout[centroid][b],e-weights[d],centroid);\n    best[centroid].insert(query(1,1,centroid_size[centroid],tin[centroid][sub[centroid][b]],tout[centroid][sub[centroid][b]],centroid));\n    long long temp=best_two(centroid);\n    update(1,1,_n,centroid,centroid,temp-old[centroid],0);\n    old[centroid]=temp;\n}\n\nint main()\n{\n    int n,q;\n    long long w;\n    scanf(\"%d%d%I64d\",&n,&q,&w);\n    _n=n;\n    for(int i=0;i<n-1;i++)\n    {\n        int a,b;\n        long long c;\n        scanf(\"%d%d%I64d\",&a,&b,&c);\n        v[a].insert({b,i});\n        v[b].insert({a,i});\n        edges.push_back({a,b});\n        weights.push_back(c);\n    }\n    tree[0].resize(4*n,0);\n    lazy[0].resize(4*n,0);\n    build(1,-1);\n    int centroid=1;\n    for(int i=1;i<=n;i++)\n    {\n        if(dad[i]!=-1) g[dad[i]].push_back(i);\n        else centroid=i;\n    }\n    ini_centroid(centroid);\n    long long d,e;\n    long long last=0;\n    while(q--)\n    {\n        scanf(\"%I64d%I64d\",&d,&e);\n        d=(d+last)%((long long)n-1);\n        e=(e+last)%w;\n        int a,b;\n        tie(a,b)=edges[d];\n        if(centroid_depth[a]>centroid_depth[b]) swap(a,b);\n        int c=a;\n        while(c!=-1)\n        {\n            update_centroid(c,a,b,d,e);\n            c=dad[c];\n        }\n        weights[d]=e;\n        last=query(1,1,_n,1,_n,0);\n        printf(\"%I64d\\n\",last);\n    }\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "58135463": {
    "code": "#include <bits/stdc++.h>\n#pragma GCC target(\"avx2\")\n\nusing namespace std;\n\nint _n;\nconst int N=100005;\nvector<set<pair<int,int>>> v(N);\nvector<int> g[N];\nvector<int> centroid_depth(N);\nvector<pair<int,int>> edges;\nvector<long long> weights;\nunordered_map<int,long long> dist[N];\nunordered_map<int,int> depth[N];\nunordered_map<int,int> up[N];\nunordered_map<int,int> sub[N];\nunordered_map<int,int> tin[N];\nunordered_map<int,int> tout[N];\nvector<int> sz(N);\nvector<int> dad(N);\nvector<long long> tree[N];\nvector<long long> lazy[N];\nint time_id;\nvector<int> centroid_size(N);\nmultiset<long long> best[N];\nvector<long long> old(N);\n\nvoid push(int idx,int centroid)\n{\n    tree[centroid][2*idx]+=lazy[centroid][idx];\n    lazy[centroid][2*idx]+=lazy[centroid][idx];\n    tree[centroid][2*idx+1]+=lazy[centroid][idx];\n    lazy[centroid][2*idx+1]+=lazy[centroid][idx];\n    lazy[centroid][idx]=0;\n}\n\nvoid update(int idx,int l,int r,int ql,int qr,long long val,int centroid)\n{\n    if(ql>qr) return;\n    if(l==ql&&r==qr)\n    {\n        tree[centroid][idx]+=val;\n        lazy[centroid][idx]+=val;\n    }\n    else\n    {\n        if(lazy[centroid][idx]!=0) push(idx,centroid);\n        int m=(l+r)/2;\n        update(2*idx,l,m,ql,min(qr,m),val,centroid);\n        update(2*idx+1,m+1,r,max(ql,m+1),qr,val,centroid);\n        tree[centroid][idx]=max(tree[centroid][2*idx],tree[centroid][2*idx+1]);\n    }\n}\n\nlong long query(int idx,int l,int r,int ql,int qr,int centroid)\n{\n    if(ql>qr) return 0;\n    if(l==ql&&r==qr) return tree[centroid][idx];\n    if(lazy[centroid][idx]!=0) push(idx,centroid);\n    int m=(l+r)/2;\n    return max(query(2*idx,l,m,ql,min(qr,m),centroid),query(2*idx+1,m+1,r,max(ql,m+1),qr,centroid));\n}\n\nint dfs_ini(int a,int p)\n{\n    sz[a]=1;\n    for(pair<int,int> t:v[a])\n    {\n        int to=t.first;\n        if(to!=p) sz[a]+=dfs_ini(to,a);\n    }\n    return sz[a];\n}\n\nint get_centroid(int a,int p,int n)\n{\n    for(pair<int,int> t:v[a])\n    {\n        int to=t.first;\n        if(to!=p&&sz[to]>n/2) return get_centroid(to,a,n);\n    }\n    return a;\n}\n\nvoid dfs(int a,int p,int centroid,int sub_id,int n)\n{\n    if(a==centroid)\n    {\n        dist[centroid].insert({a,0});\n        depth[centroid].insert({a,0});\n    }\n    else\n    {\n        dist[centroid].insert({a,dist[centroid][p]+weights[up[centroid][a]]});\n        depth[centroid].insert({a,depth[centroid][p]+1});\n    }\n    sub[centroid].insert({a,sub_id});\n    tin[centroid].insert({a,time_id++});\n    update(1,1,n,tin[centroid][a],tin[centroid][a],dist[centroid][a],centroid);\n    for(pair<int,int> t:v[a])\n    {\n        int to=t.first;\n        if(to==p) continue;\n        up[centroid].insert({to,t.second});\n        dfs(to,a,centroid,(a==centroid?to:sub_id),n);\n    }\n    tout[centroid].insert({a,time_id-1});\n}\n\nlong long best_two(int centroid)\n{\n    if(best[centroid].empty()) return 0;\n    multiset<long long>::reverse_iterator it=best[centroid].rbegin();\n    long long now=*(it++);\n    if(it!=best[centroid].rend()) now+=(*it);\n    return now;\n}\n\nvoid build(int a,int p)\n{\n    int n=dfs_ini(a,p);\n    int centroid=get_centroid(a,p,n);\n    centroid_size[centroid]=n;\n    dad[centroid]=p;\n    tree[centroid].resize(4*n,0);\n    lazy[centroid].resize(4*n,0);\n    time_id=1;\n    dist[centroid].reserve(n);\n    depth[centroid].reserve(n);\n    up[centroid].reserve(n);\n    sub[centroid].reserve(n);\n    tin[centroid].reserve(n);\n    tout[centroid].reserve(n);\n    dfs(centroid,-1,centroid,-1,n);\n    for(pair<int,int> t:v[centroid])\n    {\n        int to=t.first;\n        best[centroid].insert(query(1,1,n,tin[centroid][to],tout[centroid][to],centroid));\n        v[to].erase({centroid,t.second});\n        build(to,centroid);\n    }\n    old[centroid]=best_two(centroid);\n    update(1,1,_n,centroid,centroid,old[centroid],0);\n}\n\nvoid ini_centroid(int a,int p=-1)\n{\n    if(p!=-1) centroid_depth[a]=centroid_depth[p]+1;\n    for(int to:g[a]) if(to!=p) ini_centroid(to,a);\n}\n\nvoid update_centroid(int centroid,int a,int b,long long d,long long e)\n{\n    if(depth[centroid][a]>depth[centroid][b]) swap(a,b);\n    best[centroid].erase(best[centroid].find(query(1,1,centroid_size[centroid],tin[centroid][sub[centroid][b]],tout[centroid][sub[centroid][b]],centroid)));\n    update(1,1,centroid_size[centroid],tin[centroid][b],tout[centroid][b],e-weights[d],centroid);\n    best[centroid].insert(query(1,1,centroid_size[centroid],tin[centroid][sub[centroid][b]],tout[centroid][sub[centroid][b]],centroid));\n    long long temp=best_two(centroid);\n    update(1,1,_n,centroid,centroid,temp-old[centroid],0);\n    old[centroid]=temp;\n}\n\nint main()\n{\n    //freopen(\"C:\\\\Users\\\\Benja\\\\Downloads\\\\diameter-full\\\\5.006.in\",\"r\",stdin);\n    int n,q;\n    long long w;\n    scanf(\"%d%d%I64d\",&n,&q,&w);\n    _n=n;\n    for(int i=0;i<n-1;i++)\n    {\n        int a,b;\n        long long c;\n        scanf(\"%d%d%I64d\",&a,&b,&c);\n        v[a].insert({b,i});\n        v[b].insert({a,i});\n        edges.push_back({a,b});\n        weights.push_back(c);\n    }\n    tree[0].resize(4*n,0);\n    lazy[0].resize(4*n,0);\n    build(1,-1);\n    int centroid=1;\n    for(int i=1;i<=n;i++)\n    {\n        if(dad[i]!=-1) g[dad[i]].push_back(i);\n        else centroid=i;\n    }\n    ini_centroid(centroid);\n    long long d,e;\n    long long last=0;\n    while(q--)\n    {\n        scanf(\"%I64d%I64d\",&d,&e);\n        d=(d+last)%((long long)n-1);\n        e=(e+last)%w;\n        int a,b;\n        tie(a,b)=edges[d];\n        if(centroid_depth[a]>centroid_depth[b]) swap(a,b);\n        int c=a;\n        while(c!=-1)\n        {\n            update_centroid(c,a,b,d,e);\n            c=dad[c];\n        }\n        weights[d]=e;\n        last=query(1,1,_n,1,_n,0);\n        printf(\"%I64d\\n\",last);\n    }\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "58122230": {
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXN=200005;\nstruct edge{int x,y,next;LL c;}a[2*MAXN];int len,last[MAXN];\nvoid ins(int x,int y,LL c){len++;a[len].x=x;a[len].y=y;a[len].c=c;a[len].next=last[x];last[x]=len;}\nint num[2*MAXN],dfn,fir[2*MAXN],lst[2*MAXN];LL dep[MAXN];\nint n,m;LL W;\nvoid init(int x,int fa)\n{\n\tnum[++dfn]=x;fir[x]=dfn;\n\tfor(int k=last[x];k;k=a[k].next)\n\t{\n\t\tint y=a[k].y;\n\t\tif(y!=fa)dep[y]=dep[x]+a[k].c,init(y,x),num[++dfn]=x;\n\t}\n\tlst[x]=dfn;\n}\nstruct segtree\n{\n\t#define lc now<<1\n\t#define rc now<<1|1\n\tLL ls[4*MAXN],rs[4*MAXN],s[4*MAXN],mxdep[4*MAXN],mndep[4*MAXN];\n\tLL lazy[4*MAXN];\n\tvoid down(int now)\n\t{\n\t\tif(!lazy[now])return ;\n\t\tls[lc]-=lazy[now];rs[lc]-=lazy[now];ls[rc]-=lazy[now];rs[rc]-=lazy[now];\n\t\tmxdep[lc]+=lazy[now];mndep[lc]+=lazy[now];mxdep[rc]+=lazy[now];mndep[rc]+=lazy[now];\n\t\tlazy[lc]+=lazy[now];lazy[rc]+=lazy[now];lazy[now]=0;\n\t}\n\tvoid updata(int now)\n\t{\n\t\tmxdep[now]=max(mxdep[lc],mxdep[rc]);mndep[now]=min(mndep[lc],mndep[rc]);\n\t\tls[now]=max(max(ls[lc],ls[rc]),mxdep[lc]-2*mndep[rc]);\n\t\trs[now]=max(max(rs[lc],rs[rc]),mxdep[rc]-2*mndep[lc]);\n\t\ts[now]=max(max(s[lc],s[rc]),max(mxdep[lc]+rs[rc],mxdep[rc]+ls[lc]));\t\t\n\t}\n\tvoid modify(int now,int l,int r,int ql,int qr,LL c)\n\t{\n\t\tif(l==ql&&r==qr)\n\t\t{\n\t\t\tls[now]-=c;rs[now]-=c;mxdep[now]+=c;mndep[now]+=c;\n\t\t\tlazy[now]+=c;return ;\n\t\t}down(now);\n\t\tint mid=(l+r)/2;\n\t\tif(qr<=mid)modify(lc,l,mid,ql,qr,c);\n\t\telse if(mid+1<=ql)modify(rc,mid+1,r,ql,qr,c);\n\t\telse modify(lc,l,mid,ql,mid,c),modify(rc,mid+1,r,mid+1,qr,c);\n\t\tupdata(now);\n\t}\n\tvoid buildtree(int now,int l,int r)\n\t{\n\t\tif(l==r)\n\t\t{\n\t\t\tls[now]=rs[now]=-dep[num[l]];mxdep[now]=mndep[now]=dep[num[l]];\n\t\t\treturn ;\n\t\t}\n\t\tint mid=(l+r)/2;buildtree(lc,l,mid);buildtree(rc,mid+1,r);\n\t\tupdata(now);\n\t}\n}seg;\nint main()\n{\n\tn=read();m=read();W=read();\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read();LL c=read();\n\t\tins(x,y,c);ins(y,x,c);\n\t}\n\tinit(1,0);seg.buildtree(1,1,dfn);\n\tLL lastans=0;\n\twhile(m--)\n\t{\n\t\tint d=read();LL c=read();\n\t\td=(d+lastans)%(n-1)+1;c=(c+lastans)%W;\n\t\tLL ad=c-a[2*d].c;a[2*d].c=c;\n\t\tint x=fir[a[2*d].x]<fir[a[2*d].y]?a[2*d].y:a[2*d].x;\n\t\tseg.modify(1,1,dfn,fir[x],lst[x],ad);\n\t\tpr2(lastans=seg.s[1]);\n\t}\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "58114028": {
    "code": "//test\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pii pair<int,int> \n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\nconst int N=100005;\nint n,Q,nn,ps[N],L[N],R[N];ll k,ans,w[N];\nvector<pii>g[N];\nstruct st\n{\n\tll p,m,tg,lm,mr,lmr;\n\tinline void upd(ll v){p+=v;m-=2*v;lm-=v;mr-=v;tg+=v;}\n\tinline st operator+(const st&b)const\n\t{\n\t\tst c;c.p=max(p,b.p);c.m=max(m,b.m);\n\t\tc.lm=max(max(lm,b.lm),p+b.m);\n\t\tc.mr=max(max(mr,b.mr),m+b.p);\n\t\tc.lmr=max(max(lmr,b.lmr),max(lm+b.p,p+b.mr));\n\t\treturn c;\n\t}\n}T[N<<3];\nvoid upd(int x,int l,int r,int tl,int tr,ll v)\n{\n\tif(r<tl||tr<l)return;if(tl<=l&&r<=tr){T[x].upd(v);return;}\n\tT[x<<1].upd(T[x].tg);T[x<<1|1].upd(T[x].tg);T[x].tg=0;\n\tint mid=l+r>>1;upd(x<<1,l,mid,tl,tr,v);upd(x<<1|1,mid+1,r,tl,tr,v);\n\tT[x]=T[x<<1]+T[x<<1|1];\n}\nvoid dfs(int x,int p)\n{\n\tL[x]=++nn;\n\tfor(int i=0;i<g[x].size();i++)if(g[x][i].X!=p){ps[g[x][i].Y]=g[x][i].X;dfs(g[x][i].X,x);nn++;}\n\tR[x]=nn;\n} \nint main()\n{\n\tscanf(\"%d%d%lld\",&n,&Q,&k);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v;scanf(\"%d%d%lld\",&u,&v,&w[i]);\n\t\tg[u].pb(mp(v,i));g[v].pb(mp(u,i));\n\t}\n\tdfs(1,0);\n\tfor(int i=1;i<n;i++)upd(1,1,2*n,L[ps[i]],R[ps[i]],w[i]);\n\twhile(Q--)\n\t{\n\t\tll x,v;scanf(\"%lld%lld\",&x,&v);\n\t\tx=(x+ans)%(n-1)+1;v=(v+ans)%k;\n\t\tupd(1,1,2*n,L[ps[x]],R[ps[x]],v-w[x]);\n\t\tw[x]=v;printf(\"%lld\\n\",ans=T[1].lmr);\n\t}\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "58111809": {
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\ninline void write(int x)\n{\n    if(x<0)putchar('-'),x=-x;\n    if(x>9)write(x/10);\n    putchar(x%10+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nint n;\nlong long s[100010];\ninline int lowbit(int x){return x&-x;}\ninline void add(int x,long long w)\n{\n\twhile(x<=n)\n\t{\n\t\ts[x]+=w;\n\t\tx+=lowbit(x);\n\t}\n}\ninline long long getsum(int x)\n{\n\tlong long sum=0;\n\twhile(x>=1)\n\t{\n\t\tsum+=s[x];\n\t\tx-=lowbit(x);\n\t}return sum;\n}\nstruct node\n{\n\tint x,y,next;long long c;\n}a[200010];int len,last[100010];\ninline void ins(int x,int y,long long c)\n{\n\tlen++;\n\ta[len].x=x;a[len].y=y;a[len].c=c;\n\ta[len].next=last[x];last[x]=len;\n}\nint id,ys[100010],ex[100010],dep[100010],tot[100010],f[100010][20];\ninline void dfs(int x)\n{\n\tys[x]=++id,ex[id]=x;tot[x]=1;\n\tfor(int i=1;(1<<i)<=dep[x];i++)f[x][i]=f[f[x][i-1]][i-1];\n\tfor(int k=last[x];k;k=a[k].next)\n\t{\n\t\tint y=a[k].y;\n\t\tif(y==f[x][0])continue;\n\t\tdep[y]=dep[x]+1,f[y][0]=x;\n\t\tdfs(y);\n\t\ttot[x]+=tot[y];\n\t\tadd(ys[y],a[k].c),add(ys[y]+tot[y],-a[k].c);\n\t}\n}\ninline int LCA(int x,int y)\n{\n\tif(dep[x]<dep[y])swap(x,y);\n\tfor(int i=16;i>=0;i--)if(dep[x]-dep[y]>=(1<<i))x=f[x][i];\n\tif(x==y)return x;\n\tfor(int i=16;i>=0;i--)if(dep[x]>=(1<<i) && f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];\n\treturn f[x][0];\n}\ninline long long getdis(int x,int y)\n{\n\tint p=LCA(ex[x],ex[y]);\n\treturn getsum(x)+getsum(y)-2*getsum(ys[p]);\n}\nstruct trnode\n{\n\tint l,r,lc,rc,p[2];long long val;\n}tr[200010];int trlen;\ninline void update(int x)\n{\n\ttr[x].val=0;\n\tint lc=tr[x].lc,rc=tr[x].rc;long long uf;\n\tfor(int i=0;i<2;i++)\n\t{\n\t\tfor(int j=0;j<2;j++)\n\t\t{\n\t\t\tuf=getdis(tr[lc].p[i],tr[rc].p[j]);\n\t\t\tif(tr[x].val<uf){tr[x].val=uf;tr[x].p[0]=tr[lc].p[i],tr[x].p[1]=tr[rc].p[j];}\n\t\t}\n\t}\n\tuf=tr[lc].val;\n\tif(tr[x].val<uf){tr[x].val=uf;tr[x].p[0]=tr[lc].p[0],tr[x].p[1]=tr[lc].p[1];}\n\tuf=tr[rc].val;\n\tif(tr[x].val<uf){tr[x].val=uf;tr[x].p[0]=tr[rc].p[0],tr[x].p[1]=tr[rc].p[1];}\n}\ninline void bt(int l,int r)\n{\n\tint now=++trlen;\n\ttr[now].l=l;tr[now].r=r;\n\tif(l==r)tr[now].p[0]=tr[now].p[1]=l,tr[now].val=0;\n\telse\n\t{\n\t\tint mid=(l+r)>>1;\n\t\ttr[now].lc=trlen+1;bt(l,mid);\n\t\ttr[now].rc=trlen+1;bt(mid+1,r);\n\t\tupdate(now);\n\t}\n}\ninline void change(int now,int p)\n{\n\tif(tr[now].l<=p && p+1<=tr[now].r){change(tr[now].lc,p),change(tr[now].rc,p);update(now);}\n}\nint main()\n{\n    //freopen(\"a.in\",\"r\",stdin);\n    //freopen(\"a.out\",\"w\",stdout);\n    n=read();int q=read();long long w;scanf(\"%lld\",&w);\n    for(int i=1;i<n;i++)\n    {\n    \tint x=read(),y=read();long long c;scanf(\"%lld\",&c);\n    \tins(x,y,c),ins(y,x,c);\n    }dfs(1),bt(1,n);\n    long long ans=0;\n    while(q--)\n    {\n    \tlong long p,s;\n\t\tscanf(\"%lld%lld\",&p,&s);p=(p+ans)%(n-1)+1,s=(s+ans)%w;p*=2;\n\t\tint x=a[p].x;\n    \tif(f[a[p].y][0]==x)x=a[p].y;\n    \tadd(ys[x],-a[p].c),add(ys[x]+tot[x],a[p].c);\n    \ta[p].c=s;\n    \tadd(ys[x],a[p].c),add(ys[x]+tot[x],-a[p].c);\n    \tchange(1,ys[x]-1),change(1,ys[x]+tot[x]-1);\n    \tans=tr[1].val;printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}",
    "ext": "cpp"
  },
  "58086523": {
    "code": "// KALAM\n# include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200000 + 77;\nconst long long inf = 4e18 + 77;\nlong long A , d[N] , Ew[N];\nint n , q , m = 1;\nint Ev[N] , Eu[N] , F[N] , St[N] , En[N];\nvector < int > adj[N];\nstruct Node {\n\tlong long x = 0 , y = 0 , xy = 0 , yz = 0 , xyz = 0 , lz = 0;\n\tinline Node const operator + (Node & X) {\n\t\tNode r;\n\t\tr.x = max(x , X.x);\n\t\tr.y = min(y , X.y);\n\t\tr.xy = max(xy , max(X.xy , x - 2 * X.y));\n\t\tr.yz = max(yz , max(X.yz , X.x - y * 2));\n\t\tr.xyz = max(xyz , max(X.xyz , max(xy + X.x , x + X.yz)));\n\t\treturn r;\n\t}\n} T[N << 2];\nvoid dfs(int v , int prev = - 1) {\n\tSt[v] = m;\n\tF[m ++] = v;\n\tfor(int id : adj[v]) {\n\t\tint u = v ^ Ev[id] ^ Eu[id];\n\t\tif(u == prev) continue ;\n\t\tif(u == Ev[id]) swap(Ev[id] , Eu[id]);\n\t\td[u] = d[v] + Ew[id];\n\t\tdfs(u , v);\n\t\tF[m ++] = v;\n\t}\n\tEn[v] = m;\n}\ninline void Shift(int l , int r , int id) {\n\tlong long x = T[id].lz;\n\tif(x == 0) return ;\n\tT[id].lz = 0;\n\tT[id].x += x;\n\tT[id].y += x;\n\tT[id].xy -= x;\n\tT[id].yz -= x;\n\tif(r - l > 1)\n\t\tT[id << 1].lz += x , T[id << 1 ^ 1].lz += x;\n}\nvoid Build(int l = 1 , int r = m + 1 , int id = 1) {\n\tif(r - l < 2) {\n\t\tT[id].x = T[id].y = d[F[l]];\n\t\tT[id].xy = T[id].yz = - d[F[l]];\n\t\tT[id].xyz = 0;\n\t\treturn ;\n\t}\t\n\tint mid = ((l + r) >> 1);\n\tBuild(l , mid , id << 1);\n\tBuild(mid , r , id << 1 ^ 1);\n\tT[id] = T[id << 1] + T[id << 1 ^ 1];\n}\nvoid Add(int ql , int qr , long long x , int l = 1 , int r = m + 1 , int id = 1) {\n\tShift(l , r , id);\n\tif(qr <= l || r <= ql) return ;\n\tif(ql <= l && r <= qr) {\n\t\tT[id].lz += x;\n\t\tShift(l , r , id);\n\t\treturn ;\n\t}\n\tint mid = ((l + r) >> 1);\n\tAdd(ql , qr , x , l , mid , id << 1);\n\tAdd(ql , qr , x , mid , r , id << 1 ^ 1);\n\tT[id] = T[id << 1] + T[id << 1 ^ 1];\n}\nint main() {\n\tscanf(\"%d %d %lld\" , & n , & q , & d[0]);\n\tfor(int i = 1;i < n;++ i)\n\t\tscanf(\"%d %d %lld\" , Ev + i , Eu + i , Ew + i) , adj[Ev[i]].push_back(i) , adj[Eu[i]].push_back(i);\n\tdfs(1);\n\t-- m;\n\tBuild();\n\twhile(q --) {\n\t\tlong long dt;\n\t\tint x;\n\t\tscanf(\"%d %lld\" , & x , & dt);\n\t\tx = (x + A) % (n - 1) + 1;\n\t\tdt = (dt + A) % d[0];\n\t\tAdd(St[Eu[x]] , En[Eu[x]] , dt - Ew[x]);\n\t\tEw[x] = dt;\n\t\tA = T[1].xyz;\n\t\tprintf(\"%lld\\n\" , A);\n\t}\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "58086184": {
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define forn(i,p,k) for(int (i)=(p);(i)<=(k);++(i))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,ll> pil;\ntypedef pair<int,int> pii;\nconst int MM=100013;\nconst int baza=(1<<17);\nconst int LOG=20;\nll Tree[baza<<1];\ninline void Upd(int ind, ll v)\n{\n    ind+=baza;\n    Tree[ind]=v;\n    for(ind>>=1;ind;ind>>=1)    Tree[ind]=max(Tree[ind<<1],Tree[ind<<1|1]);\n}\ninline ll Ans(){return Tree[1];}\nint sz[MM][LOG],par[MM][LOG],Cenpar[MM],Cen[MM],Cendeep[MM],pre[MM][LOG],tim=0;\npair<pii,ll> Kraw[MM];\nvector<ll> deep[MM];\nvector<pil> G[MM];\nvector<int> W[MM],pp[MM];\nstruct Node\n{\n    Node *L,*R;\n    pair<ll,int> W1,W2;\n    ll lazy;\n    Node():L(nullptr),R(nullptr),W1({0,0}),W2({0,0}),lazy(0){}\n    inline void extend(){this->L=new Node;this->R=new Node;}\n    inline void Push(const ll v){this->L->lazy+=v;this->R->lazy+=v;}\n};\ninline void Merge(const Node &a, const Node &b, Node *WYN)\n{\n    WYN->W1=max(a.W1,b.W1);\n    WYN->W2=mp(0,0);\n    if(min(a.W1,b.W1).sc!=WYN->W1.sc)   WYN->W2=min(a.W1,b.W1);\n    if(a.W2.sc!=WYN->W1.sc)             WYN->W2=max(WYN->W2,a.W2);\n    if(b.W2.sc!=WYN->W1.sc)             WYN->W2=max(WYN->W2,b.W2);\n}\nvoid Init(Node *N, const int p, const int k, const int w)\n{\n    if(p==k)\n    {\n        N->W1=mp(deep[w][p],pp[w][p]);\n        return;\n    }\n    N->extend();\n    int mid=((p+k)>>1);\n    Init(N->L,p,mid,w);\n    Init(N->R,mid+1,k,w);\n    Merge((*N->L),(*N->R),N);\n}\nvoid Update(Node *N, const int p, const int k, const int l, const int r, const ll v)\n{\n    if(N->lazy)\n    {\n        N->W1.fi+=N->lazy;\n        if(p!=k)    N->Push(N->lazy);\n        N->lazy=0;\n    }\n    if(p>r||k<l)    return;\n    if(l<=p&&k<=r)\n    {\n        N->W1.fi+=v;\n        if(p!=k)    N->Push(v);\n        return;\n    }\n    int mid=((p+k)>>1);\n    Update(N->L,p,mid,l,r,v);\n    Update(N->R,mid+1,k,l,r,v);\n    Merge((*N->L),(*N->R),N);\n}\nint Sz(int w, int p, const int &ii)\n{\n    sz[w][ii]=1;\n    for(auto v:W[w])    if(v!=p&&Cen[v]!=1) sz[w][ii]+=Sz(v,w,ii);\n    return sz[w][ii];\n}\ninline int FindCen(int w, int p, int n, int ii)\n{\n    bool MX;\n    while(true)\n    {\n        MX=true;\n        for(auto v:W[w])    if(v!=p&&Cen[v]!=1&&sz[v][ii]>(n>>1))\n        {\n            p=w;\n            w=v;\n            MX=false;\n            break;\n        }\n        if(MX)  return w;\n    }\n}\nvoid DFS(int w, int p, ll d, const int &ppar, const int &P, const int &ii)\n{\n    pre[w][ii]=tim++;\n    par[w][ii]=p;\n    deep[P].pb(d);\n    pp[P].pb(ppar);\n    for(auto v:G[w])    if(v.fi!=p&&Cen[v.fi]!=1)   DFS(v.fi,w,d+v.sc,ppar,P,ii);\n}\nNode *root[MM];\nvoid CentroidDec(int w, int p, int ii)\n{\n    int n=Sz(w,-1,ii);\n    int x=FindCen(w,-1,n,ii);\n    Cen[x]=1;\n    Cenpar[x]=p;\n    Cendeep[x]=ii;\n    pre[x][ii]=0;\n    deep[x].pb(0);\n    pp[x].pb(0);\n    tim=1;\n    Sz(x,-1,ii);\n    for(auto v:G[x])    if(Cen[v.fi]!=1)    DFS(v.fi,x,v.sc,v.fi,x,ii);\n    Init(root[x],0,sz[x][ii]-1,x);\n    Upd(x,root[x]->W1.fi+root[x]->W2.fi);\n    for(auto v:W[x])    if(Cen[v]!=1)   CentroidDec(v,x,ii+1);\n}\ninline ll MainUpdate(int idx, ll v)\n{\n    int a=Kraw[idx].fi.fi;\n    int b=Kraw[idx].fi.sc;\n    ll x=Kraw[idx].sc;\n    x=v-x;\n    Kraw[idx].sc=v;\n    if(Cendeep[a]>Cendeep[b])   swap(a,b);\n    for(int ii=Cendeep[a],w=a;ii>=0;--ii,w=Cenpar[w])\n    {\n        if(par[a][ii]!=b)   swap(a,b);\n        Update(root[w],0,sz[w][ii]-1,pre[a][ii],pre[a][ii]+sz[a][ii]-1,x);\n        Upd(w,root[w]->W1.fi+root[w]->W2.fi);\n    }\n    return Ans();\n}\ninline void read(int &x)\n{\n    char c='*';\n    for(;c>'9'||c<'0';c=getc(stdin)){}\n    for(x=0;'0'<=c&&c<='9';c=getc(stdin))   x=(x<<3)+(x<<1)+c-'0';\n}\ninline void readL(ll &x)\n{\n    char c='*';\n    for(;c>'9'||c<'0';c=getc(stdin)){}\n    for(x=0;'0'<=c&&c<='9';c=getc(stdin))   x=(x<<3)+(x<<1)+c-'0';\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    int n,q,b,a;\n    ll w,c,last=0;\n    read(n);read(q);readL(w);\n    forn(i,1,n) root[i]=new Node;\n    forn(i,0,n-2)\n    {\n        read(a);read(b);readL(c);\n        Kraw[i].fi.fi=a;\n        Kraw[i].fi.sc=b;\n        Kraw[i].sc=c;\n        W[a].pb(b);\n        W[b].pb(a);\n        G[a].pb(mp(b,c));\n        G[b].pb(mp(a,c));\n    }\n    CentroidDec(1,-1,0);\n    forn(i,1,q)\n    {\n        read(a);readL(c);\n        a=(last+a)%(n-1);\n        c=(last+c)%w;\n        last=MainUpdate(a,c);\n        printf(\"%I64d\\n\",last);\n    }\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "58077146": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst ll inf = 1e18;\nconst int maxn = 100010;\nconst int maxq = 100010;\n\n\n\nint n, q;\nll max_weight;\nvector<int> adj[maxn];\n\nstruct Edge {\n    int u, v;\n    ll w;\n    vector<pii> intrees; // in which centroids' segment trees it is in, also the lower node\n\n    inline int other(int nd) {\n        return nd == u ? v : u;\n    }\n} edges[maxn];\n\nstruct Node {\n    Node *ln, *rn;\n    int tl, tr;\n\n    ll maxval;\n    ll lazy;\n\n    Node() {}\n\n    void init(int treel, int treer, vector<ll> &vec) {\n        tl = treel;\n        tr = treer;\n        build(vec);\n    }\n\n    inline void push() {\n        ln->maxval += lazy;\n        ln->lazy += lazy;\n        rn->maxval += lazy;\n        rn->lazy += lazy;\n        lazy = 0;\n    }\n\n    inline void merge() {\n        maxval = max(ln->maxval, rn->maxval);\n    }\n\n    void build(vector<ll> &vec) {\n        lazy = 0;\n        if (tl == tr) {\n            maxval = vec[tl];\n        } else {\n            int tm = (tl + tr) / 2;\n            ln = new Node();\n            rn = new Node();\n            ln->init(tl, tm, vec);\n            rn->init(tm+1, tr, vec);\n            merge();\n        }\n        // cout << \"tl=\" << tl << \" tr=\" << tr << \" maxval=\" << maxval << endl;\n    }\n\n    void update(int l, int r, ll val) {\n        if (l > r) {\n            return;\n        }\n        if (l <= tl && tr <= r) {\n            maxval += val;\n            lazy += val;\n            return;\n        }\n        push();\n        ln->update(l, min(r, ln->tr), val);\n        rn->update(max(l, rn->tl), r, val);\n        merge();\n    }\n\n    ll query(int l, int r) {\n        if (l > r) {\n            return 0;\n        }\n        if (l <= tl && tr <= r) {\n            return maxval;\n        }\n        push();\n        return max(ln->query(l, min(r, ln->tr)),\n                   rn->query(max(l, rn->tl), r));\n    }\n\n    void set_single(int i, ll val) {\n        if (tl == tr) {\n            maxval = val;\n            lazy = 0;\n            return;\n        }\n        if (i <= ln->tr) {\n            ln->set_single(i, val);\n        } else {\n            rn->set_single(i, val);\n        }\n        merge();\n    }\n} trees[maxn]; // segment tree for each centroid\n\n// segment tree for the array a[centroid] = max length of path\n// going through centroid, all nodes are in centroid's subtree\nNode best_path;\n\nbool removed[maxn];\nint sbsz_cdecompose[maxn];\n\nint num_calls;\nunordered_map<int, int> label[maxn]; // dfs reordering for each centroid's subtree\nvector<int> sbsz[maxn]; // subtree size for each node in each centroid's subtree\nvector<int> panc[maxn];\nmultiset<ll> panc_data[maxn];\n\nint dfs_centroid(int centroid, vector<ll> &distances, int u, int p, ll dist, int p2) {\n    distances.push_back(dist);\n    int label_u = num_calls++;\n    label[centroid][u] = label_u;\n    sbsz[centroid].push_back(1);\n    if (p2 == -1 && u != centroid) {\n        p2 = label_u;\n    }\n    panc[centroid].push_back(p2);\n    for (int i : adj[u]) {\n        int v = edges[i].other(u);\n        if (v != p && !removed[v]) {\n            edges[i].intrees.emplace_back(centroid, v);\n            int label_v = dfs_centroid(centroid, distances, v, u, dist + edges[i].w, p2);\n            sbsz[centroid][label_u] += sbsz[centroid][label_v];\n        }\n    }\n    // cout << \"dfs(u=\" << u << \", dist=\" << dist << \", p2=\" << p2 << \") label=\" << label_u << \" sbsz=\" << sbsz[centroid][label_u] << \" dist=\" << distances[label_u] << \"\\n\";\n    return label_u;\n}\n\ninline void get_centroid_best_path(int centroid) {\n    ll res = 0;\n    int i = 0;\n    for (auto it = panc_data[centroid].rbegin(); i < 2 && it != panc_data[centroid].rend(); ++i, ++it) {\n        res += *it;\n    }\n    // cout << \"panc data for centroid=\" << centroid << \": \";\n    // for (auto it = panc_data[centroid].begin(); it != panc_data[centroid].end(); ++it) {\n    //     cout << *it << ' ';\n    // }\n    // cout << endl;\n    // cout << \"best path for centroid=\" << centroid << \": \" << res << endl;\n    best_path.set_single(centroid, res);\n}\n\ninline void solve_centroid(int centroid) {\n    // cout << \"\\ncentroid: \" << centroid << endl;\n    vector<ll> distances;\n    num_calls = 0;\n    dfs_centroid(centroid, distances, centroid, -1, 0, -1);\n    // cout << \"distances: \"; for (auto x : distances) cout << x << ' '; cout << \"\\n\";\n    // cout << \"num_calls: \" << num_calls << endl;\n    trees[centroid].init(0, num_calls-1, distances);\n    for (int i : adj[centroid]) {\n        int v = edges[i].other(centroid);\n        if (!removed[v]) {\n            int label_v = label[centroid][v];\n            // cout << \"child for centroid=\" << v << \" (label=\" << label_v << \"), maxdist=\" << trees[centroid].query(label_v, label_v + sbsz[centroid][label_v] - 1) << \"\\n\";\n            panc_data[centroid].insert(trees[centroid].query(label_v, label_v + sbsz[centroid][label_v] - 1));\n        }\n    }\n    get_centroid_best_path(centroid);\n}\n\nvoid dfs_sbsz_cdecompose(int u, int p) {\n    sbsz_cdecompose[u] = 1;\n    for (int i : adj[u]) {\n        int v = edges[i].other(u);\n        if (v != p && !removed[v]) {\n            dfs_sbsz_cdecompose(v, u);\n            sbsz_cdecompose[u] += sbsz_cdecompose[v];\n        }\n    }\n}\n\nint find_centroid(int u, int p, int sz) {\n    for (int i : adj[u]) {\n        int v = edges[i].other(u);\n        if (v != p && !removed[v] && sbsz_cdecompose[v] > sz/2) {\n            return find_centroid(v, u, sz);\n        }\n    }\n    return u;\n}\n\nvoid cdecompose(int root, int parent) {\n    dfs_sbsz_cdecompose(root, parent);\n    int centroid = find_centroid(root, parent, sbsz_cdecompose[root]);\n    solve_centroid(centroid);\n    removed[centroid] = true;\n    for (int i : adj[centroid]) {\n        int v = edges[i].other(centroid);\n        if (!removed[v]) {\n            cdecompose(v, centroid);\n        }\n    }\n    removed[centroid] = false;\n}\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    cin >> n >> q >> max_weight;\n    for (int i = 0; i < n-1; ++i) {\n        cin >> edges[i].u >> edges[i].v >> edges[i].w;\n        adj[edges[i].u].push_back(i);\n        adj[edges[i].v].push_back(i);\n    }\n    {\n        vector<ll> aux(n+1, 0);\n        best_path.init(1, n, aux);\n    }\n    memset(removed, false, sizeof(removed));\n    cdecompose(1, -1);\n    ll last = 0;\n    while (q--) {\n        ll eid, new_w;\n        cin >> eid >> new_w;\n        eid = (eid + last) % (n-1);\n        new_w = (new_w + last) % max_weight;\n\n        ll change = new_w - edges[eid].w;\n        // cout << \"\\neid=\" << eid << \" new_w=\" << new_w << \" change=\" << change << \"\\n\";\n        for (pii& t : edges[eid].intrees) {\n            int centroid = t.first;\n            int v = t.second;\n            int label_v = label[centroid][v];\n            int label_p = panc[centroid][label_v];\n            ll prev_data = trees[centroid].query(label_p, label_p + sbsz[centroid][label_p] - 1);\n            // cout << \"centroid=\" << centroid << \" v=\" << v << \" label_v=\" << label_v << \" label_p=\" << label_p << \" prev_data=\" << prev_data << \"\\n\";\n            trees[centroid].update(label_v, label_v + sbsz[centroid][label_v] - 1, change);\n            panc_data[centroid].erase(panc_data[centroid].find(prev_data));\n            panc_data[centroid].insert(trees[centroid].query(label_p, label_p + sbsz[centroid][label_p] - 1));\n            get_centroid_best_path(centroid);\n        }\n        edges[eid].w = new_w;\n\n        last = best_path.maxval;\n        cout << last << '\\n';\n    }\n}\n\n",
    "ext": "cpp"
  },
  "58072362": {
    "code": "#include <bits/stdc++.h>\n#define ii pair <int, long long>\n#define x first\n#define y second\n#define db(x) cerr << #x << \" = \" << x << endl;\n#define _ << \" _ \" <<\n\nusing namespace std;\n\ninline void read(int &x){register int c = getchar();x = 0; int neg = 0;for (;((c<48 || c>57) && c != '-') ;c = getchar());if(c=='-') {neg=1;c=getchar();}for(;c>47 && c<58;c = getchar()) {x = (x<<1) + (x<<3) + c - 48;}if(neg) x=-x;}\ninline void read(long long &x){register int c = getchar();x = 0; int neg = 0;for (;((c<48 || c>57) && c != '-') ;c = getchar());if(c=='-') {neg=1;c=getchar();}for(;c>47 && c<58;c = getchar()) {x = (x<<1) + (x<<3) + c - 48;}if(neg) x=-x;}\ninline void writeln(long long x){char buffor[21];register int i=0;int neg=0; if (x<0) {neg=1; x= -x;}do{buffor[i++]=(x%10)+'0';x/=10;} while(x);i--;if (neg) putchar('-');while(i>=0) putchar(buffor[i--]);putchar('\\n');}\ninline void write(long long x){char buffor[21];register int i=0;int neg=0; if (x<0) {neg=1; x= -x;}do{buffor[i++]=(x%10)+'0';x/=10;} while(x);i--;if (neg) putchar('-');while(i>=0) putchar(buffor[i--]);putchar(' ');}\n\nconst int N = 2e5 + 7;\nconst long long oo = (long long)1e18 + 7;\n\nint n, q, Time;\nint st[N], ft[N], h[N];\nlong long W;\nlong long depthAt[N];\nvector <ii> adj[N];\n\nstruct node{\n\tlong long mn, mx;\n\tlong long pre, suf;\n\tlong long tot;\n};\n\nconst node nullNode = {0, 0, 0, 0, 0};\n\nstruct segTree{\n\tnode tree[4 * N];\n\tlong long lazy[4 * N];\n\n\tnode merge(node a, node b){\n\t\tnode res;\n\t\tres.mn = min(a.mn, b.mn);\n\t\tres.mx = max(a.mx, b.mx);\n\t\tres.pre = max(max(a.pre, b.pre), a.mx - 2 * b.mn);\n\t\tres.suf = max(max(a.suf, b.suf), b.mx - 2 * a.mn);\n\t\tres.tot = max(max(a.tot, b.tot), max(a.pre + b.mx, a.mx + b.suf));\n\t\treturn res;\n\t}\n\n\tvoid Build(int x, int low, int high){\n\t\tif (low == high){\n\t\t\tlong long val = depthAt[low];\n\t\t\ttree[x] = {val, val, -val, -val, 0};\n\t\t}\n\t\telse{\n\t\t\tint mid = low + high >> 1;\n\t\t\tBuild(2 * x, low, mid);\n\t\t\tBuild(2 * x + 1, mid + 1, high);\n\t\t\ttree[x] = merge(tree[2 * x], tree[2 * x + 1]);\n\t\t}\n\t}\n\n\tvoid Lazy(int x, bool isLeaf){\n\t\ttree[x].mn += lazy[x];\n\t\ttree[x].mx += lazy[x];\n\t\ttree[x].pre -= lazy[x];\n\t\ttree[x].suf -= lazy[x];\n\n\t\tif (!isLeaf){\n\n\t\t\tlazy[2 * x] += lazy[x];\n\t\t\tlazy[2 * x + 1] += lazy[x];\n\t\t}\n\n\t\tlazy[x] = 0;\n\t}\n\n\tvoid Update(int x, int l, int r, int i, int j, long long val){\n\t\tLazy(x, (l == r));\n\t\tif (l > j || r < i) return;\n\t\tif (l >= i && r <= j){\n\t\t\ttree[x].mn += val;\n\t\t\ttree[x].mx += val;\n\t\t\ttree[x].pre -= val;\n\t\t\ttree[x].suf -= val;\n\n\t\t\tif (l != r){\n\n\t\t\t\tlazy[2 * x] += val;\n\t\t\t\tlazy[2 * x + 1] += val;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t\tint mid = l + r >> 1;\n\t\tUpdate(2 * x, l, mid, i, j, val);\n\t\tUpdate(2 * x + 1, mid + 1, r, i, j, val);\n\t\ttree[x] = merge(tree[2 * x], tree[2 * x + 1]);\n\t}\n}IT;\n\nstruct edge{\n\tint u, v;\n\tlong long w;\n\tedge() {}\n\tedge(int u, int v, long long w): u(u), v(v), w(w) {}\n}e[N];\n\nvoid dfs(int u, long long curDepth){\n\tdepthAt[++Time] = curDepth;\n\tst[u] = Time;\n\n\tfor (auto nxt: adj[u]){\n\t\tint v = nxt.x;\n\t\tlong long w = nxt.y;\n\n\t\tif (!st[v]){\n\t\t\th[v] = h[u] + 1;\n\t\t\tdfs(v, curDepth + w);\n\t\t\tdepthAt[++Time] = curDepth;\n\t\t}\n\t\t\n\t\tft[u] = Time;\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tif(fopen(\"test.inp\", \"r\")) freopen(\"test.inp\", \"r\", stdin), freopen(\"test.out\", \"w\", stdout);\n\n\tread(n); read(q); read(W);\n\n\tfor (int i = 1; i < n; i++){\n\t\tint u, v;\n\t\tlong long w;\n\n\t\tread(u); read(v); read(w);\n\n\t\tadj[u].push_back(ii(v, w));\n\t\tadj[v].push_back(ii(u, w));\n\n\t\te[i] = {u, v, w};\n\t}\n\n\th[1] = 1;\n\tdfs(1, 0);\n\n\tfor (int i = 1; i < n; i++) \n\t\tif (h[e[i].u] > h[e[i].v]) \n\t\t\tswap(e[i].u, e[i].v);\n\n\tlong long last = 0;\n\tIT.Build(1, 1, Time);\n\n\tfor (int i = 1; i <= q; i++){\n\t\tint id;\n\t\tlong long w;\n\n\t\tread(id); read(w);\n\n\t\tid = (id + last) % (n - 1) + 1;\n\t\tw = (w + last) % W;\n\n\t\tint u = e[id].v;\n\t\tlong long delta = w - e[id].w;\n\n\t\tIT.Update(1, 1, Time, st[u], ft[u], delta);\n\t\tIT.Lazy(1, 0);\n\n\t\tlast = IT.tree[1].tot;\n\t\te[id].w = w;\n\n\t\twriteln(last);\n\t}\n}",
    "ext": "cpp"
  },
  "58070299": {
    "code": "#include <bits/stdc++.h>\n#define ii pair <int, long long>\n#define x first\n#define y second\n#define db(x) cerr << #x << \" = \" << x << endl;\n#define _ << \" _ \" <<\n\nusing namespace std;\n\ninline void read(int &x){register int c = getchar();x = 0; int neg = 0;for (;((c<48 || c>57) && c != '-') ;c = getchar());if(c=='-') {neg=1;c=getchar();}for(;c>47 && c<58;c = getchar()) {x = (x<<1) + (x<<3) + c - 48;}if(neg) x=-x;}\ninline void read(long long &x){register int c = getchar();x = 0; int neg = 0;for (;((c<48 || c>57) && c != '-') ;c = getchar());if(c=='-') {neg=1;c=getchar();}for(;c>47 && c<58;c = getchar()) {x = (x<<1) + (x<<3) + c - 48;}if(neg) x=-x;}\ninline void writeln(long long x){char buffor[21];register int i=0;int neg=0; if (x<0) {neg=1; x= -x;}do{buffor[i++]=(x%10)+'0';x/=10;} while(x);i--;if (neg) putchar('-');while(i>=0) putchar(buffor[i--]);putchar('\\n');}\ninline void write(long long x){char buffor[21];register int i=0;int neg=0; if (x<0) {neg=1; x= -x;}do{buffor[i++]=(x%10)+'0';x/=10;} while(x);i--;if (neg) putchar('-');while(i>=0) putchar(buffor[i--]);putchar(' ');}\n\nconst int N = 2e5 + 7;\nconst long long oo = (long long)1e18 + 7;\n\nint n, q, Time;\nint st[N], ft[N], h[N];\nlong long W;\nlong long depthAt[N];\nvector <ii> adj[N];\n\nstruct node{\n\tlong long mn, mx;\n\tlong long pre, suf;\n\tlong long tot;\n};\n\nconst node nullNode = {0, 0, 0, 0, 0};\n\nstruct segTree{\n\tnode tree[4 * N];\n\tlong long lazy[4 * N];\n\n\tnode merge(node a, node b){\n\t\tnode res;\n\t\tres.mn = min(a.mn, b.mn);\n\t\tres.mx = max(a.mx, b.mx);\n\t\tres.pre = max(max(a.pre, b.pre), a.mx - 2 * b.mn);\n\t\tres.suf = max(max(a.suf, b.suf), b.mx - 2 * a.mn);\n\t\tres.tot = max(max(a.tot, b.tot), max(a.pre + b.mx, a.mx + b.suf));\n\t\treturn res;\n\t}\n\n\tvoid Build(int x, int low, int high){\n\t\tif (low == high){\n\t\t\tlong long val = depthAt[low];\n\t\t\ttree[x] = {val, val, -oo, -oo, -oo};\n\t\t}\n\t\telse{\n\t\t\tint mid = low + high >> 1;\n\t\t\tBuild(2 * x, low, mid);\n\t\t\tBuild(2 * x + 1, mid + 1, high);\n\t\t\ttree[x] = merge(tree[2 * x], tree[2 * x + 1]);\n\t\t}\n\t}\n\n\tvoid Lazy(int x, bool isLeaf){\n\t\ttree[x].mn += lazy[x];\n\t\ttree[x].mx += lazy[x];\n\n\t\tif (!isLeaf){\n\t\t\ttree[x].pre -= lazy[x];\n\t\t\ttree[x].suf -= lazy[x];\n\n\t\t\tlazy[2 * x] += lazy[x];\n\t\t\tlazy[2 * x + 1] += lazy[x];\n\t\t}\n\n\t\tlazy[x] = 0;\n\t}\n\n\tvoid Update(int x, int l, int r, int i, int j, long long val){\n\t\tLazy(x, (l == r));\n\t\tif (l > j || r < i) return;\n\t\tif (l >= i && r <= j){\n\t\t\ttree[x].mn += val;\n\t\t\ttree[x].mx += val;\n\n\t\t\tif (l != r){\n\t\t\t\ttree[x].pre -= val;\n\t\t\t\ttree[x].suf -= val;\n\n\t\t\t\tlazy[2 * x] += val;\n\t\t\t\tlazy[2 * x + 1] += val;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t\tint mid = l + r >> 1;\n\t\tUpdate(2 * x, l, mid, i, j, val);\n\t\tUpdate(2 * x + 1, mid + 1, r, i, j, val);\n\t\ttree[x] = merge(tree[2 * x], tree[2 * x + 1]);\n\t}\n}IT;\n\nstruct edge{\n\tint u, v;\n\tlong long w;\n\tedge() {}\n\tedge(int u, int v, long long w): u(u), v(v), w(w) {}\n}e[N];\n\nvoid dfs(int u, long long curDepth){\n\tdepthAt[++Time] = curDepth;\n\tst[u] = Time;\n\n\tfor (auto nxt: adj[u]){\n\t\tint v = nxt.x;\n\t\tlong long w = nxt.y;\n\n\t\tif (!st[v]){\n\t\t\th[v] = h[u] + 1;\n\t\t\tdfs(v, curDepth + w);\n\t\t\tdepthAt[++Time] = curDepth;\n\t\t}\n\t\t\n\t\tft[u] = Time;\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tif(fopen(\"test.inp\", \"r\")) freopen(\"test.inp\", \"r\", stdin), freopen(\"test.out\", \"w\", stdout);\n\n\tread(n); read(q); read(W);\n\n\tfor (int i = 1; i < n; i++){\n\t\tint u, v;\n\t\tlong long w;\n\n\t\tread(u); read(v); read(w);\n\n\t\tadj[u].push_back(ii(v, w));\n\t\tadj[v].push_back(ii(u, w));\n\n\t\te[i] = {u, v, w};\n\t}\n\n\th[1] = 1;\n\tdfs(1, 0);\n\n\tfor (int i = 1; i < n; i++) \n\t\tif (h[e[i].u] > h[e[i].v]) \n\t\t\tswap(e[i].u, e[i].v);\n\n\tlong long last = 0;\n\tIT.Build(1, 1, Time);\n\n\tfor (int i = 1; i <= q; i++){\n\t\tint id;\n\t\tlong long w;\n\n\t\tread(id); read(w);\n\n\t\tid = (id + last) % (n - 1) + 1;\n\t\tw = (w + last) % W;\n\n\t\tint u = e[id].v;\n\t\tlong long delta = w - e[id].w;\n\n\t\tIT.Update(1, 1, Time, st[u], ft[u], delta);\n\t\tIT.Lazy(1, 0);\n\n\t\tlast = max(IT.tree[1].mx, IT.tree[1].tot);\n\t\te[id].w = w;\n\n\t\twriteln(last);\n\t}\n}",
    "ext": "cpp"
  },
  "58070148": {
    "code": "#include <bits/stdc++.h>\n#define ii pair <int, long long>\n#define x first\n#define y second\n#define db(x) cerr << #x << \" = \" << x << endl;\n#define _ << \" _ \" <<\n\nusing namespace std;\n\ninline void read(int &x){register int c = getchar();x = 0; int neg = 0;for (;((c<48 || c>57) && c != '-') ;c = getchar());if(c=='-') {neg=1;c=getchar();}for(;c>47 && c<58;c = getchar()) {x = (x<<1) + (x<<3) + c - 48;}if(neg) x=-x;}\ninline void read(long long &x){register int c = getchar();x = 0; int neg = 0;for (;((c<48 || c>57) && c != '-') ;c = getchar());if(c=='-') {neg=1;c=getchar();}for(;c>47 && c<58;c = getchar()) {x = (x<<1) + (x<<3) + c - 48;}if(neg) x=-x;}\ninline void writeln(long long x){char buffor[21];register int i=0;int neg=0; if (x<0) {neg=1; x= -x;}do{buffor[i++]=(x%10)+'0';x/=10;} while(x);i--;if (neg) putchar('-');while(i>=0) putchar(buffor[i--]);putchar('\\n');}\ninline void write(long long x){char buffor[21];register int i=0;int neg=0; if (x<0) {neg=1; x= -x;}do{buffor[i++]=(x%10)+'0';x/=10;} while(x);i--;if (neg) putchar('-');while(i>=0) putchar(buffor[i--]);putchar(' ');}\n\nconst int N = 2e5 + 7;\nconst long long oo = (long long)1e18 + 7;\n\nint n, q, Time;\nint st[N], ft[N], h[N];\nlong long W;\nlong long depthAt[N];\nvector <ii> adj[N];\n\nstruct node{\n\tlong long mn, mx;\n\tlong long pre, suf;\n\tlong long tot;\n};\n\nconst node nullNode = {0, 0, 0, 0, 0};\n\nstruct segTree{\n\tnode tree[4 * N];\n\tlong long lazy[4 * N];\n\n\tnode merge(node a, node b){\n\t\tnode res;\n\t\tres.mn = min(a.mn, b.mn);\n\t\tres.mx = max(a.mx, b.mx);\n\t\tres.pre = max(max(a.pre, b.pre), a.mx - 2 * b.mn);\n\t\tres.suf = max(max(a.suf, b.suf), b.mx - 2 * a.mn);\n\t\tres.tot = max(max(a.tot, b.tot), max(a.pre + b.mx, a.mx + b.suf));\n\t\treturn res;\n\t}\n\n\tvoid Build(int x, int low, int high){\n\t\tif (low == high){\n\t\t\tlong long val = depthAt[low];\n\t\t\ttree[x] = {val, val, -oo, -oo, -oo};\n\t\t}\n\t\telse{\n\t\t\tint mid = low + high >> 1;\n\t\t\tBuild(2 * x, low, mid);\n\t\t\tBuild(2 * x + 1, mid + 1, high);\n\t\t\ttree[x] = merge(tree[2 * x], tree[2 * x + 1]);\n\t\t}\n\t}\n\n\tvoid Lazy(int x, bool isLeaf){\n\t\ttree[x].mn += lazy[x];\n\t\ttree[x].mx += lazy[x];\n\n\t\tif (!isLeaf){\n\t\t\ttree[x].pre -= lazy[x];\n\t\t\ttree[x].suf -= lazy[x];\n\n\t\t\tlazy[2 * x] += lazy[x];\n\t\t\tlazy[2 * x + 1] += lazy[x];\n\t\t}\n\n\t\tlazy[x] = 0;\n\t}\n\n\tvoid Update(int x, int l, int r, int i, int j, long long val){\n\t\tLazy(x, (l == r));\n\t\tif (l > j || r < i) return;\n\t\tif (l >= i && r <= j){\n\t\t\ttree[x].mn += val;\n\t\t\ttree[x].mx += val;\n\n\t\t\tif (l != r){\n\t\t\t\ttree[x].pre -= val;\n\t\t\t\ttree[x].suf -= val;\n\n\t\t\t\tlazy[2 * x] += val;\n\t\t\t\tlazy[2 * x + 1] += val;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t\tint mid = l + r >> 1;\n\t\tUpdate(2 * x, l, mid, i, j, val);\n\t\tUpdate(2 * x + 1, mid + 1, r, i, j, val);\n\t\ttree[x] = merge(tree[2 * x], tree[2 * x + 1]);\n\t}\n\n\tnode Query(int x, int l, int r, int i, int j){\n\t\tLazy(x, (l == r));\n\t\tif (l > j || r < i) return nullNode;\n\t\tif (l >= i && r <= j) return tree[x];\n\n\t\tint mid = l + r >> 1;\n\t\tnode L = Query(2 * x, l, mid, i, j);\n\t\tnode R = Query(2 * x + 1, mid + 1, r, i, j);\n\t\treturn merge(L, R);\n\t}\n}IT;\n\nstruct edge{\n\tint u, v;\n\tlong long w;\n\tedge() {}\n\tedge(int u, int v, long long w): u(u), v(v), w(w) {}\n}e[N];\n\nvoid dfs(int u, long long curDepth){\n\tdepthAt[++Time] = curDepth;\n\tst[u] = Time;\n\n\tfor (auto nxt: adj[u]){\n\t\tint v = nxt.x;\n\t\tlong long w = nxt.y;\n\n\t\tif (!st[v]){\n\t\t\th[v] = h[u] + 1;\n\t\t\tdfs(v, curDepth + w);\n\t\t\tdepthAt[++Time] = curDepth;\n\t\t}\n\t\t\n\t\tft[u] = Time;\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tif(fopen(\"test.inp\", \"r\")) freopen(\"test.inp\", \"r\", stdin), freopen(\"test.out\", \"w\", stdout);\n\n\tread(n); read(q); read(W);\n\n\tfor (int i = 1; i < n; i++){\n\t\tint u, v;\n\t\tlong long w;\n\n\t\tread(u); read(v); read(w);\n\n\t\tadj[u].push_back(ii(v, w));\n\t\tadj[v].push_back(ii(u, w));\n\n\t\te[i] = {u, v, w};\n\t}\n\n\th[1] = 1;\n\tdfs(1, 0);\n\n\tfor (int i = 1; i < n; i++) \n\t\tif (h[e[i].u] > h[e[i].v]) \n\t\t\tswap(e[i].u, e[i].v);\n\n\tlong long last = 0;\n\tIT.Build(1, 1, Time);\n\n\tfor (int i = 1; i <= q; i++){\n\t\tint id;\n\t\tlong long w;\n\n\t\tread(id); read(w);\n\n\t\tid = (id + last) % (n - 1) + 1;\n\t\tw = (w + last) % W;\n\n\t\tint u = e[id].v;\n\t\tlong long delta = w - e[id].w;\n\n\t\tIT.Update(1, 1, Time, st[u], ft[u], delta);\n\n\t\t// for (int j = 1; j <= Time; j++){\n\t\t// \tnode val = IT.Query(1, 1, Time, j, j);\n\t\t// \twrite(val.tot);\n\t\t// }\n\n\t\t// putchar('\\n');\n\n\t\tIT.Query(1, 1, Time, 1, Time).tot;\n\n\t\tlast = max(IT.tree[1].mx, IT.tree[1].tot);\n\t\t// db(IT.tree[1].mx _ IT.tree[1].tot);\n\t\te[id].w = w;\n\n\t\twriteln(last);\n\t}\n}",
    "ext": "cpp"
  },
  "58049258": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\n#define D(x) cerr << #x << \" = \" << (x) << \", \" // debug\ntemplate <typename T> using V = vector<T>;\nusing ll = long long;\nusing pii = pair<int,int>;\n \nconst int MAXN = 100000;\nconst int MAXL = 18;\nint N, Q;\nll W;\nunordered_map<ll,ll> weights;\npii edges[MAXN];\nint tin[MAXL][MAXN];\nint tout[MAXL][MAXN];\nint subtree_size[MAXL][MAXN];\n \ninline pii edge(int a, int b)\n{\n    return make_pair(min(a, b), max(a, b));\n}\n \nll encode_edge(int a, int b)\n{\n    if (a > b) swap(a, b);\n    return (ll)a*1000000LL + b;\n}\n \nll encode_edge(const pii& p)\n{\n    return encode_edge(p.first, p.second);\n}\n \nstruct ST {\n    ll *t, *lz;\n    int n;\n \n    void setup(int n_)\n    {\n        n = n_;\n        t = new ll[4*n];\n        lz = new ll[4*n];\n        memset(t, 0, 4*n*sizeof(ll));\n        memset(lz, 0, 4*n*sizeof(ll));\n    }       \n \n    void push(int p)\n    {\n        t[2*p] += lz[p];\n        lz[2*p] += lz[p];\n        t[2*p+1] += lz[p];\n        lz[2*p+1] += lz[p];\n        lz[p] = 0;\n    }\n \n    void add_(int p, int l, int r, int i, int j, ll v)\n    {\n        if (i > j) return;\n        if (i == l and j == r) {\n            t[p] += v;\n            lz[p] += v;\n            return;\n        }\n        push(p);\n        int m = (l+r)/2;\n        add_(2*p, l, m, i, min(j, m), v);\n        add_(2*p+1, m+1, r, max(i, m+1), j, v);\n        t[p] = max(t[2*p], t[2*p+1]);\n    }\n \n    inline void add(int i, int j, ll v) { add_(1, 0, n-1, i, j, v); }\n};\n\nvoid dfs_adj(map<int,set<int>>& nadj, map<int,set<int>>& adj, int u, int p)\n{\n    for (int v : adj[u]) if (v != p) {\n        nadj[u].insert(v);\n        nadj[v].insert(u);\n        dfs_adj(nadj, adj, v, u);\n    }\n}\n \nstruct SubTree {\n    map<int,set<int>> adj;\n    int n;\n    int root;\n    int layer;\n    map<int,SubTree*> sub_centroid_tree; // subtree after centroid split each nodes belongs to\n    V<SubTree*> sub_centroid_trees;\n    multiset<ll> sct_values; // sub_centroid_trees values of paths through centroid\n    int timer;\n    int centroid;\n    int centroid_parent;\n    int root_parent;\n    multiset<ll> sub_centroid_trees_solutions;\n    ST st;\n \n    void setup(int n_, int root_, int root_parent_, int layer_)\n    {\n        n = n_;\n        root = root_;\n        root_parent = root_parent_;\n        layer = layer_;\n        centroid = -1;\n        centroid_parent = -1;\n        st.setup(n);\n        timer = 0;\n    }\n \n    void compute_euler_tour(int u, int p)\n    {\n        tin[layer][u] = timer++;\n        for (int v : adj[u]) if (v != p) {\n            compute_euler_tour(v, u);\n        }\n        tout[layer][u] = timer-1;\n    }\n \n    void compute_st_rec(int u, int p)\n    {\n        for (int v : adj[u]) if (v != p) {\n            st.add(tin[layer][v], tout[layer][v], weights[encode_edge(u, v)]);\n            compute_st_rec(v, u);\n        }\n    }\n \n    void compute_st()\n    {\n        compute_euler_tour(root, root_parent);\n        compute_st_rec(root, root_parent);\n        for (SubTree* t : sub_centroid_trees) {\n            t->compute_st();\n            sct_values.insert(   t->st.t[1] + weights[encode_edge(centroid, t->root)]   );\n            sub_centroid_trees_solutions.insert(   t->solve()   );\n        }\n    }\n \n    void compute_subtree_size(int u, int p)\n    {\n        subtree_size[layer][u] = 1;\n        for (int v : adj[u]) if (v != p) {\n            compute_subtree_size(v, u);\n            subtree_size[layer][u] += subtree_size[layer][v];\n        }\n    }\n \n    void centroid_decomp()\n    {\n        if (n == 1) {\n            centroid = root;\n        }\n        else {\n            compute_subtree_size(root, root_parent);\n            int u = root;\n            int p = root_parent;\n            while (centroid == -1) {\n                bool is_centroid = true;\n                for (int v : adj[u]) if (v != p) {\n                    if (subtree_size[layer][v] > n/2) {\n                        p = u;\n                        u = v;\n                        is_centroid = false;\n                        break;\n                    }\n                }\n                if (is_centroid) {\n                    centroid = u;\n                    centroid_parent = p;\n                }\n            }\n            // now u is centroid, p is centroid parent\n            for (int v : adj[u]) if (v != root_parent) {\n                SubTree* t = new SubTree;\n                int sz = (v == p ? subtree_size[layer][root] - subtree_size[layer][u] : subtree_size[layer][v]);\n                t->setup(sz, v, u, layer+1);\n                dfs_adj(t->adj, adj, v, u);\n                t->centroid_decomp();\n                sub_centroid_trees.push_back(t);\n                compute_sub_centroid_tree(t, v, u);\n            }\n        }\n    }\n \n    void compute_sub_centroid_tree(SubTree* t, int u, int p)\n    {   \n        sub_centroid_tree[u] = t;\n        for (int v : adj[u]) if (v != p) {\n            compute_sub_centroid_tree(t, v, u);\n        }\n    }\n \n    ll solve()\n    {\n        // check for path through centroid:\n        ll ans = 0;\n        if (sct_values.size() >= 1) {\n            auto it = sct_values.rbegin();\n            ans += *it;\n            if (sct_values.size() >= 2) {\n                ++it;\n                ans += *it;\n            }\n        }\n        \n        // solve recursively for paths without centroid:\n        if (not sub_centroid_trees_solutions.empty()) {\n            ans = max(ans, *sub_centroid_trees_solutions.rbegin());\n        }\n \n        return ans;\n    }\n \n    void update_weight(const pii& e, ll wd) // wd: weight difference\n    {\n        int u = e.first;\n        int v = e.second;\n        int l = max(tin[layer][u], tin[layer][v]);\n        int r = min(tout[layer][u], tout[layer][v]);\n        st.add(l, r, wd);\n        if (u != centroid and v != centroid) {\n            SubTree* t = sub_centroid_tree[u];\n            sct_values.erase(sct_values.find(   t->st.t[1] + weights[encode_edge(centroid, t->root)]   ));\n            sub_centroid_trees_solutions.erase(sub_centroid_trees_solutions.find(   t->solve()   ));\n            t->update_weight(e, wd);\n            sct_values.insert(   t->st.t[1] + weights[encode_edge(centroid, t->root)]   );\n            sub_centroid_trees_solutions.insert(   t->solve()   );\n        }\n        else {\n            SubTree* t = sub_centroid_tree[u == centroid ? v : u];\n            sct_values.erase(sct_values.find(   t->st.t[1] + weights[encode_edge(e)]   ));\n            sct_values.insert(   t->st.t[1] + weights[encode_edge(e)] + wd   );\n        }\n    }\n};\n \nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    memset(subtree_size, 0, sizeof(subtree_size));\n    cin >> N >> Q >> W;\n    weights.rehash(2*N);\n    SubTree* tree = new SubTree;\n    tree->setup(N, 0, -1, 0);\n    for (int i = 0; i < N-1; ++i) {\n        int a, b;\n        ll c;\n        cin >> a >> b >> c; --a; --b; // 0-idx\n        tree->adj[a].insert(b);\n        tree->adj[b].insert(a);\n        edges[i] = edge(a, b);\n        weights[encode_edge(a, b)] = c;\n    }\n \n    tree->centroid_decomp();\n    tree->compute_st();\n \n    ll last = 0;\n    for (int t = 0; t < Q; ++t) {\n        int d;\n        ll e;\n        cin >> d >> e;\n        d = (d + last) % (N - 1);\n        e = (e + last) % W;\n        ll wd = e - weights[encode_edge(edges[d])]; // weight difference\n        tree->update_weight(edges[d], wd);\n        weights[encode_edge(edges[d])] = e; // update to new value\n        last = tree->solve();\n        cout << last << endl;\n    }\n}",
    "ext": "cpp"
  },
  "57989222": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, j, k) for (int i = j; i < (int)k; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef pair<int, ll> pil;\n\ninline bool smax(ll &a, ll b) { return a < b ? a = b, true : false; }\ninline bool smin(ll &a, ll b) { return b < a ? a = b, true : false; }\n\nconst int N = 2e5 + 10;\n\nint n, q;\nll junk;\n\nll a[N], b[N], c[N];\nvector<int> adj[N];\nint st[N], fn[N], rev[N], tm__;\nll arr[N], lvl[N];\n\nvoid dfs(int v, int p = -1) {\n  st[v] = tm__;\n  rev[tm__] = v;\n  arr[tm__++] = lvl[v];\n  for (auto e : adj[v]) {\n    int u = v ^ a[e] ^ b[e];\n    if (u == p) continue;\n    if (b[e] == v) swap(a[e], b[e]);\n    lvl[u] = lvl[v] + c[e];\n    dfs(u, v);\n    rev[tm__] = v;\n    arr[tm__++] = lvl[v];\n  }\n  fn[v] = tm__;\n}\n\n#define lid id << 1\n#define rid lid | 1\n\nstruct node {\n  ll Mn, Mx, Le, Re, lazy = 0;\n  int LeId, ReId, MxId;\n};\n\nnode seg[N << 2];\n\ninline node relax(node a, node b) {\n  node res = a;\n  res.lazy = 0;\n  smin(res.Mn, b.Mn);\n  if (smax(res.Mx, b.Mx)) res.MxId = b.MxId;\n  if (smax(res.Le, b.Le)) res.LeId = b.LeId;\n  if (smax(res.Re, b.Re)) res.ReId = b.ReId;\n  if (smax(res.Le, a.Mx - 2 * b.Mn)) res.LeId = a.MxId;\n  if (smax(res.Re, b.Mx - 2 * a.Mn)) res.ReId = b.MxId;\n  return res;\n}\n\ninline void relax(int id) { seg[id] = relax(seg[lid], seg[rid]); }\n\ninline void apply(node &a, ll val) {\n  a.lazy += val;\n  a.Mn += val;\n  a.Mx += val;\n  a.Le -= val;\n  a.Re -= val;\n}\n\ninline void apply(int id, ll val) { apply(seg[id], val); }\n\ninline void shift(int id) {\n  apply(lid, seg[id].lazy);\n  apply(rid, seg[id].lazy);\n  seg[id].lazy = 0;\n  relax(id);\n}\n\nvoid build(int l = 0, int r = tm__, int id = 1) {\n  if (l == r - 1) {\n    seg[id].Mn = seg[id].Mx = arr[l];\n    seg[id].Re = seg[id].Le = -arr[l];\n    seg[id].LeId = seg[id].ReId = seg[id].MxId = l;\n    return;\n  }\n  int mid = l + r >> 1;\n  build(l, mid, lid);\n  build(mid, r, rid);\n  relax(id);\n}\n\nvoid Upt(int s, int t, ll val, int l = 0, int r = tm__, int id = 1) {\n  if (l >= t || r <= s) return;\n  if (l >= s && r <= t) {\n    apply(id, val);\n    return;\n  }\n  shift(id);\n  int mid = l + r >> 1;\n  Upt(s, t, val, l, mid, lid);\n  Upt(s, t, val, mid, r, rid);\n  relax(id);\n}\n\nnode Get(int s, int t, int l = 0, int r = tm__, int id = 1) {\n  if (l >= s && r <= t) return seg[id];\n\n  int mid = l + r >> 1;\n  shift(id);\n  if (t <= mid) return Get(s, t, l, mid, lid);\n  if (s >= mid) return Get(s, t, mid, r, rid);\n  return relax(Get(s, t, l, mid, lid), Get(s, t, mid, r, rid));\n}\n\ninline pil door(int v) {\n  node a = Get(0, fn[v]);\n  node b = Get(st[v], tm__);\n  node c = Get(st[v], st[v] + 1);\n  return a.Le > b.Re ? pil(a.LeId, a.Le + c.Mx) : pil(b.ReId, b.Re + c.Mx);\n}\n\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n  cin >> n >> q >> junk;\n\n  rep(i, 0, n - 1) {\n    cin >> a[i] >> b[i] >> c[i];\n    adj[a[i]].pb(i);\n    adj[b[i]].pb(i);\n  }\n\n  dfs(1);\n\n  build();\n\n  ll last = 0;\n  rep(test, 0, q) {\n    ll d, e;\n    cin >> d >> e;\n    d = (d + last) % (n - 1);\n    e = (e + last) % junk;\n    e -= c[d];\n    c[d] += e;\n\n    Upt(st[b[d]], fn[b[d]], e);\n\n    last = door(rev[door(1).first]).second;\n\n    cout << last << '\\n';\n  }\n\n  return 0;\n}",
    "ext": "cpp"
  },
  "57982370": {
    "code": "#include <bits/stdc++.h>\n#define int long long\n \nusing namespace std;\n \nconst int maxn = 2e5 + 7;\n \nint n, u[maxn], v[maxn], c[maxn], st[maxn], en[maxn], q, w, cnt, h[maxn], val[maxn], lz[4 * maxn];\nbool lf[4 * maxn];\nvector<int> vt[maxn];\n \nvoid DFS(int u, int p)\n{\n    for(auto i: vt[u])\n    {\n        int v = ::u[i] + ::v[i] - u;\n        int c = ::c[i];\n        if(v != p)\n        {\n            h[v] = h[u] + c;\n            st[i] = ++cnt;\n            val[cnt] = h[v];\n            DFS(v, u);\n            en[i] = ++cnt;\n            val[cnt] = h[u];\n        }\n    }\n}\nstruct Node\n{\n    int Min, Max, Prf, Suf, Ans;\n} IT[4 * maxn];\n \nNode Merge(const Node &a, const Node &b)\n{\n    Node ans;\n    ans.Min = min(a.Min, b.Min);\n    ans.Max = max(a.Max, b.Max);\n    ans.Prf = max(max(a.Prf, b.Prf), a.Max - 2 * b.Min);\n    ans.Suf = max(max(a.Suf, b.Suf), b.Max - 2 * a.Min);\n    ans.Ans = max(max(a.Ans, b.Ans), max(a.Prf + b.Max, a.Max + b.Suf));\n    return ans;\n}\n \nvoid Build(int id, int l, int r)\n{\n    if(l == r)\n    {\n        lf[id] = true;\n        IT[id].Min = IT[id].Max = val[l];\n        IT[id].Prf = IT[id].Suf = IT[id].Ans = -4e18;\n        return;\n    }\n    int mid = l + r >> 1;\n    Build(id * 2, l, mid);\n    Build(id * 2 + 1, mid + 1, r);\n    IT[id] = Merge(IT[id * 2], IT[id * 2 + 1]);\n}\n \nvoid Push_Down(int id)\n{\n    IT[id * 2].Min += lz[id];\n    IT[id * 2 + 1].Min += lz[id];\n    IT[id * 2].Max += lz[id];\n    IT[id * 2 + 1].Max += lz[id];\n    lz[id * 2] += lz[id];\n    lz[id * 2 + 1] += lz[id];\n    if(!lf[id * 2]) IT[id * 2].Prf -= lz[id], IT[id * 2].Suf -= lz[id];\n    if(!lf[id * 2 + 1]) IT[id * 2 + 1].Prf -= lz[id], IT[id * 2 + 1].Suf -= lz[id];\n    lz[id] = 0;\n}\n \nvoid Update(int id, int l, int r, int u, int v, int val)\n{\n    if(l > v || r < u) return;\n    if(u <= l && r <= v)\n    {\n        IT[id].Min += val;\n        IT[id].Max += val;\n        lz[id] += val;\n        if(!lf[id])\n        {\n            IT[id].Prf -= val;\n            IT[id].Suf -= val;\n        }\n        return;\n    }\n    Push_Down(id);\n    int mid = l + r >> 1;\n    Update(id * 2, l, mid, u, v, val);\n    Update(id * 2 + 1, mid + 1, r, u, v, val);\n    IT[id] = Merge(IT[id * 2], IT[id * 2 + 1]);\n \n}\n \nvoid Change(int idEdge, int val)\n{\n    int gau = val - c[idEdge];\n    Update(1, 1, 2 * n - 2, st[idEdge], en[idEdge] - 1, gau);\n    // Update(1, 1, 2 * n - 2, en[idEdge], 2 * n - 2, -gau);\n    c[idEdge] = val;\n}\n \nint32_t main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(\"test.inp\", \"r\")) freopen(\"test.inp\", \"r\", stdin), freopen(\"test.out\", \"w\", stdout);\n    cin >> n >> q >> w;\n    int last = 0;\n    for(int i = 1; i < n; i++)\n    {\n        cin >> u[i] >> v[i] >> c[i];\n        vt[u[i]].push_back(i);\n        vt[v[i]].push_back(i);\n    }\n    DFS(1, 1);\n    Build(1, 1, 2 * n - 2);\n    for(int i = 1; i <= q; i++)\n    {\n        int d, e;\n        cin >> d >> e;\n        d = (d + last) % (n - 1) + 1;\n        e = (e + last) % w;\n        Change(d, e);\n        last = max(IT[1].Ans, IT[1].Max);\n        cout << last << '\\n';\n    }\n}",
    "ext": "cpp"
  },
  "57981411": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\ntypedef pair<int, int> ii;\ntypedef long long ll;\n\nconst int len = 2e5+2, lg = 30+2;\nint n, q;\nll cost[len], dep[lg][len], dis[len][2], opt[len];\nint st[lg][len], en[lg][len], where[lg][len], col[lg][len], cnt[lg];\nint sz[len], block[len], nex[len][2];\nii edge[len];\nvector<ii> adj[len], kid[len];\n\nstruct seg_tree{\n    ll tree[4*len], lazy[4*len], arr[len];\n\n    void build(int p = 1, int l = 1, int r = n){\n        if (l == r)\n            tree[p] = arr[l];\n        else{\n            int mid = (l+r)/2;\n            build(2*p, l, mid);\n            build(2*p+1, mid+1, r);\n            tree[p] = max(tree[2*p], tree[2*p+1]);\n        }\n    }\n\n    void prop(int p, int l, int r){\n        if (!lazy[p]) return;\n\n        tree[p] += lazy[p];\n        if (l != r){\n            lazy[2*p] += lazy[p];\n            lazy[2*p+1] += lazy[p];\n        }\n        lazy[p] = 0;\n    }\n\n    void update(int i, int j, ll x, int p = 1, int l = 1, int r = n){\n        prop(p, l, r);\n\n        if (r < i || j < l)\n            return;\n        if (i <= l && r <= j)\n            lazy[p] += x;\n        else{\n            int mid = (l+r)/2;\n            update(i, j, x, 2*p, l, mid);\n            update(i, j, x, 2*p+1, mid+1, r);\n\n            prop(2*p, l, mid);\n            prop(2*p+1, mid+1, r);\n\n            tree[p] = max(tree[2*p], tree[2*p+1]);\n        }\n    }\n\n    ll ask(int i, int j, int p = 1, int l = 1, int r = n){\n        prop(p, l, r);\n        if (r < i || j < l)\n            return 0;\n        if (i <= l && r <= j)\n            return tree[p];\n\n        int mid = (l+r)/2;\n        return max(ask(i, j, 2*p, l, mid), ask(i, j, 2*p+1, mid+1, r));\n    }\n};\n\nseg_tree seg[lg];\n\nvoid bin(int u, int p){\n    for (int j = 0; j < adj[u].size(); j++){\n        ii v = adj[u][j];\n        if (v.fi == p) continue;\n\n        kid[u].pb(v);\n        bin(v.fi, u);\n    }\n}\n\nvoid fix(int u, int p){\n    sz[u] = 1;\n    for (int j = 0; j < adj[u].size(); j++){\n        ii v = adj[u][j];\n        if (v.fi == p || block[v.se]) continue;\n\n        fix(v.fi, u);\n        sz[u] += sz[v.fi];\n    }\n}\n\nint cent(int u, int p, int all){\n    ii big = mp(-1, -1);\n    for (int j = 0; j < adj[u].size(); j++){\n        ii v = adj[u][j];\n        if (v.se == p || block[v.se]) continue;\n\n        if (big == mp(-1, -1) || sz[v.fi] > sz[big.fi])\n            big = v;\n    }\n\n    if (big == mp(-1, -1))\n        return p;\n    if (p == -1 || sz[big.fi] > all/3)\n        return cent(big.fi, big.se, all);\n    return p;\n}\n\nvoid dfs(int u, int p, int d, int c){\n    where[d][p] = u;\n    col[d][u] = c;\n    seg[d].arr[++cnt[d]] = dep[d][u];\n    st[d][u] = cnt[d];\n    for (int j = 0; j < adj[u].size(); j++){\n        ii v = adj[u][j];\n        if (v.se == p || block[v.se]) continue;\n\n        dep[d][v.fi] = dep[d][u]+cost[v.se];\n        dfs(v.fi, v.se, d, c);\n    }\n\n    en[d][u] = cnt[d];\n}\n\nint construct(int u, int d){\n    //printf(\"construction starts with node %d\\n\", u);\n    fix(u, u);\n    u = cent(u, -1, sz[u]);\n    if (u == -1)\n        return -1;\n\n    //printf(\"u = %d, d = %d\\n\", u, d);\n\n    dfs(edge[u].fi, u, d, 0);\n    dfs(edge[u].se, u, d, 1);\n\n    block[u] = 1;\n    nex[u][0] = construct(edge[u].fi, d+1);\n    nex[u][1] = construct(edge[u].se, d+1);\n\n    return u;\n}\n\nvoid init(int u, int d){\n    dis[u][0] = seg[d].ask(st[d][edge[u].fi], en[d][edge[u].fi]);\n    dis[u][1] = seg[d].ask(st[d][edge[u].se], en[d][edge[u].se]);\n    opt[u] = dis[u][0]+cost[u]+dis[u][1];\n\n    if (nex[u][0] != -1)\n        init(nex[u][0], d+1), opt[u] = max(opt[u], opt[nex[u][0]]);\n    if (nex[u][1] != -1)\n        init(nex[u][1], d+1), opt[u] = max(opt[u], opt[nex[u][1]]);\n\n    //printf(\"u = %d, d = %d, opt = %lld, dis0 = %lld, dis1 = %lld\\n\", u, d, opt[u], dis[u][0], dis[u][1]);\n}\n\nvoid change(int u, int d, int e, ll x){\n    //printf(\"change: u = %d, d = %d, e = %d, x = %lld\\n\", u, d, e, x);\n    if (u != e){\n        int cur = where[d][e];\n        //printf(\"cur = %d\\n\", cur);\n        seg[d].update(st[d][cur], en[d][cur], x);\n        if (col[d][cur] == 0){\n            dis[u][0] = seg[d].ask(st[d][edge[u].fi], en[d][edge[u].fi]);\n            change(nex[u][0], d+1, e, x);\n        }\n        else{\n            dis[u][1] = seg[d].ask(st[d][edge[u].se], en[d][edge[u].se]);\n            change(nex[u][1], d+1, e, x);\n        }\n    }\n    else\n        cost[e] += x;\n\n    opt[u] = dis[u][0]+cost[u]+dis[u][1];\n    if (nex[u][0] != -1)\n        opt[u] = max(opt[u], opt[nex[u][0]]);\n    if (nex[u][1] != -1)\n        opt[u] = max(opt[u], opt[nex[u][1]]);\n\n    //printf(\"end change: u = %d, d = %d, opt = %lld, dis0 = %lld, dis1 = %lld\\n\", u, d, opt[u], dis[u][0], dis[u][1]);\n}\n\nint main(){\n    ll w;\n    scanf(\"%d %d %lld\", &n, &q, &w);\n    int oldn = n;\n\n    for (int i = 0; i < n-1; i++){\n        int a, b;\n        ll c;\n        scanf(\"%d %d %lld\", &a, &b, &c);\n        adj[a].pb(mp(b, i));\n        adj[b].pb(mp(a, i));\n        cost[i] = c;\n    }\n\n    // make tree binary\n    bin(1, 1);\n    for (int i = 1; i <= n; i++)\n        adj[i].clear();\n    for (int i = n; i >= 1; i--){\n        int cur = i;\n        while (kid[i].size() > 2){\n            ii v = kid[i].back();\n            kid[i].pop_back();\n\n            adj[cur].pb(v);\n            adj[v.fi].pb(mp(cur, v.se));\n            edge[v.se] = mp(v.fi, cur);\n\n\n            adj[cur].pb(mp(n+1, n-1));\n            adj[n+1].pb(mp(cur, n-1));\n            edge[n-1] = mp(cur, n+1);\n\n            cur = ++n;\n        }\n\n        while (!kid[i].empty()){\n            ii v = kid[i].back();\n            kid[i].pop_back();\n\n            adj[cur].pb(v);\n            adj[v.fi].pb(mp(cur, v.se));\n            edge[v.se] = mp(cur, v.fi);\n        }\n    }\n\n    /*for (int i = 1; i <= n; i++){\n        printf(\"i = %d, adj:\", i);\n        for (int j = 0; j < adj[i].size(); j++)\n            printf(\" (%d, %d)\", adj[i][j].fi, adj[i][j].se);\n        printf(\"\\n\");\n    }*/\n\n    // build meta tree\n    int root = construct(1, 0);\n    for (int d = 0; d < lg; d++)\n        seg[d].build();\n\n    init(root, 0);\n\n    ll last = 0;\n    for (int xx = 0; xx < q; xx++){\n        int a;\n        ll b;\n        scanf(\"%d %lld\", &a, &b);\n\n        a = (a+last)%(oldn-1);\n        b = (b+last)%w;\n        //printf(\"change edge %d to %lld\\n\", a, b);\n\n        change(root, 0, a, b-cost[a]);\n        last = opt[root];\n        printf(\"%lld\\n\", last);\n    }\n    return 0;\n}\n/*\n6 5 1000000\n1 2 2\n2 4 1\n2 5 8\n1 3 3\n3 6 5\n0 10\n3 1\n4 7\n3 10\n1 20\n*/\n",
    "ext": "cpp"
  },
  "57980386": {
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <chrono>\n#include <vector>\n#include <algorithm>\n#define CL(x) (x<<1)\n#define CR(x) (x<<1|1)\n#define Kami\n#define taskname \"TEST\"\nusing namespace std;\nconst int maxn=2e5+7;\n\nstruct Nodes{\n    long long maxDepth,minDepth;\n    long long maxLeft,maxRight;\n    long long res;\n    \n    inline void Increment(const long long &value){\n        maxDepth+=value; minDepth+=value;\n        maxLeft-=value; maxRight-=value;\n    }\n\n    inline Nodes Combine(const Nodes &lhs, const Nodes &rhs){\n        Nodes root;\n        root.maxDepth=max(lhs.maxDepth,rhs.maxDepth);\n        root.minDepth=min(lhs.minDepth,rhs.minDepth);\n        root.maxLeft=max({lhs.maxDepth-2*rhs.minDepth,lhs.maxLeft,rhs.maxLeft});\n        root.maxRight=max({rhs.maxDepth-2*lhs.minDepth,lhs.maxRight,rhs.maxRight});\n        root.res=max({lhs.res,rhs.res,lhs.maxDepth+rhs.maxRight,rhs.maxDepth+lhs.maxLeft});\n        return root;\n    }\n\n    inline Nodes operator +(const Nodes &other){\n        return Combine(*this,other);\n    }\n};\n\nint n,q,l[4*maxn],r[4*maxn];\nint lo,ri,Time[maxn],timeIn[maxn],timeOut[maxn],direction[maxn];\nlong long w,va,d[maxn],lazy[4*maxn];\nvector<int> adj[maxn];\nstruct Edges{int x,y;long long w;}e[maxn];\nNodes it[4*maxn];\n\ninline void Dfs(const int &u, const int &p){\n    static int timing=0;\n    timeIn[u]=++timing;\n    Time[timing]=u;\n    for(int i: adj[u]){\n        int v=e[i].x+e[i].y-u;\n        if(v==p) continue;\n        d[v]=d[u]+e[i].w;\n        direction[i]=v;\n        Dfs(v,u);\n    }\n    timeOut[u]=++timing;\n    Time[timing]=u;\n}\n\ninline void Build(const int &x, const int &low, const int &high){\n    l[x]=low; r[x]=high;\n    if(low!=high){\n        int mid=(low+high)>>1;\n        Build(CL(x),low,mid);\n        Build(CR(x),mid+1,high);\n        it[x]=it[CL(x)]+it[CR(x)];\n    }\n}\n\ninline void Propagate(const int &x){\n    it[x].Increment(lazy[x]);\n    if(l[x]!=r[x]){\n        lazy[CL(x)]+=lazy[x];\n        lazy[CR(x)]+=lazy[x];\n    }\n    lazy[x]=0;\n}\n\ninline void Update(const int &x){\n    Propagate(x);\n    if(l[x]>ri || r[x]<lo) return;\n    if(lo<=l[x] && r[x]<=ri){\n        lazy[x]+=va;\n        Propagate(x);\n    } else{\n        Update(CL(x));\n        Update(CR(x));\n        it[x]=it[CL(x)]+it[CR(x)];\n    }\n}\n\ninline void Modify(const int &i, const long long &value){\n    lo=timeIn[direction[i]]; ri=timeOut[direction[i]]-1; va=-e[i].w;\n    Update(1);\n    lo=timeIn[direction[i]]; ri=timeOut[direction[i]]-1; va=e[i].w=value;\n    Update(1);\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL); cout.tie(NULL); if(fopen(taskname\".INP\",\"r\"))\n    freopen(taskname\".INP\",\"r\",stdin),\n    freopen(taskname\".OUT\",\"w\",stdout);\n    #ifdef Kami\n    auto start=chrono::steady_clock::now();\n    #endif\n\n    cin>>n>>q>>w;\n    for(int i=1;i<n;i++){\n        cin>>e[i].x>>e[i].y>>e[i].w;\n        adj[e[i].x].push_back(i);\n        adj[e[i].y].push_back(i);\n    }\n    Dfs(1,-1);\n    Build(1,1,2*n);\n    for(int i=1;i<n;i++){\n        lo=timeIn[direction[i]]; ri=timeOut[direction[i]]-1; va=e[i].w;\n        Update(1);\n    }\n    for(long long last=0,cost;q--;){\n        int i; cin>>i>>cost;\n        i=(i+last)%(n-1)+1;\n        cost=(cost+last)%w;\n        Modify(i,cost);\n        cout<<(last=it[1].res)<<'\\n';\n    }\n\n    #ifdef Kami\n    auto end=chrono::steady_clock::now();\n    cerr<<\"\\nIn milliseconds : \"\n        <<chrono::duration_cast<chrono::milliseconds>(end-start).count();\n    cerr<<'\\n'<<\"In seconds : \"<<fixed<<setprecision(3)\n        <<(double)chrono::duration_cast<chrono::milliseconds>(end-start).count()/1000<<'\\n';\n    #endif\n\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57977751": {
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <unordered_map>\n#include <cstring>\nusing namespace std;\nnamespace Dynamic_Diameter//\u4f7f\u7528\u6b27\u62c9\u5e8f\u5217\n{\n    const int N = 2e5 + 1; //\u5f00\u4e24\u500d\u7a7a\u95f4\n    struct node{\n        long long a, b, ab, bc, abc, tag;\n    }f[N * 4];\n    int dfnl[N], dfnr[N];\n    long long w[N];\n    int n, tot, etot;\n    vector<pair<int, int> > g[N];\n    void add_edge(int x, int y, long long v) {\n        g[x].push_back(make_pair(y, ++etot));\n        g[y].push_back(make_pair(x, etot));\n        w[etot] = v;\n    }\n    void dfs(int x, int fa){\n        for (auto u:g[x])\n            if (u.first != fa)\n            {\n                dfnl[u.second] = ++ tot;\n                dfs(u.first, x);\n                dfnr[u.second] = ++ tot;\n            }\n    }\n    void update(int s, long long v) {\n        f[s].a += v;\n        f[s].b += v;\n        f[s].tag += v;\n        f[s].ab -= v;\n        f[s].bc -= v;\n    }\n    void down(int s) {\n        update(s + s, f[s].tag);\n        update(s + s + 1, f[s].tag);\n        f[s].tag = 0;\n    }\n    void combine(node& a, node b, node c){\n        a.a = max(b.a, c.a);\n        a.b = min(b.b, c.b);\n        a.ab = max({b.ab, c.ab, b.a - 2 * c.b});\n        a.bc = max({b.bc, c.bc, c.a - 2 * b.b});\n        a.abc = max({b.abc, c.abc, b.ab + c.a, c.bc + b.a});\n    }\n    void add(int l, int r, int s, int ll, int rr, long long v) {\n        if (r < ll || rr < l) {\n            return;\n        }\n        if (ll <=l && r <= rr) {\n            update(s, v);\n            return;\n        }\n        down(s);\n        add(l, (l + r) / 2, s + s ,ll, rr, v);\n        add((l + r) / 2 + 1, r, s + s + 1,ll, rr, v);\n        combine(f[s], f[s + s], f[s + s + 1]);\n    }\n    void build(int N) {\n        n = N;\n        tot = 0;\n        dfs(1, 0);\n        for (int i = 1; i <= etot; i ++)\n            add(1, tot, 1, dfnl[i], dfnr[i] - 1 , w[i]);\n    }\n    void change_edge_value(int  id, long long v) {\n        add(1, tot, 1, dfnl[id], dfnr[id] - 1, v - w[id]);\n        w[id] = v;\n    }\n    long long get_diameter(){\n        return f[1].abc;\n    }\n}\nint n, q;\nlong long w;\nint main(){\n    scanf(\"%d %d %lld\", &n, &q, &w);\n    for (int i = 1; i < n; i ++)\n    {\n        int x, y;\n        long long c;\n        scanf(\"%d %d %lld\", &x, &y, &c);\n        Dynamic_Diameter::add_edge(x, y, c);\n    }\n    Dynamic_Diameter::build(n);\n    long long ans = 0;\n    while (q --) {\n        int x;\n        long long y;\n        scanf(\"%d %lld\", &x, &y);\n        x = (x + ans) % (n - 1) + 1;\n        y = (y + ans) % w;\n        Dynamic_Diameter::change_edge_value(x, y);\n        ans = Dynamic_Diameter::get_diameter();\n        printf(\"%lld\\n\" ,ans);\n    }\n    return 0;\n}",
    "ext": "cpp"
  },
  "57977335": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define ll long long\n \nconst int mxN=1e5;\nint n, q, eu[mxN], ev[mxN], dt, ds[mxN], de[mxN];\nll w, ew[mxN], lz[1<<19], ans;\nvector<int> adj[mxN];\narray<ll, 5> st[1<<19];\n \nvoid app(int i, ll x) {\n\tst[i][0]+=x;\n\tst[i][1]-=2*x;\n\tst[i][2]-=x;\n\tst[i][3]-=x;\n\tlz[i]+=x;\n}\n\nvoid psh(int i) {\n\tapp(2*i, lz[i]);\n\tapp(2*i+1, lz[i]);\n\tlz[i]=0;\n}\n\nvoid upd(int l1, int r1, ll x, int i=1, int l2=0, int r2=2*n-1) {\n\tif(l1<=l2&&r2<=r1) {\n\t\tapp(i, x);\n\t\treturn;\n\t}\n\tint m2=(l2+r2)/2;\n\tpsh(i);\n\tif(l1<=m2)\n\t\tupd(l1, r1, x, 2*i, l2, m2);\n\tif(m2<r1)\n\t\tupd(l1, r1, x, 2*i+1, m2+1, r2);\n\tst[i][0]=max(st[2*i][0], st[2*i+1][0]);\n\tst[i][1]=max(st[2*i][1], st[2*i+1][1]);\n\tst[i][2]=max({st[2*i][2], st[2*i+1][2], st[2*i][0]+st[2*i+1][1]});\n\tst[i][3]=max({st[2*i][3], st[2*i+1][3], st[2*i][1]+st[2*i+1][0]});\n\tst[i][4]=max({st[2*i][4], st[2*i+1][4], st[2*i][2]+st[2*i+1][0], st[2*i][0]+st[2*i+1][3]});\n}\n\nvoid dfs(int u=0, int pe=n-1) {\n\tds[pe]=dt++;\n\tfor(int e : adj[u]) {\n\t\tif(e==pe)\n\t\t\tcontinue;\n\t\tdfs(eu[e]^ev[e]^u, e);\n\t\tupd(ds[e], de[e]-1, ew[e]);\n\t\t++dt;\n\t}\n\tde[pe]=dt;\n}\n \nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n \n\tcin >> n >> q >> w;\n\tfor(int i=0; i<n-1; ++i) {\n\t\tcin >> eu[i] >> ev[i] >> ew[i], --eu[i], --ev[i];\n\t\tadj[eu[i]].push_back(i);\n\t\tadj[ev[i]].push_back(i);\n\t}\n\tdfs();\n\twhile(q--) {\n\t\tint dj;\n\t\tll ej;\n\t\tcin >> dj >> ej;\n\t\tdj=(dj+ans)%(n-1);\n\t\tej=(ej+ans)%w;\n\t\tupd(ds[dj], de[dj]-1, ej-ew[dj]);\n\t\tew[dj]=ej;\n\t\tcout << (ans=st[1][4]) << \"\\n\";\n\t}\n}",
    "ext": "cpp"
  },
  "57974794": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\nint N, Q, num;\nint X[101010], L[101010], R[101010];\nLL W[101010], K, ans;\nvector<pii> adj[101010];\nstruct Node{\n\tLL P=0, M=0, lazy=0;\n\tLL LM=0, MR=0, LMR=0;\n\tNode operator+=(const LL &r){\n\t\tP += r, M -= 2*r;\n\t\tLM -= r, MR -= r, lazy += r;\n\t}\n\tNode operator+(const Node &r)const{\n\t\tNode ret;\n\t\tret.P = max(P, r.P);\n\t\tret.M = max(M, r.M);\n\t\tret.LM = max(LM, r.LM);\n\t\tret.LM = max(ret.LM, P + r.M);\n\t\tret.MR = max(MR, r.MR);\n\t\tret.MR = max(ret.MR, M + r.P);\n\t\tret.LMR = max(LMR, r.LMR);\n\t\tret.LMR = max(ret.LMR, LM + r.P);\n\t\tret.LMR = max(ret.LMR, P + r.MR);\n\t\treturn ret;\n\t}\n} T[808080];\nvoid update(int id, int s, int e, int ts, int te, LL v){\n\tif (e < ts || te < s) return;\n\tif (ts <= s && e <= te){\n\t\tT[id] += v;\n\t\treturn;\n\t}\n\tT[id*2] += T[id].lazy;\n\tT[id*2+1] += T[id].lazy;\n\tT[id].lazy = 0;\n\tint mid = (s+e)/2;\n\tupdate(id*2, s, mid, ts, te, v);\n\tupdate(id*2+1, mid+1, e, ts, te, v);\n\tT[id] = T[id*2] + T[id*2+1];\n}\nvoid dfs(int u, int p){\n\tL[u] = ++num;\n\tfor (pii v : adj[u]){\n\t\tif (v.first == p) continue;\n\t\tX[v.second] = v.first;\n\t\tdfs(v.first, u);\n\t\t++num;\n\t}\n \tR[u] = num;\n}\nint main(){\n\tcin>>N>>Q>>K;\n\tfor (int i=1; i<N; i++){\n\t\tint u, v;\n\t\tcin>>u>>v>>W[i];\n\t\tadj[u].push_back(pii(v, i));\n\t\tadj[v].push_back(pii(u, i));\n\t}\n\tdfs(1, 0);\n\tfor (int i=1; i<N; i++) update(1, 1, 2*N, L[X[i]], R[X[i]], W[i]);\n\twhile (Q--){\n\t\tLL k, w;\n\t\tcin>>k>>w;\n\t\tk = (k + ans) % (N-1) + 1;\n\t\tw = (w + ans) % K;\n\t\tupdate(1, 1, 2*N, L[X[k]], R[X[k]], w-W[k]);\n\t\tW[k] = w, ans = T[1].LMR;\n\t\tcout<<ans<<endl;\n\t}\n}",
    "ext": "cpp"
  },
  "57971652": {
    "code": "/*input\n4 3 2000\n1 2 100\n2 3 1000\n2 4 1000\n2 1030\n1 1020\n1 890\n\n*/\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAXN = 200200;\nconst long long INF = 2e18;\nint N, Q;\nlong long W;\nstruct Edge { int u, v; long long w; } edges[MAXN];\nvector<int> G[MAXN];\nint in[MAXN], out[MAXN], vertex[MAXN];\nlong long A[MAXN], dep[MAXN];\n\nstruct Node\n{\n\tlong long d1, d2, d12, d23, d123, inc;\n\n\tvoid update(long long d)\n\t{\n\t\td1 += d, d2 += d, d12 -= d, d23 -= d, inc += d;\n\t}\n\n\tfriend Node operator+ (Node n1, Node n2)\n\t{\n\t\tNode n;\n\t\tn.d1 = max(n1.d1, n2.d1);\n\t\tn.d2 = min(n1.d2, n2.d2);\n\t\tn.d12 = max(max(n1.d12, n2.d12), n1.d1 - 2 * n2.d2);\n\t\tn.d23 = max(max(n1.d23, n2.d23), -2 * n1.d2 + n2.d1);\n\t\tn.d123 = max(max(n1.d123, n2.d123), max(n1.d12 + n2.d1, n1.d1 + n2.d23));\n\t\tn.inc = 0;\n\t\treturn n;\n\t}\n\n\tvoid push(Node &n1, Node &n2)\n\t{\n\t\tn1.update(inc); n2.update(inc); inc = 0;\n\t}\n} tree[MAXN << 2];\n\nvoid dfs(int u)\n{\n\tstatic int timer = 0;\n\tin[u] = timer;\n\tfor (int id : G[u]) if (vertex[id] != u) {\n\t\tint v = (edges[id].u == u ? edges[id].v : edges[id].u);\n\t\tvertex[id] = v;\n\t\tdep[v] = dep[u] + edges[id].w;\n\n\t\tA[timer++] = dep[u];\n\t\tdfs(v);\n\t}\n\tA[timer++] = dep[u];\n\tout[u] = timer;\n}\n\n#define MID ((lo + hi) >> 1)\n#define ROOT1 (root << 1)\n#define ROOT2 (root << 1 | 1)\n\nvoid build(int root = 1, int lo = 0, int hi = 2 * N - 1)\n{\n\tif (lo + 1 == hi) tree[root] = {A[lo], A[lo], -INF, -INF, 0, 0};\n\telse {\n\t\tbuild(ROOT1, lo, MID);\n\t\tbuild(ROOT2, MID, hi);\n\t\ttree[root] = tree[ROOT1] + tree[ROOT2];\n\t}\n}\n\nvoid update(long long d, int l, int r, int root = 1, int lo = 0, int hi = 2 * N - 1)\n{\n\tif (l <= lo && hi <= r) {\n\t\ttree[root].update(d);\n\t\treturn;\n\t}\n\tif (hi <= l || r <= lo) return;\n\n\ttree[root].push(tree[ROOT1], tree[ROOT2]);\n\tupdate(d, l, r, ROOT1, lo, MID);\n\tupdate(d, l, r, ROOT2, MID, hi);\n\ttree[root] = tree[ROOT1] + tree[ROOT2];\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> N >> Q >> W;\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tcin >> edges[i].u >> edges[i].v >> edges[i].w;\n\t\tG[edges[i].u].push_back(i);\n\t\tG[edges[i].v].push_back(i);\n\t}\n\n\tdfs(1);\n\tbuild();\n\n\tlong long last = 0, d, e;\n\tint u;\n\tfor (int q = 0; q < Q; ++q) {\n\t\tcin >> d >> e;\n\t\td = (d + last) % (N - 1);\n\t\te = (e + last) % W;\n\t\tu = vertex[d];\n\t\tupdate(e - edges[d].w, in[u], out[u]);\n\t\tedges[d].w = e;\n\t\tcout << (last = max(tree[1].d1, tree[1].d123)) << '\\n';\n\t}\n}",
    "ext": "cpp"
  },
  "57962964": {
    "code": "#include<iostream>\n#include<vector>\n#define int long long\nusing namespace std;\nconst int N=1e5+2;\nstruct node{\n\tint deg,one,twofr,three,sec,twobk;\n};\nnode it[8*N];\nint ar[2*N],now=0;\nvector<pair<pair<int,int>,int> > adj[N];\npair<int,int> pos[N];\nvoid dfs(int x,int p){\n\tfor(int i=0;i<adj[x].size();i++){\n\t\tif(adj[x][i].first.first!=p){\n\t\t\tnow++;\n\t\t\tar[now]=adj[x][i].first.second;\n\t\t\tpos[adj[x][i].second].first=now;\n\t\t\tdfs(adj[x][i].first.first,x);\n\t\t\tnow++;\n\t\t\tar[now]=-adj[x][i].first.second;\n\t\t\tpos[adj[x][i].second].second=now;\n\t\t}\n\t}\n}\nvoid init(int idx,int l,int r){\n\tif(l==r){\n\t\tit[idx].deg=ar[l];\n\t\tit[idx].one=ar[l];\n\t\tit[idx].sec=-2*ar[l];\n\t\tit[idx].twofr=-ar[l];\n\t\tit[idx].twobk=-ar[l];\n\t\tit[idx].three=0;\n\t\treturn;\n\t}\n\tinit(2*idx,l,(l+r)/2);\n\tinit(2*idx+1,(l+r)/2+1,r);\n\tit[idx].deg=it[2*idx].deg+it[2*idx+1].deg;\n\tit[idx].one=max(it[2*idx].one,it[2*idx+1].one+it[2*idx].deg);\n\tit[idx].sec=max(it[2*idx].sec,it[2*idx+1].sec-2*it[2*idx].deg);\n\tit[idx].twofr=max(max(it[2*idx].twofr,it[2*idx+1].twofr-it[2*idx].deg),it[2*idx].one+it[2*idx+1].sec-2*it[2*idx].deg);\n\tit[idx].twobk=max(max(it[2*idx].twobk,it[2*idx+1].twobk-it[2*idx].deg),it[2*idx].sec+it[2*idx+1].one+it[2*idx].deg);\n\tit[idx].three=max(max(it[2*idx].three,it[2*idx+1].three),max(it[2*idx].twofr+it[2*idx+1].one+it[2*idx].deg,it[2*idx].one+it[2*idx+1].twobk-it[2*idx].deg));\n}\nvoid upd(int idx,int l,int r,int pos){\n\tif(l>pos||r<pos){\n\t\treturn;\n\t}\n\tif(l==r){\n\t\tit[idx].deg=ar[l];\n\t\tit[idx].one=ar[l];\n\t\tit[idx].sec=-2*ar[l];\n\t\tit[idx].twofr=-ar[l];\n\t\tit[idx].twobk=-ar[l];\n\t\tit[idx].three=0;\n\t\treturn;\n\t}\n\tupd(2*idx,l,(l+r)/2,pos);\n\tupd(2*idx+1,(l+r)/2+1,r,pos);\n\tit[idx].deg=it[2*idx].deg+it[2*idx+1].deg;\n\tit[idx].one=max(it[2*idx].one,it[2*idx+1].one+it[2*idx].deg);\n\tit[idx].sec=max(it[2*idx].sec,it[2*idx+1].sec-2*it[2*idx].deg);\n\tit[idx].twofr=max(max(it[2*idx].twofr,it[2*idx+1].twofr-it[2*idx].deg),it[2*idx].one+it[2*idx+1].sec-2*it[2*idx].deg);\n\tit[idx].twobk=max(max(it[2*idx].twobk,it[2*idx+1].twobk-it[2*idx].deg),it[2*idx].sec+it[2*idx+1].one+it[2*idx].deg);\n\tit[idx].three=max(max(it[2*idx].three,it[2*idx+1].three),max(it[2*idx].twofr+it[2*idx+1].one+it[2*idx].deg,it[2*idx].one+it[2*idx+1].twobk-it[2*idx].deg));\n}\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,q,w,i,j,k,l,ans=0;\n\tcin>>n>>q>>w;\n\tfor(i=1;i<n;i++){\n\t\tcin>>j>>k>>l;\n\t\tadj[j].push_back({{k,l},i});\n\t\tadj[k].push_back({{j,l},i});\n\t}\n\tdfs(1,1);\n\tinit(1,1,2*n-2);\n\tfor(i=1;i<=q;i++){\n\t\tcin>>j>>k;\n\t\tj=(j+ans)%(n-1);\n\t\tk=(k+ans)%w;\n\t\tj++;\n\t\tar[pos[j].first]=k;\n\t\tar[pos[j].second]=-k;\n\t\tupd(1,1,2*n-2,pos[j].first);\n\t\tupd(1,1,2*n-2,pos[j].second);\n\t\tcout<<it[1].three<<'\\n';\n\t\tans=it[1].three;\n\t}\n}",
    "ext": "cpp"
  },
  "57962786": {
    "code": "#include<iostream>\n#include<vector>\n#define int long long\nusing namespace std;\nconst int N=1e5+2;\nstruct node{\n\tint deg,one,twofr,three,sec,twobk;\n};\nnode it[8*N];\nint ar[2*N],now=0;\nvector<pair<pair<int,int>,int> > adj[N];\npair<int,int> pos[N];\nvoid dfs(int x,int p){\n\tfor(int i=0;i<adj[x].size();i++){\n\t\tif(adj[x][i].first.first!=p){\n\t\t\tnow++;\n\t\t\tar[now]=adj[x][i].first.second;\n\t\t\tpos[adj[x][i].second].first=now;\n\t\t\tdfs(adj[x][i].first.first,x);\n\t\t\tnow++;\n\t\t\tar[now]=-adj[x][i].first.second;\n\t\t\tpos[adj[x][i].second].second=now;\n\t\t}\n\t}\n}\nvoid init(int idx,int l,int r){\n\tif(l==r){\n\t\tit[idx].deg=ar[l];\n\t\tit[idx].one=ar[l];\n\t\tit[idx].sec=-2*ar[l];\n\t\tit[idx].twofr=-ar[l];\n\t\tit[idx].twobk=-ar[l];\n\t\tit[idx].three=0;\n\t\treturn;\n\t}\n\tinit(2*idx,l,(l+r)/2);\n\tinit(2*idx+1,(l+r)/2+1,r);\n\tit[idx].deg=it[2*idx].deg+it[2*idx+1].deg;\n\tit[idx].one=max(it[2*idx].one,it[2*idx+1].one+it[2*idx].deg);\n\tit[idx].sec=max(it[2*idx].sec,it[2*idx+1].sec-2*it[2*idx].deg);\n\tit[idx].twofr=max(max(it[2*idx].twofr,it[2*idx+1].twofr-it[2*idx].deg),it[2*idx].one+it[2*idx+1].sec-2*it[2*idx].deg);\n\tit[idx].twobk=max(max(it[2*idx].twobk,it[2*idx+1].twobk-it[2*idx].deg),it[2*idx].sec+it[2*idx+1].one+it[2*idx].deg);\n\tit[idx].three=max(max(it[2*idx].three,it[2*idx+1].three),max(it[2*idx].twofr+it[2*idx+1].one+it[2*idx].deg,it[2*idx].one+it[2*idx+1].twobk-it[2*idx].deg));\n}\nvoid upd(int idx,int l,int r,int pos){\n\tif(l>pos||r<pos){\n\t\treturn;\n\t}\n\tif(l==r){\n\t\tit[idx].deg=ar[l];\n\t\tit[idx].one=ar[l];\n\t\tit[idx].sec=-2*ar[l];\n\t\tit[idx].twofr=-ar[l];\n\t\tit[idx].twobk=-ar[l];\n\t\tit[idx].three=0;\n\t\treturn;\n\t}\n\tupd(2*idx,l,(l+r)/2,pos);\n\tupd(2*idx+1,(l+r)/2+1,r,pos);\n\tit[idx].deg=it[2*idx].deg+it[2*idx+1].deg;\n\tit[idx].one=max(it[2*idx].one,it[2*idx+1].one+it[2*idx].deg);\n\tit[idx].sec=max(it[2*idx].sec,it[2*idx+1].sec-2*it[2*idx].deg);\n\tit[idx].twofr=max(max(it[2*idx].twofr,it[2*idx+1].twofr-it[2*idx].deg),it[2*idx].one+it[2*idx+1].sec-2*it[2*idx].deg);\n\tit[idx].twobk=max(max(it[2*idx].twobk,it[2*idx+1].twobk-it[2*idx].deg),it[2*idx].sec+it[2*idx+1].one+it[2*idx].deg);\n\tit[idx].three=max(max(it[2*idx].three,it[2*idx+1].three),max(it[2*idx].twofr+it[2*idx+1].one+it[2*idx].deg,it[2*idx].one+it[2*idx+1].twobk-it[2*idx].deg));\n}\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,q,w,i,j,k,l,ans=0;\n\tcin>>n>>q>>w;\n\tfor(i=1;i<n;i++){\n\t\tcin>>j>>k>>l;\n\t\tadj[j].push_back({{k,l},i});\n\t\tadj[k].push_back({{j,l},i});\n\t}\n\tdfs(1,1);\n\tinit(1,1,2*n-2);\n\tfor(i=1;i<=q;i++){\n\t\tcin>>j>>k;\n\t\tj=(j+ans)%(n-1);\n\t\tk=(k+ans)%w;\n\t\tj++;\n\t\tar[pos[j].first]=k;\n\t\tar[pos[j].second]=-k;\n\t\tupd(1,1,2*n-2,pos[j].first);\n\t\tupd(1,1,2*n-2,pos[j].second);\n\t\tcout<<it[1].three<<'\\n';\n\t\tans=it[1].three;\n\t}\n}",
    "ext": "cpp"
  },
  "57959208": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define PII pair<int, int>\n#define VI vector<int>\n#define VPII vector<PII>\n#define LL long long\n#define LD long double\n#define f first\n#define s second\n#define MP make_pair\n#define PB push_back\n#define endl '\\n'\n#define ALL(c) (c).begin(), (c).end()\n#define SIZ(c) (int)(c).size()\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, b, e) for (int i = (b); i <= (int)(e); i++)\n#define FORD(i, b, e) for (int i = (b); i >= (int)(e); i--)\n#define ll long long\n#define st f\n#define nd s\n#define pb PB\n#define eb emplace_back\n#define mp make_pair\n#define siz(c) SIZ(c)\nconst int inf = 1e9 + 7;\nconst LL INF = 1e18L + 7;\n\n#define sim template<class n\nsim, class s> ostream & operator << (ostream &p, pair<n, s> x)\n{return p << \"<\" << x.f << \", \" << x.s << \">\";}\nsim> auto operator << (ostream &p, n y) ->\ntypename enable_if<!is_same<n, string>::value, decltype(y.begin(), p)>::type\n{int o = 0; p << \"{\"; for (auto c : y) {if (o++) p << \", \"; p << c;} return p << \"}\";}\nvoid dor() {cerr << endl;}\nsim, class...s> void dor(n p, s...y) {cerr << p << \" \"; dor(y...);}\nsim, class s> void mini(n &p, s y) {if (p > y) p = y;}\nsim, class s> void maxi(n &p, s y) {if (p < y) p = y;}\n\n#ifdef DEB\n#define debug(...) dor(__FUNCTION__, \":\", __LINE__, \": \", __VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\n#define I(x) #x \" = \", (x), \" \"\n#define A(a, i) #a \"[\" #i \" = \", i, \"] = \", a[i], \" \"\n\nconst int N = 1e5+7;\n\nint n, q;\n\nll maxW, last;\n\nint a[N];\nint b[N];\nll weight[N];\n\nvector<pair<int, ll> > G[N];\n\nVI curr;\n\nbitset<N> ban, vis;\nint sub[N];\nint maxSub[N];\nmultiset<ll, greater<ll> > maxFromSubs[N], maxFromCentros;\nset<PII> chooseSon[N];\nll dep[N];\nVI centroSons[N];\nint centroOnLvl[N];\nint par[N];\n\nstruct tree\n{\t\n\tint s;\n\tVI nodes;\n\tvector<ll> load, sub;\n\tunordered_map<int, int> pre, post;\n\n\tvoid build()\n\t{\n\t\twhile(__builtin_popcount(siz(nodes))>1)\n\t\t\tnodes.pb(-1);\n\n\t\ts = siz(nodes);\n\t\tload.assign(2*s, 0);\n\t\tsub.assign(2*s, 0);\n\t}\n\n\tll query(int a, int b, int v, int l, int r)\n\t{\n\t\tif(a>r || l>b)\n\t\t\treturn -INF;\n\n\t\tif(a<=l && r<=b)\n\t\t\treturn sub[v];\n\n\t\treturn load[v] + max(query(a, b, 2*v, l, (l+r)/2), query(a, b, 2*v+1, (l+r)/2+1, r));\n\t}\n\n\tvoid insert(int a, int b, ll war, int v, int l, int r)\n\t{\n\t\tif(a>r || l>b)\n\t\t\treturn;\n\n\t\tif(a<=l && r<=b)\n\t\t{\n\t\t\tsub[v] += war;\n\t\t\tload[v] += war;\n\t\t\treturn;\n\t\t}\n\n\t\tinsert(a, b, war, 2*v, l, (l+r)/2);\n\t\tinsert(a, b, war, 2*v+1, (l+r)/2+1, r);\n\t\tsub[v] = load[v] + max(sub[2*v], sub[2*v+1]);\n\t}\n};\n\ntree itsTree[N];\n\nvoid dfs1(int v)\n{\n\tvis[v] = 1;\n\tsub[v] = 1;\n\tmaxSub[v] = 0;\n\tcurr.pb(v);\n\n\tfor(auto it:G[v])\n\t{\n\t\tint u = it.st;\n\n\t\tif(!vis[u] && !ban[u])\n\t\t{\n\t\t\tdfs1(u);\n\t\t\tsub[v] += sub[u];\n\t\t\tmaxi(maxSub[v], sub[u]);\n\t\t}\n\t}\n}\n\nvoid clearVis()\n{\n\tfor(auto it:curr)\n\t\tvis[it] = 0;\n}\n\nvoid clearCurr()\n{\n\tfor(auto it:curr)\n\t{\n\t\tvis[it] = 0;\n\t\tdep[it] = 0;\n\t}\n\n\tcurr.clear();\n}\n\nvoid dfs2(int v, int centro)\n{\n\tauto drze = &itsTree[centro];\n\tdrze->pre[v] = siz(drze->nodes);\n\tdrze->nodes.pb(v);\n\tvis[v] = 1;\n\n\tfor(auto it:G[v])\n\t{\n\t\tint u = it.st;\n\t\tll w = it.nd;\n\n\t\tif(!vis[u] && !ban[u])\n\t\t{\n\t\t\tdep[u] = dep[v] + w;\n\t\t\tdfs2(u, centro);\n\t\t}\n\t}\n\n\tdrze->post[v] = siz(drze->nodes)-1;\n}\n\nint decompo(int v, int lvl = 0)\n{\n\tdfs1(v);\n\n\tfor(auto &it:curr)\n\t{\n\t\tmaxi(maxSub[it], siz(curr) - sub[it]);\n\n\t\tif(maxSub[it]<maxSub[curr[0]])\n\t\t\tswap(it, curr[0]);\n\t}\n\n\tint centro = curr[0];\n\tcentroOnLvl[centro] = lvl;\n\tban[centro] = 1;\n\tclearVis();\n\tdfs2(centro, centro);\n\tauto drze = &itsTree[centro];\n\tdrze->build();\t\n\n\tfor(auto v:curr)\n\t\tdrze->insert(drze->pre[v], drze->pre[v], dep[v], 1, 0, drze->s - 1);\n\n\tfor(auto it:G[centro])\n\t{\n\t\tint u = it.st;\n\n\t\tif(!ban[u])\n\t\t{\n\t\t\tcentroSons[centro].pb(u);\n\t\t\tint preU = drze->pre[u];\n\t\t\tint postU = drze->post[u];\n\t\t\tmaxFromSubs[centro].insert(drze->query(preU, postU, 1, 0, drze->s - 1));\n\t\t\t//debug(preU, postU, drze->query(preU, postU, 1, 0, drze->s - 1), dep[u]);\n\t\t\tchooseSon[centro].emplace(drze->post[u], u);\n\t\t}\n\t}\n\n\tmaxFromSubs[centro].insert(0);\n\tmaxFromSubs[centro].insert(0);\n\tll currTwo = *maxFromSubs[centro].begin() + *next(maxFromSubs[centro].begin());\n\tmaxFromCentros.insert(currTwo);\n\tclearCurr();\n\n\tfor(auto u:centroSons[centro])\n\t{\n\t\tpar[decompo(u, lvl+1)] = centro;\n\t}\n\n\treturn centro;\n}\n\nvoid updateCentro(int centro, int a, int b, ll change)\n{\t\n\tll currTwo = *maxFromSubs[centro].begin() + *next(maxFromSubs[centro].begin());\n\tmaxFromCentros.erase(maxFromCentros.find(currTwo));\n\n\tauto drze = &itsTree[centro];\n\n\tif(drze->pre[a]>drze->pre[b])\n\t\tswap(a, b);\n\n\tint son = (*chooseSon[centro].lower_bound(mp(drze->post[b], -inf))).nd;\n\tint pre = drze->pre[son];\n\tint post = drze->post[son];\n\tll curr = drze->query(pre, post, 1, 0, drze->s - 1);\n\tmaxFromSubs[centro].erase(maxFromSubs[centro].find(curr));\n\tdrze->insert(drze->pre[b], drze->post[b], change, 1, 0, drze->s - 1);\n\tcurr = drze->query(pre, post, 1, 0, drze->s - 1);\n\tmaxFromSubs[centro].insert(curr);\n\n\t//assert(siz(maxFromSubs[centro])>=2);\n\tcurrTwo = *maxFromSubs[centro].begin() + *next(maxFromSubs[centro].begin());\n\tmaxFromCentros.insert(currTwo);\n}\n\nvoid update(int d, ll newWeight)\n{\n\tint x = a[d];\n\tint y = b[d];\n\tint curr = -1;\n\n\tif(centroOnLvl[x]<centroOnLvl[y])\n\t\tcurr = x;\n\telse\n\t\tcurr = y;\n\n\twhile(curr)\n\t{\n\t\tupdateCentro(curr, x, y, newWeight - weight[d]);\n\t\tcurr = par[curr];\n\t}\n\n\tweight[d] = newWeight;\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\n\tcin >> n >> q >> maxW;\n\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tcin >> a[i] >> b[i] >> weight[i];\n\t\tG[a[i]].eb(b[i], weight[i]);\n\t\tG[b[i]].eb(a[i], weight[i]);\n\t}\n\n\tdecompo(1);\n\n\twhile(q--)\n\t{\n\t\tint d;\n\t\tll e;\n\t\tcin >> d >> e;\n\t\td = (d+last)%(n-1)+1;\n\t\te = (e+last)%maxW;\n\t\tupdate(d, e);\n\t\tcout << (last = *maxFromCentros.begin()) << endl;\n\t}\n}",
    "ext": "cpp"
  },
  "57953242": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(x) ((int) ((x).size()))\ntypedef long long ll;\ntypedef long double ld;\n#define MAXN 200000\n#define left(i) (2 * (i) + 1)\n#define right(i) (2 * (i) + 2)\n#define parent(i) (((i) - 1) / 2)\n\nconst int logmaxn = (int) log2(MAXN) + 1;\nconst int ts = 1 << (logmaxn + 1), to = (1 << logmaxn) - 1;\n\n// the data with default values\nstruct data {\n  ll d = 0, sw = 0, mpl = 0, mpr = 0;\n};\n\ndata t[ts];\n\n// combine the data from different branches\ndata combine(data l, data r) {\n  data c;\n  c.d = max(max(l.d, r.d), l.mpr + r.mpl);\n  c.sw = l.sw + r.sw;\n  c.mpl = max(l.mpl, r.mpl + l.sw);\n  c.mpr = max(r.mpr, l.mpr + r.sw);\n  return c;\n}\n\ndata getValue(int x) {\n  return t[x];\n}\n\nvoid calcValue(int x) {\n  t[x] = combine(getValue(left(x)), getValue(right(x)));\n}\n\n// query the data on the range [a, b[\ndata query(int a, int b, int x = 0, int l = 0, int r = 1 << logmaxn) {\n  if (a <= l && r <= b)\n    return getValue(x);\n  if (b <= l || r <= a)\n    return data();\n  int m = (l + r) / 2;\n  data d = combine(query(a, b, left(x), l, m), query(a, b, right(x), m, r));\n  calcValue(x);\n  return d;\n}\n\nvoid change(int a, data d) {\n  int x = a + to;\n  t[x] = d;\n  do {\n    x = parent(x);\n    calcValue(x);\n  } while (x != 0);\n}\n\nint n, q, m, s[MAXN], d[MAXN], hldh[MAXN], hldhh[MAXN], hldn[MAXN], hlde[MAXN], hldu[MAXN];\nll edge[MAXN][3];\nll w;\nvector<int> e[MAXN];\n\nvoid dfs(int i = 0, int p = -1, int dep = 0) {\n  s[i] = 1;\n  d[i] = dep;\n  for (int j : e[i]) {\n    if (j == p)\n      continue;\n    dfs(j, i, dep + 1);\n    s[i] += s[j];\n  }\n}\n\nvoid setEdge(int i, ll ew) {\n  change(hldn[i], {ew, ew, ew, 0});\n  i = hldh[i];\n  while (i != 0) {\n    data c = query(hldn[i], hlde[i]);\n    i = hldu[i];\n    change(i, {c.d, 0, c.mpl, c.mpl});\n    i = hldhh[i];\n  }\n}\n\nll getRes() {\n  data c = query(hldn[0], hlde[0]);\n  return c.d;\n}\n\nvoid hld(int i = 0, int p = -1, bool h = true, int hh = -1) {\n  int ms = 0, mj = -1;\n  if (h)\n    hh = i;\n  hldh[i] = hh;\n  for (int j : e[i]) {\n    if (j == p)\n      continue;\n    if (s[j] > ms)\n      ms = s[j], mj = j;\n  }\n  hldhh[m] = hh;\n  // cerr << m << \" \" << i << \"\\n\";\n  hldn[i] = m++;\n  m += sz(e[i]) - (p != -1 ? 1 : 0) - (mj != -1 ? 1 : 0);\n  if (mj != -1)\n    hld(mj, i, false, hh);\n  else\n    hlde[hh] = m;\n  int cur = hldn[i] + 1;\n  for (int j : e[i]) {\n    if (j == p || j == mj)\n      continue;\n    // cerr << cur << \" \" << j << \"u\\n\";\n    hldhh[cur] = hh;\n    hldu[j] = cur++;\n    hld(j, i, true);\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  cin >> n >> q >> w;\n  int a, b;\n  ll c;\n  for (int i = 0; i < n - 1; i++) {\n    cin >> a >> b >> c, a--, b--;\n    edge[i][0] = a, edge[i][1] = b, edge[i][2] = c;\n    e[a].push_back(b);\n    e[b].push_back(a);\n  }\n  dfs();\n  hld();\n  for (int i = 0; i < n - 1; i++) {\n    if (d[edge[i][1]] < d[edge[i][0]])\n      swap(edge[i][0], edge[i][1]);\n    setEdge(edge[i][1], edge[i][2]);\n  }\n  ll last = 0;\n  ll d, ee;\n  for (int i = 0; i < q; i++) {\n    cin >> d >> ee;\n    d = (d + last) % (n - 1);\n    ee = (ee + last) % w;\n    setEdge(edge[d][1], ee);\n    last = getRes();\n    cout << last << \"\\n\";\n  }\n}\n",
    "ext": "cpp"
  },
  "57951295": {
    "code": "#include <bits/stdc++.h>\n#define N 100001\n#define M 60 * N\nusing namespace std;\n\ntypedef long long ll;\n\nstruct m2 {\n    int c1, c2; ll v1, v2;\n    void clr() { c1 = c2 = 0; v1 = v2 = 0; }\n    void ins(int c, ll v) {\n        if (c1 == c) v1 = max(v1, v);\n        if (c2 == c) {\n            v2 = max(v2, v);\n            if (v2 > v1) {\n                swap(v1, v2);\n                swap(c1, c2);\n            }\n        }\n        if (c1 != c && c2 != c) {\n            if (!c1) c1 = c, v1 = v;\n            else if (v1 <= v) c2 = c1, v2 = v1, c1 = c, v1 = v;\n            else if (!c2 || v2 < v) c2 = c, v2 = v;\n        }\n    }\n    void ins(m2 m) {\n        if (m.c1) ins(m.c1, m.v1);\n        if (m.c2) ins(m.c2, m.v2);\n    }\n    ll get() { return v1 + v2; }\n};\n\nint ls[M], rs[M], nc;\nm2 st[M]; ll tg[M];\n\nvoid update(int p, ll w) {\n    if (st[p].c1) st[p].v1 += w;\n    if (st[p].c2) st[p].v2 += w;\n    tg[p] += w;\n}\n\nvoid push_up(int p) {\n    st[p].clr();\n    st[p].ins(st[ls[p]]);\n    st[p].ins(st[rs[p]]);\n}\n\nvoid push_down(int p) {\n    if (!tg[p]) return;\n    update(ls[p], tg[p]);\n    update(rs[p], tg[p]);\n    tg[p] = 0;\n}\n\nvoid build(const vector<pair<int, ll>>& d, int p, int lb, int rb) {\n    if (lb + 1 == rb)\n        st[p].ins(d[lb - 1].first, d[lb - 1].second);\n    else {\n        int mid = (lb + rb) >> 1;\n        build(d, ls[p] = ++nc, lb, mid);\n        build(d, rs[p] = ++nc, mid, rb);\n        push_up(p);\n    }\n}\n\nvoid modify(int l, int r, ll w, int p, int lb, int rb) {\n    if (l <= lb && rb <= r) update(p, w);\n    else {\n        int mid = (lb + rb) >> 1;\n        push_down(p);\n        if (l < mid) modify(l, r, w, ls[p], lb, mid);\n        if (r > mid) modify(l, r, w, rs[p], mid, rb);\n        push_up(p);\n    }\n}\n\nint eu[N], ev[N]; ll ew[N];\nstruct edge { int v, i; ll w; };\nvector<edge> g[N];\nset<pair<ll, int>, greater<pair<ll, int>>> ans;\nunordered_map<int, int> lb[N], rb[N];\nint rt[N], dfc[N], dep[N], fa[N], sta[N];\n\nint sz[N], msz[N]; bool vis[N];\nint dfs_sz(int u, int f, int s) {\n    int res = 0; sz[u] = 1; msz[u] = 0;\n    for (edge e : g[u]) {\n        if (e.v == f || vis[e.v]) continue;\n        int r = dfs_sz(e.v, u, s);\n        sz[u] += sz[e.v];\n        msz[u] = max(msz[u], sz[e.v]);\n        if (!res || msz[r] < msz[res]) res = r;\n    }\n    msz[u] = max(msz[u], s - sz[u]);\n    if (!res || msz[u] < msz[res]) res = u;\n    return res;\n}\n\nvoid dfs_dc(vector<pair<int, ll>>& dis, int r, int u, int f, int c, ll w, int i) {\n    if (!sta[i] || dep[sta[i]] < dep[r]) sta[i] = r;\n    dis.push_back({ c, w });\n    lb[r][i] = ++dfc[r];\n    for (edge e : g[u]) if (!vis[e.v] && e.v != f)\n        dfs_dc(dis, r, e.v, u, c, w + e.w, e.i);\n    rb[r][i] = dfc[r];\n}\n\nvoid dc(int u, int f, int s) {\n    vis[u = dfs_sz(u, 0, s)] = 1;\n    fa[u] = f; dep[u] = dep[f] + 1;\n    if (s == 1) return;\n    vector<pair<int, ll>> dis;\n    for (edge e : g[u]) {\n        if (vis[e.v]) continue;\n        dfs_dc(dis, u, e.v, u, e.v, e.w, e.i);\n        dc(e.v, u, sz[e.v] < sz[u] ? sz[e.v] : s - sz[u]);\n    }\n    build(dis, rt[u] = ++nc, 1, dfc[u] + 1);\n    ans.insert({ st[rt[u]].get(), u });\n}\n\nvoid modify(int x, ll w) {\n    ll dw = w - ew[x];\n    int u = sta[x];\n    do {\n        ans.erase({ st[rt[u]].get(), u });\n        int l = lb[u][x], r = rb[u][x];\n        modify(l, r + 1, dw, rt[u], 1, dfc[u] + 1);\n        ans.insert({ st[rt[u]].get(), u });\n    } while (u = fa[u]);\n}\n\nint main(void) {\n    int n, q; ll wm; scanf(\"%d%d%I64d\", &n, &q, &wm);\n    for (int i = 1; i <= n - 1; ++i) {\n        int u, v; ll w; scanf(\"%d%d%I64d\", &u, &v, &w);\n        g[u].push_back({ v, i, w });\n        g[v].push_back({ u, i, w });\n        eu[i] = u; ev[i] = v; ew[i] = w;\n    }\n\n    dc(1, 0, n);\n\n    ll last = 0;\n    while(q--) {\n        int x; ll w; scanf(\"%d%I64d\", &x, &w);\n        x = (x + last) % (n - 1) + 1;\n        w = (w + last) % wm;\n        modify(x, w);\n        ew[x] = w;\n        last = ans.begin()->first;\n        printf(\"%I64d\\n\", last);\n    }\n\n    return 0;\n}",
    "ext": "cpp"
  },
  "57946723": {
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <vector>\n#include <map>\n#define mp make_pair\n#pragma GCC optimize-target(\"Ofast\")\n\nusing namespace std;\nconst int nmax=100005;\nset< pair<long long,int> > s[nmax],mare;\nset< pair<long long,int> >::iterator t;\nmap<int,int> m[nmax];\nvector<long long> vechi[nmax];\nvector< pair<int,int> > bune[nmax];\nint eul[nmax],a[nmax],b[nmax];\nlong long val[nmax];\nlong long rasp[nmax];\nint rep[nmax],we[nmax],big[nmax],tt[nmax];\nvector<int> r[nmax],padre[nmax],avem[nmax];\nlong long ans;\nlong long lev[nmax];\nint n;\nstruct node\n{\n    long long val,upd;\n};\nvector< pair<int,int> > v[nmax];\nvector<int> ad[nmax];\nstruct aint\n{\n    vector<node> arb;\n    int sz,st,dr;\n    long long mx;\n    void init(int _n)\n    {\n        sz=_n;\n        arb.resize(4*_n+3);\n    }\n    void build(int nod,int l,int r)\n    {\n        if(l==r)\n        {\n            arb[nod].val=lev[rep[l]];\n            return;\n        }\n        int m=(l+r)/2;\n        build(2*nod,l,m);\n        build(2*nod+1,m+1,r);\n        arb[nod].val=max(arb[2*nod].val+arb[2*nod].upd,arb[2*nod+1].val+arb[2*nod+1].upd);\n    }\n    void update(int nod,int l,int r,int st,int dr,long long val)\n    {\n        if(st<=l&&r<=dr)\n        {\n            arb[nod].upd+=val;\n            return;\n        }\n        int m=(l+r)/2;\n        if(arb[nod].upd)\n        {\n            update(2*nod,l,m,l,m,arb[nod].upd);\n            update(2*nod+1,m+1,r,m+1,r,arb[nod].upd);\n            arb[nod].upd=0;\n        }\n        if(st<=m) update(2*nod,l,m,st,dr,val);\n        if(m<dr)  update(2*nod+1,m+1,r,st,dr,val);\n        arb[nod].val=max(arb[2*nod].val+arb[2*nod].upd,arb[2*nod+1].val+arb[2*nod+1].upd);\n    }\n    void query(int nod,int l,int r,int st,int dr)\n    {\n        if(st<=l&&r<=dr)\n        {\n            if(arb[nod].val+arb[nod].upd>mx)\n                mx=1LL*arb[nod].val+arb[nod].upd;\n            return;\n        }\n        int m=(l+r)/2;\n        if(arb[nod].upd)\n        {\n            update(2*nod,l,m,l,m,arb[nod].upd);\n            update(2*nod+1,m+1,r,m+1,r,arb[nod].upd);\n            arb[nod].upd=0;\n        }\n        if(st<=m) query(2*nod,l,m,st,dr);\n        if(m<dr)  query(2*nod+1,m+1,r,st,dr);\n        arb[nod].val=max(arb[2*nod].val+arb[2*nod].upd,arb[2*nod+1].val+arb[2*nod+1].upd);\n    }\n    long long Q(int S,int D)\n    {\n        mx=0;\n        query(1,1,sz,S,D);\n        return mx;\n    }\n}ab[nmax];\nvoid dfs(int x,int root)\n{\n    int nod=0;\n    m[root][x]=++eul[root];r[root].push_back(0);\n    rep[eul[root]]=x;we[x]=1;big[x]=0;\n    for(int i=0;i<v[x].size();i++)\n    {\n        nod=v[x][i].first;\n        if(!we[nod])\n        {\n            lev[nod]=lev[x]+val[v[x][i].second];\n            avem[root].push_back(v[x][i].second);\n            bune[v[x][i].second].push_back({root,eul[root]+1});\n            dfs(nod,root);\n            we[x]+=we[nod];\n            if(we[nod]>big[x])\n                big[x]=we[nod];\n        }\n    }\n    r[root][m[root][x]]=eul[root];\n}\nvoid rst(int lca,int mu,int it,long long dif)\n{\n    if(eul[lca]==1) return;\n    mare.erase({rasp[lca],lca});\n    int in_sus=padre[lca][it];\n    s[lca].erase({vechi[lca][in_sus],in_sus});\n    ab[lca].update(1,1,ab[lca].sz,it,r[lca][it],dif);\n    vechi[lca][in_sus]=ab[lca].Q(in_sus,r[lca][in_sus]);\n    s[lca].insert({vechi[lca][in_sus],in_sus});\n    t=(s[lca].end());t--;\n    rasp[lca]=(*t).first;\n    if(t!=s[lca].begin())\n    {\n        t--;\n        rasp[lca]+=1LL*(*t).first;\n    }\n    mare.insert({rasp[lca],lca});\n    ans=(*mare.rbegin()).first;\n}\nvoid rezolva(int R)\n{\n    lev[R]=0;\n    r[R].push_back(0);\n    dfs(R,R);\n    s[R].insert({0,R});\n    ab[R].init(eul[R]);\n    ab[R].build(1,1,ab[R].sz);\n    vechi[R].resize(eul[R]+2);\n    padre[R].resize(eul[R]+2);\n    int in_sus;\n    for(int i=0;i<v[R].size();i++)\n    {\n        int nod=v[R][i].first;\n        in_sus=m[R][nod];\n        vechi[R][in_sus]=ab[R].Q(in_sus,r[R][in_sus]);\n        s[R].insert({vechi[R][in_sus],in_sus});\n        for(int j=0;j<v[nod].size();j++)\n            if(v[nod][j].first==R)\n        {\n            swap(v[nod][j],v[nod].back());\n            v[nod].pop_back();\n        }\n        int wh=m[R][nod];\n        for(int j=wh;j<=r[R][wh];j++)\n        {\n            padre[R][j]=wh;\n        }\n    }\n    t=(s[R].end());\n    t--;\n    rasp[R]=(*t).first;\n    if(t!=s[R].begin())\n    {\n        t--;\n        rasp[R]+=1LL*(*t).first;\n    }\n    mare.insert({rasp[R],R});\n    return;\n}\nvoid desc(int R)\n{\n    rezolva(R);\n    int st,dr,x,nod,cen;\n    for(int i=0;i<v[R].size();i++)\n    {\n        x=v[R][i].first;\n        st=m[R][x];dr=r[R][st];\n        for(int j=st;j<=dr;j++)\n        {\n            nod=rep[j];\n            if(we[x]-we[nod]<=we[x]/2&&big[nod]<=we[x]/2)\n            {\n                cen=nod;\n            }\n        }\n        ad[R].push_back(cen);\n    }\n    for(int i=1;i<=eul[R];i++)\n    {\n        x=rep[i];\n        we[x]=big[x]=0;\n    }\n    for(int i=0;i<ad[R].size();i++)\n    {\n        tt[ad[R][i]]=R;\n        desc(ad[R][i]);\n    }\n}\nstring str;\nint in=0,ch=0;\nlong long nm=0;\nint get_int()\n{\n    in=0;\n    while(str[ch]>='0'&&str[ch]<='9')\n    {\n        in=in*10+str[ch]-'0';\n        ch++;\n    }\n    ch++;\n    return in;\n}\nlong long get_ll()\n{\n    nm=0;\n    while(str[ch]>='0'&&str[ch]<='9')\n    {\n        nm=1LL*nm*10+str[ch]-'0';\n        ch++;\n    }\n    ch++;\n    return nm;\n}\nvoid DF(int x)\n{\n    we[x]=1;\n    for(int i=0;i<v[x].size();i++)\n        if(!we[v[x][i].first])\n    {\n        DF(v[x][i].first);\n        we[x]+=we[v[x][i].first];\n        if(we[v[x][i].first]>big[x])\n            big[x]=we[v[x][i].first];\n    }\n}\nlong long w,edg_w;\nint q,x,y;\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    //freopen(\"data.in\",\"r\",stdin);\n    cin>>n>>q>>w;getline(cin,str);\n    for(int i=0;i<n-1;i++)\n    {\n        getline(cin,str);ch=0;\n        x=get_int();\n        y=get_int();\n        edg_w=get_ll();\n        v[x].push_back({y,i});\n        v[y].push_back({x,i});\n        a[i]=x;b[i]=y;val[i]=edg_w;\n    }\n    DF(1);\n    int cen=0;\n    for(int i=1;i<=n;i++)\n        if(we[1]-we[i]<=we[1]/2&&big[i]<=we[1]/2)\n          cen=i;\n    for(int i=1;i<=n;i++)\n        we[i]=big[i]=0;\n    desc(cen);\n    ans=0;\n    long long wh,d,n1=n-1,vv;\n    for(int cnt=1;cnt<=q;cnt++)\n    {\n        getline(cin,str);ch=0;\n        wh=get_int();\n        vv=get_ll();\n        wh=(1LL*wh+ans)%(n1);\n        vv=(1LL*vv+ans)%w;\n        x=a[wh];\n        for(int it=0;it<bune[wh].size();it++)\n            rst(bune[wh][it].first,wh,bune[wh][it].second,vv-val[wh]);\n        val[wh]=vv;\n        cout<<ans<<'\\n';\n    }\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57941324": {
    "code": "#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma comment(linker, \"/stack:200000000\")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n \n#define X first\n#define Y second\n \n//#include <boost/unordered_map.hpp>\n//using namespace boost;\n \n/*\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> rbtree;\nrbtree T;\n*/\n \nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing f64 = double;\nusing f80 = long double;\n//using i128 = __int128_t;\n//using u128 = __uint128_t;\nusing i128 = i64;\nusing u128 = u64;\n \nll power(ll a, ll b, ll p)\n{\n\tif (!b) return 1;\n\tll t = power(a, b/2, p);\n\tt = t*t%p;\n\tif (b&1) t = t*a%p;\n\treturn t;\n}\n \nll exgcd(ll a, ll b, ll &x, ll &y)\n{\n\tif (b == 0)\n\t{\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn a;\n\t}\n\tll px, py;\n\tll d = exgcd(b, a%b, px, py);\n\tx = py;\n\ty = px-a/b*py;\n\treturn d;\n}\n \ntemplate<class T>\ninline void freshmin(T &a, const T &b)\n{\n\tif (a > b) a = b;\n}\n \ntemplate<class T>\ninline void freshmax(T &a, const T &b)\n{\n\tif (a < b) a = b;\n}\n \n//#define getchar getchar_unlocked\n//#define putchar putchar_unlocked\n \nint inp() {\n\tint x = 0, f = 0; char ch;\n\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\tif(ch == '-') f = 1;\n\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\treturn f ? -x : x;\n}\n \nll inp_ll() {\n\tll x = 0; int f = 0; char ch;\n\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\tif(ch == '-') f = 1;\n\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\treturn f ? -x : x;\n}\n \ntemplate<class T>\nbool read(T &x)\n{\n\tx = 0;\n\tchar ch = getchar();\n\tif (ch == EOF) return 0;\n\tfor(; !isdigit(ch); )\n\t{\n\t\tch = getchar();\n\t\tif (ch == EOF) return 0;\n\t}\n\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\treturn 1;\n}\n \ntemplate<class T>\nvoid write(T x)\n{\n\tstatic char s[22];\n\tstatic char *it = s+20;\n\tstatic char *end = s+20;\n\tif (!x)\n\t\t*-- it = '0';\n\twhile (x)\n\t{\n\t\t*-- it = x%10+'0';\n\t\tx /= 10;\n\t}\n\tfor (; it < end; ++ it)\n\t\tputchar(*it);\n}\n \ntemplate<class T>\nvoid writeln(T x)\n{\n\twrite(x);\n\tputchar('\\n');\n}\n \nconst int MAXN = 200010;\nconst int INF = 1000000000;\nconst int MOD = 1000000007;\n\nint n;\nvector<pair<int, i64>> v[MAXN];\npii e[MAXN];\n\ni64 dis[MAXN], pre[MAXN], weight[MAXN];\nint times, r[MAXN], X[MAXN], Y[MAXN];\n\nvoid dfs(int x)\n{\n\tr[X[x] = ++ times] = x;\n\tfor (auto p : v[x])\n\t{\n\t\tint y = p.X;\n\t\ti64 z = p.Y;\n\t\tif (y == pre[x]) continue;\n\t\tdis[y] = dis[x]+z;\n\t\tpre[y] = x;\n\t\tweight[y] = z;\n\t\tdfs(y);\n\t\tr[++ times] = x;\n\t}\n\tY[x] = times;\n}\n\nstruct node\n{\n\ti64 tag, val, M, LM, MR, LMR;\n}tree[MAXN*4];\n\nvoid add(int k, i64 d)\n{\n\ttree[k].tag += d;\n\ttree[k].val += d;\n\ttree[k].M -= 2*d;\n\ttree[k].LM -= d;\n\ttree[k].MR -= d;\n}\n\nvoid clear(int k)\n{\n\tif (tree[k].tag)\n\t{\n\t\tadd(k<<1, tree[k].tag);\n\t\tadd(k<<1|1, tree[k].tag);\n\t\ttree[k].tag = 0;\n\t}\n}\n\nvoid update(int k)\n{\n\ttree[k].val = max(tree[k<<1].val, tree[k<<1|1].val);\n\ttree[k].M = max(tree[k<<1].M, tree[k<<1|1].M);\n\ttree[k].LM = max(max(tree[k<<1].LM, tree[k<<1|1].LM), tree[k<<1].val+tree[k<<1|1].M);\n\ttree[k].MR = max(max(tree[k<<1].MR, tree[k<<1|1].MR), tree[k<<1].M+tree[k<<1|1].val);\n\ttree[k].LMR = max(max(tree[k<<1].LMR, tree[k<<1|1].LMR), max(tree[k<<1].val+tree[k<<1|1].MR, tree[k<<1].LM+tree[k<<1|1].val));\n}\n\nvoid build(int k, int L, int R)\n{\n\tif (L == R)\n\t{\n\t\tint x = r[L];\n\t\ttree[k].tag = 0;\n\t\ttree[k].val = dis[x];\n\t\ttree[k].M = -2*dis[x];\n\t\ttree[k].LM = tree[k].MR = -dis[x];\n\t\ttree[k].LMR = 0;\n\t\treturn;\n\t}\n\tint m = (L+R)>>1;\n\tbuild(k<<1, L, m);\n\tbuild(k<<1|1, m+1, R);\n\tupdate(k);\n}\n\nvoid add(int k, int L, int R, int x, int y, i64 d)\n{\n\tif (L == x && R == y)\n\t{\n\t\tadd(k, d);\n\t\treturn;\n\t}\n\tclear(k);\n\tint m = (L+R)>>1;\n\tif (y <= m)\n\t\tadd(k<<1, L, m, x, y, d);\n\telse if (x > m)\n\t\tadd(k<<1|1, m+1, R, x, y, d);\n\telse\n\t{\n\t\tadd(k<<1, L, m, x, m, d);\n\t\tadd(k<<1|1, m+1, R, m+1, y, d);\n\t}\n\tupdate(k);\n}\n\nint main()\n{\n\t\n\tn = inp();\n\tint q = inp();\n\ti64 W = inp_ll();\n\tfor (int i = 1; i < n; ++ i)\n\t{\n\t\tint x = inp();\n\t\tint y = inp();\n\t\ti64 z = inp_ll();\n\t\tv[x].push_back({y, z});\n\t\tv[y].push_back({x, z});\n\t\te[i] = {x, y};\n\t}\n\tdfs(1);\n\tbuild(1, 1, times);\n\ti64 ans = 0;\n\twhile (q --)\n\t{\n\t\tint k = (inp()+ans)%(n-1)+1;\n\t\ti64 w = (inp_ll()+ans)%W;\n\t\tint x = pre[e[k].X] == e[k].Y ? e[k].X : e[k].Y;\n\t\tadd(1, 1, times, X[x], Y[x], w-weight[x]);\n\t\tweight[x] = w;\n\t\twriteln(ans = tree[1].LMR);\n\t}\n\t\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57940889": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(ll i = a; i < ll(b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (ll)(x).size()\ntypedef long long ll;\ntypedef pair<ll, ll> pii;\ntypedef vector<ll> vi;\n\nclass Node{\npublic:\n    Node *left=0,*right=0;\n    ll dn,up;\n    ll v = 0;\n    ll l = 0;\n\n    Node(ll d,ll u){\n        dn = d;\n        up = u;\n    }\n\n    void ensure(){\n        if(dn+1==up) return;\n        if(left==0){\n            left = new Node(dn,(dn+up)/2);\n            right = new Node((dn+up)/2,up);\n        }\n        left->v+=l;\n        left->l+=l;\n        right->v+=l;\n        right->l+=l;\n        l = 0;\n    }\n\n    ll add(ll a, ll b, ll val){\n        if(b<=dn||up<=a) return v;\n        if(a<=dn&&up<=b) {\n            l+=val;\n            v+=val;\n        } else {\n            ensure();\n            v = max(left->add(a,b,val),right->add(a,b,val));\n        }\n        return v;\n    }\n\n    ll query(ll a,ll b){\n        if(b<=dn||up<=a) return -1e18;\n        if(a<=dn&&up<=b) return v;\n        ensure();\n        return max(left->query(a,b),right->query(a,b));\n    }\n};\n\n\nvector<set<pii>> e;\nmultiset<ll> allAns;\nll n,q,x;\n\nvector<bool> beenCentroid;\n\nll updateSteps = 0;\n\nclass Subtree{\npublic:\n    ll root,par,cent;\n    ll leafCount = 0;\n    ll size;\n    ll ans = 0;\n    vi lg;\n    unordered_map<ll,ll> gl;\n    vi level;\n    vi subtreeSize;\n    vi we;\n    vi s,en;\n    vi child;\n    Node *st;\n    multiset<ll> ch;\n\n    unordered_map<ll,Subtree*> chSubs;\n\n    vi stStart;\n\n    Subtree(ll r,ll p){\n        root = r;\n        par = p;\n    \n            \n        dfs1(r,par);\n        size = subtreeSize[gl[root]];\n        //cout<<size<<endl;\n        cent = findCentroid();\n\n        //cout<<\"Cent: \"<<cent<<endl;\n        //trav(v,gl){\n            //cout<<v.first<<\": \"<<v.second<<endl;\n        //}\n        level.resize(size);\n        s.resize(size);\n        en.resize(size);\n        we.resize(size);\n        child.resize(size);\n        dfs2(cent,-1,0,-1,0);\n        st = new Node(0,leafCount);\n        rep(i,0,leafCount) st->add(i,i+1,stStart[i]);\n\n        trav(u,e[cent]) {\n            if(!beenCentroid[u.first])\n                ch.insert(st->query(s[gl[u.first]],en[gl[u.first]]));\n        }\n        ch.insert(0);\n        ch.insert(0);\n        allAns.insert(ans=*prev(ch.end())+*prev(prev(ch.end())));\n\n            /*trav(v,gl){\n                cout<<v.first<<\": \"<<v.second<<endl;\n            }*/\n        beenCentroid[cent] = true;\n        trav(u,e[cent]){\n            if(!beenCentroid[u.first])\n               chSubs[gl[u.first]] = new Subtree(u.first,cent);\n        }\n    }\n\n    ll findCentroid(){\n        ll pos = root;\n        ll l = par;\n        pii best = {1e18,0};\n        while(true){\n            best = {-1,0};\n            trav(u,e[pos]){\n                if(u.first==l||beenCentroid[u.first]) continue;\n                best = max(best,{subtreeSize[gl[u.first]],u.first});\n            }\n            if(best.first*2<=size) break;\n            l = pos;\n            pos = best.second;\n        }\n        return pos;\n    }\n\n    void update(ll a,ll b,ll val){\n        updateSteps++;\n        if(size==1) return;\n        //cout<<cent<<\": \"<<a<<\" \"<<b<<endl;\n        //    trav(v,gl){\n        //        cout<<v.first<<\": \"<<v.second<<endl;\n        //    }\n        if(gl.find(a)==gl.end()||gl.find(b)==gl.end()) return;\n        a = gl[a];\n        b = gl[b];\n        //cout<<a<<\" \"<<b<<endl;\n        //cout<<level[a]<<\" \"<<level[b]<<endl;\n        if(level[a]>level[b]) swap(a,b);\n        //cout<<a<<\" \"<<b<<endl;\n        //cout<<child[b]<<endl;\n        //cout<<s.size()<<endl;\n        //cout<<en.size()<<endl;\n        ll lastVal = max(0ll,st->query(s[child[b]],en[child[b]]));\n        //cout<<lastVal<<endl;\n        //trav(c,ch){\n        //    cout<<c<<\" \";\n        //}\n        //cout<<endl;\n        ch.erase(ch.find(lastVal));\n        //cout<<lg[b]<<\" \"<<s[b]<<\" \"<<en[b]<<\" \"<<val-we[b]<<endl;\n        st->add(s[b],en[b],val-we[b]);\n        we[b] = val;\n        ll newVal = max(0ll,st->query(s[child[b]],en[child[b]]));\n        //cout<<newVal<<endl;\n        ch.insert(newVal);\n\n       //trav(c,ch){\n         //   cout<<c<<\" \";\n        //}\n        //cout<<endl;\n        newAns(*prev(ch.end())+*prev(prev(ch.end())));\n\n        //trav(x,gl) cout<<x.first<<\" \";\n        //cout<<endl;\n        //cout<<cent<<endl;\n        //cout<<child[b]<<endl;\n        chSubs[child[b]]->update(lg[a],lg[b],val);\n    }\n\n    void newAns(ll x){\n        //cout<<cent<<\": \"<<x<<endl;\n        allAns.erase(allAns.find(ans));\n        allAns.insert(x);\n        ans = x;\n    }\n\n    ll dfs1(ll v,ll l){\n        //cout<<\"dfs1\"<<\" \"<<v<<\" \"<<l<<endl;\n        if(gl.find(v)==gl.end()){\n            gl[v] = lg.size();\n            lg.push_back(v);\n            subtreeSize.push_back(0);\n            //if(cent==0){\n                //cout<<\"###\"<<endl;\n                //trav(v,gl){\n                //    cout<<v.first<<\": \"<<v.second<<endl;\n               // }\n                //cout<<\"###\"<<endl;\n            //}\n        }\n        ll ret = 1;\n        trav(u,e[v]){\n            if(u.first==l||beenCentroid[u.first]) continue;\n            ret += dfs1(u.first,v);\n        }\n        //cout<<v<<\": \"<<ret<<endl;\n        subtreeSize[gl[v]] = ret;\n        return ret;\n    }\n    \n    void dfs2(ll v,ll l, ll lev, ll chi, ll sum){\n        //cout<<level.size()<<' '<<gl[v]<<endl;\n        level[gl[v]] = lev;\n        s[gl[v]] = leafCount;\n        if(l==cent) chi = gl[v];\n        //cout<<cent<<\": \"<<v<<\" \"<<chi<<endl;\n        child[gl[v]] = chi;\n        trav(u,e[v]){\n            if(u.first==l||u.first==par||beenCentroid[u.first]) continue;\n            dfs2(u.first,v,lev+1,chi,sum+u.second);\n            we[gl[u.first]] = u.second;\n        }\n        if(e[v].size()==1) {\n            leafCount++;\n            stStart.push_back(sum);\n        }\n        en[gl[v]] = leafCount;\n    }\n};\n\nSubtree *tree;\n\nll update(ll a,ll b,ll w){\n    tree->update(a,b,w);\n    return *prev(allAns.end());\n}\n\nint main() {\n    cin.sync_with_stdio(0); cin.tie(0);\n    cin.exceptions(cin.failbit);\n\n    cin>>n>>q>>x;\n    e.resize(n);\n    beenCentroid.resize(n);\n    vector<tuple<ll,ll,ll>> edges;\n    rep(i,0,n-1){\n        ll a,b,w;\n        cin>>a>>b>>w;\n        --a;\n        --b;\n        e[a].emplace(b,w);\n        e[b].emplace(a,w);\n        edges.emplace_back(a,b,w);\n    }\n\n    tree = new Subtree(0,-1);\n    rep(i,0,n-1){\n        ll a,b,w;\n        tie(a,b,w) = edges[i];\n        //update(a,b,w);\n    }\n\n    \n    ll last = 0;\n    rep(i,0,q){\n        ll d,we;\n        cin>>d>>we;\n        d = (d+last)%(n-1);\n        we = (we+last)%x;\n    \n        ll a,b,w;\n        tie(a,b,w) = edges[d];\n        updateSteps = 0;\n        //cout<<a<<\" \"<<b<<\" \"<<we<<endl;\n        cout<<(last=update(a,b,we))<<endl;\n        assert(updateSteps<=30);\n    }\n}",
    "ext": "cpp"
  },
  "57931122": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int64 infll2 = infll / 10;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename F >\nstruct FixPoint : F {\n  FixPoint(F &&f) : F(forward< F >(f)) {}\n\n  template< typename... Args >\n  decltype(auto) operator()(Args &&... args) const {\n    return F::operator()(*this, forward< Args >(args)...);\n  }\n};\n\ntemplate< typename F >\ninline decltype(auto) MFP(F &&f) {\n  return FixPoint< F >{forward< F >(f)};\n}\n\ntemplate< typename SUM, typename KEY >\nstruct LinkCutTreeSubtree {\n\n  struct Node {\n    Node *l, *r, *p;\n\n    KEY key;\n    SUM sum;\n\n    bool rev;\n    int sz;\n\n    bool is_root() const {\n      return !p || (p->l != this && p->r != this);\n    }\n\n    Node(const KEY &key, const SUM &sum) :\n        key(key), sum(sum), rev(false), sz(1),\n        l(nullptr), r(nullptr), p(nullptr) {}\n  };\n\n  const SUM ident;\n\n  LinkCutTreeSubtree(const SUM &ident) : ident(ident) {}\n\n  Node *make_node(const KEY &key) {\n    auto ret = new Node(key, ident);\n    update(ret);\n    return ret;\n  }\n\n  Node *set_key(Node *t, const KEY &key) {\n    expose(t);\n    t->key = key;\n    update(t);\n    return t;\n  }\n\n  void toggle(Node *t) {\n    swap(t->l, t->r);\n    t->sum.toggle();\n    t->rev ^= true;\n  }\n\n  void push(Node *t) {\n    if(t->rev) {\n      if(t->l) toggle(t->l);\n      if(t->r) toggle(t->r);\n      t->rev = false;\n    }\n  }\n\n\n  void update(Node *t) {\n    t->sz = 1;\n    if(t->l) t->sz += t->l->sz;\n    if(t->r) t->sz += t->r->sz;\n    t->sum.merge(t->key, t->l ? t->l->sum : ident, t->r ? t->r->sum : ident);\n  }\n\n  void rotr(Node *t) {\n    auto *x = t->p, *y = x->p;\n    if((x->l = t->r)) t->r->p = x;\n    t->r = x, x->p = t;\n    update(x), update(t);\n    if((t->p = y)) {\n      if(y->l == x) y->l = t;\n      if(y->r == x) y->r = t;\n      update(y);\n    }\n  }\n\n  void rotl(Node *t) {\n    auto *x = t->p, *y = x->p;\n    if((x->r = t->l)) t->l->p = x;\n    t->l = x, x->p = t;\n    update(x), update(t);\n    if((t->p = y)) {\n      if(y->l == x) y->l = t;\n      if(y->r == x) y->r = t;\n      update(y);\n    }\n  }\n\n\n  void splay(Node *t) {\n    push(t);\n    while(!t->is_root()) {\n      auto *q = t->p;\n      if(q->is_root()) {\n        push(q), push(t);\n        if(q->l == t) rotr(t);\n        else rotl(t);\n      } else {\n        auto *r = q->p;\n        push(r), push(q), push(t);\n        if(r->l == q) {\n          if(q->l == t) rotr(q), rotr(t);\n          else rotl(t), rotr(t);\n        } else {\n          if(q->r == t) rotl(q), rotl(t);\n          else rotr(t), rotl(t);\n        }\n      }\n    }\n  }\n\n\n  Node *expose(Node *t) {\n    Node *rp = nullptr;\n    for(auto *cur = t; cur; cur = cur->p) {\n      splay(cur);\n      if(cur->r) cur->sum.add(cur->r->sum);\n      cur->r = rp;\n      if(cur->r) cur->sum.erase(cur->r->sum);\n      update(cur);\n      rp = cur;\n    }\n    splay(t);\n    return rp;\n  }\n\n  void link(Node *child, Node *parent) {\n    expose(child);\n    expose(parent);\n    child->p = parent;\n    parent->r = child;\n  }\n\n  void cut(Node *child) {\n    expose(child);\n    auto *parent = child->l;\n    child->l = nullptr;\n    parent->p = nullptr;\n    update(child);\n  }\n\n  void evert(Node *t) {\n    expose(t);\n    toggle(t);\n    push(t);\n  }\n\n  Node *lca(Node *u, Node *v) {\n    if(get_root(u) != get_root(v)) return nullptr;\n    expose(u);\n    return expose(v);\n  }\n\n\n  Node *get_kth(Node *x, int k) {\n    expose(x);\n    while(x) {\n      push(x);\n      if(x->r && x->r->sz > k) {\n        x = x->r;\n      } else {\n        if(x->r) k -= x->r->sz;\n        if(k == 0) return x;\n        k -= 1;\n        x = x->l;\n      }\n    }\n    return nullptr;\n  }\n\n  Node *get_root(Node *x) {\n    expose(x);\n    while(x->l) {\n      push(x);\n      x = x->l;\n    }\n    return x;\n  }\n};\n\nstruct PQ {\n  priority_queue< int64 > in, out;\n\n  inline int64 top() {\n    if(!in.empty()) return in.top();\n    return -infll;\n  }\n\n  inline void insert(int64 k) {\n    in.emplace(k);\n  }\n\n  inline void erase(int64 k) {\n    out.emplace(k);\n    while(out.size() && in.top() == out.top()) {\n      in.pop();\n      out.pop();\n    }\n  }\n\n  inline int64 top2() {\n    if(in.empty()) return -infll;\n    int64 top = in.top();\n    erase(top);\n    int64 top2 = this->top();\n    in.push(top);\n    return top2;\n  }\n};\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n  int idx;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\nint main() {\n\n  using Key = int64;\n\n  struct Sum {\n    int64 all;\n    int64 p_len, c_len;\n    int64 diameter;\n\n    PQ md1, md2;\n\n    Sum() : all(0), p_len(-infll), c_len(-infll), diameter(-infll) {}\n\n\n    void toggle() {\n      swap(p_len, c_len);\n    }\n\n    void merge(Key key, const Sum &parent, const Sum &child) {\n      bool sw = false;\n      if(key == infll) {\n        sw = true;\n        key = 0;\n      }\n\n      all = parent.all + key + child.all;\n      int64 top = md1.top();\n      p_len = max(child.p_len, max(top, parent.p_len) + key + child.all);\n      c_len = max(parent.c_len, max(top, child.c_len) + key + parent.all);\n      diameter = max({parent.diameter, child.diameter, top + key + md1.top2(), md2.top()});\n      diameter = max({diameter, parent.p_len + key + max(child.c_len, top), child.c_len + key + top});\n      if(sw) {\n        p_len = max(p_len, key + child.all);\n        c_len = max(c_len, key + parent.all);\n        diameter = max(diameter, max({parent.p_len, child.c_len, top, 0LL}) + key);\n      }\n\n      if(p_len < -infll2) p_len = -infll;\n      if(c_len < -infll2) c_len = -infll;\n      if(diameter < -infll2) diameter = -infll;\n    }\n\n    void add(const Sum &ch) {\n      md1.insert(ch.c_len);\n      md2.insert(ch.diameter);\n    }\n\n    void erase(const Sum &ch) {\n      md1.erase(ch.c_len);\n      md2.erase(ch.diameter);\n    }\n  } e;\n\n  int64 N, Q, W;\n  cin >> N >> Q >> W;\n  using LCT = LinkCutTreeSubtree< Sum, int64 >;\n  LCT lct(e);\n  vector< LCT::Node * > vv(N), ee(N);\n  for(int i = 0; i < N; i++) {\n    vv[i] = lct.make_node(infll);\n  }\n  WeightedGraph< int64 > g(N);\n  for(int i = 1; i < N; i++) {\n    int64 a, b, c;\n    cin >> a >> b >> c;\n    --a, --b;\n    g[a].emplace_back(b, c);\n    g[b].emplace_back(a, c);\n    g[a].back().idx = i - 1;\n    g[b].back().idx = i - 1;\n  }\n\n  vector< LCT::Node * > ptr(N);\n  auto rec = MFP([&](auto rec, int idx, int par) -> void {\n    for(auto &to : g[idx]) {\n      if(to != par) {\n        ee[to] = lct.make_node(to.cost);\n        ptr[to.idx] = ee[to];\n        lct.link(vv[to], ee[to]);\n        lct.link(ee[to], vv[idx]);\n        rec(to, idx);\n      }\n    }\n  });\n  rec(0, -1);\n  int64 last = 0;\n\n  while(Q--) {\n    int64 D, E;\n    cin >> D >> E;\n    D = (D + last) % (N - 1);\n    E = (E + last) % W;\n    lct.set_key(ptr[D], E);\n    auto ret = ptr[D]->sum.diameter;\n    last = ret;\n    cout << ret << endl;\n  }\n}\n\n",
    "ext": "cpp"
  },
  "57918771": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100010;\ntypedef long long ll;\nint head[maxn], ver[maxn * 2], Next[maxn * 2], tot = 1, n;\nll edge[maxn * 2], w;\nmultiset<ll, greater<ll> > ss;\nvoid add(int x, int y, ll z) {\n\tver[++tot] = y, edge[tot] = z, Next[tot] = head[x], head[x] = tot;\n}\nnamespace Dis{\n\tint sz[maxn], fa[maxn], son[maxn], top[maxn], dep[maxn];\n\tvoid dfs1(int x, int pa) {\n\t\tfa[x] = pa; sz[x] = 1; dep[x] = dep[pa] + 1;\n\t\tfor(int i = head[x]; i; i = Next[i]) if(ver[i] != pa) {\n\t\t\tdfs1(ver[i], x); sz[x] += sz[ver[i]];\n\t\t\tif(sz[ver[i]] > sz[son[x]]) son[x] = ver[i];\n\t\t}\n\t}\n\tvoid dfs2(int x, int tp) {\n\t\ttop[x] = tp;\n\t\tif(son[x]) dfs2(son[x], tp);\n\t\tfor(int i = head[x]; i; i = Next[i]) if(ver[i] != fa[x] && ver[i] != son[x])\n\t\t\tdfs2(ver[i], ver[i]);\n\t}\n\tint LCA(int x, int y) {\n\t\tfor(; top[x] != top[y]; dep[top[x]] > dep[top[y]] ? x = fa[top[x]] : y = fa[top[y]]);\n\t\treturn dep[x] > dep[y] ? y : x;\n\t}\n\tll getDis(int x, int y) { return dep[x] + dep[y] - 2 * dep[LCA(x, y)]; }\n}\nnamespace Seg{\n\tint rt[maxn], cnt, lc[maxn * 80], rc[maxn * 80];\n\tll mx[maxn * 80], tag[maxn * 80];\n\tvoid pushdown(int p) {\n\t\tif(!tag[p]) return;\n\t\tif(!lc[p]) lc[p] = ++cnt; \n\t\tmx[lc[p]] += tag[p]; tag[lc[p]] += tag[p];\n\t\tif(!rc[p]) rc[p] = ++cnt; \n\t\tmx[rc[p]] += tag[p]; tag[rc[p]] += tag[p];\n\t\ttag[p] = 0;\n\t}\n\tvoid update(int &p, int l, int r, int L, int R, ll x) {\n\t\tif(!p) p = ++cnt;\n\t\tif(L <= l && r <= R) { mx[p] += x; tag[p] += x; return; }\n\t\tpushdown(p);\n\t\tint mid = (l + r) >> 1;\n\t\tif(L <= mid) update(lc[p], l, mid, L, R, x);\n\t\tif(R > mid) update(rc[p], mid + 1, r, L, R, x);\n\t\tmx[p] = max(mx[lc[p]], mx[rc[p]]);\n\t}\n\tll query(int p, int l, int r, int L, int R) {\n\t\tif(!p) return 0;\n\t\tif(L <= l && r <= R) return mx[p];\n\t\tpushdown(p);\n\t\tint mid = (l + r) >> 1; ll res = 0;\n\t\tif(L <= mid) res = max(res, query(lc[p], l, mid, L, R));\n\t\tif(R > mid) res = max(res, query(rc[p], mid + 1, r, L, R));\n\t\treturn res;\n\t}\n}\nnamespace V{\n\tint sz[maxn], v[maxn], fa[maxn], dep[maxn], mn, rt, totsz;\n\tint fir[maxn][20], sec[maxn][20], tim, bel[maxn][20];\n\tll dis[maxn];\n\tmultiset<ll, greater<ll> > s[maxn];\n\tvoid getRoot(int x, int pa) {\n\t\tsz[x] = 1; int res = 0;\n\t\tfor(int i = head[x]; i; i = Next[i]) if(ver[i] != pa && !v[ver[i]]) \n\t\t\tgetRoot(ver[i], x), sz[x] += sz[ver[i]], res = max(res, sz[ver[i]]);\n\t\tres = max(res, totsz - sz[x]);\n\t\tif(res < mn) mn = res, rt = x;\n\t}\n\tvoid dfs(int x, int pa, int anc, int ts) {\n\t\tif(!ts && x != anc) ts = x;\n\t\tsz[x] = 1; fir[x][dep[anc]] = ++tim; bel[x][dep[anc]] = ts;\n\t\tSeg::update(Seg::rt[anc], 1, totsz, tim, tim, dis[x]);\n\t\tfor(int i = head[x]; i; i = Next[i]) if(ver[i] != pa && !v[ver[i]])\n\t\t\tdis[ver[i]] = dis[x] + edge[i], dfs(ver[i], x, anc, ts), sz[x] += sz[ver[i]]; \n\t\tsec[x][dep[anc]] = tim;\n\t}\n\tvoid DFS(int x, int pa) {\n\t\tfa[x] = pa; dep[x] = dep[pa] + 1; v[x] = 1;\n\t\ttim = 0; dis[x] = 0;\n\t\tdfs(x, 0, x, 0);\n\t\tfor(int i = head[x]; i; i = Next[i]) if(!v[ver[i]]) \n\t\t\ts[x].insert(Seg::query(Seg::rt[x], 1, sz[x], fir[ver[i]][dep[x]], sec[ver[i]][dep[x]]));\n\t\tif(s[x].size() >= 2) ss.insert(*s[x].begin() + *(++s[x].begin()));\n\t\telse if(s[x].size()) ss.insert(*s[x].begin());\n\t\tfor(int i = head[x]; i; i = Next[i]) if(!v[ver[i]]) {\n\t\t\tmn = totsz = sz[ver[i]];\n\t\t\tgetRoot(ver[i], x);\n\t\t\tDFS(rt, x);\n\t\t}\n\t}\n\tvoid modify(int x, int y, ll ne, ll oe) {\n\t\tif(dep[x] < dep[y]) swap(x, y);\n\t\tint tx = x, ty = y; while(fa[tx] != ty) tx = fa[tx];\n\t\tfor(; ty; tx = ty, ty = fa[ty]) {\n\t\t\tset<ll>::iterator it;\n\t\t\tif(s[ty].size() > 1) it = ss.find(*s[ty].begin() + *(++s[ty].begin()));\n\t\t\telse it = ss.find(*s[ty].begin());\n\t\t\tss.erase(it);\n\t\t\tit = s[ty].find(Seg::query(Seg::rt[ty], 1, sz[ty], fir[bel[x][dep[ty]]][dep[ty]], sec[bel[x][dep[ty]]][dep[ty]]));\n\t\t\ts[ty].erase(it);\n\t\t\tint dx = Dis::getDis(x, ty), dy = Dis::getDis(y, ty);\n\t\t\tif(dx < dy) swap(x, y), swap(dx, dy);\n\t\t\tSeg::update(Seg::rt[ty], 1, sz[ty], fir[x][dep[ty]], sec[x][dep[ty]], ne - oe);\n\t\t\ts[ty].insert(Seg::query(Seg::rt[ty], 1, sz[ty], fir[bel[x][dep[ty]]][dep[ty]], sec[bel[x][dep[ty]]][dep[ty]]));\n\t\t\tif(s[ty].size() > 1) ss.insert(*s[ty].begin() + *(++s[ty].begin()));\n\t\t\telse ss.insert(*s[ty].begin());\n\t\t}\n\t}\n}\nint main() {\n\tint Q, x, y; ll z, ans = 0;\n\tscanf(\"%d%d%lld\", &n, &Q, &w);\n\tfor(int i = 1; i < n; i++) scanf(\"%d%d%lld\", &x, &y, &z), add(x, y, z), add(y, x, z);\n\tDis::dfs1(1, 0); Dis::dfs2(1, 1);\n\tV::mn = V::totsz = n; \n\tV::getRoot(1, 0); V::DFS(V::rt, 0);\n\twhile(Q--) {\n\t\tint d; ll e; scanf(\"%d%lld\", &d, &e);\n\t\td = (d + ans) % (n - 1) + 1; e = (e + ans) % w;\n\t\tV::modify(ver[d * 2], ver[d * 2 + 1], e, edge[d * 2]);\n\t\tedge[d * 2] = edge[d * 2 + 1] = e;\n\t\tans = *ss.begin();\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57918693": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100010;\ntypedef long long ll;\nbool b1;\nint head[maxn], ver[maxn * 2], Next[maxn * 2], tot = 1, n;\nll edge[maxn * 2], w;\nmultiset<ll, greater<ll> > ss;\nvoid add(int x, int y, ll z) {\n\tver[++tot] = y, edge[tot] = z, Next[tot] = head[x], head[x] = tot;\n}\nnamespace Dis{\n\tint sz[maxn], fa[maxn], son[maxn], top[maxn], dep[maxn];\n\tvoid dfs1(int x, int pa) {\n\t\tfa[x] = pa; sz[x] = 1; dep[x] = dep[pa] + 1;\n\t\tfor(int i = head[x]; i; i = Next[i]) if(ver[i] != pa) {\n\t\t\tdfs1(ver[i], x); sz[x] += sz[ver[i]];\n\t\t\tif(sz[ver[i]] > sz[son[x]]) son[x] = ver[i];\n\t\t}\n\t}\n\tvoid dfs2(int x, int tp) {\n\t\ttop[x] = tp;\n\t\tif(son[x]) dfs2(son[x], tp);\n\t\tfor(int i = head[x]; i; i = Next[i]) if(ver[i] != fa[x] && ver[i] != son[x])\n\t\t\tdfs2(ver[i], ver[i]);\n\t}\n\tint LCA(int x, int y) {\n\t\tfor(; top[x] != top[y]; dep[top[x]] > dep[top[y]] ? x = fa[top[x]] : y = fa[top[y]]);\n\t\treturn dep[x] > dep[y] ? y : x;\n\t}\n\tll getDis(int x, int y) { return dep[x] + dep[y] - 2 * dep[LCA(x, y)]; }\n}\nnamespace Seg{\n\tint rt[maxn], cnt, lc[maxn * 80], rc[maxn * 80];\n\tll mx[maxn * 80], tag[maxn * 80];\n\tvoid pushdown(int p) {\n\t\tif(!tag[p]) return;\n\t\tif(!lc[p]) lc[p] = ++cnt; \n\t\tmx[lc[p]] += tag[p]; tag[lc[p]] += tag[p];\n\t\tif(!rc[p]) rc[p] = ++cnt; \n\t\tmx[rc[p]] += tag[p]; tag[rc[p]] += tag[p];\n\t\ttag[p] = 0;\n\t}\n\tvoid update(int &p, int l, int r, int L, int R, ll x) {\n\t\tif(!p) p = ++cnt;\n//\t\tcout << p << ' ' << l << ' ' << r << ' ' << x << endl;\n\t\tif(L <= l && r <= R) { mx[p] += x; tag[p] += x; return; }\n\t\tpushdown(p);\n\t\tint mid = (l + r) >> 1;\n\t\tif(L <= mid) update(lc[p], l, mid, L, R, x);\n\t\tif(R > mid) update(rc[p], mid + 1, r, L, R, x);\n\t\tmx[p] = max(mx[lc[p]], mx[rc[p]]);\n\t}\n\tll query(int p, int l, int r, int L, int R) {\n\t\tif(!p) return 0;\n//\t\tcout << p << ' ' << l << ' ' << r << ' ' << mx[p] << endl;\n\t\tif(L <= l && r <= R) return mx[p];\n\t\tpushdown(p);\n\t\tint mid = (l + r) >> 1; ll res = 0;\n\t\tif(L <= mid) res = max(res, query(lc[p], l, mid, L, R));\n\t\tif(R > mid) res = max(res, query(rc[p], mid + 1, r, L, R));\n\t\treturn res;\n\t}\n}\nnamespace V{\n\tint sz[maxn], v[maxn], fa[maxn], dep[maxn], mn, rt, totsz;\n\tint fir[maxn][20], sec[maxn][20], tim, bel[maxn][20];\n\tll dis[maxn];\n\tmultiset<ll, greater<ll> > s[maxn];\n\tvoid getRoot(int x, int pa) {\n\t\tsz[x] = 1; int res = 0;\n\t\tfor(int i = head[x]; i; i = Next[i]) if(ver[i] != pa && !v[ver[i]]) \n\t\t\tgetRoot(ver[i], x), sz[x] += sz[ver[i]], res = max(res, sz[ver[i]]);\n\t\tres = max(res, totsz - sz[x]);\n\t\tif(res < mn) mn = res, rt = x;\n\t}\n\tvoid dfs(int x, int pa, int anc, int ts) {\n\t\tif(!ts && x != anc) ts = x;\n\t\tsz[x] = 1; fir[x][dep[anc]] = ++tim; bel[x][dep[anc]] = ts;\n//\t\tcout << x << ' ' << anc << ' ' << dis[x] << endl;\n\t\tSeg::update(Seg::rt[anc], 1, totsz, tim, tim, dis[x]);\n\t\tfor(int i = head[x]; i; i = Next[i]) if(ver[i] != pa && !v[ver[i]])\n\t\t\tdis[ver[i]] = dis[x] + edge[i], dfs(ver[i], x, anc, ts), sz[x] += sz[ver[i]]; \n\t\tsec[x][dep[anc]] = tim;\n\t}\n\tvoid DFS(int x, int pa) {\n//\t\tcout << x << ' ' << totsz << endl;\n\t\tfa[x] = pa; dep[x] = dep[pa] + 1; v[x] = 1;\n\t\ttim = 0; dis[x] = 0;\n\t\tdfs(x, 0, x, 0);\n\t\tfor(int i = head[x]; i; i = Next[i]) if(!v[ver[i]]) \n\t\t\ts[x].insert(Seg::query(Seg::rt[x], 1, sz[x], fir[ver[i]][dep[x]], sec[ver[i]][dep[x]]));\n//\t\tfor(set<ll>::iterator it = s[x].begin(); it != s[x].end(); ++it) cout << *it << ' '; cout << endl;\n\t\tif(s[x].size() >= 2) ss.insert(*s[x].begin() + *(++s[x].begin()));\n\t\telse if(s[x].size()) ss.insert(*s[x].begin());\n\t\tfor(int i = head[x]; i; i = Next[i]) if(!v[ver[i]]) {\n\t\t\tmn = totsz = sz[ver[i]];\n\t\t\tgetRoot(ver[i], x);\n\t\t\tDFS(rt, x);\n\t\t}\n\t}\n\tvoid modify(int x, int y, ll ne, ll oe) {\n//\t\tcout << x << ' ' << y << ' ' << ne << ' ' << oe << endl;\n\t\tif(dep[x] < dep[y]) swap(x, y);\n\t\tint tx = x, ty = y; while(fa[tx] != ty) tx = fa[tx];\n\t\tfor(; ty; tx = ty, ty = fa[ty]) {\n//\t\t\tcout << tx << ' ' << ty << endl;\n\t\t\tset<ll>::iterator it;\n\t\t\tif(s[ty].size() > 1) it = ss.find(*s[ty].begin() + *(++s[ty].begin()));\n\t\t\telse it = ss.find(*s[ty].begin());\n\t\t\tss.erase(it);\n\t\t\tit = s[ty].find(Seg::query(Seg::rt[ty], 1, sz[ty], fir[bel[x][dep[ty]]][dep[ty]], sec[bel[x][dep[ty]]][dep[ty]]));\n\t\t\ts[ty].erase(it);\n\t\t\tint dx = Dis::getDis(x, ty), dy = Dis::getDis(y, ty);\n\t\t\tif(dx < dy) swap(x, y), swap(dx, dy);\n//\t\t\tif(ty == 10) cout << Seg::query(Seg::rt[ty], 1, sz[ty], fir[1][dep[ty]], sec[1][dep[ty]]) << endl;\n\t\t\tSeg::update(Seg::rt[ty], 1, sz[ty], fir[x][dep[ty]], sec[x][dep[ty]], ne - oe);\n\t\t\ts[ty].insert(Seg::query(Seg::rt[ty], 1, sz[ty], fir[bel[x][dep[ty]]][dep[ty]], sec[bel[x][dep[ty]]][dep[ty]]));\n\t\t\tif(s[ty].size() > 1) ss.insert(*s[ty].begin() + *(++s[ty].begin()));\n\t\t\telse ss.insert(*s[ty].begin());\n//\t\t\tfor(set<ll>::iterator it = s[ty].begin(); it != s[ty].end(); ++it) cout << *it << ' '; cout << endl;\n//\t\t\tif(ty == 10) cout << Seg::query(Seg::rt[ty], 1, sz[ty], fir[1][dep[ty]], sec[1][dep[ty]]) << endl;\n\t\t}\n\t}\n}\nbool b2;\nint main() {\n//\tprintf(\"%lf\\n\", (double)(&b2-&b1)/1024/1024);\n\tint Q, x, y; ll z, ans = 0;\n\tscanf(\"%d%d%lld\", &n, &Q, &w);\n\tfor(int i = 1; i < n; i++) scanf(\"%d%d%lld\", &x, &y, &z), add(x, y, z), add(y, x, z);\n\tDis::dfs1(1, 0); Dis::dfs2(1, 1);\n\tV::mn = V::totsz = n; \n\tV::getRoot(1, 0); V::DFS(V::rt, 0);\n//\tfor(set<ll>::iterator it = ss.begin(); it != ss.end(); ++it) cout << *it << ' '; cout << endl;\n\twhile(Q--) {\n\t\tint d; ll e; scanf(\"%d%lld\", &d, &e);\n\t\td = (d + ans) % (n - 1) + 1; e = (e + ans) % w;\n\t\tV::modify(ver[d * 2], ver[d * 2 + 1], e, edge[d * 2]);\n\t\tedge[d * 2] = edge[d * 2 + 1] = e;\n\t\tans = *ss.begin();\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57913904": {
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pii pair<int,int> \n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\nconst int N=100005;\nint n,Q,nn,ps[N],L[N],R[N];ll k,ans,w[N];\nvector<pii>g[N];\nstruct st\n{\n\tll p,m,tg,lm,mr,lmr;\n\tinline void upd(ll v){p+=v;m-=2*v;lm-=v;mr-=v;tg+=v;}\n\tinline st operator+(const st&b)const\n\t{\n\t\tst c;c.p=max(p,b.p);c.m=max(m,b.m);\n\t\tc.lm=max(max(lm,b.lm),p+b.m);\n\t\tc.mr=max(max(mr,b.mr),m+b.p);\n\t\tc.lmr=max(max(lmr,b.lmr),max(lm+b.p,p+b.mr));\n\t\treturn c;\n\t}\n}T[N<<3];\nvoid upd(int x,int l,int r,int tl,int tr,ll v)\n{\n\tif(r<tl||tr<l)return;if(tl<=l&&r<=tr){T[x].upd(v);return;}\n\tT[x<<1].upd(T[x].tg);T[x<<1|1].upd(T[x].tg);T[x].tg=0;\n\tint mid=l+r>>1;upd(x<<1,l,mid,tl,tr,v);upd(x<<1|1,mid+1,r,tl,tr,v);\n\tT[x]=T[x<<1]+T[x<<1|1];\n}\nvoid dfs(int x,int p)\n{\n\tL[x]=++nn;\n\tfor(int i=0;i<g[x].size();i++)if(g[x][i].X!=p){ps[g[x][i].Y]=g[x][i].X;dfs(g[x][i].X,x);nn++;}\n\tR[x]=nn;\n} \nint main()\n{\n\tscanf(\"%d%d%lld\",&n,&Q,&k);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v;scanf(\"%d%d%lld\",&u,&v,&w[i]);\n\t\tg[u].pb(mp(v,i));g[v].pb(mp(u,i));\n\t}\n\tdfs(1,0);\n\tfor(int i=1;i<n;i++)upd(1,1,2*n,L[ps[i]],R[ps[i]],w[i]);\n\twhile(Q--)\n\t{\n\t\tll x,v;scanf(\"%lld%lld\",&x,&v);\n\t\tx=(x+ans)%(n-1)+1;v=(v+ans)%k;\n\t\tupd(1,1,2*n,L[ps[x]],R[ps[x]],v-w[x]);\n\t\tw[x]=v;printf(\"%lld\\n\",ans=T[1].lmr);\n\t}\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57913556": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\nstruct lazysegtree {\n\tvector<ll> a, b;\n\tint maxn;\n\n\tlazysegtree(int n = 1) {\n\t\tmaxn = 1;\n\t\twhile (maxn < n)\n\t\t\tmaxn <<= 1;\n\t\ta.resize(2*maxn);\n\t\tb.resize(2*maxn);\n\t}\n\n\tvoid push(int x) {\n\t\tif (!b[x])\n\t\t\treturn;\n\t\tif (x < maxn) {\n\t\t\tb[2*x] += b[x];\n\t\t\tb[2*x+1] += b[x];\n\t\t}\n\t\ta[x] += b[x];\n\t\tb[x] = 0;\n\t}\n\n\tvoid update(int l, int r, ll v, int x, int xl, int xr) {\n\t\tif (r < xl || xr < l) {\n\t\t\tpush(x);\n\t\t\treturn;\n\t\t}\n\t\tif (l <= xl && xr <= r) {\n\t\t\tb[x] += v;\n\t\t\tpush(x);\n\t\t\treturn;\n\t\t}\n\t\tint xm = (xl+xr) >> 1;\n\t\tpush(x);\n\t\tupdate(l, r, v, 2*x, xl, xm);\n\t\tupdate(l, r, v, 2*x+1, xm+1, xr);\n\t\ta[x] = max(a[2*x], a[2*x+1]);\n\t}\n\n\tvoid update(int l, int r, ll v) {\n\t\tupdate(l, r, v, 1, 0, maxn-1);\n\t}\n\n\tll query() {\n\t\tpush(1);\n\t\treturn a[1];\n\t}\n};\n\nint n, q;\nll wmod;\nint u[100005], v[100005];\nll w[100005];\nbasic_string<int> e[100005];\nbool blocked[100005];\n\ninline int adj(int i, int x) {\n\treturn u[i] ^ v[i] ^ x;\n}\n\nint dfs1(int x, int p) {\n\tint sz = 1;\n\tfor (int i : e[x]) {\n\t\tint y = adj(i, x);\n\t\tif (y == p || blocked[y])\n\t\t\tcontinue;\n\t\tsz += dfs1(y, x);\n\t}\n\treturn sz;\n}\n\nint dfs2(int x, int p, int tree_sz, int& centroid) {\n\tint my_sz = 1;\n\tbool ok = true;\n\tfor (int i : e[x]) {\n\t\tint y = adj(i, x);\n\t\tif (y == p || blocked[y])\n\t\t\tcontinue;\n\t\tint t = dfs2(y, x, tree_sz, centroid);\n\t\tmy_sz += t;\n\t\tif (2*t > tree_sz)\n\t\t\tok = false;\n\t}\n\tint gore = tree_sz - my_sz;\n\tif (2*gore > tree_sz)\n\t\tok = false;\n\tif (ok)\n\t\tcentroid = x;\n\treturn my_sz;\n}\n\nint el[20][100005], er[20][100005], echid[20][100005];\nint edub[20][100005], eroot[20][100005];\n\nvoid dfs3(int x, int p, int& t, int child_id, int lvl, int dub, int root) {\n\tel[lvl][x] = t++;\n\techid[lvl][x] = child_id;\n\tedub[lvl][x] = dub;\n\teroot[lvl][x] = root;\n\tfor (int i : e[x]) {\n\t\tint y = adj(i, x);\n\t\tif (y == p || blocked[y])\n\t\t\tcontinue;\n\t\tdfs3(y, x, t, child_id, lvl, dub+1, root);\n\t}\n\ter[lvl][x] = t;\n}\n\nvector<lazysegtree> drva[100005];\nmultiset<ll> veze[100005], master;\n\nvoid subtree(int x, int lvl) {\n\teroot[lvl][x] = x;\n\tint ch = 0;\n\tfor (int i : e[x]) {\n\t\tint y = adj(i, x);\n\t\tif (blocked[y])\n\t\t\tcontinue;\n\t\tint t = 0;\n\t\tdfs3(y, x, t, ch, lvl, 1, x);\n\t\t// cerr << \"ST \" << x << ' ' << lvl << \" smer \" << y << \" sz \" << t << '\\n';\n\t\tdrva[x].emplace_back(t);\n\t\tveze[x].insert(0);\n\t\tch++;\n\t}\n\tmaster.insert(0);\n}\n\nvoid centroid(int x, int lvl) {\n\tint sz = dfs1(x, x);\n\tint cvor = x;\n\tdfs2(x, x, sz, cvor);\n\tblocked[cvor] = 1;\n\tsubtree(cvor, lvl);\n\tfor (int i : e[cvor]) {\n\t\tint y = adj(i, cvor);\n\t\tif (blocked[y])\n\t\t\tcontinue;\n\t\tcentroid(y, lvl+1);\n\t}\n}\n\nll dva(multiset<ll>& a) {\n\tif (a.size() >= 2)\n\t\treturn *--a.end() + *-- -- a.end();\n\telse if (a.size() == 1)\n\t\treturn *--a.end();\n\treturn 0;\n}\n\nvoid delta(int i, ll delta_w) {\n\tfor (int lvl=0; lvl<20; lvl++) {\n\t\tint x = u[i], y = v[i];\n\n\t\t// cerr << x << ' ' << y << ' ' << eroot[lvl][x] << ' ' << eroot[lvl][y];\n\t\t// cerr << ' ' << delta_w << '\\n';\n\n\t\tif (eroot[lvl][x] != eroot[lvl][y])\n\t\t\treturn; // mozda continue?\n\n\t\tint dx = edub[lvl][x];\n\t\tint dy = edub[lvl][y];\n\n\t\tif (dx < dy) {\n\t\t\tswap(x, y);\n\t\t\tswap(dx, dy);\n\t\t}\n\n\t\t// dx i dy ne vaze vise, x treba upd\n\t\tint chid = echid[lvl][x], root = eroot[lvl][x];\n\t\tll old = drva[root][chid].query();\n\n\t\t// cerr << \"suck it \" << root << ' ' << chid << ' ' << el[lvl][x] <<\n\t\t\t// ' ' << er[lvl][x]-1 << ' ' << delta_w << ' ' << x <<\n\t\t\t// ' ' << y << ' ' << dx << ' ' << dy << '\\n';\n\n\t\tdrva[root][chid].update(el[lvl][x], er[lvl][x]-1, delta_w);\n\t\tll nu = drva[root][chid].query();\n\n\t\t// cerr << \"cu brisnem \" << (dva(veze[root])) << '\\n';\n\t\t// cerr << \"veze promena \" << old << \" --> \" << nu << '\\n';\n\n\t\tmaster.erase(master.find(dva(veze[root])));\n\t\tveze[root].erase(veze[root].find(old));\n\t\tveze[root].insert(nu);\n\t\tmaster.insert(dva(veze[root]));\n\n\t\t// cerr << \"cu dodam \" << (dva(veze[root])) << '\\n';\n\t}\n}\n\nvoid update(int i, ll nw) {\n\tdelta(i, nw - w[i]);\n\tw[i] = nw;\n}\n\nvoid preprocess() {\n\tcentroid(1, 0);\n\tfor (int i=0; i<n-1; i++)\n\t\tdelta(i, w[i]);\n}\n\nll diameter() {\n\treturn *master.rbegin();\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcerr.tie(nullptr);\n\n\tcin >> n >> q >> wmod;\n\tfor (int i=0; i<n-1; i++) {\n\t\tcin >> u[i] >> v[i] >> w[i];\n\t\te[u[i]] += i;\n\t\te[v[i]] += i;\n\t}\n\n\tcerr << u[0] << ' ' << v[0] << ' ' << w[0] << '\\n';\n\n\tpreprocess();\n\n\tcerr << u[0] << ' ' << v[0] << ' ' << w[0] << '\\n';\n\n\tll last = 0;\n\twhile (q--) {\n\t\tint grana; ll tez;\n\t\tcin >> grana >> tez;\n\t\tgrana = (grana + last) % (n-1);\n\t\ttez = (tez + last) % wmod;\n\t\tupdate(grana, tez);\n\t\tcout << (last = diameter()) << '\\n';\n\t}\n}",
    "ext": "cpp"
  },
  "57912533": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100100;\n\nstruct Edge\n{\n  int x, y;\n  long long c;\n};\n\nstruct SegmentTree\n{\n  int low, mid, high;\n  long long v, save;\n  SegmentTree *l, *r;\n\n  SegmentTree(int low, int high, long long initialDist[]): low(low), high(high)\n  {\n    mid = (low + high) / 2;\n    save = 0;\n    if (low == high) v = initialDist[low];\n    else\n    {\n      l = new SegmentTree(low, mid, initialDist);\n      r = new SegmentTree(mid + 1, high, initialDist);\n      v = max(l->v, r->v);\n    }\n  }\n\n  void pushDown()\n  {\n    l->v += save;\n    l->save += save;\n    r->v += save;\n    r->save += save;\n    save = 0;\n  }\n\n  void update(int x, int y, long long dif)\n  {\n    if (low == x && high == y)\n    {\n      v += dif;\n      save += dif;\n    }\n    else\n    {\n      pushDown();\n      if (x <= mid)\n        l->update(x, min(y, mid), dif);\n      if (mid < y)\n        r->update(max(x, mid + 1), y, dif);\n      v = max(l->v, r->v);\n    }\n  }\n\n  long long get(int x, int y)\n  {\n    if (low == x && high == y)\n      return v;\n    pushDown();\n    long long u = 0, v = 0;\n    if (x <= mid)\n      u = l->get(x, min(y, mid));\n    if (mid < y)\n      v = r->get(max(x, mid + 1), y);\n    return max(u, v);\n  }\n};\n\nstruct CentroidData\n{\n  SegmentTree *segTree;\n  multiset<long long> candidates;\n  vector<pair<int, int>> segments;\n\n  long long getAns()\n  {\n    if (candidates.empty())\n      return 0;\n    auto u = candidates.rbegin();\n    return candidates.size() == 1 ? *u : *u + *(++u);\n  }\n};\n\nstruct CentroidNode\n{\n  int root, preDfs, postDfs, branchId;\n};\n\nint n, dfsTime;\nEdge edges[N];\nvector<pair<int, int>> adj[N];\nlong long initialDist[N];\nmultiset<long long> ans;\n// centroid variables\nint done[N], treeSize[N];\nvector<int> activeNodes;\nCentroidData centroidData[N];\nvector<CentroidNode> centroidNodes[N];\n\nvoid dfsPre(int x, int par, long long dist, int root, int branchId)\n{\n  int preDfs = ++dfsTime;\n  initialDist[preDfs] = dist;\n  for (auto u : adj[x])\n  {\n    int y = u.first;\n    if (y != par && !done[y])\n      dfsPre(y, x, dist + edges[u.second].c, root, branchId);\n  }\n  centroidNodes[x].push_back({root, preDfs, dfsTime, branchId});\n}\n\nvoid initCentroid(int root)\n{\n  int branchId = 0;\n  dfsTime = 0;\n  for (auto u : adj[root])\n  {\n    int x = u.first;\n    if (!done[x])\n    {\n      dfsPre(x, root, edges[u.second].c, root, branchId);\n      CentroidNode node = centroidNodes[x].back();\n      centroidData[root].segments.push_back({node.preDfs, node.postDfs});\n      branchId++;\n    }\n  }\n\n  centroidNodes[root].push_back({root, 0, dfsTime, -1});\n  centroidData[root].segTree = dfsTime > 0 ? new SegmentTree(1, dfsTime, initialDist) : NULL;\n  for (auto u : centroidData[root].segments)\n    centroidData[root].candidates.insert(centroidData[root].segTree->get(u.first, u.second));\n  ans.insert(centroidData[root].getAns());\n}\n\nvoid dfs(int x, int par)\n{\n  activeNodes.push_back(x);\n  treeSize[x] = 1;\n  for (auto u : adj[x])\n  {\n    int y = u.first;\n    if (!done[y] && y != par)\n    {\n      dfs(y, x);\n      treeSize[x] += treeSize[y];\n    }\n  }\n}\n\nvoid decompose(int x)\n{\n  activeNodes.clear();\n  dfs(x, 0);\n  int centroid = x;\n  for (int y : activeNodes)\n    if (treeSize[y] * 2 >= treeSize[x] && treeSize[y] < treeSize[centroid])\n      centroid = y;\n\n  initCentroid(centroid);\n  done[centroid] = 1;\n\n  for (auto u : adj[centroid])\n    if (!done[u.first])\n      decompose(u.first);\n}\n\nint main()\n{\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n\n  long long w, e;\n  int q, x, y, d;\n  long long c;\n  cin >> n >> q >> w;\n  for (int i = 0; i < n - 1; i++)\n  {\n    cin >> x >> y >> c;\n    adj[x].push_back({y, i});\n    adj[y].push_back({x, i});\n    edges[i] = {x, y, c};\n  }\n\n  decompose(1);\n\n  long long curAns = 0;\n  while (q--)\n  {\n    cin >> d >> e;\n    int i = (d + curAns) % (n - 1), x = edges[i].x, y = edges[i].y;\n    long long newC = (e + curAns) % w, diff = newC - edges[i].c;\n    edges[i].c = newC;\n    for (int j = 0; j < centroidNodes[x].size() && j < centroidNodes[y].size(); j++)\n    {\n      auto nodeX = centroidNodes[x][j], nodeY = centroidNodes[y][j];\n      if (nodeX.root != nodeY.root)\n        break;\n\n      int root = centroidNodes[x][j].root;\n      if (nodeX.preDfs > nodeY.preDfs)\n        swap(nodeX, nodeY);\n\n      ans.erase(ans.find(centroidData[root].getAns()));\n      auto segment = centroidData[root].segments[nodeY.branchId];\n      auto &segTree = centroidData[root].segTree;\n      auto &candidates = centroidData[root].candidates;\n      long long u = segTree->get(segment.first, segment.second);\n      candidates.erase(candidates.find(u));\n      segTree->update(nodeY.preDfs, nodeY.postDfs, diff);\n      candidates.insert(segTree->get(segment.first, segment.second));\n      ans.insert(centroidData[root].getAns());\n    }\n    curAns = *ans.rbegin();\n    cout << curAns << '\\n';\n  }\n}\n",
    "ext": "cpp"
  },
  "57909073": {
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#pragma GCC optimize (\"O3\")\nconst int N=1e5+5;\nint n,q,u[N],v[N],check[N],child[N];\nint con[N],idx[N][20],cnt[N],sz[N];\nlong long w[N],weight,d,e,ans,h[N],st_cen[4*N];\nvector<pair<int,long long> > adj[N];\nvector<long long> dd[N],tour[N],lazy[N];\nvector<pair<long long,pair<int,int> > > st[N];\npair<int,int> sub[N][20],par[N][20];\n//IT centroid\nvoid push_down(int id,int l,int r,int pos){\n\tif(lazy[pos][id]!=0){\n\t\tst[pos][id].fi+=lazy[pos][id];\n\t\tif(l<r){\n\t\t\tlazy[pos][2*id]+=lazy[pos][id];\n\t\t\tlazy[pos][2*id+1]+=lazy[pos][id];\n\t\t}\n\t\tlazy[pos][id]=0;\n\t}\n}\nvoid update(int id,int l,int r,int i,int j,long long x,int pos){\n\tpush_down(id,l,r,pos);\n\tif(l>j||r<i||i>j){\n\t\treturn;\n\t}\n\tif(l>=i&&r<=j){\n\t\tst[pos][id].fi+=x;\n\t\tif(l<r){\n\t\t\tlazy[pos][2*id]+=x;\n\t\t\tlazy[pos][2*id+1]+=x;\n\t\t}else{\n\t\t\tif(dd[pos][i]==0){\n\t\t\t\tst[pos][id].se=par[tour[pos][i]][cnt[tour[pos][i]]];\n\t\t\t\tdd[pos][i]=1;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tint mid=(l+r)/2;\n\tupdate(2*id,l,mid,i,j,x,pos);\n\tupdate(2*id+1,mid+1,r,i,j,x,pos);\n\tst[pos][id]=max(st[pos][2*id],st[pos][2*id+1]);\n}\n//IT ans\nvoid update_cen(int id,int l,int r,int i,long long x){\n\tif(l>i||r<i){\n\t\treturn;\n\t}\n\tif(l==r){\n\t\tst_cen[id]=x;\n\t\treturn;\n\t}\n\tint mid=(l+r)/2;\n\tupdate_cen(2*id,l,mid,i,x);\n\tupdate_cen(2*id+1,mid+1,r,i,x);\n\tst_cen[id]=max(st_cen[2*id],st_cen[2*id+1]);\n}\n//centroid;\nvoid dfs(int u,int p){\n\tchild[u]=1; \n\tcon[u]=h[u]=0;\n\tfor(auto tmp: adj[u]){\n\t\tint v=tmp.fi;\n\t\tif(v!=p && check[v]==0){\n\t\t\tdfs(v,u);\n\t\t\tchild[u]+=child[v];\n\t\t}\n\t}\n}\nint findcen(int u,int p,int size){\n\tfor(auto tmp: adj[u]){\n\t\tint v=tmp.fi;\n\t\tif(v!=p && check[v]==0){\n\t\t\tif(child[v]*2>size){\n\t\t\t\treturn findcen(v,u,size);\n\t\t\t}\n\t\t}\n\t}\n\treturn u;\n}\n//build tree\nvoid build(int u,int p,long long dist,int cen){\n\tcnt[u]++; \n\tidx[u][cnt[u]] = cen;\n\ttour[cen].push_back(u);\n\tsub[u][cnt[u]].fi = tour[cen].size()-1;\n\th[u] = h[p] + dist; \n\tcon[u] = 1;\n\tif(p==cen){\n\t\tpar[u][cnt[u]].fi=u;\n\t\tpar[u][cnt[u]].se=cnt[u];\n\t}else{\n\t\tpar[u][cnt[u]]=par[p][cnt[p]];\n\t}\n\tupdate(1,1,sz[cen],sub[u][cnt[u]].fi,sub[u][cnt[u]].fi,h[u],cen);\n\tfor(auto tmp: adj[u]){\n\t\tint v=tmp.fi;\n\t\tlong long w=tmp.se;\n\t\tif(v!=p && check[v]==0){\n\t\t\tbuild(v,u,w,cen);\n\t\t\tcon[u]+=con[v];\n\t\t}\n\t}\n\tsub[u][cnt[u]].se = sub[u][cnt[u]].fi+con[u]-1;\n}\nvoid centroid(int root){\n\tdfs(root,root);\n\tint cen=findcen(root,root,child[root]);\n\tsz[cen] = child[root];\n\t//init\n\tst[cen].assign(4*sz[cen]+5, {0,{0,0}});\n\tlazy[cen].assign(4*sz[cen]+5, 0);\n\tdd[cen].assign(sz[cen]+1,0);\n\ttour[cen].push_back(0);\n\tbuild(cen,0,0,cen);\n\t//get max\n\tlong long tmp = st[cen][1].fi;\n\tint hah = st[cen][1].se.fi, wow = st[cen][1].se.se;\n\tupdate(1,1,sz[cen],sub[hah][wow].fi,sub[hah][wow].se,-1e18,cen);\n\ttmp=tmp+st[cen][1].fi;\n\tupdate(1,1,sz[cen],sub[hah][wow].fi,sub[hah][wow].se,1e18,cen);\n\tupdate_cen(1,1,n,cen,tmp);\n\t//centroid\n\tcheck[cen]=1;\n\tfor(auto tmp: adj[cen]){\n\t\tint v=tmp.fi;\n\t\tif(check[v]==0){\n\t\t\tcentroid(v);\n\t\t}\n\t}\n}\n//main\nint main(){\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin>>n>>q>>weight;\n\tfor(int i=1;i<n;i++){\n\t\tcin>>u[i]>>v[i]>>w[i];\n\t\tadj[u[i]].push_back({v[i],w[i]});\n\t\tadj[v[i]].push_back({u[i],w[i]});\n\t}\n\tcentroid(1);\n\tfor(int vl=1;vl<=q;vl++){\n\t\tcin>>d>>e;\n\t\td=(d+ans)%(n-1)+1;\n\t\te=(e+ans)%weight;\n\t\tfor(int i=1;i<=cnt[u[d]];i++){\n\t\t\tint cen=idx[u[d]][i],luu;\n\t\t\tbool kt=0;\n\t\t\tfor(int j=1;j<=cnt[v[d]];j++){\n\t\t\t\tif(idx[v[d]][j]==cen){\n\t\t\t\t\tkt=1;\n\t\t\t\t\tluu=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(kt==0) continue;\n\t\t\tif(sub[u[d]][i].fi>sub[v[d]][luu].fi){\n\t\t\t\tupdate(1,1,sz[cen], sub[u[d]][i].fi, sub[u[d]][i].se, e-w[d], cen);\n\t\t\t}else{\n\t\t\t\tupdate(1,1,sz[cen],sub[v[d]][luu].fi,sub[v[d]][luu].se,e-w[d],cen);\n\t\t\t}\n\t\t\tlong long tmp = st[cen][1].fi;\n\t\t\tint hah = st[cen][1].se.fi, wow = st[cen][1].se.se;\n\t\t\tupdate(1,1,sz[cen], sub[hah][wow].fi, sub[hah][wow].se, -1e18,cen);\n\t\t\ttmp=tmp+st[cen][1].fi;\n\t\t\tupdate(1,1,sz[cen], sub[hah][wow].fi, sub[hah][wow].se, 1e18,cen);\n\t\t\tupdate_cen(1,1,n,cen,tmp);\n\t\t}\n\t\tw[d]=e;\n\t\tans=st_cen[1];\n\t\tcout<<ans<<endl;\n\t}\n}",
    "ext": "cpp"
  },
  "57903823": {
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\n \nconst ll Inf = 1e18;\n \nstruct SegmentTree {\n    vector <ll> t, mod;\n    int n;\n    void build(int l, int r, int v, const vector <ll> &a) {\n        if (l + 1 == r) {\n            t[v] = a[l];\n        } else {\n            int m = (l + r) >> 1;\n            build(l, m, 2 * v + 1, a);\n            build(m, r, 2 * v + 2, a);\n            t[v] = max(t[2 * v + 1], t[2 * v + 2]);\n        }\n    }\n    SegmentTree() {}\n    void init(const vector <ll> &a) {\n        n = a.size();\n        int x = 31 - __builtin_clz(n);\n        int rofl = 1 << x;\n        t.resize(2 * rofl);\n        mod.resize(2 * rofl);\n        build(0, n, 0, a);\n    }\n    void init(int sz) {\n        n = sz;\n        t.resize(4 * n);\n        mod.resize(4 * n);\n    }\n    void update(int v, ll val) {\n        t[v] += val;\n        mod[v] += val;\n    }\n    void push(int v) {\n        if (mod[v]) {\n            update(2 * v + 1, mod[v]);\n            update(2 * v + 2, mod[v]);\n            mod[v] = 0;\n        }\n    }\n    void modify(int ql, int qr, ll val, int l, int r, int v) {\n        if (qr <= l || r <= ql) return;\n        if (ql <= l && r <= qr) {\n            update(v, val);\n        } else {\n            push(v);\n            int m = (l + r) >> 1;\n            modify(ql, qr, val, l, m, 2 * v + 1);\n            modify(ql, qr, val, m, r, 2 * v + 2);\n            t[v] = max(t[2 * v + 1], t[2 * v + 2]);\n        }\n    }\n    void modify(int ql, int qr, ll val) {\n        modify(ql, qr, val, 0, n, 0);\n    }\n    ll get(int ql, int qr, int l, int r, int v) {\n        if (qr <= l || r <= ql) return -Inf;\n        if (ql <= l && r <= qr) return t[v];\n        else {\n            push(v);\n            int m = (l + r) >> 1;\n            return max(get(ql, qr, l, m, 2 * v + 1), get(ql, qr, m, r, 2 * v + 2));\n        }\n    }\n    ll get(int ql, int qr) {\n        return get(ql, qr, 0, n, 0);\n    }\n};\n \nconst int N = 1e5 + 7;\nconst int K = 18;\n \nvector <pair <int, ll>> g[N];\nmultiset <ll> cAns;\n \nmultiset <ll> fromC[N];\nSegmentTree tr[N];\n \nint par[N], d[N], l[K][N], r[K][N], cmp[K][N], parC[K][N];\n \nll ans[K][N];\nbool used[N];\n \nll getSum(const multiset <ll> &a) {\n    ll res = 0;\n    if ((int)a.size() >= 1) res += *prev(a.end());\n    if ((int)a.size() >= 2) res += *prev(prev(a.end()));\n    return res;\n}\n \nvoid updateCentroid(int c, int v, ll val) {\n    int cd = d[c];\n    int who = cmp[cd][v];\n    cAns.erase(cAns.find(getSum(fromC[c])));\n    fromC[c].erase(fromC[c].find(ans[cd][who]));\n    tr[c].modify(l[cd][v], r[cd][v], val);\n    ll cVal = tr[c].get(l[cd][who], r[cd][who]);\n    fromC[c].insert(cVal);\n    ans[cd][who] = cVal;\n    cAns.insert(getSum(fromC[c]));\n}\n \nint dfs(int u, int sz, int &c, int p) {\n    int sum = 1;\n    for (auto &[v, w] : g[u]) {\n        if (!used[v] && v != p) {\n            sum += dfs(v, sz, c, u);\n        }\n    }\n    if (c == -1 && (p == -1 || 2 * sum >= sz)) {\n        c = u;\n    }\n    return sum;\n}\n \nint t = 0;\n \nvoid jhfs(int u, int cd, int st, int c, ll wg, int p) {\n    parC[cd][u] = p;\n    cmp[cd][u] = st;\n    l[cd][u] = t++;\n    cmp[cd][u] = st;\n    for (auto &[v, w] : g[u]) {\n        if (!used[v] && v != p) jhfs(v, cd, st, c, w, u);\n    }\n    r[cd][u] = t;\n    tr[c].modify(l[cd][u], r[cd][u], wg);\n    if (u == st) {\n        ll cVal = tr[c].get(l[cd][u], r[cd][u]);\n        fromC[c].insert(cVal);\n        ans[cd][u] = cVal;\n    }\n}   \n\nint cmpSize = 0;\n\nvoid memfs(int u, int p) {\n    ++cmpSize;\n    for (auto &[v, w] : g[u]) {\n        if (!used[v] && v != p) {\n            memfs(v, u);\n        }\n    }\n}\n \nvoid buildCentroid(int u, int sz, int p) {\n    int c = -1;\n    dfs(u, sz, c, -1);\n    used[c] = 1;\n    par[c] = p;\n    d[c] = (p == -1 ? 0 : d[p] + 1);\n    t = 0;\n    cmpSize = 1;\n    for (auto &[v, w] : g[c]) {\n        if (!used[v]) {\n            memfs(v, c);\n        }\n    }\n    tr[c].init(cmpSize);\n    for (auto &[v, w] : g[c]) {\n        if (!used[v]) {\n            jhfs(v, d[c], v, c, w, c);\n        }\n    }\n \n    cAns.insert(getSum(fromC[c]));\n \n    for (auto &[v, w] : g[c]) {\n        if (!used[v]) {\n            buildCentroid(v, (sz + 1) / 2, c);\n        }\n    }\n}\n \nvoid update(int u, int v, ll w) {\n    vector <int> crd;\n    int cur = u;\n    while (cur != -1) {\n        crd.push_back(cur);\n        cur = par[cur];\n    }\n    reverse(crd.begin(), crd.end());\n    for (int i = 0; i < K; ++i) {\n        if (parC[i][u] != v && parC[i][v] != u) break;\n        if (parC[i][u] == v) swap(u, v);\n        assert(parC[i][v] == u);\n        updateCentroid(crd[i], v, w);\n    }\n}\n \nll getDiam() {\n    return *prev(cAns.end());\n}\n \nstruct Edge {\n    int u, v; ll w;\n};\n \nsigned main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.setf(ios::fixed); cout.precision(20);\n    #ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif\n    for (int i = 0; i < K; ++i) {\n        for (int j = 0; j < N; ++j) {\n            parC[i][j] = -1;\n        }\n    }\n    vector <Edge> E;\n    int n, q; ll w;\n    cin >> n >> q >> w;\n    for (int i = 0; i + 1 < n; ++i) {\n        int a, b; ll c;\n        cin >> a >> b >> c;\n        --a, --b;\n        g[a].emplace_back(b, c);\n        g[b].emplace_back(a, c);\n        E.push_back({a, b, c});\n    }\n    buildCentroid(0, n, -1);\n    ll last = 0;\n    for (int i = 0; i < q; ++i) {\n        ll d, e;\n        cin >> d >> e;\n        d += last, e += last;\n        d %= (n - 1);\n        e %= w;\n        update(E[d].u, E[d].v, e - E[d].w);\n        E[d].w = e;\n        last = getDiam();\n        cout << last << '\\n';\n    }\n}",
    "ext": "cpp"
  },
  "57895118": {
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#if __cplusplus >= 201103L\n#endif\n\nint gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }\n\n#define ll long long\n#define pb push_back\n#define ld long double\n#define mp make_pair\n#define F first\n#define S second\n#define pii pair<ll,ll> \n\nusing namespace ::std;\n\nconst ll maxn = 1e5 + 500;\n\nstruct M {\n\tll lazy;\n\tll a, b, ab, bc, abc;\n};\n\nM seg[maxn * 8];\n\nM merge(M a, M b) {\n\tM ans;\n\tans.lazy = 0;\n\tans.a = max(a.a, b.a);\n\tans.b = max(a.b, b.b);\n\tans.ab = max(a.a + b.b, max(a.ab, b.ab));\n\tans.bc = max(a.b + b.a, max(a.bc, b.bc));\n\tans.abc = max(max(a.abc, b.abc), max(a.a + b.bc, a.ab + b.a));\n\treturn ans;\n}\nvoid put(ll a, ll v) {\n\tseg[a].lazy += v;\n\tseg[a].a += v;\n\tseg[a].b -= 2 * v;\n\tseg[a].ab -= v;\n\tseg[a].bc -= v;\n}\nvoid shift(ll a) {\n\tput(2 * a, seg[a].lazy);\n\tput(2 * a + 1, seg[a].lazy);\n\tseg[a].lazy = 0;\n}\nvoid update(ll L, ll R, ll node, ll l, ll r, ll v) {\n\tif (l <= L && R <= r) {\n\t\tput(node, v);\n\t\treturn;\n\t}\n\tif (r <= L || R <= l)return;\n\tll mid = (L + R) / 2;\n\tshift(node);\n\tupdate(L, mid, 2 * node, l, r, v);\n\tupdate(mid, R, 2 * node + 1, l, r, v);\n\tseg[node] = merge(seg[2 * node], seg[2 * node + 1]);\n}\n\nvector<ll> ger[maxn];\nll a[maxn];\nll b[maxn];\nll c[maxn];\n\nll st[maxn];\nll et[maxn];\nll tt = 0;\n\nvoid dfs(ll v, ll p = -1) {\n\ttt++;\n\tfor (auto e : ger[v]) {\n\t\tll u = (v ^ a[e] ^ b[e]);\n\t\tif (u != p) {\n\t\t\tst[e] = tt;\n\t\t\tdfs(u, v);\n\t\t\tet[e] = tt;\n\t\t\ttt++;\n\t\t}\n\t}\n}\nvoid bild(ll n) {\n\tdfs(1);\n\tfor (ll i = 0; i < n - 1; i++) {\n\t\tupdate(0, tt, 1, st[i], et[i], c[i]);\n\t}\n}\nll update(ll d, ll e) {\n\tupdate(0, tt, 1, st[d], et[d], e - c[d]);\n\tc[d] = e;\n\treturn seg[1].abc;\n}\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tll n, q, w;\n\tcin >> n >> q >> w;\n\tfor (ll i = 0; i + 1 < n; i++) {\n\t\tcin >> a[i] >> b[i] >> c[i];\n\t\tif (a[i] > b[i])swap(a[i], b[i]);\n\t\tger[a[i]].pb(i);\n\t\tger[b[i]].pb(i);\n\t}\n\tbild(n);\n\tll last = 0;\n\tfor (ll i = 0; i < q; i++) {\n\t\tll d, e;\n\t\tcin >> d >> e;\n\t\td = (d + last) % (n - 1);\n\t\te = (e + last) % w;\n\t\tlast = update(d, e);\n\t\tcout << last << endl;\n\t}\n}",
    "ext": "cpp"
  },
  "57883986": {
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=200005,MAXM=400005,MAXBIT=19;\nstruct tnode\n{\n\tlong long max1,lazy;\n\tint l,r;\n};\nstruct Segment_Tree\n{\n\tvector<tnode>t;\n\tvoid pushdown(int root)\n\t{\n\t\tif(t[root].lazy!=0)\n\t\t{\n\t\t\tt[root].max1+=t[root].lazy;\n\t\t\tif(t[root].l!=t[root].r)\n\t\t\t{\n\t\t\t\tint ch=root<<1;\n\t\t\t\tt[ch].lazy+=t[root].lazy;\n\t\t\t\tt[ch+1].lazy+=t[root].lazy;\n\t\t\t}\n\t\t\tt[root].lazy=0;\n\t\t}\n\t}\n\tvoid update (int root)\n\t{\n\t\tint ch=root<<1;\n\t\tpushdown(ch);\n\t\tpushdown(ch+1);\n\t\tt[root].max1=max(t[ch].max1,t[ch+1].max1);\n\t}\n\tvoid init(const long long A[],int n)\n\t{\n\t    t.resize(4*n);\n\t    buildit(1,1,n,A);\n\t}\n\tvoid buildit(int root,int l,int r,const long long A[])\n\t{\n\t\tt[root].l=l;\n\t\tt[root].r=r;\n\t\tt[root].lazy=0;\n\t\tif(l!=r)\n\t\t{\n\t\t\tint mid=(l+r)>>1;\n\t\t\tint ch=root<<1;\n\t\t\tbuildit(ch,l,mid,A);\n\t\t\tbuildit(ch+1,mid+1,r,A);\n\t\t\tupdate(root);\n\t\t}\n\t\telse t[root].max1=A[l];\n\t}\n\tvoid change(int root,int l,int r,long long delta)\n\t{\n\t    pushdown(root);\n\t\tif(l==t[root].l&&r==t[root].r)\n\t\t{\n\t\t\tt[root].lazy+=delta;\n\t\t\tpushdown(root);\n\t\t\treturn;\n\t\t}\n\t\tint mid=(t[root].l+t[root].r)>>1;\n\t\tint ch=root<<1;\n\t\tif(r<=mid)change(ch,l,r,delta);\n\t\telse if(l>mid)change(ch+1,l,r,delta);\n\t\telse {change(ch,l,mid,delta);change(ch+1,mid+1,r,delta);}\n\t\tupdate(root);\n\t}\n\tlong long qmax(int root,int l,int r)\n\t{\n\t\tpushdown(root);\n\t\tif(t[root].l==l&&t[root].r==r)\n\t\t{\n\t\t\treturn t[root].max1;\n\t\t}\n\t\tint mid=(t[root].l+t[root].r)>>1;\n\t\tint ch=root<<1;\n\t\tif(r<=mid)return qmax(ch,l,r);\n\t\telse if(l>mid)return qmax(ch+1,l,r);\n\t\telse return max(qmax(ch,l,mid),qmax(ch+1,mid+1,r));\n\t}\n};\nSegment_Tree ST[MAXN];\nint n,q,u,v,g[MAXN],tot,gravity_size[MAXN],gravity_max[MAXN],gravity,siz,g_deep[MAXN],belone[MAXN][MAXBIT],L[MAXN][MAXBIT],R[MAXN][MAXBIT],chain_top[MAXN][MAXBIT],dfn,g_fa[MAXN];\nlong long p_val[MAXN],temp_val[MAXN],W,last_ans,dj,ej;\nbool div_vis[MAXN];\nmultiset<long long>tans[MAXN],ans;\nstruct edges\n{\n    int to;\n    int next;\n}e[MAXM<<1];\nvoid add_edge(int from,int to)\n{\n    e[++tot].to=to;\n    e[tot].next=g[from];\n    g[from]=tot;\n    return;\n}\nvoid get_gravity(int x,int fa)\n{\n    gravity_size[x]=1;\n    gravity_max[x]=-1;\n    for(int i=g[x];i;i=e[i].next)\n    {\n        if(e[i].to!=fa&&!div_vis[e[i].to])\n        {\n            get_gravity(e[i].to,x);\n            if(gravity_max[x]==-1||gravity_max[x]<gravity_size[e[i].to])\n            {\n                gravity_max[x]=gravity_size[e[i].to];\n            }\n            gravity_size[x]+=gravity_size[e[i].to];\n        }\n    }\n    gravity_max[x]=max(gravity_max[x],siz-gravity_size[x]);\n    if(gravity==-1||gravity_max[gravity]>gravity_max[x])gravity=x;\n}\nvoid get_size(int x,int fa)\n{\n    ++siz;\n    for(int i=g[x];i;i=e[i].next)\n    {\n        if(e[i].to!=fa&&!div_vis[e[i].to])\n        {\n            get_size(e[i].to,x);\n        }\n    }\n}\nvoid dfs_get_date(int now,int fa,int c_top,long long nowsum,const int &state)\n{\n    L[now][state]=++dfn;\n    belone[now][state]=gravity;\n    if(gravity==c_top)\n    {\n        c_top=now;\n    }\n    chain_top[now][state]=c_top;\n    temp_val[dfn]=nowsum;\n     for(int i=g[now];i;i=e[i].next)\n    {\n        if(e[i].to!=fa&&!div_vis[e[i].to])\n        {\n            dfs_get_date(e[i].to,now,c_top,nowsum+p_val[e[i].to],state);\n        }\n    }\n    R[now][state]=dfn;\n}\nlong long get_template_ans(int now)\n{\n    if(tans[now].size()>=2)\n    {\n        multiset<long long>::reverse_iterator it=tans[now].rbegin();\n        it++;\n        return *tans[now].rbegin()+*it;\n    }\n    return *tans[gravity].rbegin();\n}\n\nvoid tree_div(int x,int pre,int deep)\n{\n    siz=0;\n    get_size(x,-1);\n    gravity=-1;\n    get_gravity(x,-1);\n    div_vis[gravity]=true;\n    g_deep[gravity]=deep;\n\n    dfn=0;\n    dfs_get_date(gravity,-1,gravity,0,deep);\n\n    /*\n    cout<<\"test:\"<<gravity<<endl;\n    for(int i=1;i<=siz;++i)\n    {\n        cout<<temp_val[i]<<\" \";\n    }\n    cout<<endl;\n    */\n\n    ST[gravity].init(temp_val,siz);\n    tans[gravity].insert(0);\n\n    for(int i=g[gravity];i;i=e[i].next)\n    {\n        if(!div_vis[e[i].to])\n        {\n            tans[gravity].insert(ST[gravity].qmax(1,L[e[i].to][deep],R[e[i].to][deep]));\n        }\n    }\n    /*\n    cout<<\"ins: \"<<endl;\n    for(auto &i:tans[gravity])\n    {\n        cout<<i<<\" \";\n    }\n    cout<<endl;\n    */\n    ans.insert(get_template_ans(gravity)+p_val[gravity]);\n    int t_g=gravity;\n    g_fa[t_g]=pre;\n    for(int i=g[gravity];i;i=e[i].next)\n    {\n        if(!div_vis[e[i].to])\n        {\n            tree_div(e[i].to,t_g,deep+1);\n        }\n    }\n    return;\n}\nvoid change(int now_g,int now_p,long long preval,long long nowval)\n{\n    while(now_g)\n    {\n        int now_top=chain_top[now_p][g_deep[now_g]];\n        if(now_top==now_g)\n        {\n            ans.erase(ans.find(get_template_ans(now_g)+preval));\n            ans.insert(get_template_ans(now_g)+nowval);\n        }\n        else\n        {\n            ans.erase(ans.find(get_template_ans(now_g)+p_val[now_g]));\n            long long t_temp=ST[now_g].qmax(1,L[now_top][g_deep[now_g]],R[now_top][g_deep[now_g]]);\n            tans[now_g].erase(tans[now_g].find(t_temp));\n            ST[now_g].change(1,L[now_p][g_deep[now_g]],R[now_p][g_deep[now_g]],nowval-preval);\n            t_temp=ST[now_g].qmax(1,L[now_top][g_deep[now_g]],R[now_top][g_deep[now_g]]);\n            tans[now_g].insert(t_temp);\n            ans.insert(get_template_ans(now_g)+p_val[now_g]);\n        }\n        now_g=g_fa[now_g];\n    }\n    p_val[now_p]=nowval;\n}\nint main()\n{\n    scanf(\"%d %d %lld\",&n,&q,&W);\n    for(int i=1;i<n;++i)\n    {\n        scanf(\"%d %d %lld\",&u,&v,&p_val[n+i]);\n        add_edge(u,n+i);\n        add_edge(n+i,u);\n        add_edge(v,n+i);\n        add_edge(n+i,v);\n    }\n    tree_div(1,0,0);\n\n    //cout<<\"---\"<<*ans.rbegin()<<endl;\n    while(q--)\n    {\n        scanf(\"%lld %lld\",&dj,&ej);\n        dj=(dj+last_ans)%(n-1);\n        ej=(ej+last_ans)%W;\n        change(dj+n+1,dj+n+1,p_val[dj+n+1],ej);\n        //cout<<\"test\"<<dj+n+1<<\" \"<<ej<<endl;\n        last_ans=*ans.rbegin();\n        printf(\"%lld\\n\",last_ans);\n    }\n\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57882404": {
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 1 << 19;\nvector<pair<int, long long>> gr[N];\nint tin[N], tout[N];\n\nstruct Node {\n\tlong long mx, mn, suf, pref;\n\tlong long ans;\n};\n\nvector<long long> a;\n\nvoid dfs(int v, int p = -1, long long d = 0)\n{\n\ttin[v] = a.size();\n\ta.push_back(d);\n\tfor (auto [u, e] : gr[v])\n\t\tif (u != p) {\n\t\t\tdfs(u, v, d + e);\n\t\t\ta.push_back(d);\n\t\t}\n\ttout[v] = a.size();\n}\n\nNode merge(Node a, Node b) {\n\tNode res;\n\tres.mn = min(a.mn, b.mn);\n\tres.mx = max(a.mx, b.mx);\n\tres.suf = max(max(a.suf, b.suf), a.mx - 2 * b.mn);\n\tres.pref = max(max(a.pref, b.pref), b.mx - 2 * a.mn);\n\tres.ans = max(max(a.ans, b.ans), max(a.mx + b.pref, b.mx + a.suf));\n\treturn res;\n}\n\nNode t[N];\nlong long pu[N];\n\n#define left 2 * v + 1\n#define right 2 * v + 2\n\nvoid build(int v, int l, int r)\n{\n\tif (r - l == 1) {\n\t\tt[v].ans = 0;\n\t\tt[v].mn = t[v].mx = a[l];\n\t\tt[v].pref = t[v].suf = -a[l];\n\t}\n\telse {\n\t\tint m = (l + r) >> 1;\n\t\tbuild(left, l, m);\n\t\tbuild(right, m, r);\n\t\tt[v] = merge(t[left], t[right]);\n\t}\n}\n\nvoid push(int v, int l, int r)\n{\n\tt[v].mn += pu[v];\n\tt[v].mx += pu[v];\n\tt[v].pref -= pu[v];\n\tt[v].suf -= pu[v];\n\tif (r - l > 1) {\n\t\tpu[left] += pu[v];\n\t\tpu[right] += pu[v];\n\t}\n\tpu[v] = 0;\n}\n\nvoid add(int v, int l, int r, int ql, int qr, long long x)\n{\n\tpush(v, l, r);\n\tif (qr <= l || r <= ql)\n\t\treturn;\n\telse if (ql <= l && r <= qr) {\n\t\tpu[v] = x;\n\t\tpush(v, l, r);\n\t}\n\telse {\n\t\tint m = (r + l) >> 1;\n\t\tadd(left, l, m, ql, qr, x);\n\t\tadd(right, m, r, ql, qr, x);\n\t\tt[v] = merge(t[left], t[right]);\n\t}\n}\n\nstruct {\n\tint a, b;\n\tlong long c;\n} eges[N];\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0);\n#ifdef ONPC\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\n\tint n, q;\n\tlong long w;\n\tcin >> n >> q >> w;\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint a, b;\n\t\tlong long c;\n\t\tcin >> a >> b >> c;\n\t\ta--, b--;\n\t\tgr[a].push_back({ b, c });\n\t\tgr[b].push_back({ a, c });\n\t\teges[i] = { a, b, c };\n\t}\n\n\tdfs(0);\n\tfor (auto &x : eges)\n\t\tif (tin[x.b] < tin[x.a])\n\t\t\tswap(x.a, x.b);\n\n\tint m = a.size();\n\n\tbuild(0, 0, m);\n\tlong long last = 0;\n\twhile (q--) {\n\t\tlong long d, e;\n\t\tcin >> d >> e;\n\t\td = (d + last) % (n - 1) + 1;\n\t\te = (e + last) % w;\n\t\tadd(0, 0, m, tin[eges[d].b], tout[eges[d].b], e - eges[d].c);\n\t\teges[d].c = e;\n\t\tcout << t[0].ans << '\\n';\n\t\tlast = t[0].ans;\n\t}\n}\n",
    "ext": "cpp"
  },
  "57875683": {
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nconst int maxn = 100002;\nconst int logn = 20;\n\nstruct node{\n\tnode *prt;\n\tunion {\n\t\tstruct {\n\t\t\tnode *ls, *rs;\n\t\t};\n\t\tnode *ch[2];\n\t};\n\tlong long v, d, lazy;\n\tint cnt;\n};\n\nnode* create(long long v) {\n\tstatic node pool[logn*maxn];\n\tstatic node *p = pool;\n\tp->prt = p->ls = p->rs = NULL;\n\tp->v = p->d = v;\n\tp->lazy = 0;\n\tp->cnt = 1;\n\treturn p++;\n}\n\nlong long dwl(node *p) {\n\treturn p ? p->d + p->lazy : 0;\n}\n\nint get_cnt(node *p) {\n\treturn p ? p->cnt : 0;\n}\n\nvoid update(node *p) {\n\tp->d = max(p->v, max(dwl(p->ls), dwl(p->rs)));\n\tp->cnt = 1 + get_cnt(p->ls) + get_cnt(p->rs);\n}\n\nvoid push_down(node *p) {\n\tif (!p->lazy) return;\n\tp->d += p->lazy;\n\tp->v += p->lazy;\n\tif (p->ls) p->ls->lazy += p->lazy;\n\tif (p->rs) p->rs->lazy += p->lazy;\n\tp->lazy = 0;\n}\n\nbool relation(node *p) {\n\treturn p == p->prt->rs;\n}\n\nvoid rotate(node *p) {\n\tif (p->prt->prt) push_down(p->prt->prt);\n\tpush_down(p->prt);\n\tpush_down(p);\n\tbool rel = relation(p);\n\tif (p->prt->prt) p->prt->prt->ch[relation(p->prt)] = p;\n\tp->prt->ch[rel] = p->ch[!rel];\n\tif (p->ch[!rel]) p->ch[!rel]->prt = p->prt;\n\tp->ch[!rel] = p->prt;\n\tp->prt = p->prt->prt;\n\tp->ch[!rel]->prt = p;\n\tupdate(p->ch[!rel]);\n\tupdate(p);\n}\n\nvoid splay(node *p, node *goal = NULL) {\n\twhile (p->prt != goal) {\n\t\tif (p->prt->prt == goal) {\n\t\t\trotate(p);\n\t\t\tbreak;\n\t\t}\n\t\tif (relation(p->prt) == relation(p)) {\n\t\t\trotate(p->prt);\n\t\t\trotate(p);\n\t\t}\n\t\telse {\n\t\t\trotate(p);\n\t\t\trotate(p);\n\t\t}\n\t}\n}\n\nnode* find(node *p, int cnt) {\n\twhile (p) {\n\t\tif (cnt <= get_cnt(p->ls)) p = p->ls;\n\t\telse if (cnt > get_cnt(p->ls) + 1) cnt -= get_cnt(p->ls) + 1, p = p->rs;\n\t\telse return p;\n\t}\n}\n\nvoid change(node *&rt, int l, int r, long long d) {\n\t//fprintf(stderr, \"splay %d %d %lld\\n\", l, r, d);\n\t//fprintf(stderr, \"%d\\n\", get_cnt(rt));\n\trt = find(rt, l);\n\tsplay(rt);\n\tsplay(find(rt, r + 2), rt);\n\t//fprintf(stderr, \"*\\n\");\n\trt->rs->ls->lazy += d;\n\t//fprintf(stderr, \"#\\n\");\n\tupdate(rt->rs);\n\tupdate(rt);\n}\n\nstruct edge{\n\tint v;\n\tlong long w;\n\tedge(){}\n\tedge(int v, long long w): v(v), w(w) {}\n};\n\nint eu[maxn], ev[maxn];\nlong long ew[maxn];\nvector<edge> adj[maxn];\nbool solve[maxn];\nint dep[maxn], prt[maxn];\nint first[logn][maxn];\nint prv[logn][maxn], cnt[logn][maxn];\nnode* rt[logn][maxn];\npriority_queue<long long> q[maxn], dq[maxn], ans, dans;\nint n, m;\nlong long maxw;\n\nint center(int u);\nvoid split(int u);\nvoid change(int id, long long w);\nlong long cal_ans();\n\nint main() {\n\tscanf(\"%d%d%lld\", &n, &m, &maxw);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d%lld\", &eu[i], &ev[i], &ew[i]);\n\t\tadj[eu[i]].push_back(edge(ev[i],ew[i]));\n\t\tadj[ev[i]].push_back(edge(eu[i],ew[i]));\n\t}\n\tint rt = center(1);\n\tdep[rt] = 1;\n\t//fprintf(stderr, \"split begin\\n\");\n\tsplit(rt);\n\t//fprintf(stderr, \"split end\\n\");\n\tlong long last_ans = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint id;\n\t\tlong long w;\n\t\tscanf(\"%d%lld\", &id, &w);\n\t\tid = (id + last_ans) % (n - 1) + 1;\n\t\tw = (w + last_ans) % maxw;\n\t\t//fprintf(stderr, \"query %d %d\\n\", id, w);\n\t\tchange(id, w);\n\t\tlast_ans = cal_ans();\n\t\tprintf(\"%lld\\n\", last_ans);\n\t}\n\treturn 0;\n}\n\nint center_cnt[maxn];\nbool center_vis[maxn];\n\nvoid dfs1(int u) {\n\tcenter_vis[u] = 1;\n\tcenter_cnt[u] = 1;\n\tfor (int i = 0; i < adj[u].size(); i++) {\n\t\tint v = adj[u][i].v;\n\t\tif (center_vis[v] || solve[v]) continue;\n\t\tdfs1(v);\n\t\tcenter_cnt[u] += center_cnt[v];\n\t}\n\tcenter_vis[u] = 0;\n}\n\nint dfs2(int u, int cnt) {\n\tcenter_vis[u] = 1;\n\tint mch = cnt - center_cnt[u];\n\tint ret = -1;\n\tfor (int i = 0; i < adj[u].size(); i++) {\n\t\tint v = adj[u][i].v;\n\t\tif (center_vis[v] || solve[v]) continue;\n\t\tret = dfs2(v, cnt);\n\t\tmch = max(mch, center_cnt[v]);\n\t\tif (ret != -1) break;\n\t}\n\tcenter_vis[u] = 0;\n\tif (2 * mch <= cnt) ret = u;\n\treturn ret;\n}\n\nint center(int u) {\n\tdfs1(u);\n\treturn dfs2(u, center_cnt[u]);\n}\n\nbool vis[maxn];\nint rev[maxn];\nlong long dis[maxn];\nint t;\n\nvoid dfs(int u, int dep, int fir) {\n\tvis[u] = 1;\n\tprv[dep][u] = ++t;\n\trev[t] = u;\n\tcnt[dep][u] = 1;\n\tfirst[dep][u] = fir;\n\tfor (int i = 0; i < adj[u].size(); i++) {\n\t\tint v = adj[u][i].v;\n\t\tlong long w = adj[u][i].w;\n\t\tif (vis[v] || solve[v]) continue;\n\t\tdis[v] = dis[u] + w;\n\t\tdfs(v, dep, fir);\n\t\tcnt[dep][u] += cnt[dep][v];\n\t}\n\tvis[u] = 0;\n}\n\nnode* build(int l, int r) {\n\tif (l > r) return NULL;\n\tint mid = (l + r) / 2;\n\tnode* p = create(dis[rev[mid]]);\n\tp->ls = build(l, mid - 1);\n\tif (p->ls) p->ls->prt = p;\n\tp->rs = build(mid + 1, r);\n\tif (p->rs) p->rs->prt = p;\n\tupdate(p);\n\treturn p;\n}\n\nlong long cal_ans(int u) {\n\twhile (!dq[u].empty() && dq[u].top() == q[u].top()) {\n\t\tdq[u].pop();\n\t\tq[u].pop();\n\t}\n\tlong long ans1 = q[u].top();\n\tq[u].pop();\n\twhile (!dq[u].empty() && dq[u].top() == q[u].top()) {\n\t\tdq[u].pop();\n\t\tq[u].pop();\n\t}\n\tif (!q[u].size()) {\n\t\tq[u].push(ans1);\n\t\treturn ans1;\n\t}\n\tlong long ans2 = q[u].top();\n\tq[u].push(ans1);\n\treturn ans1 + ans2;\n}\n\nvoid split(int u) {\n\tsolve[u] = 1;\n\tq[u].push(0);\n\tfor (int i = 0; i < adj[u].size(); i++) {\n\t\tint  v = adj[u][i].v;\n\t\tlong long w = adj[u][i].w;\n\t\tif (solve[v]) continue;\n\t\tdis[v] = w;\n\t\tt = 0;\n\t\tdfs(v, dep[u], v);\n\t\trev[t + 1] = 0;\n\t\trt[dep[u]][v] = build(0, t + 1);\n\t\tq[u].push(dwl(rt[dep[u]][v]));\n\t}\n\tans.push(cal_ans(u));\n\tfor (int i = 0; i < adj[u].size(); i++) {\n\t\tint v = adj[u][i].v;\n\t\tif (solve[v]) continue;\n\t\tv = center(v);\n\t\tdep[v] = dep[u] + 1;\n\t\tprt[v] = u;\n\t\tsplit(v);\n\t}\n}\n\nvoid change(int id, long long w) {\n\tlong long d = w - ew[id];\n\tew[id] = w;\n\tint u = eu[id];\n\tint v = ev[id];\n\tint cur;\n\tif (dep[u] > dep[v]) cur = v;\n\telse cur = u;\n\twhile (cur) {\n\t\tint dep = ::dep[cur];\n\t\tif (prv[dep][u] < prv[dep][v]) swap(u, v);\n\t\tint fir = first[dep][u];\n\t\tdans.push(cal_ans(cur));\n\t\tdq[cur].push(dwl(rt[dep][fir]));\n\t\t//fprintf(stderr, \"change %d %d %d\\n\", dep, u, fir);\n\t\tchange(rt[dep][fir], prv[dep][u], prv[dep][u] + cnt[dep][u] - 1, d);\n\t\t//fprintf(stderr, \"end change\\n\");\n\t\tq[cur].push(dwl(rt[dep][fir]));\n\t\tans.push(cal_ans(cur));\n\t\tcur = prt[cur];\n\t}\n}\n\nlong long cal_ans() {\n\twhile (!dans.empty() && dans.top() == ans.top()) {\n\t\tdans.pop();\n\t\tans.pop();\n\t}\n\treturn ans.top();\n}",
    "ext": "cpp"
  },
  "57864053": {
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n \nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<ll, ll> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<ll> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n \n#define FOR(i, a, b) for (ll i = (a); i < (b); i++)\n#define F0R(i, a) for (ll i = 0; i < (a); i++)\n#define FORd(i,a,b) for (ll i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (ll i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n \n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n \n#define sz(x) (ll)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n \nconst ll MOD = 998244353; // 998244353\nconst ll INF = 1e18;\nconst ll MX = 200005;\nconst ld PI = 4*atan((ld)1);\n \ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n \nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n \n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n \n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n \nusing namespace input;\n \nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n \n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n \n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // prll w/ spaces\n    }\n}\n \nusing namespace output;\n \nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n \nusing namespace io;\n \ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n \ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    modular(const ll& v) { \n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    \n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n    friend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n \n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular pow(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n \ntypedef modular<ll> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n/**\n * Description: 1D range update, range query\n * Source: USACO Counting Haybales\n * Verification: SPOJ Horrible\n */\n\ntemplate<class T, ll SZ> struct LazySegTree {\n    T sum[2*SZ], mx[2*SZ], mn[2*SZ], lazy[2*SZ], ansval[2*SZ], ab[2*SZ], cb[2*SZ]; // set SZ to a power of 2\n    \n    LazySegTree() {\n        memset (sum,0,sizeof sum);\n        memset (mx,0,sizeof mx);\n        memset (lazy,0,sizeof lazy);\n        memset (ansval, 0, sizeof ansval);\n        memset (ab, 0, sizeof ab);\n        memset (cb, 0, sizeof cb);\n    }\n    \n    void push(ll ind, ll L, ll R) { \n        sum[ind] += (R-L+1)*lazy[ind];\n        mx[ind] += lazy[ind];\n        mn[ind] += lazy[ind];\n        ab[ind] -= lazy[ind];\n        cb[ind]-=lazy[ind];\n        if (L != R) lazy[2*ind] += lazy[ind], lazy[2*ind+1] += lazy[ind];\n        lazy[ind] = 0;\n    }\n    void pull(ll ind) {\n        sum[ind] = sum[2*ind]+sum[2*ind+1];\n        mx[ind] = max(mx[2*ind],mx[2*ind+1]);\n        mn[ind] = min(mn[2*ind], mn[2*ind+1]);\n        ab[ind] = max(ab[2*ind], ab[2*ind+1]);\n        ab[ind] = max(ab[ind], mx[2*ind]-2*mn[2*ind+1]);\n        cb[ind] = max(cb[2*ind], cb[2*ind+1]);\n        cb[ind] = max(cb[ind], mx[2*ind+1]-2*mn[2*ind]);\n        ansval[ind] = max(ansval[2*ind], ansval[2*ind+1]);\n        ansval[ind] = max(ansval[ind], ab[2*ind]+mx[2*ind+1]);\n        ansval[ind] = max(ansval[ind], cb[2*ind+1]+mx[2*ind]);\n    }\n    \n    void build() {\n        FORd(i,1,SZ) pull(i);\n    }\n    \n    // Good up to here\n    \n    array<T, 5> qansval(ll lo, ll hi, ll ind = 1, ll L = 0, ll R = SZ-1){\n        push(ind, L, R);\n        T anses[5]; // ansval, ab, cb, mx, mn\n        if (lo > R || L > hi) return {0, 0, 0, 0, INF};\n        if (lo <= L && R <= hi) return {ansval[ind], ab[ind], cb[ind], mx[ind], mn[ind]};\n        ll M = (L+R)/2;\n        T ransval, rab, rcb, rmx, rmn;\n        array<T, 5> lanses = qansval(lo, hi, 2*ind, L, M);\n        array<T, 5> ranses = qansval(lo, hi, 2*ind+1, M+1, R);\n        rmx = max(lanses[3], ranses[3]);\n        \n        rmn = min(lanses[4], ranses[4]);\n        \n        rab = max(lanses[1], ranses[1]);\n        rab = max(rab, lanses[3]-2*ranses[4]);\n        \n        rcb = max(lanses[2], ranses[2]);\n        rcb = max(rcb, ranses[3]-2*lanses[4]);\n        \n        ransval = max(lanses[0], ranses[0]);\n        ransval = max(ransval, lanses[1]+ranses[3]);\n        ransval = max(ransval, ranses[2]+lanses[3]);\n        return {ransval, rab, rcb, rmx, rmn};\n    }\n    T qsum(ll lo, ll hi, ll ind = 1, ll L = 0, ll R = SZ-1) {\n        push(ind,L,R);\n        if (lo > R || L > hi) return 0;\n        if (lo <= L && R <= hi) return sum[ind];\n        \n        ll M = (L+R)/2;\n        return qsum(lo,hi,2*ind,L,M) + qsum(lo,hi,2*ind+1,M+1,R);\n    }\n\n    T qmax(ll lo, ll hi, ll ind = 1, ll L = 0, ll R = SZ-1) {\n        push(ind,L,R);\n        if (lo > R || L > hi) return 0;\n        if (lo <= L && R <= hi) return mx[ind];\n        \n        ll M = (L+R)/2;\n        return max(qmax(lo,hi,2*ind,L,M), qmax(lo,hi,2*ind+1,M+1,R));\n    }\n    \n    void upd(ll lo, ll hi, ll inc, ll ind = 1, ll L = 0, ll R = SZ-1) {\n        push(ind,L,R);\n        if (hi < L || R < lo) return;\n        if (lo <= L && R <= hi) {\n            lazy[ind] = inc;\n            push(ind,L,R);\n            return;\n        }\n        \n        ll M = (L+R)/2;\n        upd(lo,hi,inc,2*ind,L,M); upd(lo,hi,inc,2*ind+1,M+1,R);\n        pull(ind);\n    }\n};\n\nvector<pair<ll ,ll>> edges[100005];\nll par[100005];\nll indcount = 0;\nll matchind[200009];\npi firstlast[100005];\nll firstdepths[100005];\nLazySegTree<ll, 2622144> treedeps;\nvector<pair<pair<ll ,ll>, ll>> edges1;\nvoid assignpar(ll a){\n    for(auto u: edges[a]){\n    \t//cout << a << \" \" << u.f << \"\\n\";\n        if(par[a] == u.f) continue;\n        par[u.f] = a;\n        assignpar(u.f);\n    }\n}\n\nvoid setindex(ll a){\n    matchind[indcount] = a;\n    firstlast[a].s = indcount;\n    if(firstlast[a].f == 0) firstlast[a].f = indcount;\n    indcount++;\n    for(auto u: edges[a]){\n        if(par[a] == u.f) continue;\n        setindex(u.f);\n        matchind[indcount] = a;\n        firstlast[a].s = indcount;\n        if(firstlast[a].f == 0) firstlast[a].f = indcount;\n        indcount++;\n    }\n}\nvoid setdepth(ll a){\n    for(auto u: edges[a]){\n        if(par[a] == u.f) continue;\n        firstdepths[u.f] = firstdepths[a] + u.s;\n        setdepth(u.f);\n    }\n}\n\nint main() {\n    setIO();\n    ll n, q;\n    ll w;\n    cin >> n >> q >> w;\n    for(ll i = 0; i < n-1; i++){\n        ll a, b;\n        ll c;\n        cin >> a >> b >> c;\n        edges[a].pb(mp(b, c));\n        edges[b].pb(mp(a, c));\n        edges1.pb(mp(mp(a, b), c));\n    }\n    assignpar(1);\n    setindex(1);\n    setdepth(1);\n    firstlast[1].f = 0;\n    for(ll i = 0; i <= (n-1)*2; i++){\n        treedeps.upd(i, i, firstdepths[matchind[i]]);\n    }\n    ll last = 0;\n    \n    /*for(ll i = 1; i <= 10; i++){\n    \t//cout << par[i] << \"\\n\";\n    }*/\n    \n    for(ll i =0; i < q; i++){\n    \tll d;\n    \tll e;\n    \tcin >> d >> e;\n    \tll dp = (d+(last % (n-1))) % (n-1);\n    \tll ep = (e+(last % w)) % w;\n    \tll pind;\n    \tif(par[edges1[dp].f.f] == edges1[dp].f.s) pind = edges1[dp].f.f;\n    \telse pind = edges1[dp].f.s;\n    \ttreedeps.upd(firstlast[pind].f, firstlast[pind].s, ep-edges1[dp].s);\n    \tedges1[dp].s = ep;\n    \t\n    \tlast = (treedeps.qansval(0, (n-1)*2))[0];\n    \tcout << last << \"\\n\";\n    }\n    /*\n    Plan: \n    1. Calculate depth of every node - DONE\n    2. Make lazy segment tree that handles addition to a subtree (update) and query = a-2*b+c - DONE\n    3.1 build the initial tree\n    3. Query across entire tree and update accordingly\n    */\n    \n}\n\n/* stuff you should look for\n    * ll overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n",
    "ext": "cpp"
  },
  "57863631": {
    "code": "#ifdef _LOCAL\n//#include \"debug.h\"\n#else\n//#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC optimize(\"-O3\")\n//#pragma GCC optimize(\"Ofast\")\n#endif\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\n#define sz(x) int(x.size())\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int>\n#define PB push_back\n#define MP make_pair\n#define pll pair<ll,ll>\n#define pii pair<int,int>\n#define pil pair<int,ll>\n#define F first\n#define S second\nusing namespace std;\nusing namespace __gnu_cxx;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef long double ld;\ntemplate<class T>\nusing ordered_set = tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\nconst int N = 100100;\nconst int K = 10100;\nconst int oo = 2e9;\nconst ll OO = 1e18;\nconst int PW = 20;\nconst int md = 998244353;\nmultiset<ll> st[N],ST;\nvector<int> vec[N],cd[N],vc[N],tin[N],tout[N],tp[N];\nvector<ll> mx[N],psh[N],dst[N];\nll Z[N],DST[N],last=0,val[N][PW],w;\nint n,q,sz[N],X[N],Y[N],h[N],start,kol[N],PR[N];\nbool mrk[N];\n\nvoid build_sz(int v,int p){\n    sz[v]=1;\n    for (int i : vec[v]){\n        int u=X[i];\n        if (u==v) u=Y[i];\n        if (mrk[u] || u==p) continue;\n        build_sz(u,v); sz[v]+=sz[u];\n    }\n}\n\nint FIND(int v,int p,int SZ){\n    for (int i : vec[v]){\n        int u=X[i];\n        if (u==v) u=Y[i];\n        if (mrk[u] || u==p) continue;\n        if (sz[u]>SZ/2)\n            return FIND(u,v,SZ);\n    }\n    return v;\n}\n\nvoid dfs(int v,int p){\n    tin[v].PB(sz(vc[start])); vc[start].PB(v);\n    dst[start].PB(DST[v]);\n    for (int i : vec[v]){\n        int u=X[i];\n        if (u==v) u=Y[i];\n        if (mrk[u] || u==p) continue;\n        DST[u]=DST[v]+Z[i];\n        if (v==start)\n            tp[u].PB(u);\n        else tp[u].PB(tp[v].back());\n        dfs(u,v);\n    }\n    tout[v].PB(sz(vc[start])); vc[start].PB(v);\n    dst[start].PB(DST[v]);\n}\n\nvoid build(int nm,int v,int l,int r){\n    if (sz(mx[nm])<=v) {\n        mx[nm].resize(v+1);\n        psh[nm].resize(v+1);\n    }\n    psh[nm][v]=0ll;\n    if (l==r) {\n        mx[nm][v]=dst[nm][l]; return;\n    }\n    int md=(l+r)>>1;\n    build(nm,v+v,l,md);\n    build(nm,v+v+1,md+1,r);\n    mx[nm][v]=max(mx[nm][v+v],mx[nm][v+v+1]);\n}\n\ninline void push(int nm,int v){\n    if (psh[nm][v]!=0){\n        mx[nm][v]+=psh[nm][v];\n        if (v+v+1<sz(mx[nm])){\n            psh[nm][v+v]+=psh[nm][v];\n            psh[nm][v+v+1]+=psh[nm][v];\n        }\n        psh[nm][v]=0;\n    }\n}\n\nll MAX(int nm,int v,int tl,int tr,int l,int r){\n    if (l>r) return -OO;\n    push(nm,v);\n    if (tl==l && tr==r) return mx[nm][v];\n    int md=(tl+tr)>>1;\n    return max(MAX(nm,v+v,tl,md,l,min(r,md)),\n               MAX(nm,v+v+1,md+1,tr,max(l,md+1),r));\n}\n\nvoid build_cd(int v,int p){\n    build_sz(v,p);\n    v=FIND(v,p,sz[v]);\n    if (p>=0) {\n        cd[p].PB(v); h[v]=h[p]+1;\n    }\n    PR[v]=p;\n    if (sz[v]==1) return;\n    start=v; DST[v]=0ll; dfs(v,-1);\n    build(v,1,0,sz(vc[v])-1);\n    mrk[v]=1; st[v].clear();\n    for (int i : vec[v]){\n        int u=X[i];\n        if (u==v) u=Y[i];\n        if (mrk[u]) continue;\n        val[u][h[v]]=MAX(v,1,0,sz(vc[v])-1,tin[u].back(),tout[u].back());\n        st[v].insert(val[u][h[v]]);\n    }\n    ll res=(*(--st[v].end()));\n    if (sz(st[v])>1) res+=(*(--(--st[v].end())));\n    ST.insert(res);\n    for (int i : vec[v]){\n        int u=X[i];\n        if (u==v) u=Y[i];\n        if (!mrk[u]) build_cd(u,v);\n    }\n}\n\nvoid update(int nm,int v,int tl,int tr,int l,int r,ll vl){\n    if (l>r) return;\n    push(nm,v);\n    if (tl==l && tr==r) { psh[nm][v]+=vl; return; }\n    int md=(tl+tr)>>1;\n    update(nm,v+v,tl,md,l,min(r,md),vl);\n    update(nm,v+v+1,md+1,tr,max(md+1,l),r,vl);\n    push(nm,v+v); push(nm,v+v+1);\n    mx[nm][v]=max(mx[nm][v+v],mx[nm][v+v+1]);\n}\n\nvoid Update(int nm,int ed,ll cst){\n    if (nm<0) return;\n    ll res=(*(--st[nm].end()));\n    if (sz(st[nm])>1) res+=(*(--(--st[nm].end())));\n    ST.erase(ST.find(res));\n    int H=h[nm];\n    int cur=(tin[X[ed]][H]<tin[Y[ed]][H] ? Y[ed] : X[ed]);\n    int tip=tp[cur][H];\n    st[nm].erase(st[nm].find(val[tip][H]));\n    update(nm,1,0,sz(vc[nm])-1,tin[cur][H],tout[cur][H],cst-Z[ed]);\n    val[tip][H]=MAX(nm,1,0,sz(vc[nm])-1,tin[tip][H],tout[tip][H]);\n    st[nm].insert(val[tip][H]);\n    res=(*(--st[nm].end()));\n    if (sz(st[nm])>1) res+=(*(--(--st[nm].end())));\n    ST.insert(res);\n    Update(PR[nm],ed,cst);\n}\n\nint main() {\n#ifndef _LOCAL\n//    freopen(\"cardgame.in\",\"r\",stdin); freopen(\"cardgame.out\",\"w\",stdout);\n\tios_base::sync_with_stdio(0); cin.tie(0);\n#else\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n    cin>>n>>q>>w;\n    for (int i=1;i<n;i++){\n        cin>>X[i]>>Y[i]>>Z[i]; X[i]--; Y[i]--;\n        vec[X[i]].PB(i); vec[Y[i]].PB(i);\n    }\n    build_cd(0,-1);\n    for (;q;q--){\n        ll d,e; cin>>d>>e;\n        d=(d+last)%(ll(n)-1ll); d++;\n        e=(e+last)%w;\n        Update((h[X[d]]<h[Y[d]] ? X[d] : Y[d]),d,e);\n        Z[d]=e; last=(*(--ST.end()));\n        cout<<last<<'\\n';\n    }\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57863622": {
    "code": "#ifdef _LOCAL\n//#include \"debug.h\"\n#else\n//#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC optimize(\"-O3\")\n//#pragma GCC optimize(\"Ofast\")\n#endif\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\n#define sz(x) int(x.size())\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int>\n#define PB push_back\n#define MP make_pair\n#define pll pair<ll,ll>\n#define pii pair<int,int>\n#define pil pair<int,ll>\n#define F first\n#define S second\nusing namespace std;\nusing namespace __gnu_cxx;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef long double ld;\ntemplate<class T>\nusing ordered_set = tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\nconst int N = 100100;\nconst int K = 10100;\nconst int oo = 2e9;\nconst ll OO = 1e18;\nconst int PW = 20;\nconst int md = 998244353;\nmultiset<ll> st[N],ST;\nvector<ll> vec[N],cd[N],vc[N],tin[N],tout[N],tp[N];\nvector<ll> mx[N],psh[N],dst[N];\nll Z[N],DST[N],last=0,val[N][PW];\nll n,q,w,sz[N],X[N],Y[N],h[N],start,PR[N];\nbool mrk[N];\n\nvoid build_sz(int v,int p){\n    sz[v]=1;\n    for (int i : vec[v]){\n        int u=X[i];\n        if (u==v) u=Y[i];\n        if (mrk[u] || u==p) continue;\n        build_sz(u,v); sz[v]+=sz[u];\n    }\n}\n\nint FIND(int v,int p,int SZ){\n    for (int i : vec[v]){\n        int u=X[i];\n        if (u==v) u=Y[i];\n        if (mrk[u] || u==p) continue;\n        if (sz[u]>SZ/2)\n            return FIND(u,v,SZ);\n    }\n    return v;\n}\n\nvoid dfs(int v,int p){\n    tin[v].PB(sz(vc[start])); vc[start].PB(v);\n    dst[start].PB(DST[v]);\n    for (int i : vec[v]){\n        int u=X[i];\n        if (u==v) u=Y[i];\n        if (mrk[u] || u==p) continue;\n        DST[u]=DST[v]+Z[i];\n        if (v==start)\n            tp[u].PB(u);\n        else tp[u].PB(tp[v].back());\n        dfs(u,v);\n    }\n    tout[v].PB(sz(vc[start])); vc[start].PB(v);\n    dst[start].PB(DST[v]);\n}\n\nvoid build(int nm,int v,int l,int r){\n    if (sz(mx[nm])<=v) {\n        mx[nm].resize(v+1);\n        psh[nm].resize(v+1);\n    }\n    psh[nm][v]=0ll;\n    if (l==r) {\n        mx[nm][v]=dst[nm][l]; return;\n    }\n    int md=(l+r)>>1;\n    build(nm,v+v,l,md);\n    build(nm,v+v+1,md+1,r);\n    mx[nm][v]=max(mx[nm][v+v],mx[nm][v+v+1]);\n}\n\ninline void push(int nm,int v){\n    if (psh[nm][v]!=0){\n        mx[nm][v]+=psh[nm][v];\n        if (v+v+1<sz(mx[nm])){\n            psh[nm][v+v]+=psh[nm][v];\n            psh[nm][v+v+1]+=psh[nm][v];\n        }\n        psh[nm][v]=0;\n    }\n}\n\nll MAX(int nm,int v,int tl,int tr,int l,int r){\n    if (l>r) return -OO;\n    push(nm,v);\n    if (tl==l && tr==r) return mx[nm][v];\n    int md=(tl+tr)>>1;\n    return max(MAX(nm,v+v,tl,md,l,min(r,md)),\n               MAX(nm,v+v+1,md+1,tr,max(l,md+1),r));\n}\n\nvoid build_cd(int v,int p){\n    build_sz(v,p);\n    v=FIND(v,p,sz[v]);\n    if (p>=0) {\n        cd[p].PB(v); h[v]=h[p]+1;\n    }\n    PR[v]=p;\n    if (sz[v]==1) return;\n    start=v; DST[v]=0ll; dfs(v,-1);\n    build(v,1,0,sz(vc[v])-1);\n    mrk[v]=1; st[v].clear();\n    for (int i : vec[v]){\n        int u=X[i];\n        if (u==v) u=Y[i];\n        if (mrk[u]) continue;\n        val[u][h[v]]=MAX(v,1,0,sz(vc[v])-1,tin[u].back(),tout[u].back());\n        st[v].insert(val[u][h[v]]);\n    }\n    ll res=(*(--st[v].end()));\n    if (sz(st[v])>1) res+=(*(--(--st[v].end())));\n    ST.insert(res);\n    for (int i : vec[v]){\n        int u=X[i];\n        if (u==v) u=Y[i];\n        if (!mrk[u]) build_cd(u,v);\n    }\n}\n\nvoid update(int nm,int v,int tl,int tr,int l,int r,ll vl){\n    if (l>r) return;\n    push(nm,v);\n    if (tl==l && tr==r) { psh[nm][v]+=vl; return; }\n    int md=(tl+tr)>>1;\n    update(nm,v+v,tl,md,l,min(r,md),vl);\n    update(nm,v+v+1,md+1,tr,max(md+1,l),r,vl);\n    push(nm,v+v); push(nm,v+v+1);\n    mx[nm][v]=max(mx[nm][v+v],mx[nm][v+v+1]);\n}\n\nvoid Update(int nm,int ed,ll cst){\n    if (nm<0) return;\n    ll res=(*(--st[nm].end()));\n    if (sz(st[nm])>1) res+=(*(--(--st[nm].end())));\n    ST.erase(ST.find(res));\n    int H=h[nm];\n    int cur=(tin[X[ed]][H]<tin[Y[ed]][H] ? Y[ed] : X[ed]);\n    int tip=tp[cur][H];\n    st[nm].erase(st[nm].find(val[tip][H]));\n    update(nm,1,0,sz(vc[nm])-1,tin[cur][H],tout[cur][H],cst-Z[ed]);\n    val[tip][H]=MAX(nm,1,0,sz(vc[nm])-1,tin[tip][H],tout[tip][H]);\n    st[nm].insert(val[tip][H]);\n    res=(*(--st[nm].end()));\n    if (sz(st[nm])>1) res+=(*(--(--st[nm].end())));\n    ST.insert(res);\n    Update(PR[nm],ed,cst);\n}\n\nint main() {\n#ifndef _LOCAL\n//    freopen(\"cardgame.in\",\"r\",stdin); freopen(\"cardgame.out\",\"w\",stdout);\n\tios_base::sync_with_stdio(0); cin.tie(0);\n#else\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n    cin>>n>>q>>w;\n    for (int i=1;i<n;i++){\n        cin>>X[i]>>Y[i]>>Z[i]; X[i]--; Y[i]--;\n        vec[X[i]].PB(i); vec[Y[i]].PB(i);\n    }\n    build_cd(0,-1);\n    for (;q;q--){\n        ll d,e; cin>>d>>e;\n        d=(d+last)%(ll(n)-1ll); d++;\n        e=(e+last)%w;\n        Update((h[X[d]]<h[Y[d]] ? X[d] : Y[d]),d,e);\n        Z[d]=e; last=(*(--ST.end()));\n        cout<<last<<'\\n';\n    }\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57863078": {
    "code": "#ifdef _LOCAL\n//#include \"debug.h\"\n#else\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"-O3\")\n#pragma GCC optimize(\"Ofast\")\n#endif\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\n#define sz(x) ll(x.size())\n#define all(x) x.begin(),x.end()\n#define pii pair<ll,ll>\n#define PB push_back\n#define MP make_pair\n#define pll pair<ll,ll>\n#define pii pair<ll,ll>\n#define pil pair<ll,ll>\n#define F first\n#define S second\nusing namespace std;\nusing namespace __gnu_cxx;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef long double ld;\ntemplate<class T>\nusing ordered_set = tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\nconst ll N = 100100;\nconst ll K = 10100;\nconst ll oo = 2e9;\nconst ll OO = 1e18;\nconst ll PW = 20;\nconst ll md = 998244353;\nmultiset<ll> st[N],ST;\nvector<ll> vec[N],cd[N],vc[N],tin[N],tout[N],tp[N];\nvector<ll> mx[N],psh[N],dst[N];\nll Z[N],DST[N],last=0,val[N][PW];\nll n,q,w,sz[N],X[N],Y[N],h[N],start,kol[N],PR[N];\nbool mrk[N];\n\nvoid build_sz(ll v,ll p){\n    sz[v]=1;\n    for (ll i : vec[v]){\n        ll u=X[i];\n        if (u==v) u=Y[i];\n        if (mrk[u] || u==p) continue;\n        build_sz(u,v); sz[v]+=sz[u];\n    }\n}\n\nll FIND(ll v,ll p,ll SZ){\n    for (ll i : vec[v]){\n        ll u=X[i];\n        if (u==v) u=Y[i];\n        if (mrk[u] || u==p) continue;\n        if (sz[u]>SZ/2)\n            return FIND(u,v,SZ);\n    }\n    return v;\n}\n\nvoid dfs(ll v,ll p){\n    tin[v].PB(sz(vc[start])); vc[start].PB(v);\n    dst[start].PB(DST[v]);\n    for (ll i : vec[v]){\n        ll u=X[i];\n        if (u==v) u=Y[i];\n        if (mrk[u] || u==p) continue;\n        DST[u]=DST[v]+Z[i];\n        if (v==start)\n            tp[u].PB(u);\n        else tp[u].PB(tp[v].back());\n        dfs(u,v);\n    }\n    tout[v].PB(sz(vc[start])); vc[start].PB(v);\n    dst[start].PB(DST[v]);\n}\n\nvoid build(ll nm,ll v,ll l,ll r){\n    if (sz(mx[nm])<=v) {\n        mx[nm].resize(v+1);\n        psh[nm].resize(v+1);\n    }\n    psh[nm][v]=0ll;\n    if (l==r) {\n        mx[nm][v]=dst[nm][l]; return;\n    }\n    ll md=(l+r)>>1;\n    build(nm,v+v,l,md);\n    build(nm,v+v+1,md+1,r);\n    mx[nm][v]=max(mx[nm][v+v],mx[nm][v+v+1]);\n}\n\ninline void push(ll nm,ll v){\n    if (psh[nm][v]!=0){\n        mx[nm][v]+=psh[nm][v];\n        if (v+v+1<sz(mx[nm])){\n            psh[nm][v+v]+=psh[nm][v];\n            psh[nm][v+v+1]+=psh[nm][v];\n        }\n        psh[nm][v]=0;\n    }\n}\n\nll MAX(ll nm,ll v,ll tl,ll tr,ll l,ll r){\n    if (l>r) return -OO;\n    push(nm,v);\n    if (tl==l && tr==r) return mx[nm][v];\n    ll md=(tl+tr)>>1;\n    return max(MAX(nm,v+v,tl,md,l,min(r,md)),\n               MAX(nm,v+v+1,md+1,tr,max(l,md+1),r));\n}\n\nvoid build_cd(ll v,ll p){\n    build_sz(v,p);\n    v=FIND(v,p,sz[v]);\n    if (p>=0) {\n        cd[p].PB(v); h[v]=h[p]+1;\n    }\n    PR[v]=p;\n    if (sz[v]==1) return;\n    start=v; DST[v]=0ll; dfs(v,-1);\n    build(v,1,0,sz(vc[v])-1);\n    mrk[v]=1; st[v].clear();\n    for (ll i : vec[v]){\n        ll u=X[i];\n        if (u==v) u=Y[i];\n        if (mrk[u]) continue;\n        val[u][h[v]]=MAX(v,1,0,sz(vc[v])-1,tin[u].back(),tout[u].back());\n        st[v].insert(val[u][h[v]]);\n    }\n    ll res=(*(--st[v].end()));\n    if (sz(st[v])>1) res+=(*(--(--st[v].end())));\n    ST.insert(res);\n    for (ll i : vec[v]){\n        ll u=X[i];\n        if (u==v) u=Y[i];\n        if (!mrk[u]) build_cd(u,v);\n    }\n}\n\nvoid update(ll nm,ll v,ll tl,ll tr,ll l,ll r,ll vl){\n    if (l>r) return;\n    push(nm,v);\n    if (tl==l && tr==r) { psh[nm][v]+=vl; return; }\n    ll md=(tl+tr)>>1;\n    update(nm,v+v,tl,md,l,min(r,md),vl);\n    update(nm,v+v+1,md+1,tr,max(md+1,l),r,vl);\n    push(nm,v+v); push(nm,v+v+1);\n    mx[nm][v]=max(mx[nm][v+v],mx[nm][v+v+1]);\n}\n\nvoid Update(ll nm,ll ed,ll cst){\n    if (nm<0) return;\n    ll res=(*(--st[nm].end()));\n    if (sz(st[nm])>1) res+=(*(--(--st[nm].end())));\n    ST.erase(ST.find(res));\n    ll H=h[nm];\n    ll cur=(tin[X[ed]][H]<tin[Y[ed]][H] ? Y[ed] : X[ed]);\n    ll tip=tp[cur][H];\n    st[nm].erase(st[nm].find(val[tip][H]));\n    update(nm,1,0,sz(vc[nm])-1,tin[cur][H],tout[cur][H],cst-Z[ed]);\n    val[tip][H]=MAX(nm,1,0,sz(vc[nm])-1,tin[tip][H],tout[tip][H]);\n    st[nm].insert(val[tip][H]);\n    res=(*(--st[nm].end()));\n    if (sz(st[nm])>1) res+=(*(--(--st[nm].end())));\n    ST.insert(res);\n    Update(PR[nm],ed,cst);\n}\n\nint main() {\n#ifndef _LOCAL\n//    freopen(\"cardgame.in\",\"r\",stdin); freopen(\"cardgame.out\",\"w\",stdout);\n\tios_base::sync_with_stdio(0); cin.tie(0);\n#else\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n    cin>>n>>q>>w;\n    for (ll i=1;i<n;i++){\n        cin>>X[i]>>Y[i]>>Z[i]; X[i]--; Y[i]--;\n        vec[X[i]].PB(i); vec[Y[i]].PB(i);\n    }\n    build_cd(0,-1);\n    for (;q;q--){\n        ll d,e; cin>>d>>e;\n        d=(d+last)%(ll(n)-1ll); d++;\n        e=(e+last)%w;\n        Update((h[X[d]]<h[Y[d]] ? X[d] : Y[d]),d,e);\n        Z[d]=e; last=(*(--ST.end()));\n        cout<<last<<'\\n';\n    }\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57861703": {
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nint gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);}\n\n#define ll long long\n#define pb push_back\n#define ld long double\n#define mp make_pair\n#define F first\n#define S second\n#define pii pair<ll,ll> \n\nusing namespace :: std;\n\nconst ll maxn=1e5+500;\n\nstruct M {\n\tll lazy;\n\tll a,b,ab,bc,abc;\n};\n\nM seg[maxn*8];\n\nM merge(M a,M b){\n\tM ans;\n\tans.lazy=0;\n\tans.a=max(a.a,b.a);\n\tans.b=max(a.b,b.b);\n\tans.ab=max(a.a+b.b,max(a.ab,b.ab));\n\tans.bc=max(a.b+b.a,max(a.bc,b.bc));\n\tans.abc=max(max(a.abc,b.abc),max(a.a+b.bc,a.ab+b.a));\n\treturn ans;\n}\nvoid put(ll a,ll v){\n\tseg[a].lazy+=v;\n\tseg[a].a+=v;\n\tseg[a].b-=2*v;\n\tseg[a].ab-=v;\n\tseg[a].bc-=v;\n}\nvoid shift(ll a){\n\tput(2*a,seg[a].lazy);\n\tput(2*a+1,seg[a].lazy);\n\tseg[a].lazy=0;\n}\t\nvoid update(ll L,ll R,ll node,ll l,ll r,ll v){\n\tif(l<=L && R<=r){\n\t\tput(node,v);\n\t\treturn;\n\t}\n\tif(r<=L || R<=l)return;\n\tll mid=(L+R)/2;\n\tshift(node);\n\tupdate(L,mid,2*node,l,r,v);\n\tupdate(mid,R,2*node+1,l,r,v);\n\tseg[node]=merge(seg[2*node],seg[2*node+1]);\n}\n\nvector<ll> ger[maxn];\nll a[maxn];\nll b[maxn];\nll c[maxn];\n\nll st[maxn];\nll et[maxn];\nll tt=0;\n\nvoid dfs(ll v,ll p=-1){\n\ttt++;\n\tfor(auto e:ger[v]){\n\t\tll u=(v^a[e]^b[e]);\n\t\tif(u!=p){\n\t\t\tst[e]=tt;\n\t\t\tdfs(u,v);\n\t\t\tet[e]=tt;\n\t\t\ttt++;\n\t\t}\n\t}\n}\nvoid bild(ll n){\n\tdfs(1);\n\tfor(ll i=0;i<n-1;i++){\n\t\tupdate(0,tt,1,st[i],et[i],c[i]);\n\t}\n}\nll update(ll d,ll e){\n\tupdate(0,tt,1,st[d],et[d],e-c[d]);\n\tc[d]=e;\n\treturn seg[1].abc;\n}\nint main(){\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\t\n\tll n,q,w;\n\tcin>>n>>q>>w;\n\tfor(ll i=0;i+1<n;i++){\n\t\tcin>>a[i]>>b[i]>>c[i];\n\t\tif(a[i]>b[i])swap(a[i],b[i]);\n\t\tger[a[i]].pb(i);\n\t\tger[b[i]].pb(i);\n\t}\n\tbild(n);\n\tll last=0;\n\tfor(ll i=0;i<q;i++){\n\t\tll d,e;\n\t\tcin>>d>>e;\n\t\td=(d+last)%(n-1);\n\t\te=(e+last)%w;\n\t\tlast=update(d,e);\n\t\tcout<<last<<endl;\n\t}\n}\n",
    "ext": "cpp"
  },
  "57859662": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> ii; \n\nconst int N = 1e5 + 10; \n\nstruct Node {\n    ll d, a, b, c, ab, bc, abc; \n    Node(ll d=0, ll a=0, ll b=0, ll c=0, ll ab=0, ll bc=0, ll abc=0) :\n        d(d), a(a), b(b), c(c), ab(ab), bc(bc), abc(abc) {}\n    Node shift(ll del) {\n        return Node(d+del, a+del, b-2*del, c+del, ab-del, bc-del, abc);\n    }\n} t[N << 3]; \n\nint n, m, q, in[N], out[N], l[N], r[N], idx; \nvector<int> adj[N];\nll w[N], W; \n\nNode merge(Node L, Node R) {\n    R = R.shift(L.d);\n   \n    Node ret; \n    ret.d = R.d; \n    ret.a = max(L.a, R.a); \n    ret.b = max(L.b, R.b); \n    ret.c = max(L.c, R.c); \n    ret.ab = max({L.ab, R.ab, L.a + R.b});\n    ret.bc = max({L.bc, R.bc, L.b + R.c}); \n    ret.abc = max({L.abc, R.abc, L.ab + R.c, L.a + R.bc});\n\n    return ret; \n}\n\nvoid update(int node, int l, int r, int i, ll x) {\n    if(l == r) {\n        t[node] = Node(x, x, -2 * x, x, -x, -x, 0);\n    } else {\n        int m = l + r >> 1; \n        if(i <= m) update(node << 1, l, m, i, x); \n        else update(node << 1 | 1, m + 1, r, i, x); \n        t[node] = merge(t[node << 1], t[node << 1 | 1]);\n    }\n}\n\nvoid dfs(int u, int p) {\n    for(int i : adj[u]) {\n        int v = l[i] ^ r[i] ^ u;\n        if(v == p) continue; \n        update(1, 1, m, ++idx, w[i]);\n        in[i] = idx; \n        dfs(v, u); \n        update(1, 1, m, ++idx, -w[i]);\n        out[i] = idx;\n    }\n}\n\nint main(int argc, char const *argv[]) {\n    scanf(\"%d %d %lld\", &n, &q, &W);\n    for(int i = 0; i < n - 1; ++i) {\n        scanf(\"%d %d %lld\", &l[i], &r[i], &w[i]);\n        adj[l[i]].push_back(i);\n        adj[r[i]].push_back(i);\n    }\n\n    m = 2 * (n - 1);\n    dfs(1, 0);\n\n    ll last = 0; \n\n    while(q--) {\n        int i; ll e; \n        scanf(\"%d %lld\", &i, &e); \n        i = (i + last) % (n - 1); \n        e = (e + last) % W;\n\n        update(1, 1, m, in[i], e); \n        update(1, 1, m, out[i], -e); \n\n        printf(\"%lld\\n\", last = t[1].abc);\n    }\n}",
    "ext": "cpp"
  },
  "57856908": {
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define pb push_back\n\nconst int maxn = 2e5 + 20;\n\nstruct node\n{\n\tll val[4][4] , Add;\n\tnode()\n\t{\n\t\tmemset(val , 0 , sizeof val);\n\t\tAdd = 0;\n\t}\n};\n\nnode seg[maxn * 4];\n\nint n;\n\nconst int zarib[] = {1 , -2 , 1};\nint Z[4][4];\n\nvector<int> adj[maxn];\n\nnode merge(node a , node b)\n{\n\tnode c = a;\n\tc.Add = 0;\n\tfor(int l = 0; l < 3; l++)\n\t\tfor(int r = l + 1; r < 4; r++)\n\t\t\tfor(int k = l; k < r; k++)\n\t\t\t\tc.val[l][r] = max(c.val[l][r] , a.val[l][k] + b.val[k][r]);\n\treturn c;\n}\n\nvoid put(int v , ll val)\n{\n\tseg[v].Add += val;\n\tfor(int l = 0; l < 3; l++)\n\t\tfor(int r = l + 1; r < 4; r++)\n\t\t\tseg[v].val[l][r] += Z[l][r] * val;\n}\n\nvoid shift(int s , int e , int v)\n{\n\tif(e - s >= 2 && seg[v].Add)\n\t{\n\t\tput(2 * v , seg[v].Add);\n\t\tput(2 * v + 1 , seg[v].Add);\n\t}\n\tseg[v].Add = 0;\n}\n\nvoid add(int l , int r , ll val , int s = 0 , int e = 2 * n - 1 , int v = 1)\n{\n\tif(l <= s && e <= r)\n\t{\n\t\tput(v , val);\n\t\treturn;\n\t}\n\tif(r <= s || e <= l)\n\t\treturn;\n\n\tshift(s , e , v);\n\tint m = (s + e) / 2;\n\n\tadd(l , r , val , s , m , 2 * v);\n\tadd(l , r , val , m , e , 2 * v + 1);\n\n\tseg[v] = merge(seg[2 * v] , seg[2 * v + 1]);\n}\n\nint frst[maxn] , last[maxn] , id;\n\nint from[maxn] , to[maxn];\nll w[maxn] , h[maxn];\n\nvoid dfs(int v , int p = -1)\n{\n\tadd(id , id + 1 , h[v]);\n\tfrst[v] = last[v] = id++;\n\tfor(auto e : adj[v])\n\t{\n\t\tint u = from[e] ^ to[e] ^ v;\n\t\tif(u != p)\n\t\t{\n\t\t\th[u] = h[v] + w[e];\n\t\t\tdfs(u , v);\n\n\t\t\tadd(id , id + 1 , h[v]);\n\t\t\tlast[v] = id++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tfor(int l = 0; l < 3; l++)\n\t\tfor(int r = l + 1; r < 4; r++)\n\t\t\tZ[l][r] = Z[l][r - 1] + zarib[r - 1];\n\n\tint q;\n\tll W;\n\tcin >> n >> q >> W;\n\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint a , b;\n\t\tcin >> a >> b >> w[i];\n\t\ta-- , b--;\n\n\t\tadj[a].pb(i);\n\t\tadj[b].pb(i);\n\n\t\tfrom[i] = a , to[i] = b;\n\t}\n\n\tdfs(0);\n\n\tll lst = 0;\n\twhile(q--)\n\t{\n\t\tll e , nw;\n\t\tcin >> e >> nw;\n\t\te = (e + lst) % (n - 1);\n\t\tnw = (nw + lst) % W;\n\n\t\tint v = from[e] , u = to[e];\n\t\tif(h[v] < h[u])\n\t\t\tswap(v , u);\n\n\t\tadd(frst[v] , last[v] + 1 , nw - w[e]);\n\t\tw[e] = nw;\n\n\t\tlst = seg[1].val[0][3];\n\t\tcout << lst << endl;\n\t}\n}\n\n\n",
    "ext": "cpp"
  },
  "57856135": {
    "code": "    // Why do I need to ternarize and shave off a log factor?\n    //#pragma GCC optimize(\"O3\")\n    //#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\") // codeforces\n    #include <bits/stdc++.h>\n    using namespace std;\n \n    using ll = long long;\n    using ull = unsigned long long;\n    using fl = long double;\n    template<typename T>\n    using min_heap = priority_queue<T, vector<T>, greater<T>>;\n    template<typename S, typename T>\n    void xmin(S&a, T const&b){if(b<a) a=b;}\n    template<typename S, typename T>\n    void xmax(S&a, T const&b){if(b>a) a=b;}\n \n    template<bool enabled>\n    struct Debug{\n        template<typename S, typename T = void> struct Tag_Printable : false_type {};\n        template<typename S> struct Tag_Printable<S, decltype((void)(cerr << declval<S>()))> : true_type {};\n        template<typename S, typename T = void> struct Tag_Iterable: false_type {};\n        template<typename S> struct Tag_Iterable<S, decltype((void)(begin(declval<S>()), end(declval<S>())))> : true_type {};\n        template<typename T, typename... Args>\n        Debug& print(T const&x, true_type, Args...){\n            #ifdef LOCAL_RUN\n            if(enabled){\n                cerr << boolalpha << x;\n            }\n            #endif // LOCAL_RUN\n            return *this;\n        }\n        template<typename T>\n        Debug& print(T const&x, false_type, true_type){\n            *this << \"[\";\n            bool first = true;\n            for(auto &e:x){\n                if(!first) *this << \", \";\n                *this << e;\n                first = false;\n            }\n            return *this << \"]\";\n        }\n        template<typename S, typename T>\n        Debug& print(pair<S, T> const&x, false_type, false_type){\n            return *this << \"(\" << x.first << \", \" << x.second << \")\";\n        }\n        template<typename T>\n        Debug& operator<<(T const&x){\n            return print(x, Tag_Printable<T>{}, Tag_Iterable<T>{});\n        }\n    };\n    // Debug<true> debug;\n     Debug<false> debug; // disable debug printing\n    #define named(x) string(#x) << \" : \" <<  x\n \n \n    template<typename T>\n    struct Small_Set{\n        array<T, 5> data;\n        int size = 0;\n        T max(){\n            return *max_element(data.begin(), data.begin()+size);\n        }\n        bool empty(){\n            return size == 0;\n        }\n        void insert(T const&x){\n            data[size++] = x;\n        }\n        void erase(T const&x){\n            auto i = find(data.begin(), data.end(), x) - data.begin();\n            --size;\n            swap(data[i], data[size]);\n        }\n    };\n    struct LL{\n        ll val;\n        int index;\n        bool operator<(LL const&o) const{\n            return make_pair(val, index) < make_pair(o.val, o.index);\n        }\n        bool operator==(LL const&o) const {\n            return make_pair(val, index) == make_pair(o.val, o.index);\n        }\n        friend ostream& operator<<(ostream&o, LL const&a){\n            return o << \"(\" << a.val << \",\" << a.index << \")\";\n        }\n    };\n    LL operator+(LL const&a, ll const&x){\n        return LL{a.val+x, a.index};\n    }\n    LL operator+(ll const&x, LL const&a){\n        return a+x;\n    }\n \n    constexpr ll inf = 2e18;\n \n    struct Agg{\n        LL pre, suff;\n        ll sum;\n        int id;\n        Small_Set<LL> passive_ch;\n        LL ch_max(){\n            return passive_ch.empty() ? LL{0, id} : passive_ch.max();\n        }\n    };\n    const Agg NONE {LL{-inf, -1}, LL{-inf, -1}, 0, -1, {}};\n    // Link-cut tree with path aggregates\n    #define lct_assert(x) assert(x)\n    struct LinkCutTree{\n        struct Node{\n            Node*p=0, *pp=0, *c[2]={0, 0};\n            int id;\n            bool ev=0;\n            ll agg;\n            Agg sub_agg;\n            LL pp_up_val;\n            Node(int _id=-1):id(_id), agg(0), sub_agg{LL{0,id}, LL{0,id}, 0, id, {}} {}\n            void recalc(){\n                //assert(!ev);\n                auto L = c[0] ? c[0]->sub_agg : NONE;\n                auto R = c[1] ? c[1]->sub_agg : NONE;\n                if(c[0] && c[0]->ev) swap(L.pre,L.suff);\n                if(c[1] && c[1]->ev) swap(R.pre,R.suff);\n                sub_agg.sum = L.sum + agg + R.sum;\n                sub_agg.pre = max({\n                                  L.pre,\n                                  L.sum + agg + sub_agg.ch_max(),\n                                  L.sum + agg + R.pre\n                                  });\n                sub_agg.suff = max({\n                                   L.suff + agg + R.sum,\n                                   sub_agg.ch_max() + agg + R.sum,                               R.suff\n                                   });\n \n                for(int i:{0, 1})\n                    if(c[i]){\n                        c[i]->p=this;\n                    }\n            }\n            template<bool do_recalc>\n            LL get_upval() {\n                if(do_recalc) pp_up_val = ev ? sub_agg.suff : sub_agg.pre;\n                return pp_up_val;\n                //return ev ? sub_agg.suff : sub_agg.pre;\n            }\n            void add_passive_ch(LL x){\n                //debug << \"Add \" << id << \" : \" << x << \"\\n\";\n                sub_agg.passive_ch.insert(x);\n                recalc();\n            }\n            void rem_passive_ch(LL x){\n                //debug << \"Rem \" << id << \" : \" << x << \"\\n\";\n                sub_agg.passive_ch.erase(x);\n                recalc();\n            }\n            void push(){\n                if(ev){\n                    ev=0;\n                    swap(sub_agg.pre, sub_agg.suff);\n                    swap(c[0], c[1]);\n                    for(int i:{0, 1})\n                        if(c[i]) c[i]->ev^=1;\n                }\n            }\n            void unlink(int i){\n                lct_assert(c[i]);\n                c[i]->p=0;\n                c[i]=0;\n                recalc();\n            }\n            int up(){return p?p->c[1]==this:-1;}\n            void rot(){\n                swap(pp, p->pp);\n                swap(pp_up_val, p->pp_up_val);\n                int i = up(), j=p->up();\n                p->c[i]=c[!i];\n                c[!i]=p; p=p->p;\n                if(p) p->c[j]= this;\n                c[!i]->recalc(); recalc();\n                if(p) p->recalc();\n            }\n            Node* splay(){\n                for(push();p;){\n                    if(p->p) p->p->push();\n                    p->push(); push();\n                    if(p->up()==up())\n                        p->rot();\n                    rot();\n                }\n                return this;\n            }\n            Node*first(){\n                push();\n                return c[0]?c[0]->first():splay();\n            }\n        };\n        vector<Node> g;\n        LinkCutTree(size_t N){\n            g.reserve(N);\n            for(size_t i=0;i<N;++i)\n                g.emplace_back(i);\n        }\n        bool connected(int u, int v){\n            Node*x = access(&g[u])->first();\n            Node*y = access(&g[v])->first();\n            return x==y;\n        }\n        void link(int u, int p){\n            assert(0 <= u && u <(int)g.size());\n            lct_assert(!connected(u, p));\n            make_root(&g[u]);\n            access(&g[p]);\n            g[u].pp=&g[p];\n            g[p].add_passive_ch(g[u].get_upval<true>());\n        }\n        void cut_up(int u){\n            Node*x = &g[u];\n            access(x);\n            x->unlink(0);\n        }\n        /*void cut(int u, int v){\n            lct_assert(connected(u, v));\n            Node*x = &g[u],*y=&g[v];\n            make_root(x); make_root(y);\n            x->splay();\n            lct_assert(x->pp?y==x->pp:(y==x->c[0] || (x->c[0] && y==x->c[0]->c[0])));\n            if(x->pp) x->pp=0;\n            else x->unlink(0);\n        }*/\n        void make_root(Node*u){\n            access(u);\n            u->ev^=1;\n            access(u);\n        }\n        /// TODO\n        Node*access(Node*x){\n            Node*u = x;\n            u->splay();\n            while(Node*pp=u->pp){\n                pp->splay();\n                u->pp=0;\n                pp->rem_passive_ch(u->get_upval<false>());\n                if(pp->c[1]){\n                    pp->add_passive_ch(pp->c[1]->get_upval<true>());\n                    swap(pp->c[1]->p,pp->c[1]->pp);\n                }\n                pp->c[1]=u;\n                pp->recalc();\n                u=pp;\n            }\n            x->splay();\n            if(x->c[1]){\n                x->add_passive_ch(x->c[1]->get_upval<true>());\n                x->c[1]->pp=x;\n                x->unlink(1);\n            }\n            return u;\n        }\n        /*int lca(int u, int v){\n            access(&g[u]);\n            return access(&g[v])->id;\n        }\n        pair<int, int> pathagg(int u, int v){\n            make_root(&g[u]);\n            access(&g[v]);\n            return g[v].sub_agg;\n        }*/\n    \tvoid set_agg(int u, ll const& new_agg){\n    \t\taccess(&g[u]);\n    \t\tg[u].agg = new_agg;\n    \t\tg[u].recalc();\n    \t}\n    \tLL get_subagg_pre(int u){\n            make_root(&g[u]);\n            auto const ret = g[u].get_upval<true>();\n            debug << u << \": \" << ret << \"\\n\";\n            return ret;\n    \t}\n    };\n \n \n    void solve(){\n        /// SOLVE HERE\n \n        int n, q;\n        ll w;\n        cin >> n >> q >> w;\n        LinkCutTree lct(4*n);\n \n        vector<vector<int> > g(n+1);\n \n \n        for(int i=1;i<n;++i){\n            int a, b;\n            ll c;\n            cin >> a >> b >> c;\n            const int u = n+i;\n            g[a].push_back(u);\n            g[b].push_back(u);\n            lct.set_agg(u, c);\n            //lct.link(a, u);\n            //lct.link(b, u);\n        }\n        const int k = 3;\n        int pool = 2*n;\n        for(int i=1;i<=n;++i){\n            int x = i;\n            for(int j=0;j<(int)g[i].size();++j){\n                if((j+1) % k == 0){\n                    lct.link(x, ++pool);\n                    x = pool;\n                }\n                lct.link(x, g[i][j]);\n            }\n        }\n        for(int i=n;i<2*n;++i){\n            //lct.access(&lct.g[i]);\n        }\n \n        int u = 1;\n        ll last = 0;\n        for(int it=0;it<q;++it){\n            int d;\n            ll e;\n            cin >> d >> e;\n            d = (d+last)%(n-1)+1;\n            e = (e+last)%w;\n            lct.set_agg(n+d, e);\n            debug << \"Query: \" << d << \" \" << e << \"\\n\";\n            for(int it=0;it<2;++it){\n                auto tmp = lct.get_subagg_pre(u);\n                u = tmp.index;\n                assert(u != -1);\n                last = tmp.val;\n            }\n            cout << last << \"\\n\";\n        }\n    }\n \n    signed gen(int T){\n        mt19937 rng(43151);\n        auto get_rand = [&](int64_t l, int64_t r){\n            return uniform_int_distribution<int64_t>(l, r)(rng);\n        }; (void) get_rand;\n        auto get_double = [&](double l, double r){\n            return uniform_real_distribution<double>(l, r)(rng);\n        };  (void) get_double;\n        ofstream o(\"gen.txt\");\n        o << T << \"\\n\";\n        for(int cas=0;cas<T;++cas){\n            /// GEN HERE\n \n            o << \"\\n\";\n        }\n        o << endl;\n        o.close();\n        return 0;\n    }\n \n    signed main()\n    {\n        #ifdef LOCAL_RUN\n        freopen(\"in.txt\", \"r\", stdin);\n        //freopen(\"out.txt\", \"w\", stdout);\n        cin.exceptions(ios::badbit | ios::eofbit | ios::failbit);\n        cin.tie(0); ios_base::sync_with_stdio(false);\n        int TTT; cin >> TTT;\n    \tif(TTT < 0) return gen(-TTT);\n    \twhile(TTT--){\n        #else\n        cin.tie(0); ios_base::sync_with_stdio(false);\n        #endif // LOCAL_RUN\n \n        solve();\n \n        #ifdef LOCAL_RUN\n        cout << flush;\n        }\n        #endif // LOCAL_RUN\n        return 0;\n    }",
    "ext": "cpp"
  },
  "57855145": {
    "code": "// ItnoE\n#include<bits/stdc++.h>\n#define lc (id << 1)\n#define rc (lc ^ 1)\n#define md (l + r >> 1)\nusing namespace std;\ntypedef long long ll;\nconst int N = 200005;\nstruct Data {ll a, b, ab, bc, abc, lz;};\nint n, q, ts, St[N], Fn[N];\nll MW, W[N];\nData D[N * 4];\nvector < pair < int , int > > Adj[N];\ninline void Update(int id, ll val)\n{\n    D[id].a += val;\n    D[id].b += val;\n    D[id].ab -= val;\n    D[id].bc -= val;\n    D[id].lz += val;\n}\ninline void Shift(int id)\n{\n    Update(lc, D[id].lz);\n    Update(rc, D[id].lz);\n    D[id].lz = 0;\n}\nvoid Add(int le, int ri, ll val, int id = 1, int l = 0, int r = ts)\n{\n    if (ri <= l || r <= le)\n        return ;\n    if (le <= l && r <= ri)\n        return void(Update(id, val));\n    Shift(id);\n    Add(le, ri, val, lc, l, md);\n    Add(le, ri, val, rc, md, r);\n    D[id].a = max(D[lc].a, D[rc].a);\n    D[id].b = min(D[lc].b, D[rc].b);\n    D[id].ab = max({D[lc].ab, D[rc].ab, D[lc].a - D[rc].b * 2});\n    D[id].bc = max({D[lc].bc, D[rc].bc, D[rc].a - D[lc].b * 2});\n    D[id].abc = max({D[lc].abc, D[rc].abc, D[lc].a + D[rc].bc, D[lc].ab + D[rc].a});\n}\nvoid DFS(int v, int p)\n{\n    for (auto u : Adj[v])\n        if (u.first != p)\n        {\n            St[u.second] = ++ ts;\n            DFS(u.first, v);\n            Fn[u.second] = ++ ts;\n        }\n}\nint main()\n{\n    scanf(\"%d%d%lld\", &n, &q, &MW);\n    for (int i = 1; i < n; i ++)\n    {\n        int v, u; ll w;\n        scanf(\"%d%d%lld\", &v, &u, &W[i]);\n        Adj[v].push_back({u, i});\n        Adj[u].push_back({v, i});\n    }\n    DFS(1, 0);\n    for (int i = 1; i < n; i ++)\n        Add(St[i], Fn[i], W[i]);\n    for (ll last = 0; q; q --)\n    {\n        int i; ll w;\n        scanf(\"%d%lld\", &i, &w);\n        i = (last + i) % (n - 1) + 1;\n        w = (last + w) % MW;\n        Add(St[i], Fn[i], w - W[i]);\n        W[i] = w; last = D[1].abc;\n        printf(\"%lld\\n\", last);\n    }\n    return 0;\n}",
    "ext": "cpp"
  },
  "57854306": {
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pii pair<int,int> \n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\nconst int N=100005;\nint n,Q,nn,ps[N],L[N],R[N];ll k,ans,w[N];\nvector<pii>g[N];\nstruct st\n{\n\tll p,m,tg,lm,mr,lmr;\n\tinline void upd(ll v){p+=v;m-=2*v;lm-=v;mr-=v;tg+=v;}\n\tinline st operator+(const st&b)const\n\t{\n\t\tst c;c.p=max(p,b.p);c.m=max(m,b.m);\n\t\tc.lm=max(max(lm,b.lm),p+b.m);\n\t\tc.mr=max(max(mr,b.mr),m+b.p);\n\t\tc.lmr=max(max(lmr,b.lmr),max(lm+b.p,p+b.mr));\n\t\treturn c;\n\t}\n}T[N<<3];\nvoid upd(int x,int l,int r,int tl,int tr,ll v)\n{\n\tif(r<tl||tr<l)return;if(tl<=l&&r<=tr){T[x].upd(v);return;}\n\tT[x<<1].upd(T[x].tg);T[x<<1|1].upd(T[x].tg);T[x].tg=0;\n\tint mid=l+r>>1;upd(x<<1,l,mid,tl,tr,v);upd(x<<1|1,mid+1,r,tl,tr,v);\n\tT[x]=T[x<<1]+T[x<<1|1];\n}\nvoid dfs(int x,int p)\n{\n\tL[x]=++nn;\n\tfor(int i=0;i<g[x].size();i++)if(g[x][i].X!=p){ps[g[x][i].Y]=g[x][i].X;dfs(g[x][i].X,x);nn++;}\n\tR[x]=nn;\n} \nint main()\n{\n\tscanf(\"%d%d%lld\",&n,&Q,&k);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v;scanf(\"%d%d%lld\",&u,&v,&w[i]);\n\t\tg[u].pb(mp(v,i));g[v].pb(mp(u,i));\n\t}\n\tdfs(1,0);\n\tfor(int i=1;i<n;i++)upd(1,1,2*n,L[ps[i]],R[ps[i]],w[i]);\n\twhile(Q--)\n\t{\n\t\tll x,v;scanf(\"%lld%lld\",&x,&v);\n\t\tx=(x+ans)%(n-1)+1;v=(v+ans)%k;\n\t\tupd(1,1,2*n,L[ps[x]],R[ps[x]],v-w[x]);\n\t\tw[x]=v;printf(\"%lld\\n\",ans=T[1].lmr);\n\t}\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57852784": {
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mp make_pair\nusing namespace std;\nconst int maxn = 100100;\nconst int maxlog = 18;\nvector<pair<int,int> > g[maxn];\nll n, q, w;\n\nint br, euler[maxn];\nll cost[maxn];\nll dist[maxn];\n\nint opentt[maxn], sbtsizee[maxn];\n\nll aa[maxn], bb[maxn];\nll parent[maxn];\n\nbool deleted[maxn];\nint sbt[maxn], p[maxn];\n\nint open_node[maxlog][maxn];\nint opent[maxlog][maxn];\nint sbtsize[maxlog][maxn];\n\nint centroid_parent[maxn];\nint centroid_root[maxlog][maxn];\nint ttsize[maxn];\n\nmultiset<ll>ms[maxn], globalms;\n\nclass segment_tree{\npublic:\n\tvector<ll> tree, lazy;\n\tint sz;\n\n\tvoid init(int _sz) {\n\t\tsz = _sz;\n\t\ttree.resize(4*sz, 0);\n\t\tlazy.resize(4*sz, 0);\n\t}\n\tvoid build(int li, int ri, int index) {\n\t\tif(li == ri) {\n\t\t\ttree[index] = dist[euler[li]];\n\t\t}\n\t\telse {\n\t\t\tint mid = (li + ri) / 2;\n\t\t\tbuild(li, mid, 2*index);\n\t\t\tbuild(mid+1, ri, 2*index+1);\n\t\t\ttree[index] = max(tree[2*index], tree[2*index+1]);\n\t\t}\n\t}\n\tvoid push_update(int li, int ri, int index) {\n\t\tif(lazy[index] != 0) {\n\t\t\ttree[index] += lazy[index];\n\t\t\tif(li != ri) {\n\t\t\t\tlazy[2*index] += lazy[index]; \n\t\t\t\tlazy[2*index+1] += lazy[index];\n\t\t\t}\n\t\t\tlazy[index] = 0;\n\t\t}\n\t}\n\tvoid update(int ul, int ur, ll uval, int li, int ri, int index) {\n\t\tpush_update(li, ri, index);\n\t\tif(li > ur || ri < ul) return;\n\t\telse if(li >= ul && ri <= ur) {\n\t\t\tlazy[index] += uval;\n\t\t\tpush_update(li, ri, index);\n\t\t}\n\t\telse {\n\t\t\tint mid = (li + ri) / 2;\n\t\t\tupdate(ul, ur, uval, li, mid, 2*index);\n\t\t\tupdate(ul, ur, uval, mid+1, ri, 2*index+1);\n\t\t\ttree[index] = max(tree[2*index], tree[2*index+1]);\n\t\t}\n\t}\n\tll query(int ql, int qr, int li, int ri, int index) {\n\t\tpush_update(li, ri, index);\n\t\tif(li > qr || ri < ql) return LLONG_MIN;\n\t\telse if(li >= ql && ri <= qr) return tree[index];\n\t\telse {\n\t\t\tint mid = (li + ri) / 2;\n\n\t\t\tll lftquery = query(ql, qr, li, mid, 2*index);\n\t\t\tll rghquery = query(ql, qr, mid+1, ri, 2*index+1);\n\n\t\t\ttree[index] = max(tree[2*index], tree[2*index+1]);\n\t\t\treturn max(lftquery, rghquery);\n\t\t}\n\t}\n};\n\n\nsegment_tree trees[maxn];\n\nclass path {\npublic:\n\tll node, cost, open_time, sbt_size, froot;\n};\n\nvector<path>paths;\nvoid get_paths(int node, int par, ll _cost, int froot) {\n\teuler[br] = node;\n\topentt[node] = br;\n\tsbtsizee[node] = 1;\n\tbr++;\n\n\tfor(auto i:g[node]) {\n\t\tint nxt_node = i.first;\n\t\tll nxt_cost = cost[i.second];\n\n\t\tif(nxt_node == par || deleted[nxt_node]) continue;\n\t\tget_paths(nxt_node, node, _cost + nxt_cost, froot);\n\t\tsbtsizee[node] += sbtsizee[nxt_node];\n\t}\n\tpaths.pb({node, _cost, opentt[node], sbtsizee[node], froot});\n}\n\nvoid precompute(int centroid, int depth) {\n\t// find all paths that are rooted at centroid\n\t// cout<<\"Centroid: \"<<centroid<<\" at depth: \"<<depth<<\"\\n\";\n\tbr = 0;\n\tint total_size = 0;\n\tfor(auto i:g[centroid]) {\n\t\tint nxt_node = i.first;\n\t\tll nxt_cost = cost[i.second];\n\n\t\tif(deleted[nxt_node]) continue;\n\n\t\tget_paths(nxt_node, centroid, nxt_cost, nxt_node);\n\t\ttotal_size += sbtsizee[nxt_node];\n\t}\n\n\t//cout<<\"From: \"<<centroid<<\" on depth: \"<<depth<<\"\\n\";\n\tfor(auto i:paths) {\n\t\topen_node[depth][i.node] = i.froot;\n\t\topent[depth][i.node] = i.open_time;\n\t\tsbtsize[depth][i.node] = i.sbt_size;\n\t\tdist[i.node] = i.cost;\n\t\tcentroid_root[depth][i.node] = centroid;\n\t\t//cout<<i.node<<\" --> \"<<i.open_time<<\" \"<<i.open_time+i.sbt_size-1<<\" - \"<<\"\\n\";\n\t}\n\n\tcentroid_root[depth][centroid] = centroid;\n\ttotal_size += 1;\n\tttsize[centroid] = total_size;\n\tsbtsize[depth][centroid] = total_size - 1;\n\ttrees[centroid].init(total_size);\n\ttrees[centroid].build(0, total_size-1, 1);\n\n\tfor(auto i:g[centroid]) {\n\t\tint nxt_node = i.first;\n\n\t\tif(deleted[nxt_node]) continue;\n\n\t\tms[centroid].insert(trees[centroid].query(opent[depth][nxt_node], opent[depth][nxt_node] + sbtsize[depth][nxt_node]-1, 0, total_size-1, 1));\n\t}\n\n\tif(ms[centroid].size() == 0) {\n\t\tpaths.clear();\n\t\treturn;\n\t}\n\n\tll fst = *(ms[centroid].rbegin());\n\tms[centroid].erase(ms[centroid].find(fst));\n\tll tmp = fst;\n\tif(ms[centroid].size() > 0) {\n\t\tll scd = *(ms[centroid].rbegin());\n\t\ttmp += scd;\n\t}\n\n\tms[centroid].insert(fst);\n\tglobalms.insert(tmp);\n\tpaths.clear();\n}\n\nvoid dfs_sbt(int node, int par) {\n\tsbt[node] = 1;\n\tp[node] = par;\n\tfor(auto i:g[node]) {\n\t\tint nxt_node = i.first;\n\n\t\tif(nxt_node == par || deleted[nxt_node]) continue;\n\t\tdfs_sbt(nxt_node, node);\n\t\tsbt[node] += sbt[nxt_node];\n\t}\n}\n\nint decompose(int node, int depth) {\n\tdfs_sbt(node, -1);\n\n\t// find centroid using bfs\n\tqueue<int>q;\n\tq.push(node);\n\n\tint min_sbt = INT_MAX;\n\tint ind = -1;\n\n\twhile(!q.empty()) {\n\t\tint curr = q.front();\n\t\tq.pop();\n\n\t\tint curr_subtree = sbt[node] - sbt[curr];\n\t\tfor(auto i:g[curr]) {\n\t\t\tint nxt_node = i.first;\n\n\t\t\tif(deleted[nxt_node] || nxt_node == p[curr]) continue;\n\n\t\t\tq.push(nxt_node);\n\t\t\tcurr_subtree = max(curr_subtree, sbt[nxt_node]);\n\t\t}\n\n\t\tif(curr_subtree < min_sbt) {\n\t\t\tmin_sbt = curr_subtree;\n\t\t\tind = curr;\n\t\t}\n\t}\n\n\tdeleted[ind] = true;\n\tprecompute(ind, depth);\n\tfor(auto i:g[ind]) {\n\t\tint nxt_node = i.first;\n\n\t\tif(deleted[nxt_node]) continue;\n\t\tint nxt_root = decompose(nxt_node, depth+1);\n\n\t\tcentroid_parent[nxt_root] = ind;\n\t}\n\n\treturn ind;\n}\n\nvoid update_tree(int centroid, int edge_ind, ll edge_val, int depth) {\n\tint curr;\n\tif(sbtsize[depth][aa[edge_ind]] > sbtsize[depth][bb[edge_ind]]) curr = bb[edge_ind]; // aa is before bb\n\telse curr = aa[edge_ind];\n\n\tif(ms[centroid].size() > 0) {\n\t\tll fst = *(ms[centroid].rbegin());\n\t\tms[centroid].erase(ms[centroid].find(fst));\n\t\tll tmp = fst;\n\t\tif(ms[centroid].size() > 0) {\n\t\t\tll scd = *(ms[centroid].rbegin());\n\t\t\ttmp += scd;\n\t\t}\n\n\t\tms[centroid].insert(fst);\n\t\tglobalms.erase(globalms.find(tmp));\n\n\t\t//cout<<\"Erased old info\\n\";\n\t\t//cout<<\"OLD info:\" <<trees[centroid].query(opent[depth][open_node[depth][curr]], opent[depth][open_node[depth][curr]] + sbtsize[depth][open_node[depth][curr]] - 1, 0, ttsize[centroid]-1, 1)<<\"\\n\";\n\n\t\tll old_info = trees[centroid].query(opent[depth][open_node[depth][curr]], opent[depth][open_node[depth][curr]] + sbtsize[depth][open_node[depth][curr]] - 1, 0, ttsize[centroid]-1, 1);\n\n\t\tif(ms[centroid].find(old_info) != ms[centroid].end()) {\n\t\t\tms[centroid].erase(ms[centroid].find(old_info));\n\t\t} \t\t\n\t\n\n\t\ttrees[centroid].update(opent[depth][curr], opent[depth][curr] + sbtsize[depth][curr] - 1,edge_val - cost[edge_ind], 0, ttsize[centroid]-1, 1);\n\t\tms[centroid].insert(trees[centroid].query(opent[depth][open_node[depth][curr]], opent[depth][open_node[depth][curr]] + sbtsize[depth][open_node[depth][curr]] - 1, 0, ttsize[centroid]-1, 1));\n\t\t\n\t\tfst = *(ms[centroid].rbegin());\n\t\tms[centroid].erase(ms[centroid].find(fst));\n\t\ttmp = fst;\n\t\tif(ms[centroid].size() > 0) {\n\t\t\tll scd = *(ms[centroid].rbegin());\n\t\t\ttmp += scd;\n\t\t}\n\n\t\tms[centroid].insert(fst);\n\t\tglobalms.insert(tmp);\n\t}\n}\n\nbool star_graph() {\n\tint cnt = 0;\n\tfor(int i=0;i<n-1;i++) {\n\t\tif(aa[i] == 1 || bb[i] == 1) cnt++;\n\t}\n\treturn n - 1 == cnt;\n}\n\nint main() {\n\t//ios_base::sync_with_stdio(false);\n\t//cin.tie(0);\n\n\tcin>>n>>q>>w;\n\tfor(int i=0;i<n-1;i++) {\n\t\tll a, b, c;\n\t\tcin>>a>>b>>c;\n\n\t\tg[a].pb(mp(b, i));\n\t\tg[b].pb(mp(a, i));\n\n\t\taa[i] = a;\n\t\tbb[i] = b;\n\n\t\tcost[i] = c;\n\t}\n\n\tif(star_graph()) {\n\t\tmultiset<ll>st;\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tst.insert(cost[i]);\n\t\t}\n\t\tll result = 0LL;\n \n\t\tll lst_res = 0LL;\n\t\twhile(q--) {\n\t\t\tll _d, _e;\n\t\t\tcin>>_d>>_e;\n \n\t\t\tll ind = (_d + lst_res) % (n-1);\n\t\t\tll nw_cost = (_e + lst_res) % w;\n \n\t\t\tst.erase(st.find(cost[ind]));\n\t\t\tcost[ind] = nw_cost;\n\t\t\tst.insert(nw_cost);\n \n\t\t\t//cout<<aa[ind]<<\" \"<<bb[ind]<<\" - \"<<nw_cost<<\"\\n\";\n \n\t\t\tll fst = *(st.rbegin());\n\t\t\tst.erase(st.find(fst));\n\t\t\tresult = fst;\n \n\t\t\tif(n > 2) {\n\t\t\t\tll scd = *(st.rbegin());\n\t\t\t\tresult += scd;\n\t\t\t}\n\t\t\tst.insert(fst);\n \n\t\t\tlst_res = result;\n\t\t\tcout<<result<<\"\\n\";\n\t\t}\n\t\treturn 0;\n\t}\n\n\tmemset(centroid_root, -1, sizeof(centroid_root));\n\tdecompose(1, 0);\n\n\tll lst_res = 0LL;\n\tll result = 0LL;\n\twhile(q--) {\n\t\tll _d, _e;\n\t\tcin>>_d>>_e;\n\n\t\tll ind = (_d + lst_res) % (n-1);\n\t\tll nw_cost = (_e + lst_res) % w;\t\n\n\t\t//cout<<aa[ind]<<\", \"<<bb[ind]<<\" - \"<<nw_cost<<\"\\n\";\n\n\t\tfor(int level=maxlog-1;level>=0;level--) {\n\t\t\tif(centroid_root[level][aa[ind]] == -1 || centroid_root[level][bb[ind]] == -1) continue;\n\t\t\tif(centroid_root[level][aa[ind]] != centroid_root[level][bb[ind]]) continue;\n\n\t\t\t//cout<<centroid_root[level][aa[ind]]<<\" for edge: (\"<<aa[ind]<<\", \"<<bb[ind]<<\")\\n\";\n\n\t\t\tupdate_tree(centroid_root[level][aa[ind]], ind, nw_cost, level);\n\t\t\t// At the tree rooted at centroid_root[level[aa[ind]]] update the edge between aa[ind] and bb[ind]\n\t\t}\n\n\t\tcost[ind] = nw_cost;\n\n\t\tll result = *(globalms.rbegin());\n\t\tlst_res = result;\n\t\tcout<<result<<\"\\n\";\n\t}\n\t\n}",
    "ext": "cpp"
  },
  "57849336": {
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = (a), i##ed = (b); i <= i##ed; i++)\n#define per(i, a, b) for(int i = (a), i##ed = (b); i >= i##ed; i--)\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int N = 1000010;\nint n, m; ll W, ans;\nvector<pii> e[N]; ll w[N];\nint dfn[N], low[N], idx = 0, fr[N], ar[N];\n\ntemplate<typename T> inline T Max(const T &x, const T &y) { return x > y ? x : y; }\n\nstruct P {\n\tll lm, mr, lmr, lz, m, p;\n\tP(ll LM = 0, ll MR = 0, ll LMR = 0, ll LZ = 0, ll M = 0, ll P = 0) :\n\t\tlm(LM), mr(MR), lmr(LMR), lz(LZ), m(M), p(P) {}\n\tinline P operator+(const ll &w)const {\n\t\treturn P(lm - w, mr - w, lmr, lz + w, m - w - w, p + w);\n\t}\n\tinline P operator+(const P &w)const {\n\t\tP res;\n\t\tres.p = Max(p, w.p), res.m = Max(m, w.m);\n\t\tres.lm = Max(lm, Max(w.lm, p + w.m));\n\t\tres.mr = Max(mr, Max(w.mr, m + w.p));\n\t\tres.lmr = Max(lmr, Max(w.lmr, Max(lm + w.p, p + w.mr)));\n\t\treturn res;\n\t}\n}; P tr[N];\n\nvoid dfs(int u, int ff) {\n\tdfn[u] = ++idx, ar[idx] = u;\n\tfor(auto v : e[u]) if(v.fst != ff)\n\t\tdfs(v.fst, u), fr[v.snd] = v.fst, ar[++idx] = u;\n\tlow[u] = idx;\n}\ninline void pushup(int u) { tr[u] = tr[u * 2] + tr[u * 2 + 1]; }\nvoid pushdown(int u) {\n\tif(tr[u].lz) {\n\t\ttr[u * 2] = tr[u * 2] + tr[u].lz;\n\t\ttr[u * 2 + 1] = tr[u * 2 + 1] + tr[u].lz;\n\t\ttr[u].lz = 0;\n\t}\n}\nvoid mdy(int u, int l, int r, int L, int R, ll w) {\n\tif(L <= l && r <= R) { tr[u] = tr[u] + w; return ; }\n\tint mid = (l + r) >> 1; pushdown(u);\n\tif(L <= mid) mdy(u * 2, l, mid, L, R, w);\n\tif(R > mid) mdy(u * 2 + 1, mid + 1, r, L, R, w);\n\tpushup(u);\n}\nint main() {\n\tscanf(\"%d%d%lld\", &n, &m, &W);\n\trep(i, 2, n) {\n\t\tint x, y; scanf(\"%d%d%lld\", &x, &y, &w[i]);\n\t\te[x].pb(mp(y, i)), e[y].pb(mp(x, i));\n\t}\n\tdfs(1, 0);\n\trep(i, 2, n) mdy(1, 1, n + n, dfn[fr[i]], low[fr[i]], w[i]);\n\tfor(; m; --m) {\n\t\tll x, y; scanf(\"%lld%lld\", &x, &y);\n\t\tx = (x + ans) % (n - 1) + 2, y = (y + ans) % W;\n\t\tmdy(1, 1, n + n, dfn[fr[x]], low[fr[x]], y - w[x]), w[x] = y;\n\t\tans = tr[1].lmr, printf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57846932": {
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\nusing namespace std;\n#define X first\n#define Y second\n#define pb push_back\ntypedef pair<int, int> ii;\ntypedef long long ll;\n\nconst int maxn = 1e5+5;\n\nint n, q;\nll len[maxn];\n\nvector< ii > adj[maxn];\nint eu[maxn], ev[maxn];\n\nint prf[maxn];\nint par[maxn];\n\nint dfs(int u = 1, int p = 0)\n{\n\tii best = {0, -1};\n\tfor(ii kk : adj[u])\n\t{\n\t\tint v = kk.X;\n\t\tif(v == p) continue;\n\t\tpar[v] = u;\n\t\tbest = max(best, {dfs(v, u), v});\n\t}\n\tprf[u] = best.Y;\n\treturn best.X+1;\n}\n\nint pos[maxn];\nint head[maxn];\nint tail[maxn];\n\nvoid hld()\n{\n\tint sigan = 0;\n\tfor(int i = 1; i<= n; i++)\n\t{\n\t\tif(prf[par[i]] == i) continue;\n\t\tfor(int j = i; j != -1; j = prf[j])\n\t\t{\n\t\t\thead[j] = i;\n\t\t\tpos[j] = ++sigan; \n\t\t\ttail[i] = j;\n\t\t}\n\t}\n}\n\nstruct node\n{\n\tll dp, dist;\n\tll a, b, opt;\n\tll ans;\n\tnode(){}\n\tnode(ll dp, ll dist, ll a, ll b, ll opt, ll ans) : dp(dp), dist(dist), a(a), b(b), opt(opt), ans(ans) {}\n\tnode operator + (node &other)\n\t{\n\t\tnode res;\n\t\tres.dp = res.dist = 0;\n\t\tres.a = max(a, other.a);\n\t\tres.b = max(b, other.b);\n\t\tres.opt = max(max(opt, other.opt), a+other.b);\n\t\tres.ans = max(res.opt, max(ans, other.ans));\n\t\treturn res;\n\t}\n};\n\nstruct segtree\n{\n\tnode st[4*maxn];\n\tll lz[4*maxn];\n\tvoid pushdown(int p, int L, int R)\n\t{\n\t\tif(!lz[p]) return;\n\t\tst[p].dist += lz[p];\n\t\tst[p].a -= lz[p];\n\t\tst[p].b += lz[p];\n\t\tif(L != R)\n\t\t{\n\t\t\tlz[2*p] += lz[p];\n\t\t\tlz[2*p+1] += lz[p];\n\t\t}\n\t\tlz[p] = 0;\n\t}\n\tvoid pull(int p, int L, int R)\n\t{\n\t\tif(L == R) return;\n\t\tst[p] = st[2*p]+st[2*p+1];\n\t}\n\tvoid update_dp(int x, ll dx, int p = 1, int L = 1, int R = n)\n\t{\n\t\t// printf(\"%d %d %d %d %d\\n\", x, dx, p, L, R);\n\t\tpushdown(p, L, R);\n\t\tif(x< L || R< x) return;\n\t\tif(x<= L && R<= x)\n\t\t{\n\t\t\tst[p].dp = dx;\n\t\t\tst[p].a = st[p].dp-st[p].dist;\n\t\t\tst[p].b = st[p].dp+st[p].dist;\n\t\t\tst[p].opt = st[p].dp;\n\t\t\treturn;\n\t\t}\n\t\tint M = (L+R)/2;\n\t\tupdate_dp(x, dx, 2*p, L, M);\n\t\tupdate_dp(x, dx, 2*p+1, M+1, R);\n\t\tpull(p, L, R);\n\t}\n\tvoid update_L(int i, int j, ll dx, int p = 1, int L = 1, int R = n)\n\t{\n\t\tpushdown(p, L, R);\n\t\tif(i> R || j< L) return;\n\t\tif(i<= L && R<= j)\n\t\t{\n\t\t\tlz[p] += dx;\n\t\t\tpushdown(p, L, R);\n\t\t\treturn;\n\t\t}\n\t\tint M = (L+R)/2;\n\t\tupdate_L(i, j, dx, 2*p, L, M);\n\t\tupdate_L(i, j, dx, 2*p+1, M+1, R);\n\t\tpull(p, L, R);\n\t}\n\tvoid update_ans(int x, ll dx, int p = 1, int L = 1, int R = n)\n\t{\n\t\tpushdown(p, L, R);\n\t\tif(x< L || R< x) return;\n\t\tif(x<= L && R<= x)\n\t\t{\n\t\t\tst[p].ans = dx;\n\t\t\treturn;\n\t\t}\n\t\tint M = (L+R)/2;\n\t\tupdate_ans(x, dx, 2*p, L, M);\n\t\tupdate_ans(x, dx, 2*p+1, M+1, R);\n\t\tpull(p, L, R);\n\t}\n\tnode ask(int i, int j, int p = 1, int L = 1, int R = n)\n\t{\n\t\tif(i> R || j< L) return node(0, 0, -1e14, -1e14, -1e14, -1e14);\n\t\tpushdown(p, L, R);\n\t\tif(i<= L && R<= j) return st[p];\n\t\tint M = (L+R)/2;\n\t\tnode x = ask(i, j, 2*p, L, M);\n\t\tnode y = ask(i, j, 2*p+1, M+1, R);\n\t\treturn x+y;\n\t}\n};\n\nsegtree foo;\n\nmultiset<ll> bst[maxn];\nmultiset<ll> good[maxn];\n\nvoid build(int u = 1, int p = 0)\n{\n\t// printf(\"%d\\n\", u);\n\tfor(ii kk : adj[u])\n\t{\n\t\tint v = kk.X, id = kk.Y;\n\t\tif(v == p) continue;\n\t\tll w = len[id];\n\t\tfoo.update_L(pos[v], pos[tail[head[v]]], w);\n\t\tbuild(v, u);\n\t}\n\tfor(ii kk : adj[u])\n\t{\n\t\tint v = kk.X, id = kk.Y;\n\t\tif(v == p) continue;\n\t\tif(prf[u] == v) continue;\n\t\tnode tmp = foo.ask(pos[v], pos[tail[head[v]]]);\n\t\tbst[u].insert(tmp.b);\n\t\tgood[u].insert(tmp.ans);\n\t}\n\tll best = 0, ndbest = 0;\n\tif(!bst[u].empty()) \n\t{\n\t\tauto it = --bst[u].end();\n\t\tbest = *it;\n\t\tif(it != bst[u].begin())\n\t\t{\n\t\t\t--it;\n\t\t\tndbest = *it;\n\t\t}\n\t\tfoo.update_dp(pos[u], best);\n\t}\n\tif(!good[u].empty()) \n\t{\n\t\tfoo.update_ans(pos[u], max(best+ndbest,*(--good[u].end())));\n\t}\n}\n\nvoid update(int u)\n{\n\tif(!u) return;\n\tint v = par[head[u]];\n\tif(v)\n\t{\n\t\tnode tmp = foo.ask(pos[head[u]], pos[tail[head[u]]]);\n\t\tll ob = tmp.b, oans = tmp.ans;\n\t\tbst[v].erase(bst[v].find(ob));\n\t\tgood[v].erase(good[v].find(oans));\n\t\t// printf(\"okay\\n\");\n\t}\n\tll best = 0, ndbest = 0;\n\tif(!bst[u].empty())\n\t{\n\t\tauto it = --bst[u].end();\n\t\tbest = *it;\n\t\tif(it != bst[u].begin())\n\t\t{\n\t\t\t--it;\n\t\t\tndbest = *it;\n\t\t}\n\t\tfoo.update_dp(pos[u], best);\n\t}\n\telse foo.update_dp(pos[u], 0);\n\tif(!good[u].empty())\n\t{\n\t\tfoo.update_ans(pos[u], max(best+ndbest, *(--good[u].end())));\n\t}\n\telse foo.update_ans(pos[u], 0);\n\tif(v)\n\t{\n\t\tnode tmp = foo.ask(pos[head[u]], pos[tail[head[u]]]);\n\t\tbst[v].insert(tmp.b);\n\t\tgood[v].insert(tmp.ans);\n\t\tupdate(v);\n\t}\n}\n\nvoid change(int u, int v, int id, ll w)\n{\n\tif(par[u] == v) swap(u, v);\n\tassert(par[v] == u);\n\tnode tmp = foo.ask(pos[head[v]], pos[tail[head[v]]]);\n\tll ob = tmp.b, oans = tmp.ans;\n\tif(head[v] != 1)\n\t{\n\t\tauto it = bst[par[head[v]]].find(ob);\n\t\tauto it2 = good[par[head[v]]].find(oans);\n\t\tif(it != bst[par[head[v]]].end()) bst[par[head[v]]].erase(it);\n\t\tif(it2 != good[par[head[v]]].end()) good[par[head[v]]].erase(it2);\n\t}\n\tll from = len[id];\n\tfoo.update_L(pos[v], pos[tail[head[v]]], w-from);\n\tlen[id] = w;\n\ttmp = foo.ask(pos[head[v]], pos[tail[head[v]]]);\n\tif(head[v] != 1)\n\t{\n\t\tbst[par[head[v]]].insert(tmp.b);\n\t\tgood[par[head[v]]].insert(tmp.ans);\n\t}\n\tupdate(par[head[v]]);\n}\n\nll get_ans()\n{\n\tnode tmp = foo.ask(pos[head[1]], pos[tail[head[1]]]);\n\treturn tmp.ans;\n}\n\nll md;\n\nint main()\n{\n\tscanf(\"%d %d %lld\", &n, &q, &md);\n\tfor(int i = 1; i<= n-1; i++)\n\t{\n\t\tint u, v; ll w;\n\t\tscanf(\"%d %d %lld\", &u, &v, &w);\n\t\tadj[u].pb(ii(v, i));\n\t\tadj[v].pb(ii(u, i));\n\t\teu[i] = u; ev[i] = v;\n\t\tlen[i] = w;\n\t}\n\tdfs();\n\thld();\n\tbuild();\n\tll last = 0;\n\tfor(int qq = 1; qq<= q; qq++)\n\t{\n\t\tint d;\n\t\tll e; scanf(\"%d %lld\", &d, &e);\n\t\tint id = (d+last)%(n-1);\n\t\tid++;\n\t\tll nw = (e+last)%md;\n\t\tchange(eu[id], ev[id], id, nw);\n\t\tlast = get_ans();\n\t\tprintf(\"%lld\\n\", last);\n\t}\n}",
    "ext": "cpp"
  },
  "57841255": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int MAX_N = 150005;\nconst int INF = 0x3f3f3f3f;\n\nstruct Edge{ int u, v; ll w; };\nint N, Q, cnt;\nll W, last;\nint pa[MAX_N], siz[MAX_N], edge[MAX_N], vis[MAX_N];\nvector<int> belongs[MAX_N];\nvector< P > G[MAX_N];\nEdge e[MAX_N];\nmultiset<ll> ans;\n\nclass Segtree{\n    vector<ll> f, lazy;\n\n    void pushup(int x, int l, int r){\n        if(l == r) return;\n        f[x] = max(f[x * 2], f[x * 2 + 1]);\n    }\n\n    void pushdown(int x, int l, int r){\n        if(l == r) return;\n        f[x * 2] += lazy[x];\n        f[x * 2 + 1] += lazy[x];\n        lazy[x * 2] += lazy[x];\n        lazy[x * 2 + 1] += lazy[x];\n        lazy[x] = 0;\n    }\n\npublic:\n    void init(int siz){\n        f.assign(siz * 4, 0);\n        lazy.assign(siz * 4, 0);\n    }\n\n    void update(int x, int l, int r, int ql, int qr, ll val){\n        if(ql <= l && r <= qr){\n            f[x] += val;\n            lazy[x] += val;\n            return;\n        }\n\n        int mid = (l + r) / 2;\n        if(lazy[x]) pushdown(x, l, r);\n        if(ql <= mid) update(x * 2, l, mid, ql, qr, val);\n        if(mid + 1 <= qr) update(x * 2 + 1, mid + 1, r, ql, qr, val);\n        pushup(x, l, r);\n    }\n\n    ll query(int x, int l, int r, int ql, int qr){\n        if(ql <= l && r <= qr) return f[x];\n        int mid = (l + r) / 2;\n        ll res = 0;\n        if(lazy[x]) pushdown(x, l, r);\n        if(ql <= mid) res = max(res, query(x * 2, l, mid, ql, qr));\n        if(mid + 1 <= qr) res = max(res, query(x * 2 + 1, mid + 1, r, ql, qr));\n        return res;\n    }\n};\n\nstruct centroidTree{\n    int centroid, lim, siz, centroidVal, temp;\n    ll curMax;\n    unordered_map<int, int> l, r, boss, depth;\n    Segtree s;\n    multiset<ll> res;\n\n    ll getans(){\n        ll val = 0;\n        auto it = res.end();\n        if(res.size() >= 1) it--, val += *it;\n        if(res.size() >= 2) it--, val += *it;\n        return val;\n    }\n\n    void update(int u, int v, ll w, ll val){\n        if(depth[u] < depth[v]) swap(u, v);\n\n        ll cur = s.query(1, 1, siz, l[boss[u]], r[boss[u]]);\n        res.erase(res.find(cur));\n        ans.erase(ans.find(curMax));\n\n        s.update(1, 1, siz, l[u], r[u], val - w);\n        res.insert(s.query(1, 1, siz, l[boss[u]], r[boss[u]]));\n        curMax = getans();\n        ans.insert(curMax);\n    }\n};\n\ncentroidTree t[MAX_N];\n\nvoid getInfo(int u, int pa){\n    siz[u] = 1;\n    for(auto ed : G[u])\n        if(ed.first != pa && !vis[ed.first]){\n            belongs[ed.second].push_back(cnt);\n            getInfo(ed.first, u);\n            siz[u] += siz[ed.first];\n        }\n}\n\nvoid getCentroid(int u, int pa){\n    int res = t[cnt].siz - siz[u];\n    for(auto ed : G[u])\n        if(ed.first != pa && !vis[ed.first]){\n            getCentroid(ed.first, u);\n            res = max(res, siz[ed.first]);\n        }\n    if(res < t[cnt].centroidVal)\n        t[cnt].centroidVal = res, t[cnt].centroid = u;\n}\n\nvoid preorder(int u, int pa, int bos){\n    t[cnt].boss[u] = bos;\n    t[cnt].depth[u] = t[cnt].depth[pa] + 1;\n    t[cnt].l[u] = ++t[cnt].temp;\n    t[cnt].r[u] = t[cnt].l[u];\n    for(auto ed : G[u])\n        if(ed.first != pa && ed.first != t[cnt].lim && !vis[ed.first]){\n            if(pa == 0)\n                preorder(ed.first, u, ed.first);\n            else\n                preorder(ed.first, u, bos);\n            t[cnt].r[u] = t[cnt].r[ed.first];\n            t[cnt].s.update(1, 1, t[cnt].siz, t[cnt].l[ed.first], t[cnt].r[ed.first], e[ed.second].w);\n        }\n}\n\nvoid centroidDecomp(int tempRoot, int lim){\n    int cur = cnt + 1;\n    cnt++;\n    getInfo(tempRoot, lim);\n    t[cnt].siz = siz[tempRoot], t[cnt].centroidVal = INF;\n    getCentroid(tempRoot, lim);\n\n\n    t[cnt].s.init(t[cnt].siz + 5);\n    t[cnt].lim = lim;\n    t[cnt].temp = 0;\n\n    preorder(t[cnt].centroid, 0, 0);\n    for(auto ed : G[t[cnt].centroid])\n        if(ed.first != lim && !vis[ed.first])\n            t[cnt].res.insert( t[cnt].s.query(1, 1, t[cnt].siz, t[cnt].l[ed.first], t[cnt].r[ed.first]) );\n\n    t[cnt].curMax = t[cnt].getans();\n    ans.insert(t[cnt].curMax);\n\n    vis[t[cnt].centroid] = true;\n    for(auto ed : G[t[cur].centroid])\n        if(ed.first != lim && !vis[ed.first])\n            centroidDecomp(ed.first, t[cur].centroid);\n}\n\nll printAns(){\n    auto it = ans.end();\n    if(ans.size() == 0) return 0;\n    else {it--; return *it;}\n}\n\nint main(){\n    // freopen(\"b.in\", \"r\", stdin);\n    // freopen(\"b.out\", \"w\", stdout);\n\n    scanf(\"%d%d%lld\", &N, &Q, &W);\n    for(int i = 1; i < N; i++){\n        scanf(\"%d%d%lld\", &e[i].u, &e[i].v, &e[i].w);\n        G[e[i].u].push_back( P(e[i].v, i) );\n        G[e[i].v].push_back( P(e[i].u, i) );\n    }\n\n    centroidDecomp(1, 0);\n    for(int i = 1; i <= Q; i++){\n        int id;\n        ll val;\n        scanf(\"%d%lld\", &id, &val);\n        id = (id + last) % (N - 1) + 1;\n        val = (val + last) % W;\n\n        for(auto tree : belongs[id])\n            t[tree].update(e[id].u, e[id].v, e[id].w, val);\n        e[id].w = val;\n        last = printAns();\n        printf(\"%lld\\n\", last);\n    }\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57833876": {
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int lld;\ntypedef pair<lld,lld> pii;\ntypedef multiset<lld>::iterator mit;\n#define INF 1000000000000000\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define trav(a,v) for(auto a:v)\n#pragma GCC optimize(\"O3\")\nint n;\nint q;\nlld w;\nvector<int> nei[1000000];\nlld edge_list[1000000][3];\nclass ST_M{\n  vector<pii> best;\n  vector<pii> second_best;\n  vector<lld> lazy;\n  vector<pii> V;\n  vector<lld> P;\n  int N;\npublic:\n  void init(int size){\n    N=size;\n    best.resize(4*N);\n    second_best.resize(4*N);\n    lazy.resize(4*N);\n    P.resize(N);\n  }\n  void propagate(int a, int b, int node){\n    if(lazy[node]!=0){\n      best[node].first+=lazy[node];\n      second_best[node].first+=lazy[node];\n    }\n    if(a!=b){\n      lazy[2*node+1]+=lazy[node];\n      lazy[2*node]+=lazy[node];\n    }\n    lazy[node]=0;\n  }\n  void build(int a, int b, int node){\n    lazy[node]=0;\n    if(a==b){\n      best[node]=pii(0,a);\n      second_best[node]=pii(-INF,a);\n      P[a]=0;\n      return;\n    }\n    int mid=(a+b)/2;\n    build(a,mid,2*node);\n    build(mid+1,b,2*node+1);\n    V.clear();\n    V.push_back(best[2*node]);\n    V.push_back(best[2*node+1]);\n    V.push_back(second_best[2*node]);\n    V.push_back(second_best[2*node+1]);\n    sort(V.begin(),V.end());\n    reverse(V.begin(),V.end());\n    best[node]=V[0];\n    second_best[node]=V[1];\n  }\n  void update_range(int a, int b, int node,int x, int y, lld val){\n    propagate(a,b,node);\n    if(b<x || y<a)return;\n    if(x<=a && b<=y){\n      lazy[node]+=val;\n      propagate(a,b,node);\n      return;\n    }\n    int mid=(a+b)/2;\n    update_range(a,mid,2*node,x,y,val);\n    update_range(mid+1,b,2*node+1,x,y,val);\n    V.clear();\n    V.push_back(best[2*node]);\n    V.push_back(best[2*node+1]);\n    V.push_back(second_best[2*node]);\n    V.push_back(second_best[2*node+1]);\n    sort(V.begin(),V.end());\n    reverse(V.begin(),V.end());\n    best[node]=V[0];\n    second_best[node]=V[1];\n  }\n  void update_P(int a, int b, int node, int pos, lld val){\n    propagate(a,b,node);\n    if(b<pos || pos<a)return;\n    if(a==b){\n      lazy[node]+=val-P[a];\n      propagate(a,b,node);\n      P[a]=val;\n      return;\n    }\n    int mid=(a+b)/2;\n    update_P(a,mid,2*node,pos,val);\n    update_P(mid+1,b,2*node+1,pos,val);\n    V.clear();\n    V.push_back(best[2*node]);\n    V.push_back(best[2*node+1]);\n    V.push_back(second_best[2*node]);\n    V.push_back(second_best[2*node+1]);\n    sort(V.begin(),V.end());\n    reverse(V.begin(),V.end());\n    best[node]=V[0];\n    second_best[node]=V[1];\n  }\n  pii Best(){\n    return best[1];\n  }\n  pii Second(){\n    return second_best[1];\n  }\n  \n};\nclass ST_m{\n  vector<pii> best;\n  vector<pii> second_best;\n  vector<lld> lazy;\n  vector<pii> V;\n  vector<lld> P;\n  int N;\npublic:\n  void init(int size){\n    N=size;\n    best.resize(4*N);\n    second_best.resize(4*N);\n    lazy.resize(4*N);\n    P.resize(N);\n  }\n  void propagate(int a, int b, int node){\n    if(lazy[node]!=0){\n      best[node].first+=lazy[node];\n      second_best[node].first+=lazy[node];\n    }\n    if(a!=b){\n      lazy[2*node+1]+=lazy[node];\n      lazy[2*node]+=lazy[node];\n    }\n    lazy[node]=0;\n  }\n  void build(int a, int b, int node){\n    lazy[node]=0;\n    if(a==b){\n      best[node]=pii(0,a);\n      second_best[node]=pii(INF,a);\n      P[a]=0;\n      return;\n    }\n    int mid=(a+b)/2;\n    build(a,mid,2*node);\n    build(mid+1,b,2*node+1);\n    V.clear();\n    V.push_back(best[2*node]);\n    V.push_back(best[2*node+1]);\n    V.push_back(second_best[2*node]);\n    V.push_back(second_best[2*node+1]);\n    sort(V.begin(),V.end());\n    best[node]=V[0];\n    second_best[node]=V[1];\n  }\n  void update_range(int a, int b, int node,int x, int y, lld val){\n    propagate(a,b,node);\n    if(b<x || y<a)return;\n    if(x<=a && b<=y){\n      lazy[node]+=val;\n      propagate(a,b,node);\n      return;\n    }\n    int mid=(a+b)/2;\n    update_range(a,mid,2*node,x,y,val);\n    update_range(mid+1,b,2*node+1,x,y,val);\n    V.clear();\n    V.push_back(best[2*node]);\n    V.push_back(best[2*node+1]);\n    V.push_back(second_best[2*node]);\n    V.push_back(second_best[2*node+1]);\n    sort(V.begin(),V.end());\n    best[node]=V[0];\n    second_best[node]=V[1];\n  }\n  void update_P(int a, int b, int node, int pos, lld val){\n    propagate(a,b,node);\n    if(b<pos || pos<a)return;\n    if(a==b){\n      lazy[node]-=val-P[a];\n      propagate(a,b,node);\n      P[a]=val;\n      return;\n    }\n    int mid=(a+b)/2;\n    update_P(a,mid,2*node,pos,val);\n    update_P(mid+1,b,2*node+1,pos,val);\n    V.clear();\n    V.push_back(best[2*node]);\n    V.push_back(best[2*node+1]);\n    V.push_back(second_best[2*node]);\n    V.push_back(second_best[2*node+1]);\n    sort(V.begin(),V.end());\n    best[node]=V[0];\n    second_best[node]=V[1];\n  }\n  pii Best(){\n    return best[1];\n  }\n  pii Second(){\n    return second_best[1];\n  }\n};\nint dist[100000];\nbool visited[100000];\nint size[100000];\nvector<int> child[100000];\nint parent[200000];\nint prefered[200000];\nvoid DFS(int node){\n  size[node]=1;\n  visited[node]=true;\n  trav(v,nei[node]){\n    if(!visited[v]){\n      dist[v]=dist[node]+1;\n      DFS(v);\n      parent[v]=node;\n      size[node]+=size[v];\n      child[node].push_back(v);\n    }\n  }\n  prefered[node]=-1;\n  trav(v,child[node]){\n    if(size[v]*2>=size[node]){\n      prefered[node]=v;\n    }\n  }\n}\nvector<vector<int> >chain;\nint chain_num[1000000];\nint chain_pos[1000000];\nvoid Decompose(int node){\n  chain_num[node]=chain.size()-1;\n  chain_pos[node]=chain[chain.size()-1].size();\n  chain[chain.size()-1].push_back(node);\n  if(prefered[node]!=-1){\n    Decompose(prefered[node]);\n    trav(v,child[node]){\n      if(v!=prefered[node]){\n\tvector<int> New;\n\tchain.push_back(New);\n\tDecompose(v);\n      }\n    }\n    return;\n  }\n  trav(v,child[node]){\n    vector<int> New;\n    chain.push_back(New);\n    Decompose(v);\n  }\n}\nvector<ST_M*> Max_trees;\nvector<ST_m*> Min_trees;\nmultiset<lld> max_depth[1000000];\nlld P[1000000];\nlld parent_val[1000000];\nmit m;\nlld Diameters[1000000];\nmultiset<lld> Internal[1000000];\nmultiset<lld> DIAM;\nlld Longest_track(int node){\n  if(max_depth[node].size()!=0){\n    m=max_depth[node].end();\n    m--;\n    return max(*m,Max_trees[chain_num[node]]->Best().first);\n  }return Max_trees[chain_num[node]]->Best().first;\n}\n\nlld calc_Int(int node){\n  if(max_depth[node].size()==0)return 0;\n  m=max_depth[node].end();\n  m--;\n  lld ans=*m;\n  if(m==max_depth[node].begin())return ans;\n  m--;\n  ans+=*m;\n  return ans;\n}\nvoid UPD_diam(int node){\n  \n  //cout<<node<<\"UP\"<<endl;\n  int num=chain_num[node];\n  m=Internal[num].end();\n  DIAM.erase(DIAM.find(Diameters[num]));\n  /*trav(a,Internal[num])cout<<a<<\" \";\n  cout<<endl;*/\n  m--;\n  lld ans=*m;\n  if(max_depth[node].size()>=2){\n    m=max_depth[node].end();\n    m--;\n    lld can=*m;\n    m--;\n    can+=*m;\n    ans=max(ans,can);\n  }\n  \n  if(max_depth[node].size()>=1){\n    m=max_depth[node].end();\n    m--;\n    lld can=*m;\n    if(Max_trees[num]->Best().second!=0){\n      can+=Max_trees[num]->Best().first;\n      //cout<<m<<\" \"<<Max_trees[num]->Best().first;\n      ans=max(ans,can);\n    }else{\n      can+=Max_trees[num]->Second().first;\n      //cout<<m<<\" \"<<Max_trees[num]->Best().first;\n      ans=max(ans,can);\n    }\n  }\n\n  \n  pii BM=Max_trees[num]->Best();\n  pii Bm=Min_trees[num]->Best();\n  //cout<<BM.first<<\" \"<<BM.second<<\" \"<<Bm.first<<\" \"<<Bm.second<<endl;\n  if(BM.second!=Bm.second){\n    ans=max(ans,BM.first-Bm.first);\n    Diameters[num]=ans;\n  }else{\n    ans=max(ans,BM.first-Min_trees[num]->Second().first);\n    ans=max(ans,Max_trees[num]->Second().first-Bm.first);\n    Diameters[num]=ans;\n  }\n  DIAM.insert(Diameters[num]);\n}\nvoid UPD(int p,int node,lld last){\n  //cout<<p<<\" \"<<last<<\" \"<<parent_val[node]<<\" \"<<node<<endl;\n  \n  int num=chain_num[p];\n  int pos=chain_pos[p];\n  lld Last_Int=calc_Int(p);\n  Internal[num].erase(Internal[num].find(Last_Int));\n  max_depth[p].erase(max_depth[p].find(last));\n  //cout<<\"A\"<<endl;\n  \n  max_depth[p].insert(parent_val[node]+Longest_track(node));\n  \n  m=max_depth[p].end();\n  m--;  \n  P[p]=*m;\n  last=Max_trees[num]->Best().first;\n  Max_trees[num]->update_P(0,chain[num].size()-1,1,pos,P[p]);\n  Min_trees[num]->update_P(0,chain[num].size()-1,1,pos,P[p]);\n  Internal[num].insert(calc_Int(p));\n  node=chain[chain_num[p]][0];\n  UPD_diam(node);\n  if(node==0){\n    return;\n  }\n  p=parent[node];\n  last+=parent_val[node];\n  UPD(p,node,last);\n}\nvoid UPD2(int node, lld val){\n  //cout<<node<<\" \"<<val<<endl;\n  int num=chain_num[node];\n  if(node==chain[num][0]){\n    \n    int p=parent[node];\n    /*lld Last_P=Max_trees[num]->Best().first;\n    //cout<<\"A\"<<endl;\n    //cout<<Last_P<<\" \"<<parent_val[node]<<\" \"<<p<<endl;\n    max_depth[p].erase(max_depth[p].find(Last_P+parent_val[node]));\n    //cout<<\"A\"<<endl;\n    max_depth[p].insert(Last_P+parent_val[node]+val);\n    m=max_depth[p].end();\n    m--;\n    \n    P[p]=*m;*/\n    parent_val[node]+=val;\n    UPD(p,node,Longest_track(node)+parent_val[node]-val);\n  }else{\n    int pos=chain_pos[node];\n    lld Last_P=Max_trees[num]->Best().first;\n    //cout<<pos<<endl;\n    Max_trees[num]->update_range(0,chain[num].size()-1,1,pos,chain[num].size()-1,val);\n    Min_trees[num]->update_range(0,chain[num].size()-1,1,pos,chain[num].size()-1,val);\n    //cout<<Last_P<<\" \"<<Max_trees[num]->Best().first<<endl;\n    node=chain[num][0];\n    //cout<<node<<endl;\n    if(node!=0){\n      UPD_diam(node);\n      UPD(parent[node],node,Last_P+parent_val[node]);\n    }\n    else UPD_diam(0);\n  }\n  \n}\nint main(){\n  scanf(\"%d %d %lld\",&n,&q,&w);\n  rep(i,0,n-1){\n    rep(j,0,3){\n      cin>>edge_list[i][j];\n      if(j<2)edge_list[i][j]--;\n    }\n    nei[edge_list[i][0]].push_back(edge_list[i][1]);\n    nei[edge_list[i][1]].push_back(edge_list[i][0]);\n  }\n  //rep(i,0,n-1)cout<<edge_list[i][2]<<endl;\n  rep(i,0,n){\n    Diameters[i]=0;\n    parent_val[i]=0;\n    visited[i]=false;\n    size[i]=0;\n  }\n  dist[0]=0;\n  DFS(0);\n  chain.resize(1);\n  Decompose(0);\n  Max_trees.resize(chain.size());\n  Min_trees.resize(chain.size());\n  rep(i,0,chain.size()){\n    DIAM.insert(0);\n    rep(j,0,chain[i].size())Internal[i].insert(0);\n    Max_trees[i]=new ST_M();\n    Max_trees[i]->init(chain[i].size());\n    Max_trees[i]->build(0,chain[i].size()-1,1);\n    Min_trees[i]=new ST_m();\n    Min_trees[i]->init(chain[i].size());\n    Min_trees[i]->build(0,chain[i].size()-1,1);\n  }\n  \n  rep(i,0,n){\n    P[i]=0;\n    rep(j,0,child[i].size())max_depth[i].insert(0);\n  }\n  lld ANSWER=0;\n  \n  //cout<<\"A\"<<endl;\n  rep(e,0,n-1){\n    /*rep(i,0,n){\n      cout<<Longest_track(i)<<\" \"<<Diameters[i]<<\" \"<<calc_Int(i)<<endl;\n      cout<<\"E\"<<endl;\n      trav(a,max_depth[i])cout<<a<<\" \";\n      cout<<endl;\n      }*/\n    //cout<<dist[edge_list[e][0]]<<\" \"<<dist[edge_list[e][1]]<<\"B\"<<endl;\n    //cout<<e<<endl;\n    if(dist[edge_list[e][0]]>dist[edge_list[e][1]]){\n      UPD2(edge_list[e][0],edge_list[e][2]);\n    }else{\n      UPD2(edge_list[e][1],edge_list[e][2]);\n    }\n    //cout<<e<<endl;\n  }\n  /*rep(i,0,n){\n      cout<<Longest_track(i)<<\" \"<<Diameters[i]<<\" \"<<calc_Int(i)<<endl;\n      cout<<\"E\"<<endl;\n      trav(a,max_depth[i])cout<<a<<\" \";\n      cout<<endl;\n    }*/\n  lld ans=0;\n  \n  //cout<<ans<<endl;\n  while(q--){\n    lld e;\n    lld val;\n    scanf(\"%lld %lld\",&e,&val);\n    //cout<<e<<endl;\n    e=e+ANSWER;\n    e%=(lld)(n-1);\n    val+=ANSWER;\n    val%=w;\n    //cout<<\"B\"<<endl;\n    //cout<<e<<\" \"<<val<<endl;\n    //cout<<val-edge_list[e][2]<<endl;\n    //cout<<e<<\" \"<<edge_list[e][0]<<\" \"<<edge_list[e][1]<<endl;\n    if(dist[edge_list[e][0]]>dist[edge_list[e][1]]){\n      //cout<<edge_list[e][0]<<\"A\"<<endl;\n      UPD2(edge_list[e][0],val-edge_list[e][2]);\n    }else{\n      //cout<<edge_list[e][1]<<\"B\"<<endl;\n      UPD2(edge_list[e][1],val-edge_list[e][2]);\n    }\n    edge_list[e][2]=val;\n    //rep(i,0,n)cout<<Longest_track(i)<<\" \"<<Diameters[i]<<\" \"<<calc_Int(i)<<endl;\n    /*trav(a,DIAM)cout<<a<<\" \";\n      cout<<endl;*/\n    m=DIAM.end();\n    m--;\n    ans=*m;\n    /*ans=0;\n    rep(i,0,n)ans=max(ans,Diameters[i]);*/\n    printf(\"%lld\\n\",ans);\n    \n    ANSWER=ans;\n  }\n  /*trav(a,chain){\n    trav(b,a)cout<<b<<\" \";\n    cout<<endl;\n  }\n  rep(i,0,n)cout<<chain_num[i]<<\" \"<<chain_pos[i]<<endl;*/\n  //rep(i,0,n)cout<<prefered[i]<<endl;\n  /*rep(i,0,n){\n    cout<<size[i]<<endl;\n  }*/\n  \n  /*ST_M *S=new ST_M();\n  //cout<<\"A\"<<endl;\n  S->init(10);\n  S->build(0,9,1);\n  S->update_range(0,9,1,2,3,4);\n  S->update_P(0,9,1,3,4);\n  cout<<S->Best().first<<\" \"<<S->Best().second<<endl;\n  cout<<S->Second().first<<\" \"<<S->Second().second<<endl;*/\n  return 0;\n}",
    "ext": "cpp"
  },
  "57833389": {
    "code": "// InterestingLSY\n// 2659723130\n// \u300a\u5e7d\u7075\u516c\u4e3b\u300b\u662f\u771f\u7684\u597d\u770b\uff01\n#include <bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define elif else if\n\n// Type\n#define ld double\n#define ll long long\n#define ull unsigned ll\n\n// Vector\n#define vc vector\n#define Pb push_back\n#define Pf push_front\n#define Eb emplace_back\n#define All(x) x.begin(),x.end()\n#define AllRev(x) x.rbegin(),x.rend()\n\n// Memory\n#define Ms(_data) memset(_data,0,sizeof(_data))\n#define Msn(_data,_num) memset(_data,_num,sizeof(_data))\n\n// Template\n#define _cl class\n#define _tp template\n#define _tyn typename\n\n// Pair\n#define Mp make_pair\n#define F first\n#define S second\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n\n// Loop\n#define For(i,j) for( int (i) = 1 ; (i) <= (j) ; ++(i) )\n#define For0(i,j) for( int (i) = 0 ; (i) < (j) ; ++(i) )\n#define Forx(i,j,k) for( int (i) = (j) ; (i) <= (k) ; ++(i) )\n#define Forstep(i,j,k,st) for( int (i) = (j) ; (i) <= (k) ; (i) += (st) )\n#define fOR(i,j) for( int (i) = (j) ; (i) >= 1 ; --(i) )\n#define fOR0(i,j) for( int (i) = (j)-1 ; (i) >= 0 ; --(i) )\n#define fORx(i,j,k) for( int (i) = (k) ; (i) >= (j) ; --(i) )\n\n// Read\nstruct InputReader{\n\t#define bs 1048576\n\tchar buf[bs]; int p;\n\til InputReader(){ p = bs; }\n\til void Flush(){ p = 0; fread(buf,1,bs,stdin); }\n\til char C(){ if(p >= bs) Flush(); return buf[p++]; }\n\til char Readnum(){ char ch = C(); while( !isdigit(ch) && ch != '-' ) ch = C(); return ch; }\n\til void Readalpha( char &c ){ c = C(); while( !isalpha(c) ) c = C(); }\n\tint operator() (){\n\t\tint ans = 0, fu = 1; char ch = Readnum();\n\t\tif( ch == '-' ) fu = -1, ch = C();\n\t\twhile( ch >= '0' && ch <= '9' ){\n\t\t\tans = ans*10 + ch-'0';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\tll Readll(){\n\t\tll ans = 0LL, fu = 1LL; char ch = Readnum();\n\t\tif( ch == '-' ) fu = -1LL, ch = C();\n\t\twhile( ch >= '0' && ch <= '9' ){\n\t\t\tans = ans*10LL + ch-'0';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\til void Readstring( string &x ){\n\t\tx.clear(); char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  &&  ch != '#'  &&  ch != '.' ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  ||  ch == '#'  ||  ch == '.' ){\n\t\t\tx += ch;\n\t\t\tch = C();\n\t\t}\n\t}\n\til void Readchstring( char s[] ){\n\t\tint len = 0; char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  /*&&  ch != '*'  &&  ch != '?'*/ ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  /*||  ch == '*'  ||  ch == '?'*/ ){\n\t\t\ts[len++] = ch;\n\t\t\tch = C();\n\t\t}\n\t\ts[len] = '\\0';\n\t}\n\til void Specialread( char &c ){\n\t\tc = C();\n\t\twhile( !isdigit(c) && !isalpha(c) && c != '#'  &&  c != '.'  &&  c != '='  &&  c != 'B' ) c = C();\n\t}\n\t#undef bs\n}In;\nil void Read( int &x ){ x = In(); }\nil void Read( int &x, int &y ){ x = In(); y = In(); }\nil void Read( int &x1 , int &x2 , int &x3 ){ x1 = In(); x2 = In(); x3 = In(); }\nil void Read( int &x1 , int &x2 , int &x3 , int &x4 ){ x1 = In(); x2 = In(); x3 = In(); x4 = In(); }\nil void Read( ll &x ){ x = In.Readll(); }\nil void Read( ll &x, ll &y ){ x = In.Readll(); y = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 , ll &x4 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); x4 = In.Readll(); }\n_tp<_tyn T> void Read( T a[] , int st , int ed ){ Forx(i,st,ed) Read(a[i]); }\n#define iRead(k) int k; Read(k);\n#define iRead2(a,b) iRead(a); iRead(b);\n#define iRead3(a,b,c) iRead2(a,b); iRead(c);\n#define iRead4(a,b,c,d) iRead2(a,b); iRead2(c,d);\n#define lRead(k) ll k; Read(k);\n#define lRead2(a,b) lRead(a); lRead(b);\n#define lRead3(a,b,c) lRead2(a,b); lRead(c);\n#define lRead4(a,b,c,d) lRead2(a,b); lRead2(c,d);\n\n// File\n#define Fin(a) freopen(a,\"r\",stdin)\n#define Fout(a) freopen(a,\"w\",stdout)\nil void FILEIO(){\n\t#ifdef intLSY\n\t\tFin(\"in.in\");\n\t#endif\n}\nil void FILEIO( string pname ){\n\t#ifndef intLSY\n\t\tFin((pname+\".in\").c_str());\n\t\tFout((pname+\".out\").c_str());\n\t#else\n\t\tFin(\"in.in\");\n\t#endif\n}\nil void FILEIO_OICONTEST( string pname ){\n\tFin((pname+\".in\").c_str());\n\t#ifndef intLSY\n\t\tFout((pname+\".out\").c_str());\n\t#endif\n}\nvoid Printtime(){\n\t#ifdef intLSY\n\t\tdouble _timeuse = clock()* 1000.0 / CLOCKS_PER_SEC;\n\t\tfprintf(stderr,\"\\n\\nTime usage:\\n%.0lf ms\\n\",_timeuse);\n\t#endif\n}\nvoid END(){ Printtime(); exit(0); }\n_tp<_tyn T>void END( T mes ){ cout << mes << endl; END(); }\n\n// Debug\n#define B cerr << \"BreakPoint\" << endl;\n#define O(x) cerr << #x << \" \" << x << endl;\n#define o(x) cerr << #x << \" \" << x << \"  \";\n#define Msz(x) cerr << \"Sizeof \" << #x << \" \" << sizeof(x)/1024/1024 << \" MB\" << endl;\n_tp<_tyn T>void Print( T a[] , int s , int t , char sp = ' ' , char ed = '\\n' ){\n\tif( s > t ) return;\n\tfor( int i = s ; i < t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << a[t] << ed;\n\tcout.flush();\n}\n_tp<_tyn T>void Print( T a , int s = 0 , int t = -1 , char sp = ' ' , char ed = '\\n' ){\n\tif( t == -1 ) t = a.size()-1;\n\tfor( int i = s ; i <= t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << ed;\n\tcout.flush();\n}\n\n// Optimize\n#define Max(a,b) ((a)>(b)?(a):(b))\n#define Min(a,b) ((a)<(b)?(a):(b))\n#define Mymax(a,b) (a) = max((a),(b))\n#define Mymin(a,b) (a) = min((a),(b))\n#define MyMax(a,b) (a) = Max((a),(b))\n#define MyMin(a,b) (a) = Min((a),(b))\n#define INF (0x3f3f3f3f)\n#define LINF ((long long)(0x3f3f3f3f3f3f3f3f))\n#define Sqr(x) ((x)*(x))\n#define Lowbit(a) ((a)&(-(a)))\nvc<int> Range( int l , int r ){\n\tvc<int> ret{};\n\tForx(i,l,r) ret.Pb(i);\n\treturn ret;\n}\nmt19937 Rand(0xe38195e38293);\t// \u3055\u3093\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n/*\n\u70b9\u5206\u6cbb\uff0c\u8bb0\u5f55\u901a\u8fc7\u6bcf\u4e2a\u70b9\u7684\u6700\u957f\u8def\u5f84\n*/\n// #undef ll\n// #define ll unsigned long long\nconst int MAXN = 262144;\nconst int LOG = 20;\n\nconst int SGTSZ = 524288;\nstruct SGT{\n\t#define LSON l,l+r>>1,pos<<1\n\t#define RSON (l+r>>1)+1,r,pos<<1|1\n\t#define ROOT 1,n+n-1,1\n\t#define ARG int l , int r , int pos\n\tll t[SGTSZ], add[SGTSZ];\n\t// il SGT(){\n\t\t// Msn(t,-INF);\n\t\t// Ms(add);\n\t// }\n\til void Update( int pos ){\n\t\tt[pos] = max( t[pos<<1] , t[pos<<1|1] );\n\t}\n\til void Push(ARG){\n\t\tif( add[pos] == 0 ) return;\n\t\tint mid = l+r >> 1;\n\t\tt[pos<<1] += add[pos];\n\t\tadd[pos<<1] += add[pos];\n\t\tt[pos<<1|1] += add[pos];\n\t\tadd[pos<<1|1] += add[pos];\n\t\tadd[pos] = 0;\n\t}\n\tvoid Set( int gpos , const ll &x , ARG ){\n\t\tif( l == r ){\n\t\t\tt[pos] = x;\n\t\t\treturn;\n\t\t}\n\t\tPush(l,r,pos);\n\t\tint mid = l+r >> 1;\n\t\tif( gpos <= mid ) Set(gpos,x,LSON);\n\t\telse Set(gpos,x,RSON);\n\t\tUpdate(pos);\n\t}\n\tvoid Add( int gl , int gr , ll x , ARG ){\n\t\tif( gl <= l and r <= gr ){\n\t\t\tt[pos] += x;\n\t\t\tadd[pos] += x;\n\t\t\treturn;\n\t\t}\n\t\tPush(l,r,pos);\n\t\tint mid = l+r >> 1;\n\t\tif( gl <= mid ) Add(gl,gr,x,LSON);\n\t\tif( gr > mid ) Add(gl,gr,x,RSON);\n\t\tUpdate(pos);\n\t}\n\tll Query( int gl , int gr , ARG ){\n\t\tif( gl <= l and r <= gr ) return t[pos];\n\t\tPush(l,r,pos);\n\t\tint mid = l+r >> 1;\n\t\tif( gr <= mid ) return Query(gl,gr,LSON);\n\t\tif( gl > mid ) return Query(gl,gr,RSON);\n\t\treturn max( Query(gl,gr,LSON) , Query(gl,gr,RSON) );\n\t}\n}sgt[LOG];\n\nint n,q; ll wlim;\nvc<int> e[MAXN];\nll w[MAXN];\nll ans = 0;\n\nint root;\nvc<int> de[MAXN]; int defa[MAXN];\nmultiset<ll> anses_set;\nll anses[MAXN];\n\nbool vis[MAXN];\nint in[LOG][MAXN], out[LOG][MAXN], nowtime[LOG];\nint inlay[MAXN], from[LOG][MAXN];\nmultiset<ll> mxs[MAXN];\nvoid GetSz( int pos , int fa , int sz[] , int weight[] , vc<int> &past ){\n\tsz[pos] = 1;\n\tweight[pos] = 0;\n\tpast.Eb(pos);\n\tfor( auto v : e[pos] ){\n\t\tif( v == fa or vis[v] ) continue;\n\t\tGetSz(v,pos,sz,weight,past);\n\t\tsz[pos] += sz[v];\n\t\tMymax(weight[pos],sz[v]);\n\t}\n}\nint FindG( int pos ){\n\tstatic int sz[MAXN], weight[MAXN];\n\tstatic vc<int> past; past.clear();\n\tGetSz(pos,0,sz,weight,past);\n\tint tot = sz[pos], min_weight = INF, g = -1;\n\tfor( auto p : past ){\n\t\tMymax(weight[p],tot-sz[p]);\n\t\tif( weight[p] < min_weight ){\n\t\t\tmin_weight = weight[p];\n\t\t\tg = p;\n\t\t}\n\t}\n\treturn g;\n}\n\nll GetAns( int pos ){\n\tif(mxs[pos].empty()) return w[pos];\n\tauto p = mxs[pos].rbegin();\n\treturn (mxs[pos].size() == 1 ? *p : *p + *next(p)) + w[pos];\n}\nvoid InitDfs( int pos , int fa , int lay , int fr , ll dep , ll &maxdep ){\n\tin[lay][pos] = ++nowtime[lay];\n\tfrom[lay][pos] = fr;\n\tdep += w[pos];\n\tsgt[lay].Set(in[lay][pos],dep,ROOT);\n\tMymax(maxdep,dep);\n\tfor( auto v : e[pos] ){\n\t\tif( v == fa or vis[v] ) continue;\n\t\tInitDfs(v,pos,lay,fr,dep,maxdep);\n\t}\n\tout[lay][pos] = nowtime[lay];\n}\nvoid InitLayerData( int pos , int lay ){\n\tin[lay][pos] = ++nowtime[lay];\n\tfor( auto v : e[pos] ){\n\t\tif(vis[v]) continue;\n\t\tll mxdep = 0;\n\t\tInitDfs(v,pos,lay,v,0,mxdep);\n\t\tmxs[pos].insert(mxdep);\n\t}\n\t// cout << pos << endl;\n\t// for( auto v : mxs[pos] ) cout << v << \" \";\n\t// cout << endl;\n\tout[lay][pos] = nowtime[lay];\n\tanses[pos] = GetAns(pos);\n\tanses_set.insert(anses[pos]);\n}\nvoid PreDfs( int g , int lay ){\n\t// cout << g << \" \" << lay << endl;\n\tinlay[g] = lay;\n\tInitLayerData(g,lay);\n\tvis[g] = 1;\n\tfor( auto v : e[g] ){\n\t\tif(vis[v]) continue;\n\t\tint vg = FindG(v);\n\t\tde[g].Pb(vg);\n\t\tdefa[vg] = g;\n\t\tPreDfs(vg,lay+1);\n\t}\n}\n\nil void Rein( int pos ){\n\tanses_set.erase(anses_set.find(anses[pos]));\n\tanses[pos] = GetAns(pos);\n\tanses_set.insert(anses[pos]);\n}\nvoid Modify( int pos , ll delta ){\n\tint opos = pos;\n\tRein(pos);\n\tpos = defa[pos];\n\twhile(pos){\n\t\tint lay = inlay[pos];\n\t\tint ov = from[lay][opos];\n\t\tmxs[pos].erase(mxs[pos].find(sgt[lay].Query(in[lay][ov],out[lay][ov],ROOT)));\n\t\tsgt[lay].Add(in[lay][opos],out[lay][opos],delta,ROOT);\n\t\tmxs[pos].insert(sgt[lay].Query(in[lay][ov],out[lay][ov],ROOT));\n\t\tRein(pos);\n\t\tpos = defa[pos];\n\t}\n}\n\nint main(){\n\tFILEIO();\n\t// ios_base::sync_with_stdio(false);\n\t// cin.tie(0); cout.tie(0);\n\n\tRead(n,q); Read(wlim);\n\tFor(i,n-1){\n\t\tiRead2(a,b); lRead(c);\n\t\tint p = i+n;\n\t\tw[p] = c;\n\t\te[a].Pb(p); e[p].Pb(a);\n\t\te[b].Pb(p); e[p].Pb(b);\n\t}\n\n\troot = FindG(1);\n\tPreDfs(root,1);\n\t// Print(anses,1,n+n-1);\n\n\tFor(qi,q){\n\t\tlRead2(pos,x);\n\t\tpos = (pos+ans)%(n-1) + n + 1;\n\t\tx = (x+ans)%wlim;\n\t\tll delta = x - w[pos];\n\t\tw[pos] = x;\n\t\tModify(pos,delta);\n\t\t// cout << pos << \" \" << x << endl;\n\n\t\tans = *anses_set.rbegin();\n\t\t#ifdef WIN32\n\t\t\tprintf(\"%I64d\\n\",ans);\n\t\t#else\n\t\t\tprintf(\"%lld\\n\",ans);\n\t\t#endif\n\t\t// Print(anses,1,n+n-1);\n\t}\n\n\tEND();\n}\n",
    "ext": "cpp"
  },
  "57831037": {
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define PII pair<int, int>\nconst int MAXN = 200005;\nconst LL INF = (LL) 1e9 + 5;\nconst LL MOD = 998244353;\nusing namespace std;\n\nstruct Segment_tree {\n\tLL dia[4 * MAXN], maxL[4 * MAXN], maxR[4 * MAXN], maxv[4 * MAXN], minv[4 * MAXN], add[4 * MAXN];\n\tvoid pull(int idx, int len) {\n\t\tint l = idx << 1, r = idx << 1 | 1;\n\t\tdia[idx] = max({dia[l], dia[r], maxL[l] + maxv[r], maxR[r] + maxv[l]});\n\t\tmaxL[idx] = max({maxL[l], maxL[r], maxv[l] - 2 * minv[r]}) - add[idx];\n\t\tmaxR[idx] = max({maxR[l], maxR[r], maxv[r] - 2 * minv[l]}) - add[idx];\n\t\tmaxv[idx] = max(maxv[l], maxv[r]) + add[idx];\n\t\tminv[idx] = min(minv[l], minv[r]) + add[idx];\n\t}\n\tvoid init(vector<LL> &depth, int l, int r, int idx) {\n\t\tif (l == r) {\n\t\t\tdia[idx] = 0;\n\t\t\tmaxL[idx] = maxR[idx] = -depth[l];\n\t\t\tmaxv[idx] = minv[idx] = depth[l];\n\t\t\treturn;\n\t\t}\n\t\tint m = (l + r) >> 1;\n\t\tinit(depth, l, m, idx << 1);\n\t\tinit(depth, m + 1, r, idx << 1 | 1);\n\t\tpull(idx, r - l + 1);\n\t}\n\tvoid range_add(int ql, int qr, LL w, int l, int r, int idx) {\n\t\tif (ql <= l && r <= qr) {\n\t\t\tmaxL[idx] -= w;\n\t\t\tmaxR[idx] -= w;\n\t\t\tmaxv[idx] += w;\n\t\t\tminv[idx] += w;\n\t\t\tadd[idx] += w;\n\t\t\treturn;\n\t\t}\n\t\tint m = (l + r) >> 1;\n\t\tif (ql <= m) range_add(ql, qr, w, l, m, idx << 1);\n\t\tif (qr > m) range_add(ql, qr, w, m + 1, r, idx << 1 | 1);\n\t\tpull(idx, r - l + 1);\n\t}\n} tree;\n\nstruct Edge {\n\tint to;\n\tLL w;\n\tint id;\n};\n\nint N, M, Q;\nLL W;\n\nLL wei[MAXN], last;\nint son[MAXN];\n\nint st[MAXN], ed[MAXN], pa[MAXN];\nvector<int> tour;\nvector<LL> depth;\nvector<Edge> G[MAXN];\n\nvoid dfs(int v, int p, LL d) {\n//\tcout << \"DFS \" << v << '\\n';\n\tst[v] = tour.size();\n\tdepth.push_back(d);\n\ttour.push_back(v);\n\tfor (Edge &e : G[v]) {\n\t\tif (e.to == p) continue;\n\t\tson[e.id] = e.to;\n\t\tdfs(e.to, v, d + e.w);\n\t\tdepth.push_back(d);\n\t\ttour.push_back(v);\n\t}\n\ted[v] = tour.size() - 1;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\t\n\tcin >> N >> Q >> W;\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint a, b;\n\t\tLL c;\n\t\tcin >> a >> b >> c;\n\t\twei[i] = c;\n\t\tG[a].push_back({b, c, i});\n\t\tG[b].push_back({a, c, i});\n\t}\n\t\n\ttour.push_back(-1);\n\tdepth.push_back(-1);\n\tdfs(1, 1, 0);\n\tM = tour.size() - 1;\n\ttree.init(depth, 1, M, 1);\n\t\n//\tcout << \"Tour:\\n\";\n//\tfor (int i = 1; i <= M; i++) cout << tour[i] << ' '; cout << '\\n';\n//\tfor (int i = 1; i <= M; i++) cout << depth[i] << ' '; cout << '\\n';\n\t\n\twhile (Q--) {\n\t\tLL d, e;\n\t\tcin >> d >> e;\n\t\td = (d + last) % (N - 1);\n\t\te = (e + last) % W;\n//\t\tcout << \"Q \" << d << \" \" << e << '\\n';\n//\t\tcout << \"Go \" << st[son[d]] << \" \" << ed[son[d]] << \" \" << e << \" \" << e - wei[d] << '\\n';\n\t\t\n\t\ttree.range_add(st[son[d]], ed[son[d]], e - wei[d], 1, M, 1);\n\t\twei[d] = e;\n\t\tlast = tree.dia[1];\n\t\tcout << last << '\\n';\n\t}\n}",
    "ext": "cpp"
  },
  "57829411": {
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\n#define REP(i, n) for(int i = 0;i < n;i ++)\n#define REP1(i, n) for(int i = 1;i <= n;i ++)\n#define FILL(i, n) memset(i, n, sizeof(i))\n#define X first\n#define Y second\n#define pb push_back\n#define SZ(_a) ((int)(_a).size())\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#define endl '\\n'\n\nconst ll MAXn = 1e5 + 5;\n\nnamespace pre{\n\tvector<ii> v[MAXn];\n\tll p[MAXn], ed[MAXn];\n\tii e[MAXn];\n\n\tvoid dfs(ll now,ll f){\n\t\tfor(ii k:v[now])if(k.X != f){\n\t\t\tp[k.X] = now;\n\t\t\tdfs(k.X, now);\n\t\t}\n\t}\n\tvoid go(ll n){\n\t\tREP1(i, n - 1){\n\t\t\tll a, b, c;\n\t\t\tcin>>a>>b>>c;\n\t\t\te[i] = {a, b};ed[i] = c;\n\t\t\tv[a].pb({b, c});\n\t\t\tv[b].pb({a, c});\n\t\t}\n\t\tp[1] = 0;\n\t\tdfs(1, -1);\n\t}\n};\n\ntypedef pair<ll*, ll*> tg;\n\nll zz = 0, *z = &zz;\ntg ez = {z, z};\n\nstruct node{\n\tnode *p;\n\tll mx, d1, d2, len;\n\ttg omx, nmx, nlen;\n\tpair<tg, tg> nd1, nd2;\n\tnode():p(0), mx(0), d1(0), d2(0), len(0), omx(ez), nmx(ez), nlen(ez), nd1({ez, ez}), nd2({ez, ez}){}\n\tvoid setv(ll x){\n\t\tmx = d1 = d2 = len = x;\n\t}\n\tvoid pull(){\n\t\tmx = max({*omx.X, *omx.Y, *nmx.X + *nmx.Y});\n\t\tlen = *nlen.X + *nlen.Y;\n\t\td1 = max(*nd1.X.X + *nd1.X.Y, *nd1.Y.X + *nd1.Y.Y);\n\t\td2 = max(*nd2.X.X + *nd2.X.Y, *nd2.Y.X + *nd2.Y.Y);\n\t}\n};\n\n#define CLR(_v) (_v).clear(), (_v).shrink_to_fit()\n\nvector<ll> v[MAXn];\nll ed[MAXn], u[MAXn], nct, e[MAXn];\nnode *en[MAXn], *nd[MAXn];\n\nvoid dfs(ll now){\n\tu[now] = 0;\n\tfor(ll k:v[now])dfs(k);\n\tif(!SZ(v[now]))return;\n\tif(SZ(v[now]) == 1 && !u[v[now][0]] && now != 1){\n\t\tll a = now, b = v[now][0];\n\t\tu[a] = u[b] = 1;\n\t\tnode *n = new node(), *na = nd[a], *nb = nd[b];\n\t\tna->p = nb->p = n;\n\t\tn->omx = {&na->mx, &nb->mx};\n\t\tn->nmx = {&na->d2, &nb->d1};\n\t\tn->nlen = {&na->len, &nb->len};\n\t\tn->nd1 = {{&na->d1, z}, {&nb->d1, &na->len}};\n\t\tn->nd2 = {{&nb->d2, z}, {&na->d2, &nb->len}};\n\t\tv[a] = v[b];\n\t\t//CLR(v[b]);\n\t\tnd[a] = n;\n\t\tn->pull();\n\t\tnct --;\n\t\treturn;\n\t}\n\tvector<ll> nv;\n\tvector<ii> pv;\n\tqueue<ll> qa, qb;\n\tfor(ll x:v[now])if(!u[x]){\n\t\tif(SZ(v[x]) == 0)qa.push(x);\n\t\telse qb.push(x);\n\t}else nv.pb(x);\n\n\twhile(SZ(qa)){\n\t\tll a = qa.front(), b;qa.pop();\n\t\tif(SZ(qb))b = qb.front(), qb.pop();\t\n\t\telse if(SZ(qa))b = qa.front(), qa.pop();\n\t\telse{\n\t\t\tnv.pb(a);\n\t\t\tbreak;\n\t\t}\n\t\tpv.pb({a, b});\n\t}\n\twhile(SZ(qb))nv.pb(qb.front()), qb.pop();\n\tfor(auto &p:pv){\n\t\tll a = p.X, b = p.Y;\n\t\tu[a] = u[b] = 1;\n\t\tnode *n = new node(), *na = nd[a], *nb = nd[b];\n\t\tna->p = nb->p = n;\n\t\tn->omx = {&na->mx, &nb->mx};\n\t\tn->nmx = {&na->d1, &nb->d1};\n\t\tn->nlen = {&nb->len, z};\n\t\tn->nd1 = {{&na->d1, z}, {&nb->d1, z}};\n\t\tn->nd2 = {{&nb->d2, z}, {&na->d1, &nb->len}};\n\t\tnv.pb(b);\n\t\tnd[b] = n;\n\t\tn->pull();\n\t\tnct --;\n\t}\n\t//CLR(v[now]);\n\tv[now] = nv;\n}\n\nvoid upd(node *n){\n\twhile(n->p){\n\t\tn = n->p, n->pull();\n\t}\n}\n\nint main(){\n\tIOS();\n\tll n, q, w;\n\tcin>>n>>q>>w;\n\tpre::go(n);\n\tREP1(i, n - 1)e[i] = (pre::p[pre::e[i].X] == pre::e[i].Y ? pre::e[i].X : pre::e[i].Y);\n\tfor(int i = 2;i <= n;i ++)v[pre::p[i]].pb(i);\n\n\tREP1(i, n - 1)\n\t{\n\t\ted[i] = pre::ed[i];\n\t\ten[i] = new node();\n\t\ten[i]->setv(ed[i]);\n\t\tnd[e[i]] = en[i];\n\t}\n\t\n\tnct = n - 1;\n\twhile(nct > 1)dfs(1);\n\tnode *rt = nd[v[1][0]];\n\tll lst = 0;\n\twhile(q--)\n\t{\n\t\tll a, b;\n\t\tcin>>a>>b;\n\t\ta = (a + lst) % (n - 1) + 1;\n\t\tb = (b + lst) % w;\n\t\ten[a]->setv(b);\n\t\tupd(en[a]);\n\t\tll ans = rt->mx;\n\t\tcout<<ans<<endl;\n\t\tlst = ans;\n\t}\n}",
    "ext": "cpp"
  },
  "57828921": {
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\n#define REP(i, n) for(int i = 0;i < n;i ++)\n#define REP1(i, n) for(int i = 1;i <= n;i ++)\n#define FILL(i, n) memset(i, n, sizeof(i))\n#define X first\n#define Y second\n#define pb push_back\n#define ALL(_a) (_a).begin(), (_a).end()\n#define SZ(_a) ((int)(_a).size())\n#ifdef brian\n#define IOS()\ntemplate<typename T>void _do(T &&x){cerr<<x<<endl;}\ntemplate<typename T, typename ...t>void _do(T &&x, t &&...X){cerr<<x<<\", \";_do(X...);}\n#define debug(...) {\\\n\tfprintf(stderr, \"%s - %d (%s) = \", __PRETTY_FUNCTION__, __LINE__, #__VA_ARGS__);\\\n\t_do(__VA_ARGS__);\\\n}\n#else\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#define endl '\\n'\n#define debug(...)\n#endif\n\nconst ll MAXn = 1e5 + 5;\nconst ll INF = ll(1e18);\n\nnamespace pre{\n\tvector<ii> v[MAXn];\n\tll p[MAXn], ed[MAXn];\n\tii e[MAXn];\n\n\tvoid dfs(ll now,ll f)\n\t{\n\t\tfor(ii k:v[now])if(k.X != f)\n\t\t{\n\t\t\tp[k.X] = now;\n\t\t\tdfs(k.X, now);\n\t\t}\n\t}\n\tvoid go(ll n)\n\t{\n\t\tREP1(i, n - 1)\n\t\t{\n\t\t\tll a, b, c;\n\t\t\tcin>>a>>b>>c;\n\t\t\te[i] = {a, b};ed[i] = c;\n\t\t\tv[a].pb({b, c});\n\t\t\tv[b].pb({a, c});\n\t\t}\n\t\tp[1] = 0;\n\t\tdfs(1, -1);\n\t}\n};\n\ntypedef pair<ll*, ll*> tg;\n\nll zz = 0, *z = &zz;\ntg ez = make_pair(z, z);\n\nstruct node{\n\tnode *p;\n\tll mx, d1, d2, len;\n\ttg omx, nmx, nlen;\n\tpair<tg, tg> nd1, nd2;\n\tnode():p(0), mx(0), d1(0), d2(0), len(0), omx(ez), nmx(ez), nlen(ez), nd1({ez, ez}), nd2({ez, ez}){}\n\tvoid setv(ll x)\n\t{\n\t\tmx = d1 = d2 = len = x;\n\t}\n\tvoid pull(){\n\t\tmx = max({*omx.X, *omx.Y, *nmx.X + *nmx.Y});\n\t\tlen = *nlen.X + *nlen.Y;\n\t\td1 = max(*nd1.X.X + *nd1.X.Y, *nd1.Y.X + *nd1.Y.Y);\n\t\td2 = max(*nd2.X.X + *nd2.X.Y, *nd2.Y.X + *nd2.Y.Y);\n\t}\n};\n\n#define CLR(_v) (_v).clear(), (_v).shrink_to_fit()\n\nvector<ll> v[MAXn];\nll ed[MAXn], u[MAXn], nct;\nnode *en[MAXn], *nd[MAXn];\nll e[MAXn];\n\n\nvoid dfs(ll now)\n{\n\tu[now] = 0;\n\tfor(ll k:v[now])dfs(k);\n\tif(!SZ(v[now]))return;\n\tif(SZ(v[now]) == 1 && !u[v[now][0]] && now != 1)\n\t{\n\t\tll a = now, b = v[now][0];\n\t\tu[a] = u[b] = 1;\n\t\tnode *n = new node(), *na = nd[a], *nb = nd[b];\n\t\tna->p = nb->p = n;\n\t\tn->omx = {&na->mx, &nb->mx};\n\t\tn->nmx = {&na->d2, &nb->d1};\n\t\tn->nlen = {&na->len, &nb->len};\n\t\tn->nd1 = {{&na->d1, z}, {&nb->d1, &na->len}};\n\t\tn->nd2 = {{&nb->d2, z}, {&na->d2, &nb->len}};\n\t\tv[a] = v[b];\n\t\tCLR(v[b]);\n\t\tnd[a] = n;\n\t\tn->pull();\n\t\tnct --;\n\t\treturn;\n\t}\n\tvector<ll> nv;\n\tvector<ii> pv;\n\tqueue<ll> qa, qb;\n\tfor(ll x:v[now])if(!u[x])\n\t{\n\t\tif(SZ(v[x]) == 0)qa.push(x);\n\t\telse qb.push(x);\n\t}else nv.pb(x);\n\n\twhile(SZ(qa))\n\t{\n\t\tll a = qa.front(), b;qa.pop();\n\t\tif(SZ(qb))b = qb.front(), qb.pop();\t\n\t\telse if(SZ(qa))b = qa.front(), qa.pop();\n\t\telse{\n\t\t\tnv.pb(a);\n\t\t\tbreak;\n\t\t}\n\t\tpv.pb({a, b});\n\t}\n\twhile(SZ(qb))nv.pb(qb.front()), qb.pop();\n\tfor(auto &p:pv)\n\t{\n\t\tll a = p.X, b = p.Y;\n\t\tu[a] = u[b] = 1;\n\t\tnode *n = new node(), *na = nd[a], *nb = nd[b];\n\t\tna->p = nb->p = n;\n\t\tn->omx = {&na->mx, &nb->mx};\n\t\tn->nmx = {&na->d1, &nb->d1};\n\t\tn->nlen = {&nb->len, z};\n\t\tn->nd1 = {{&na->d1, z}, {&nb->d1, z}};\n\t\tn->nd2 = {{&nb->d2, z}, {&na->d1, &nb->len}};\n\t\tnv.pb(b);\n\t\tnd[b] = n;\n\t\tn->pull();\n\t\tnct --;\n\t}\n\tCLR(v[now]);\n\tv[now] = nv;\n}\n\nvoid upd(node *n){\n\twhile(n->p){\n\t\tn = n->p, n->pull();\n\t}\n}\n\nint main(){\n\tIOS();\n\tll n, q, w;\n\tcin>>n>>q>>w;\n\tpre::go(n);\n\tREP1(i, n - 1)e[i] = (pre::p[pre::e[i].X] == pre::e[i].Y ? pre::e[i].X : pre::e[i].Y);\n\tfor(int i = 2;i <= n;i ++)v[pre::p[i]].pb(i);\n\n\tREP1(i, n - 1)\n\t{\n\t\ted[i] = pre::ed[i];\n\t\ten[i] = new node();\n\t\ten[i]->setv(ed[i]);\n\t\tnd[e[i]] = en[i];\n\t}\n\n\tnct = n - 1;\n\twhile(nct > 1)dfs(1);\n\tnode *rt = nd[v[1][0]];\n\tll lst = 0;\n\twhile(q--)\n\t{\n\t\tll a, b;\n\t\tcin>>a>>b;\n\t\ta = (a + lst) % (n - 1) + 1;\n\t\tb = (b + lst) % w;\n\t\ten[a]->setv(b);\n\t\tupd(en[a]);\n\t\tll ans = rt->mx;\n\t\tcout<<ans<<endl;\n\t\tlst = ans;\n\t}\n}",
    "ext": "cpp"
  },
  "57828272": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, ll> pil;\ntypedef pair<pil, int> pili;\n\nvector<pili> g[100005];\n\nll baseArr[100005];\nint chainIdx[100005];\nint chainHead[100005];\nint posArr[100005];\n\nint chainNo = 1;\nint idx = 1;\n\nint depth[100005];\nint par[17][100005];\nint sz[100005];\n\nll arr[100005];\nint tmp[100005];\nint n, q;\n\nstruct st{\n    ll ST[400005], lazy[400005];\n\n    void build(int n, int s, int e){\n        if(s == e) ST[n] = arr[s];\n        else{\n            int mid = (s+e)/2;\n            build(n+n, s, mid);\n            build(n+n+1, mid+1, e);\n            ST[n] = max(ST[n+n], ST[n+n+1]);\n        }\n    }\n    void update_val(int n, int s, int e, ll v){\n        ST[n] += v;\n        if(s != e){\n            lazy[n+n] += v;\n            lazy[n+n+1] += v;\n        }\n        lazy[n] = 0;\n    }\n    void update2(int n, int s, int e, int l, int r, ll v){\n        update_val(n, s, e, lazy[n]);\n        if(l > r || s > r || l > e) return;\n        if(l <= s && e <= r){\n            update_val(n, s, e, v);\n            return;\n        }\n        int mid = (s+e)/2;\n        update2(n+n, s, mid, l, r, v);\n        update2(n+n+1, mid+1, e, l, r, v);\n        ST[n] = max(ST[n*2], ST[n*2+1]);\n    }\n    ll query(int n, int s, int e, int l, int r){\n        update_val(n, s, e, lazy[n]);\n        if(l > r || s > r || l > e) return -1e18;\n        if(l <= s && e <= r) return ST[n];\n        int mid = (s+e)/2;\n        ll p1 = query(n*2, s, mid, l, r);\n        ll p2 = query(n*2+1, mid+1, e, l, r);\n        return max(p1, p2);\n    }\n\n    int query2(int n, int s, int e){\n        update_val(n, s, e, lazy[n]);\n        if(s == e) return tmp[s];\n        else{\n            int mid = (s+e)/2;\n            if(query(n+n, s, mid, s, mid) > query(n+n+1, mid+1, e, mid+1, e)) return query2(n+n, s, mid);\n            return query2(n+n+1, mid+1, e);\n        }\n    }\n}st1, st2;\n\nint LCA(int a, int b){\n    if(depth[a] < depth[b]) swap(a, b);\n    int diff = depth[a] - depth[b];\n    for(int i=19;i>=0;i--){\n        if((diff>>i)&1) a = par[i][a];\n    }\n    if(a == b) return a;\n    for(int i=19;i>=0;i--){\n        if(par[i][a] != par[i][b]) a = par[i][a], b = par[i][b];\n    }\n    return par[0][a];\n}\n\nvoid addEdge(int a, int b, ll c, int i){\n    g[a].push_back(pili(pil(b, c), i));\n    g[b].push_back(pili(pil(a, c), i));\n}\n\nint IDX[100005], wh[100005];\nint st[100005], en[100005];\nll we[100005];\nint heavy[100005];\nvoid dfs(int u, int p, int d){\n    depth[u] = d;\n    par[0][u] = p;\n    sz[u] = 1;\n\n    for(int i=0;i<g[u].size();i++){\n        int v = g[u][i].first.first;\n        ll w = g[u][i].first.second;\n        if(v == p) continue;\n        dfs(v, u, d+1);\n        sz[u] += sz[v];\n    }\n}\n\nvoid decompose(int u, int p, ll sum, ll w = 0, int i = -1){\n    if(chainHead[chainNo] == 0) chainHead[chainNo] = u;\n    chainIdx[u] = chainNo;\n    posArr[u] = idx;\n\n    if(i != -1){\n        IDX[u] = i;\n        wh[i] = u;\n    }\n    st[u] = idx;\n    we[u] = w;\n    tmp[idx] = u;\n    arr[idx++] = sum;\n    ll nc = 0, pos = -1, tsz = 0, ie = 0;\n    for(int i=0;i<g[u].size();i++){\n        int v = g[u][i].first.first;\n        ll w = g[u][i].first.second;\n        int j = g[u][i].second;\n        if(v == p) continue;\n        if(sz[v] > tsz){\n            tsz = sz[v];\n            pos = v;\n            nc = w;\n            ie = j;\n        }\n    }\n    if(pos != -1){\n        heavy[u] = pos;\n        decompose(pos, u, sum+nc, nc, ie);\n    }\n    for(int i=0;i<g[u].size();i++){\n        int v = g[u][i].first.first;\n        ll w = g[u][i].first.second;\n        int j = g[u][i].second;\n        if(v == p || v == pos) continue;\n        chainNo++;\n        decompose(v, u, sum+w, w, j);\n    }\n    en[u] = idx-1;\n}\n\nll query_up(int u){\n    ll res = 0;\n    int last = u, last2 = u;\n    while(1){\n        int uchain = chainIdx[u];\n        u = chainHead[uchain];\n\n        res = max(res, st2.query(1, 1, n, st[u], st[last]-1));\n        res = max(res, st2.query(1, 1, n, en[last]+1, en[u]));\n\n        last2 = u;\n        u = par[0][u];\n        last = u;\n        if(u == 0) break;\n        res = max(res, max(st1.query(1, 1, n, st[u], st[last2]-1), st1.query(1, 1, n, en[last2]+1, en[u])) - 2*st1.query(1, 1, n, st[u], st[u]));\n    }\n    return res;\n}\n\nvoid update_up(int u, ll w){\n    st1.update2(1, 1, n, st[u], en[u], w);\n    st2.update2(1, 1, n, st[u], en[u], -w);\n    int last = u;\n    while(1){\n        int uchain = chainIdx[u];\n        u = chainHead[uchain];\n        if(u == 1) break;\n        last = u;\n        u = par[0][u];\n        ll mx = max(st1.query(1, 1, n, st[u], st[heavy[u]]-1), st1.query(1, 1, n, en[heavy[u]]+1, en[u]));\n        ll sum = st1.query(1, 1, n, st[u], st[u]);\n        ll q = st2.query(1, 1, n, st[u], st[u]);\n        st2.update2(1, 1, n, st[u], st[u], -q + mx - 2*sum);\n    }\n}\n\nint main(){\n    ll w, c;\n    scanf(\"%d%d%lld\", &n, &q, &w);\n    for(int i=0;i<n-1;i++){\n        int a, b;\n        scanf(\"%d%d%lld\", &a, &b, &c);\n        addEdge(a, b, c, i);\n    }\n    dfs(1, 0, 0);\n    for(int j=1;j<=16;j++) for(int i=1;i<=n;i++) if(par[j-1][i] != 0) par[j][i] = par[j-1][par[j-1][i]];\n    decompose(1, 0, 0);\n    st1.build(1, 1, n);\n\n    for(int u=1;u<=n;u++){\n        ll mx = max(st1.query(1, 1, n, st[u], st[heavy[u]]-1), st1.query(1, 1, n, en[heavy[u]]+1, en[u]));\n        if(heavy[u] == 0) mx = st1.query(1, 1, n, st[u], en[u]);\n        ll sum = st1.query(1, 1, n, st[u], st[u]);\n\n        ll q = st2.query(1, 1, n, st[u], st[u]);\n        st2.update2(1, 1, n, st[u], st[u], -q + mx - 2*sum);\n    }\n\n    ll ans = 0;\n    for(int i=1;i<=q;i++){\n        ll d, e;\n        scanf(\"%lld%lld\", &d, &e);\n        d = (d+ans)%(n-1);\n        e = (e+ans)%w;\n        update_up(wh[d], -we[wh[d]]+e);\n        we[wh[d]] = e;\n\n        int u = st1.query2(1, 1, n);\n\n        ans = st1.query(1, 1, n, st[u], st[u]) + query_up(u);\n        printf(\"%lld\\n\", ans);\n    }\n}",
    "ext": "cpp"
  },
  "57827251": {
    "code": "/*input\n50 1 10000\n1 8 6341\n24 13 9970\n49 33 8948\n8 4 7841\n37 20 8622\n14 20 9574\n1 46 1759\n3 48 9588\n41 42 3168\n47 34 541\n20 22 7825\n15 21 2424\n9 20 6679\n42 15 9261\n23 1 31\n49 15 1996\n45 16 1249\n44 32 9036\n22 15 2694\n23 30 8009\n27 9 7800\n19 11 6125\n20 38 6891\n28 39 5247\n16 3 8141\n32 7 8846\n5 23 8802\n33 31 746\n6 26 7533\n13 34 8359\n20 1 7012\n39 36 7446\n23 2 5414\n29 47 2589\n1 3 8717\n19 9 3588\n13 12 7596\n43 21 3347\n1 44 2753\n39 9 4381\n50 48 5682\n18 3 2576\n22 35 5894\n40 20 5801\n10 44 8922\n11 17 975\n25 20 4275\n26 20 108\n2 47 5098\n36 9878\n\n\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb emplace_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define EL cout<<'\\n'\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n    out<<'('<<P.F<<','<<P.S<<')';\n    return out;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out,vector<T> V){\n    REP(i,SZ(V)) out<<V[i]<<((i!=SZ(V)-1)?\" \":\"\");\n    return out;\n}\n#define version 20190726\n//}}}\nconst ll maxn=100005;\nconst ll maxlg=20;\nconst ll INF64=1e18;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst ld PI=acos(-1);\nconst ld eps=1e-9;\n//const ll p=880301;\n//const ll P=31;\n \nll mypow(ll a,ll b){\n    ll res=1LL;\n    while(b){\n        if(b&1) res=res*a%MOD;\n        a=a*a%MOD;\n        b>>=1;\n    }\n    return res;\n}\n \nstruct Cluster{\n    Cluster *par=NULL;\n    int b1,b2;\n    ll D,d1,d2;\n    Cluster *lc,*rc;\n    ll ans;\n \n    bool mytype;\n \n    Cluster(){}\n    Cluster(Cluster *A,Cluster *B,bool type){\n        // cout<<\"Merge: \"<<MP(A->b1,A->b2)<<' '<<MP(B->b1,B->b2)<<' '<<type<<'\\n';\n \n        A->par=this;\n        B->par=this;\n        lc=A,rc=B;\n        mytype=type;\n        update();\n    }\n    Cluster(int u,int v,ll d){\n        if(u>v) swap(u,v); \n        ans=d;\n        b1=u,b2=v;\n        D=d1=d2=d;\n        lc=rc=par=NULL;\n    }\n    Cluster(int u,ll d){\n        ans=d;\n        b1=-1,b2=u;\n        D=d2=d;\n        d1=-1;\n        lc=rc=par=NULL;\n    }\n    Cluster(ll d){\n        ans=d;\n        b1=b2=-1;\n        D=d1=d2=-1;\n        lc=rc=par=NULL;\n    }\n    void mdf(ll d){ //only for single edge\n        D=d1=d2=d;\n        ans=d;\n    }\n    void update(){ //type := 1 if the common boundary is still a boundary\n        ans=max(lc->ans,rc->ans);\n        assert(lc!=NULL&&rc!=NULL);\n        if(lc->b1==-1){\n            if(rc->b1==-1){\n                assert(lc->b2==rc->b2);\n                if(mytype==0){\n                    b1=b2=-1;\n                    D=d1=d2=-1;\n                    ans=max(ans,lc->d2+rc->d2);\n                }\n                else{\n                    b1=-1,b2=lc->b2;\n                    D=-1;\n                    d1=-1;\n                    d2=max(lc->d2,rc->d2);\n                    ans=max(ans,lc->d2+rc->d2);\n                }\n            }\n            else{\n                if(mytype){\n                    if(lc->b2==rc->b1){\n                        b1=rc->b1;\n                        b2=rc->b2;\n                        D=rc->D;\n                        d1=max(lc->d2,rc->d1);\n                        d2=max(rc->d2,rc->D+lc->d2);\n                        ans=max(ans,lc->d2+rc->d1);\n                    }\n                    else{\n                        b1=rc->b1;\n                        b2=rc->b2;\n                        D=rc->D;\n                        d1=max(rc->d1,D+lc->d2);\n                        d2=max(rc->d2,lc->d2);\n                        ans=max(ans,lc->d2+rc->d2);\n                    }\n                }\n                else{\n                    if(lc->b2==rc->b1){\n                        b1=-1;\n                        b2=rc->b2;\n                        D=-1;\n                        d1=-1;\n                        d2=max(rc->d2,rc->D+lc->d2);\n                        ans=max(ans,lc->d2+rc->d1);\n                    }\n                    else{\n                        b1=-1;\n                        b2=rc->b1;\n                        D=-1;\n                        d1=-1;\n                        d2=max(rc->d1,rc->D+lc->d2);\n                        ans=max(ans,lc->d2+rc->d2);\n                    }\n                }\n            }\n        }\n        else{\n            if(rc->b1==-1){\n                swap(lc,rc);\n                update();\n            }\n            else{\n                if(lc->b1==rc->b1){\n                    if(lc->b2>rc->b2) swap(lc,rc);\n                    b1=lc->b2;\n                    b2=rc->b2;\n                    D=lc->D+rc->D;\n                    d1=max(lc->d2,lc->D+rc->d1);\n                    d2=max(rc->d2,rc->D+lc->d1);\n                    ans=max(ans,lc->d1+rc->d1);\n                }\n                else if(lc->b1==rc->b2||rc->b1==lc->b2){\n                    if(rc->b2==lc->b1) swap(lc,rc);\n                    b1=lc->b1;\n                    b2=rc->b2;\n                    D=lc->D+rc->D;\n                    d1=max(lc->d1,lc->D+rc->d1);\n                    d2=max(rc->d2,rc->D+lc->d2);\n                    ans=max(ans,lc->d2+rc->d1);\n                }\n                else{\n                    if(lc->b1>rc->b1) swap(lc,rc);\n                    b1=lc->b1;\n                    b2=rc->b1;\n                    D=lc->D+rc->D;\n                    d1=max(lc->d1,lc->D+rc->d2);\n                    d2=max(rc->d1,rc->D+lc->d2);\n                    ans=max(ans,lc->d2+rc->d2);\n                }\n            }\n        }\n    }\n};\n \n \nvector<Cluster*> nb[maxn];\nvector<Cluster*> lst;\n \nbool vis[maxn];\nvector<Cluster*> remain;\n \nbool dfs(int u,int root){\n    vis[u]=1;\n    vector<Cluster*> leaf;\n    vector<Cluster*> other; \n    int deg=(u!=root);\n    Cluster *toPar;\n    for(Cluster* c:nb[u]){\n        if(c->b1==-1){\n            leaf.pb(c);\n            deg++;\n        }\n        else if(vis[c->b1+c->b2-u]) toPar=c;\n        else{\n            // cout<<\"From \"<<u<<\" to \"<<c->b1+c->b2-u<<\".\\n\";\n            bool res=dfs(c->b1+c->b2-u,root);\n            if(res) other.pb(c);\n            deg++;\n        }\n    }\n    // cout<<\"u: \"<<u<<'\\n';\n    // cout<<\"Leaves: \"<<SZ(leaf)<<'\\n';\n    // cout<<\"Others: \";\n    // for(Cluster *c:other) cout<<MP(c->b1,c->b2)<<' ';\n    // cout<<endl;\n    // cout<<\"Remain: \";\n    // for(Cluster *c:remain) cout<<MP(c->b1,c->b2)<<' ';\n    // cout<<endl;\n \n    int sz=SZ(leaf);\n    while(SZ(leaf)>=2){\n        Cluster *mrg=new Cluster(leaf.back(),leaf[SZ(leaf)-2],!(sz==2&&u==root&&deg==2));\n        remain.pb(mrg);\n        leaf.back()->par=mrg;\n        leaf[SZ(leaf)-2]->par=mrg;\n        leaf.pop_back();\n        leaf.pop_back();\n    }\n    if(SZ(leaf)==1&&u!=root){\n        Cluster *mrg=new Cluster(leaf[0],toPar,!(deg==2&&SZ(other)==0&&sz==1));\n        leaf.pop_back();\n        remain.pb(mrg);\n        for(Cluster *c:other) remain.pb(c);\n        return 0;\n    }\n    if(SZ(leaf)==1&&u==root){\n        if(SZ(other)!=0){\n            Cluster *mrg=new Cluster(leaf[0],other.back(),!(sz==1&&SZ(other)==1&&deg==2));\n            remain.pb(mrg);\n            leaf.pop_back();\n            other.pop_back();\n        }\n        else{\n            remain.pb(leaf[0]);\n        }\n    }\n    if(deg==2&&sz==0&&u!=root&&SZ(other)==1){\n        Cluster *mrg=new Cluster(other[0],toPar,0);\n        remain.pb(mrg);\n        return 0;\n    }\n    if(u==root&&deg==2&&sz==0&&SZ(other)==2){\n        Cluster *mrg=new Cluster(other[0],other[1],0);\n        remain.pb(mrg);\n        return 0;\n    }\n    for(Cluster *i:other) remain.pb(i);\n    return 1;\n}\n \nCluster* edge[maxn];\nint uu[maxn],vv[maxn],distan[maxn];\nint _deg[maxn];\nint32_t main(){\n    IOS;\n    int n,q;\n    ll w;\n    cin>>n>>q>>w;\n \n    REP(i,n-1){\n        cin>>uu[i]>>vv[i]>>distan[i];\n        uu[i]--;vv[i]--;\n        _deg[uu[i]]++;\n        _deg[vv[i]]++;\n    }\n\n    REP(i,n-1){\n        if(_deg[uu[i]]>_deg[vv[i]]) swap(uu[i],vv[i]);\n        if(_deg[uu[i]]==1){\n            if(_deg[vv[i]]==1){\n                edge[i]=new Cluster(distan[i]);\n            }\n            edge[i]=new Cluster(vv[i],distan[i]);\n        }\n        else{\n            edge[i]=new Cluster(uu[i],vv[i],distan[i]);\n        }\n        lst.pb(edge[i]);\n    }\n    while(SZ(lst)!=1){\n        // for(Cluster *c:lst){\n        //     cout<<MP(c->b1,c->b2)<<' ';\n        // }\n        // cout<<endl;\n        // cout<<endl;\n        REP(i,n) nb[i].clear();\n        REP(i,n) vis[i]=0;\n        remain.clear();\n        int root=lst[0]->b2;\n        // cout<<\"Root: \"<<root<<endl;\n        for(Cluster* c:lst){\n            if(c->b1!=-1){\n                nb[c->b1].pb(c);\n            }\n            if(c->b2!=-1){\n                nb[c->b2].pb(c);\n            }\n        }\n        dfs(root,root);\n        lst=remain;\n    }\n \n    // REP(i,n-1){\n    //     cout<<i<<'\\n';\n    //     Cluster *cur=edge[i];\n    //     while(cur!=NULL){\n    //         cout<<MP(cur->b1,cur->b2)<<' ';\n    //         cur=cur->par;\n    //     }\n    //     cout<<'\\n';\n    // }\n \n    ll last_ans=0;\n    while(q--){\n        ll idx,wei;\n        cin>>idx>>wei;\n        idx=(idx+last_ans)%(n-1);\n        wei=(wei+last_ans)%w;\n \n        edge[idx]->mdf(wei);\n        ll ans=0;\n        Cluster* cur=edge[idx];\n        while(cur!=NULL){\n            ans=max(ans,cur->ans);\n            cur=cur->par;\n            if(cur==NULL) break;\n            cur->update();\n        }\n        cout<<ans<<'\\n';\n        last_ans=ans;\n    }\n    return 0;\n}",
    "ext": "cpp"
  },
  "57826229": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Neighbour {\n\tint to, id;\n\tlong long w;\n\tNeighbour(int to_, int id_, long long w_) : to(to_), id(id_), w(w_) {}\n};\n\nstruct Datum {\n\tint ia, ib, from, to;\n\tDatum(int ia_, int ib_, int from_, int to_) : ia(ia_), ib(ib_), from(from_), to(to_) {}\n};\n\nstruct MyQueue {\n\tstruct Label {\n\t\tlong long val;\n\t\tint id;\n\t\tLabel(long long val_, int id_) : val(val_), id(id_) {}\n\t\tbool operator<(const Label& rhs) const {return val < rhs.val;} \n\t};\n\tpriority_queue<Label> q;\n\tvector<long long> cur;\n\tvoid Update(int id, long long val) {\n\t\tif (val == cur[id])\n\t\t\treturn;\n\t\tq.emplace(cur[id] = val, id);\n\t}\n\tlong long GetMax() {\n\t\twhile (cur[q.top().id] != q.top().val)\n\t\t\tq.pop();\n\t\treturn q.top().val;\n\t}\n\tlong long GetMax2() {\n\t\twhile (cur[q.top().id] != q.top().val)\n\t\t\tq.pop();\n\t\tauto tmp = q.top();\n\t\tq.pop();\n\t\twhile (cur[q.top().id] != q.top().val || q.top().id == tmp.id)\n\t\t\tq.pop();\n\t\tlong long re = tmp.val + q.top().val;\n\t\tq.push(tmp);\n\t\treturn re;\n\t}\n};\n\nint n, q, dp[100005], si, bi, bv, cnt, root, now;\nbool g[100005];\nlong long w, cur[100005], z[100005], add, old[100005];\nvector<Neighbour> v[100005];\nvector<Datum> up[100005];\nMyQueue ans;\nchar zzz[30];\n\nstruct Componet {\n\tstruct Branch {\n\t\tint si;\n\t\tvector<pair<long long, long long>> seg;\n\t\tvoid Build(int l, int r, int i) {\n\t\t\twhile (i >= seg.size())\n\t\t\t\tseg.emplace_back(0, 0);\n\t\t\tif (l + 1 == r) {\n\t\t\t\tseg[i].first = z[l];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint mi = (l + r) / 2;\n\t\t\tBuild(l, mi, i * 2);\n\t\t\tBuild(mi, r, i * 2 + 1);\n\t\t\tseg[i].first = max(seg[i * 2].first, seg[i * 2 + 1].first);\n\t\t}\n\t\tvoid Update(int a, int b, int l, int r, int i) {\n\t\t\tif (a == l && b == r) {\n\t\t\t\tseg[i].first += add;\n\t\t\t\tseg[i].second += add;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint mi = (l + r) / 2;\n\t\t\tif (a < mi)\n\t\t\t\tUpdate(a, min(mi, b), l, mi, i * 2);\n\t\t\tif (mi < b)\n\t\t\t\tUpdate(max(mi, a), b, mi, r, i * 2 + 1);\n\t\t\tseg[i].first = max(seg[i * 2].first, seg[i * 2 + 1].first) + seg[i].second;\n\t\t}\n\t};\n\tvector<Branch> v;\n\tMyQueue q;\n\tvoid Update(int id, int a, int b) {\n\t\tv[id].Update(a, b, 0, v[id].si, 1);\n\t\tq.Update(id, v[id].seg[1].first);\n\t}\n} x[100005];\n\nvoid dfs1(int a, int b) {\n\tdp[a] = 1;\n\tint tmp = 0;\n\tfor (auto& i : v[a])\n\t\tif (i.to != b && !g[i.to]) {\n\t\t\tdfs1(i.to, a);\n\t\t\tdp[a] += dp[i.to];\n\t\t\ttmp = max(tmp, dp[i.to]);\n\t\t}\n\ttmp = max(tmp, si - dp[a]);\n\tif (tmp < bv) {\n\t\tbi = a;\n\t\tbv = tmp;\n\t}\n}\n\nvoid dfs2(int a, int b, long long c, int d) {\n\tdp[a] = 1;\n\tint ia = cnt;\n\tfor (auto& i : v[a])\n\t\tif (i.to != b && !g[i.to]) {\n\t\t\tdfs2(i.to, a, c + i.w, i.id);\n\t\t\tdp[a] += dp[i.to];\n\t\t}\n\tif (dp[a] == 1)\n\t\tz[cnt++] = c;\n\tup[d].emplace_back(root, now, ia, cnt);\n}\n\nvoid go(int a) {\n\tbv = INT_MAX;\n\tdfs1(a, 0);\n\troot = bi;\n\tg[root] = 1;\n\tauto& y = x[root];\n\tnow = 0;\n\tfor (auto& i : v[root])\n\t\tif (!g[i.to]) {\n\t\t\ty.v.emplace_back();\n\t\t\tcnt = 0;\n\t\t\tdfs2(i.to, 0, i.w, i.id);\n\t\t\ty.v.back().Build(0, cnt, 1);\n\t\t\ty.v.back().si = cnt;\n\t\t\tnow++;\n\t\t}\n\ty.q.cur.resize(now);\n\tfor (int i = 0; i < now; i++)\n\t\ty.q.q.emplace(y.q.cur[i] = y.v[i].seg[1].first, i);\n\tfor (auto& i : v[root])\n\t\tif (!g[i.to] && dp[i.to] >= 3) {\n\t\t\tsi = dp[i.to];\n\t\t\tgo(i.to);\n\t\t}\n}\n\nint main() {\n\tscanf(\"%d%d%lld\", &n, &q, &w);\n\tif (n == 2) {\n\t\tscanf(\"%s%s%s\", zzz, zzz, zzz);\n\t\tlong long last = 0;\n\t\twhile (q--) {\n\t\t\tlong long e;\n\t\t\tscanf(\"%s%lld\", zzz, &e);\n\t\t\tlast = (last + e) % w;\n\t\t\tprintf(\"%lld\\n\", last);\n\t\t}\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint ta, tb;\n\t\tlong long tc;\n\t\tscanf(\"%d%d%lld\", &ta, &tb, old + i);\n\t\tv[ta].emplace_back(tb, i, old[i]);\n\t\tv[tb].emplace_back(ta, i, old[i]);\n\t}\n\tsi = n;\n\tgo(1);\n\tans.cur.resize(n + 1);\n\tfor (int i = 1; i < n; i++)\n\t\tif (!x[i].q.q.empty())\n\t\t\tans.q.emplace(ans.cur[i] = x[i].q.GetMax2(), i);\n\tlong long last = 0;\n\twhile (q--) {\n\t\tint tmp;\n\t\tscanf(\"%d%lld\", &tmp, &add);\n\t\ttmp = (tmp + last) % (n - 1);\n\t\tadd = (add + last) % w;\n\t\tswap(old[tmp], add);\n\t\tadd = old[tmp] - add;\n\t\tfor (auto& i : up[tmp]) {\n\t\t\tx[i.ia].Update(i.ib, i.from, i.to);\n\t\t\tans.Update(i.ia, x[i.ia].q.GetMax2());\n\t\t}\n\t\tlast = ans.GetMax();\n\t\tprintf(\"%lld\\n\", last);\n\t}\n}\n",
    "ext": "cpp"
  },
  "57825872": {
    "code": "#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx2,tune=native\")\n//#pragma comment(linker, \"/stack:200000000\")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n \n#define X first\n#define Y second\n \n//#include <boost/unordered_map.hpp>\n//using namespace boost;\n \n/*\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> rbtree;\nrbtree T;\n*/\n \nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing f64 = double;\nusing f80 = long double;\n//using i128 = __int128_t;\n//using u128 = __uint128_t;\nusing i128 = i64;\nusing u128 = u64;\n \nll power(ll a, ll b, ll p)\n{\n\tif (!b) return 1;\n\tll t = power(a, b/2, p);\n\tt = t*t%p;\n\tif (b&1) t = t*a%p;\n\treturn t;\n}\n \nll exgcd(ll a, ll b, ll &x, ll &y)\n{\n\tif (b == 0)\n\t{\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn a;\n\t}\n\tll px, py;\n\tll d = exgcd(b, a%b, px, py);\n\tx = py;\n\ty = px-a/b*py;\n\treturn d;\n}\n \ntemplate<class T>\ninline void freshmin(T &a, const T &b)\n{\n\tif (a > b) a = b;\n}\n \ntemplate<class T>\ninline void freshmax(T &a, const T &b)\n{\n\tif (a < b) a = b;\n}\n \n//#define getchar getchar_unlocked\n//#define putchar putchar_unlocked\n \nint inp() {\n\tint x = 0, f = 0; char ch;\n\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\tif(ch == '-') f = 1;\n\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\treturn f ? -x : x;\n}\n \nll inp_ll() {\n\tll x = 0; int f = 0; char ch;\n\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\tif(ch == '-') f = 1;\n\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\treturn f ? -x : x;\n}\n \ntemplate<class T>\nbool read(T &x)\n{\n\tx = 0;\n\tchar ch = getchar();\n\tif (ch == EOF) return 0;\n\tfor(; !isdigit(ch); )\n\t{\n\t\tch = getchar();\n\t\tif (ch == EOF) return 0;\n\t}\n\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\treturn 1;\n}\n \ntemplate<class T>\nvoid write(T x)\n{\n\tstatic char s[22];\n\tstatic char *it = s+20;\n\tstatic char *end = s+20;\n\tif (!x)\n\t\t*-- it = '0';\n\twhile (x)\n\t{\n\t\t*-- it = x%10+'0';\n\t\tx /= 10;\n\t}\n\tfor (; it < end; ++ it)\n\t\tputchar(*it);\n}\n \ntemplate<class T>\nvoid writeln(T x)\n{\n\twrite(x);\n\tputchar('\\n');\n}\n \nconst int MAXN = 100010;\nconst i64 INF = 2000000000000000000LL;\nconst int MOD = 998244353;\n \nint n;\npii e[MAXN];\nvector<pair<int, i64>> v[MAXN];\nvector<int> son[MAXN];\n \nint pre[MAXN], size[MAXN];\ni64 weight[MAXN];\n \nvoid dfs1(int x)\n{\n\tsize[x] = 1;\n\tfor (auto p : v[x])\n\t{\n\t\tint y = p.X;\n\t\ti64 z = p.Y;\n\t\tif (y == pre[x]) continue;\n\t\tpre[y] = x;\n\t\tson[x].push_back(y);\n\t\tweight[y] = z;\n\t\tdfs1(y);\n\t\tsize[x] += size[y];\n\t}\n}\n \nint times, X[MAXN], Y[MAXN], r[MAXN];\nint from[MAXN], leaf[MAXN];\ni64 f[MAXN][2], g[MAXN][2];\nmultiset<i64> H[MAXN][2];\n\nvoid get_gval(int x)\n{\n\tg[x][0] = g[x][1] = 0;\n\tif (!H[x][0].empty())\n\t\tfreshmax(g[x][0], *H[x][0].rbegin());\n\tif (!H[x][1].empty())\n\t{\n\t\tif (H[x][1].size() == 1)\n\t\t\tfreshmax(g[x][0], *H[x][1].rbegin());\n\t\telse\n\t\t\tfreshmax(g[x][0], *H[x][1].rbegin()+*++ H[x][1].rbegin());\n\t\tfreshmax(g[x][1], *H[x][1].rbegin());\n\t}\n}\n \nvoid dfs2(int x)\n{\n\tX[x] = ++ times;\n\tr[times] = x;\n\tif (!son[x].empty())\n\t{\n\t\tsort(son[x].begin(), son[x].end(), [&](int a, int b)\n\t\t{\n\t\t\treturn size[a] > size[b];\n\t\t});\n\t\tint next = son[x][0];\n\t\tfor (auto y : son[x])\n\t\t{\n\t\t\tfrom[y] = y == next ? from[x] : y;\n\t\t\tdfs2(y);\n\t\t\tif (y != next)\n\t\t\t{\n\t\t\t\tH[x][0].insert(f[y][0]);\n\t\t\t\tH[x][1].insert(f[y][1]);\n\t\t\t}\n\t\t}\n\t\tget_gval(x);\n\t\tf[x][0] = max(max(f[next][0], g[x][0]), f[next][1]+g[x][1]);\n\t\tf[x][1] = max(f[next][1], g[x][1])+weight[x];\n\t}\n\telse\n\t{\n\t\tleaf[from[x]] = x;\n\t\tf[x][0] = 0;\n\t\tf[x][1] = weight[x];\n\t}\n\tY[x] = times;\n}\n\nstruct matrix\n{\n\ti64 v[2][2];\n\tvoid set(int x)\n\t{\n\t\tv[0][0] = g[x][1], v[0][1] = g[x][0];\n\t\tv[1][0] = weight[x], v[1][1] = g[x][1]+weight[x];\n\t}\n\tfriend matrix operator * (const matrix &a, const matrix &b)\n\t{\n\t\tmatrix c;\n\t\tc.v[0][0] = max(b.v[0][0], a.v[0][0]+b.v[1][0]);\n\t\tc.v[0][1] = max(max(b.v[0][1], a.v[0][1]), a.v[0][0]+b.v[1][1]);\n\t\tc.v[1][0] = a.v[1][0]+b.v[1][0];\n\t\tc.v[1][1] = max(a.v[1][0]+b.v[1][1], a.v[1][1]);\n\t\treturn c;\n\t}\n};\n\nmatrix tree[MAXN*4];\n\nvoid update(int k)\n{\n\ttree[k] = tree[k<<1]*tree[k<<1|1];\n}\n\nvoid build(int k, int L, int R)\n{\n\tif (L == R)\n\t{\n\t\ttree[k].set(r[L]);\n\t\treturn;\n\t}\n\tint m = (L+R)>>1;\n\tbuild(k<<1, L, m);\n\tbuild(k<<1|1, m+1, R);\n\tupdate(k);\n}\n\nvoid rebuild(int k, int L, int R, int x)\n{\n\tif (L == R)\n\t{\n\t\ttree[k].set(r[x]);\n\t\treturn;\n\t}\n\tint m = (L+R)>>1;\n\tif (x <= m)\n\t\trebuild(k<<1, L, m, x);\n\telse\n\t\trebuild(k<<1|1, m+1, R, x);\n\tupdate(k);\n}\n\nmatrix get(int k, int L, int R, int x, int y)\n{\n\tif (L == x && R == y)\n\t\treturn tree[k];\n\tint m = (L+R)>>1;\n\tif (y <= m)\n\t\treturn get(k<<1, L, m, x, y);\n\tif (x > m)\n\t\treturn get(k<<1|1, m+1, R, x, y);\n\treturn get(k<<1, L, m, x, m)*get(k<<1|1, m+1, R, m+1, y);\n}\n \nvoid modify(int px, i64 pw)\n{\n\tfor (int x = px; x; )\n\t{\n\t\tint y = from[x];\n\t\tif (x = pre[y])\n\t\t{\n\t\t\tmatrix M = get(1, 1, n, X[y], X[leaf[y]]);\n\t\t\ti64 fy0 = max(M.v[0][0], M.v[0][1]);\n\t\t\ti64 fy1 = max(M.v[1][0], M.v[1][1]);\n\t\t\tH[x][0].erase(H[x][0].lower_bound(fy0));\n\t\t\tH[x][1].erase(H[x][1].lower_bound(fy1));\n\t\t}\n\t}\n\t\n\tweight[px] = pw;\n\trebuild(1, 1, n, X[px]);\n\t\n\tfor (int x = px; x; )\n\t{\n\t\tint y = from[x];\n\t\tif (x = pre[y])\n\t\t{\n\t\t\tmatrix M = get(1, 1, n, X[y], X[leaf[y]]);\n\t\t\ti64 fy0 = max(M.v[0][0], M.v[0][1]);\n\t\t\ti64 fy1 = max(M.v[1][0], M.v[1][1]);\n\t\t\tH[x][0].insert(fy0);\n\t\t\tH[x][1].insert(fy1);\n\t\t\tget_gval(x);\n\t\t\trebuild(1, 1, n, X[x]);\n\t\t}\n\t}\n}\n \ni64 diameter()\n{\n\tmatrix M = get(1, 1, n, X[1], X[leaf[1]]);\n\treturn max(M.v[0][0], M.v[0][1]);\n}\n\nint main()\n{\n\t\n\tn = inp();\n\tint q = inp();\n\ti64 W = inp_ll();\n\t\n\tfor (int i = 1; i < n; ++ i)\n\t{\n\t\tint x = inp();\n\t\tint y = inp();\n\t\ti64 z = inp_ll();\n\t\tv[x].push_back({y, z});\n\t\tv[y].push_back({x, z});\n\t\te[i] = {x, y};\n\t}\n\t\n\tdfs1(1);\n\tfrom[1] = 1;\n\tdfs2(1);\n\t\n\tbuild(1, 1, n);\n\t\n\ti64 ans = 0;\n\twhile (q --)\n\t{\n\t\tint a = (inp()+ans)%(n-1)+1;\n\t\ti64 b = (inp_ll()+ans)%W;\n\t\tint x = pre[e[a].X] == e[a].Y ? e[a].X : e[a].Y;\n\t\tmodify(x, b);\n\t\tans = diameter();\n\t\twriteln(ans);\n\t}\n\t\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57825812": {
    "code": "#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx2,tune=native\")\n//#pragma comment(linker, \"/stack:200000000\")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n \n#define X first\n#define Y second\n \n//#include <boost/unordered_map.hpp>\n//using namespace boost;\n \n/*\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> rbtree;\nrbtree T;\n*/\n \nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing f64 = double;\nusing f80 = long double;\n//using i128 = __int128_t;\n//using u128 = __uint128_t;\nusing i128 = i64;\nusing u128 = u64;\n \nll power(ll a, ll b, ll p)\n{\n\tif (!b) return 1;\n\tll t = power(a, b/2, p);\n\tt = t*t%p;\n\tif (b&1) t = t*a%p;\n\treturn t;\n}\n \nll exgcd(ll a, ll b, ll &x, ll &y)\n{\n\tif (b == 0)\n\t{\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn a;\n\t}\n\tll px, py;\n\tll d = exgcd(b, a%b, px, py);\n\tx = py;\n\ty = px-a/b*py;\n\treturn d;\n}\n \ntemplate<class T>\ninline void freshmin(T &a, const T &b)\n{\n\tif (a > b) a = b;\n}\n \ntemplate<class T>\ninline void freshmax(T &a, const T &b)\n{\n\tif (a < b) a = b;\n}\n \n//#define getchar getchar_unlocked\n//#define putchar putchar_unlocked\n \nint inp() {\n\tint x = 0, f = 0; char ch;\n\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\tif(ch == '-') f = 1;\n\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\treturn f ? -x : x;\n}\n \nll inp_ll() {\n\tll x = 0; int f = 0; char ch;\n\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\tif(ch == '-') f = 1;\n\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\treturn f ? -x : x;\n}\n \ntemplate<class T>\nbool read(T &x)\n{\n\tx = 0;\n\tchar ch = getchar();\n\tif (ch == EOF) return 0;\n\tfor(; !isdigit(ch); )\n\t{\n\t\tch = getchar();\n\t\tif (ch == EOF) return 0;\n\t}\n\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\treturn 1;\n}\n \ntemplate<class T>\nvoid write(T x)\n{\n\tstatic char s[22];\n\tstatic char *it = s+20;\n\tstatic char *end = s+20;\n\tif (!x)\n\t\t*-- it = '0';\n\twhile (x)\n\t{\n\t\t*-- it = x%10+'0';\n\t\tx /= 10;\n\t}\n\tfor (; it < end; ++ it)\n\t\tputchar(*it);\n}\n \ntemplate<class T>\nvoid writeln(T x)\n{\n\twrite(x);\n\tputchar('\\n');\n}\n \nconst int MAXN = 100010;\nconst i64 INF = 2000000000000000000LL;\nconst int MOD = 998244353;\n \nint n;\npii e[MAXN];\nvector<pair<int, i64>> v[MAXN];\nvector<int> son[MAXN];\n \nint pre[MAXN], size[MAXN];\ni64 weight[MAXN];\n \nvoid dfs1(int x)\n{\n\tsize[x] = 1;\n\tfor (auto p : v[x])\n\t{\n\t\tint y = p.X;\n\t\ti64 z = p.Y;\n\t\tif (y == pre[x]) continue;\n\t\tpre[y] = x;\n\t\tson[x].push_back(y);\n\t\tweight[y] = z;\n\t\tdfs1(y);\n\t\tsize[x] += size[y];\n\t}\n}\n \nint times, X[MAXN], Y[MAXN], r[MAXN];\nint from[MAXN], leaf[MAXN];\ni64 f[MAXN][2], g[MAXN][2];\nmultiset<i64> H[MAXN][2];\n\nvoid get_gval(int x)\n{\n\tg[x][0] = g[x][1] = 0;\n\tif (!H[x][0].empty())\n\t\tfreshmax(g[x][0], *H[x][0].rbegin());\n\tif (!H[x][1].empty())\n\t{\n\t\tif (H[x][1].size() == 1)\n\t\t\tfreshmax(g[x][0], *H[x][1].rbegin());\n\t\telse\n\t\t\tfreshmax(g[x][0], *H[x][1].rbegin()+*++ H[x][1].rbegin());\n\t\tfreshmax(g[x][1], *H[x][1].rbegin());\n\t}\n}\n \nvoid dfs2(int x)\n{\n\tX[x] = ++ times;\n\tr[times] = x;\n\tif (!son[x].empty())\n\t{\n\t\tsort(son[x].begin(), son[x].end(), [&](int a, int b)\n\t\t{\n\t\t\treturn size[a] > size[b];\n\t\t});\n\t\tint next = son[x][0];\n\t\tfor (auto y : son[x])\n\t\t{\n\t\t\tfrom[y] = y == next ? from[x] : y;\n\t\t\tdfs2(y);\n\t\t\tif (y != next)\n\t\t\t{\n\t\t\t\tH[x][0].insert(f[y][0]);\n\t\t\t\tH[x][1].insert(f[y][1]);\n\t\t\t}\n\t\t}\n\t\tget_gval(x);\n\t\tf[x][0] = max(max(f[next][0], g[x][0]), f[next][1]+g[x][1]);\n\t\tf[x][1] = max(f[next][1], g[x][1])+weight[x];\n\t}\n\telse\n\t{\n\t\tleaf[from[x]] = x;\n\t\tf[x][0] = 0;\n\t\tf[x][1] = weight[x];\n\t}\n\tY[x] = times;\n}\n\nstruct matrix\n{\n\ti64 v[3][3];\n\tvoid set(int x)\n\t{\n\t\tv[0][1] = g[x][1], v[0][2] = g[x][0];\n\t\tv[1][1] = weight[x], v[1][2] = g[x][1]+weight[x];\n\t}\n\tfriend matrix operator * (const matrix &a, const matrix &b)\n\t{\n\t\tmatrix c;\n\t\tc.v[0][1] = max(b.v[0][1], a.v[0][1]+b.v[1][1]);\n\t\tc.v[0][2] = max(max(b.v[0][2], a.v[0][2]), a.v[0][1]+b.v[1][2]);\n\t\tc.v[1][1] = a.v[1][1]+b.v[1][1];\n\t\tc.v[1][2] = max(a.v[1][1]+b.v[1][2], a.v[1][2]);\n\t\treturn c;\n\t}\n};\n\nmatrix tree[MAXN*4];\n\nvoid update(int k)\n{\n\ttree[k] = tree[k<<1]*tree[k<<1|1];\n}\n\nvoid build(int k, int L, int R)\n{\n\tif (L == R)\n\t{\n\t\ttree[k].set(r[L]);\n\t\treturn;\n\t}\n\tint m = (L+R)>>1;\n\tbuild(k<<1, L, m);\n\tbuild(k<<1|1, m+1, R);\n\tupdate(k);\n}\n\nvoid rebuild(int k, int L, int R, int x)\n{\n\tif (L == R)\n\t{\n\t\ttree[k].set(r[x]);\n\t\treturn;\n\t}\n\tint m = (L+R)>>1;\n\tif (x <= m)\n\t\trebuild(k<<1, L, m, x);\n\telse\n\t\trebuild(k<<1|1, m+1, R, x);\n\tupdate(k);\n}\n\nmatrix get(int k, int L, int R, int x, int y)\n{\n\tif (L == x && R == y)\n\t\treturn tree[k];\n\tint m = (L+R)>>1;\n\tif (y <= m)\n\t\treturn get(k<<1, L, m, x, y);\n\tif (x > m)\n\t\treturn get(k<<1|1, m+1, R, x, y);\n\treturn get(k<<1, L, m, x, m)*get(k<<1|1, m+1, R, m+1, y);\n}\n \nvoid modify(int px, i64 pw)\n{\n\tfor (int x = px; x; )\n\t{\n\t\tint y = from[x];\n\t\tif (x = pre[y])\n\t\t{\n\t\t\tmatrix M = get(1, 1, n, X[y], X[leaf[y]]);\n\t\t\ti64 fy0 = max(M.v[0][1], M.v[0][2]);\n\t\t\ti64 fy1 = max(M.v[1][1], M.v[1][2]);\n\t\t\tH[x][0].erase(H[x][0].lower_bound(fy0));\n\t\t\tH[x][1].erase(H[x][1].lower_bound(fy1));\n\t\t}\n\t}\n\t\n\tweight[px] = pw;\n\trebuild(1, 1, n, X[px]);\n\t\n\tfor (int x = px; x; )\n\t{\n\t\tint y = from[x];\n\t\tif (x = pre[y])\n\t\t{\n\t\t\tmatrix M = get(1, 1, n, X[y], X[leaf[y]]);\n\t\t\ti64 fy0 = max(M.v[0][1], M.v[0][2]);\n\t\t\ti64 fy1 = max(M.v[1][1], M.v[1][2]);\n\t\t\tH[x][0].insert(fy0);\n\t\t\tH[x][1].insert(fy1);\n\t\t\tget_gval(x);\n\t\t\trebuild(1, 1, n, X[x]);\n\t\t}\n\t}\n}\n \ni64 diameter()\n{\n\tmatrix M = get(1, 1, n, X[1], X[leaf[1]]);\n\treturn max(M.v[0][1], M.v[0][2]);\n}\n\nint main()\n{\n\t\n\tn = inp();\n\tint q = inp();\n\ti64 W = inp_ll();\n\t\n\tfor (int i = 1; i < n; ++ i)\n\t{\n\t\tint x = inp();\n\t\tint y = inp();\n\t\ti64 z = inp_ll();\n\t\tv[x].push_back({y, z});\n\t\tv[y].push_back({x, z});\n\t\te[i] = {x, y};\n\t}\n\t\n\tdfs1(1);\n\tfrom[1] = 1;\n\tdfs2(1);\n\t\n\tbuild(1, 1, n);\n\t\n\ti64 ans = 0;\n\twhile (q --)\n\t{\n\t\tint a = (inp()+ans)%(n-1)+1;\n\t\ti64 b = (inp_ll()+ans)%W;\n\t\tint x = pre[e[a].X] == e[a].Y ? e[a].X : e[a].Y;\n\t\tmodify(x, b);\n\t\tans = diameter();\n\t\twriteln(ans);\n\t}\n\t\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57825524": {
    "code": "#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx2,tune=native\")\n//#pragma comment(linker, \"/stack:200000000\")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n \n#define X first\n#define Y second\n \n//#include <boost/unordered_map.hpp>\n//using namespace boost;\n \n/*\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> rbtree;\nrbtree T;\n*/\n \nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing f64 = double;\nusing f80 = long double;\n//using i128 = __int128_t;\n//using u128 = __uint128_t;\nusing i128 = i64;\nusing u128 = u64;\n \nll power(ll a, ll b, ll p)\n{\n\tif (!b) return 1;\n\tll t = power(a, b/2, p);\n\tt = t*t%p;\n\tif (b&1) t = t*a%p;\n\treturn t;\n}\n \nll exgcd(ll a, ll b, ll &x, ll &y)\n{\n\tif (b == 0)\n\t{\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn a;\n\t}\n\tll px, py;\n\tll d = exgcd(b, a%b, px, py);\n\tx = py;\n\ty = px-a/b*py;\n\treturn d;\n}\n \ntemplate<class T>\ninline void freshmin(T &a, const T &b)\n{\n\tif (a > b) a = b;\n}\n \ntemplate<class T>\ninline void freshmax(T &a, const T &b)\n{\n\tif (a < b) a = b;\n}\n \n//#define getchar getchar_unlocked\n//#define putchar putchar_unlocked\n \nint inp() {\n\tint x = 0, f = 0; char ch;\n\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\tif(ch == '-') f = 1;\n\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\treturn f ? -x : x;\n}\n \nll inp_ll() {\n\tll x = 0; int f = 0; char ch;\n\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\tif(ch == '-') f = 1;\n\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\treturn f ? -x : x;\n}\n \ntemplate<class T>\nbool read(T &x)\n{\n\tx = 0;\n\tchar ch = getchar();\n\tif (ch == EOF) return 0;\n\tfor(; !isdigit(ch); )\n\t{\n\t\tch = getchar();\n\t\tif (ch == EOF) return 0;\n\t}\n\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\treturn 1;\n}\n \ntemplate<class T>\nvoid write(T x)\n{\n\tstatic char s[22];\n\tstatic char *it = s+20;\n\tstatic char *end = s+20;\n\tif (!x)\n\t\t*-- it = '0';\n\twhile (x)\n\t{\n\t\t*-- it = x%10+'0';\n\t\tx /= 10;\n\t}\n\tfor (; it < end; ++ it)\n\t\tputchar(*it);\n}\n \ntemplate<class T>\nvoid writeln(T x)\n{\n\twrite(x);\n\tputchar('\\n');\n}\n \nconst int MAXN = 100010;\nconst i64 INF = 2000000000000000000LL;\nconst int MOD = 998244353;\n \nint n;\npii e[MAXN];\nvector<pair<int, i64>> v[MAXN];\nvector<int> son[MAXN];\n \nint pre[MAXN], size[MAXN];\ni64 weight[MAXN];\n \nvoid dfs1(int x)\n{\n\tsize[x] = 1;\n\tfor (auto p : v[x])\n\t{\n\t\tint y = p.X;\n\t\ti64 z = p.Y;\n\t\tif (y == pre[x]) continue;\n\t\tpre[y] = x;\n\t\tson[x].push_back(y);\n\t\tweight[y] = z;\n\t\tdfs1(y);\n\t\tsize[x] += size[y];\n\t}\n}\n \nint times, X[MAXN], Y[MAXN], r[MAXN];\nint from[MAXN], leaf[MAXN];\ni64 f[MAXN][2], g[MAXN][2];\nmultiset<i64> H[MAXN][2];\n\nvoid get_gval(int x)\n{\n\tg[x][0] = g[x][1] = 0;\n\tif (!H[x][0].empty())\n\t\tfreshmax(g[x][0], *H[x][0].rbegin());\n\tif (!H[x][1].empty())\n\t{\n\t\tif (H[x][1].size() == 1)\n\t\t\tfreshmax(g[x][0], *H[x][1].rbegin());\n\t\telse\n\t\t\tfreshmax(g[x][0], *H[x][1].rbegin()+*++ H[x][1].rbegin());\n\t\tfreshmax(g[x][1], *H[x][1].rbegin());\n\t}\n}\n \nvoid dfs2(int x)\n{\n\tX[x] = ++ times;\n\tr[times] = x;\n\tif (!son[x].empty())\n\t{\n\t\tsort(son[x].begin(), son[x].end(), [&](int a, int b)\n\t\t{\n\t\t\treturn size[a] > size[b];\n\t\t});\n\t\tint next = son[x][0];\n\t\tfor (auto y : son[x])\n\t\t{\n\t\t\tfrom[y] = y == next ? from[x] : y;\n\t\t\tdfs2(y);\n\t\t\tif (y != next)\n\t\t\t{\n\t\t\t\tH[x][0].insert(f[y][0]);\n\t\t\t\tH[x][1].insert(f[y][1]);\n\t\t\t}\n\t\t}\n\t\tget_gval(x);\n\t\tf[x][0] = max(max(f[next][0], g[x][0]), f[next][1]+g[x][1]);\n\t\tf[x][1] = max(f[next][1], g[x][1])+weight[x];\n\t}\n\telse\n\t{\n\t\tleaf[from[x]] = x;\n\t\tf[x][0] = 0;\n\t\tf[x][1] = weight[x];\n\t}\n\tY[x] = times;\n}\n\nstruct matrix\n{\n\ti64 v[3][3];\n\tvoid set(int x)\n\t{\n\t\tv[0][0] = 0, v[0][1] = g[x][1], v[0][2] = g[x][0];\n\t\tv[1][0] = -INF, v[1][1] = weight[x], v[1][2] = g[x][1]+weight[x];\n\t\tv[2][0] = v[2][1] = -INF, v[2][2] = 0;\n\t}\n\tfriend matrix operator * (const matrix &a, const matrix &b)\n\t{\n\t\tmatrix c;\n\t\tfor (int i = 0; i < 3; ++ i)\n\t\t\tfor (int j = 0; j < 3; ++ j)\n\t\t\t{\n\t\t\t\tc.v[i][j] = -INF;\n\t\t\t\tfor (int k = 0; k < 3; ++ k)\n\t\t\t\t\tfreshmax(c.v[i][j], a.v[i][k]+b.v[k][j]);\n\t\t\t}\n\t\treturn c;\n\t}\n};\n\nmatrix tree[MAXN*4];\n\nvoid update(int k)\n{\n\ttree[k] = tree[k<<1]*tree[k<<1|1];\n}\n\nvoid build(int k, int L, int R)\n{\n\tif (L == R)\n\t{\n\t\ttree[k].set(r[L]);\n\t\treturn;\n\t}\n\tint m = (L+R)>>1;\n\tbuild(k<<1, L, m);\n\tbuild(k<<1|1, m+1, R);\n\tupdate(k);\n}\n\nvoid rebuild(int k, int L, int R, int x)\n{\n\tif (L == R)\n\t{\n\t\ttree[k].set(r[x]);\n\t\treturn;\n\t}\n\tint m = (L+R)>>1;\n\tif (x <= m)\n\t\trebuild(k<<1, L, m, x);\n\telse\n\t\trebuild(k<<1|1, m+1, R, x);\n\tupdate(k);\n}\n\nmatrix get(int k, int L, int R, int x, int y)\n{\n\tif (L == x && R == y)\n\t\treturn tree[k];\n\tint m = (L+R)>>1;\n\tif (y <= m)\n\t\treturn get(k<<1, L, m, x, y);\n\tif (x > m)\n\t\treturn get(k<<1|1, m+1, R, x, y);\n\treturn get(k<<1, L, m, x, m)*get(k<<1|1, m+1, R, m+1, y);\n}\n \nvoid modify(int px, i64 pw)\n{\n\tfor (int x = px; x; )\n\t{\n\t\tint y = from[x];\n\t\tif (x = pre[y])\n\t\t{\n\t\t\tmatrix M = get(1, 1, n, X[y], X[leaf[y]]);\n\t\t\ti64 fy0 = max({M.v[0][0], M.v[0][1], M.v[0][2]});\n\t\t\ti64 fy1 = max({M.v[1][0], M.v[1][1], M.v[1][2]});\n\t\t\tH[x][0].erase(H[x][0].lower_bound(fy0));\n\t\t\tH[x][1].erase(H[x][1].lower_bound(fy1));\n\t\t}\n\t}\n\t\n\tweight[px] = pw;\n\trebuild(1, 1, n, X[px]);\n\t\n\tfor (int x = px; x; )\n\t{\n\t\tint y = from[x];\n\t\tif (x = pre[y])\n\t\t{\n\t\t\tmatrix M = get(1, 1, n, X[y], X[leaf[y]]);\n\t\t\ti64 fy0 = max({M.v[0][0], M.v[0][1], M.v[0][2]});\n\t\t\ti64 fy1 = max({M.v[1][0], M.v[1][1], M.v[1][2]});\n\t\t\tH[x][0].insert(fy0);\n\t\t\tH[x][1].insert(fy1);\n\t\t\tget_gval(x);\n\t\t\trebuild(1, 1, n, X[x]);\n\t\t}\n\t}\n}\n \ni64 diameter()\n{\n\tmatrix M = get(1, 1, n, X[1], X[leaf[1]]);\n\treturn max({M.v[0][0], M.v[0][1], M.v[0][2]});\n}\n\nint main()\n{\n\t\n\tn = inp();\n\tint q = inp();\n\ti64 W = inp_ll();\n\t\n\tfor (int i = 1; i < n; ++ i)\n\t{\n\t\tint x = inp();\n\t\tint y = inp();\n\t\ti64 z = inp_ll();\n\t\tv[x].push_back({y, z});\n\t\tv[y].push_back({x, z});\n\t\te[i] = {x, y};\n\t}\n\t\n\tdfs1(1);\n\tfrom[1] = 1;\n\tdfs2(1);\n\t\n\tbuild(1, 1, n);\n\t\n\ti64 ans = 0;\n\twhile (q --)\n\t{\n\t\tint a = (inp()+ans)%(n-1)+1;\n\t\ti64 b = (inp_ll()+ans)%W;\n\t\tint x = pre[e[a].X] == e[a].Y ? e[a].X : e[a].Y;\n\t\tmodify(x, b);\n\t\tans = diameter();\n\t\twriteln(ans);\n\t}\n\t\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57824297": {
    "code": "import java.util.*\nimport kotlin.math.max\n\nfun main() {\n    val jin = Scanner(System.`in`)\n    val n = jin.nextInt()\n    val q = jin.nextInt()\n    val w = jin.nextLong()\n    val nodes = Array(n + 1, ::Node)\n    nodes[1].parent = nodes[0]\n    nodes[1].edges.add(Edge(nodes[0], 0, 0))\n    for (i in 0 until n - 1) {\n        val a = jin.nextInt()\n        val b = jin.nextInt()\n        val length = jin.nextLong()\n        nodes[a].edges.add(Edge(nodes[b], length, i))\n        nodes[b].edges.add(Edge(nodes[a], length, i))\n    }\n    val dfs = Array(n) { nodes[1] }\n    val qodes = Array(n - 1) { nodes[0] }\n    var j = 1\n    for (i in 0 until n) {\n        for (k in 0 until dfs[i].edges.size - 1) {\n            var edge = dfs[i].edges[k]\n            if (edge.node == dfs[i].parent) {\n                edge = dfs[i].edges.last()\n                dfs[i].edges[k] = edge\n            }\n            qodes[edge.ix] = edge.node\n            edge.node.parent = dfs[i]\n            edge.node.parentLength = edge.length\n            dfs[j] = edge.node\n            j++\n        }\n        dfs[i].edges.removeAt(dfs[i].edges.size - 1)\n    }\n    for (node in dfs.reversed()) {\n        node.parent.subTreeSize += node.subTreeSize\n        var bestIx = -1\n        for (k in 0 until node.edges.size) {\n            node.edges[k].node.treeix = k\n            if (node.bestChild == null || node.bestChild!!.subTreeSize < node.edges[k].node.subTreeSize) {\n                node.bestChild = node.edges[k].node\n                bestIx = k\n            }\n        }\n        //println(\"$node.bestChild = ${node.bestChild}\")\n        if (node.bestChild != null) {\n            node.edges.last().node.treeix = bestIx\n            node.edges[bestIx] = node.edges.last()\n            node.edges.removeAt(node.edges.size - 1)\n        }\n        node.hortree = Hortree(node.edges.size)\n    }\n    for (node in dfs) {\n        if (node.parent.bestChild == node) {\n            continue\n        }\n        var amt = 0\n        var subNode: Node? = node.bestChild\n        while (subNode != null) {\n            subNode.treeix = amt\n            subNode = subNode.bestChild\n            amt++\n        }\n        node.vertree = Vertree(node, amt)\n        subNode = node.bestChild\n        while (subNode != null) {\n            subNode.vertree = node.vertree\n            subNode = subNode.bestChild\n        }\n    }\n    for (node in dfs.reversed()) {\n        if (node != nodes[1]) {\n            node.update()\n        }\n    }\n    var last: Long = 0\n    for (i in 1..q) {\n        val d = (jin.nextLong() + last) % (n - 1)\n        var e = (jin.nextLong() + last) % w\n        var node = qodes[d.toInt()]\n        //println(\"node = $node, e = $e\")\n        node.parentLength = e\n        while (node != nodes[1]) {\n            node.update()\n            if (node == node.parent.bestChild) {\n                node = node.vertree.topNode\n            } else {\n                node = node.parent\n            }\n        }\n        last = maxOf(nodes[1].hortree.posAnswer(), nodes[1].vertree.posAnswer(), nodes[1].hortree.longest() + nodes[1].vertree.longest())\n        println(last)\n    }\n}\n\nclass Node(val ix: Int) {\n    lateinit var parent: Node\n    var parentLength: Long = -1\n    var subTreeSize = 1\n    val edges = mutableListOf<Edge>()\n    var bestChild: Node? = null\n    lateinit var hortree: Hortree\n    lateinit var vertree: Vertree\n    var treeix = -1\n\n    fun update() {\n        //println(\"$this.update()\")\n        if (parent.bestChild == this) {\n            vertree.update(\n                    treeix,\n                    Verval(\n                            parentLength,\n                            hortree.longest() + parentLength,\n                            hortree.longest(),\n                            hortree.posAnswer()\n                    )\n            )\n        } else {\n            parent.hortree.update(\n                    treeix,\n                    Horval(\n                            max(vertree.longest(),\n                                    hortree.longest()) + parentLength,\n                            0,\n                            maxOf(vertree.posAnswer(), hortree.posAnswer(), vertree.longest() + hortree.longest())\n                    )\n            )\n        }\n    }\n\n    override fun toString() = \"nodes[$ix]\"\n}\n\nclass Edge(val node: Node, val length: Long, val ix: Int)\n\nval HORIZONTAL_IDENTITY = Horval(0, 0, 0)\nval VERTICAL_IDENTITY = Verval(0, 0, 0, 0)\n\ndata class Horval(val longest1: Long, val longest2: Long, val posAnswer: Long) {\n    operator fun plus(other: Horval): Horval {\n        if (longest1 > other.longest1) {\n            return Horval(longest1, max(longest2, other.longest1), max(posAnswer, other.posAnswer))\n        } else {\n            return Horval(other.longest1, max(longest1, other.longest2), max(posAnswer, other.posAnswer))\n        }\n    }\n}\n\ndata class Verval(val length: Long, val longest: Long, val longestToUse: Long, val posAnswer: Long) {\n    // this is above, other is below\n    operator fun times(other: Verval) = Verval(\n            length + other.length,\n            max(longest, other.longest + length),\n            max(longestToUse + other.length, other.longestToUse),\n            maxOf(posAnswer, other.posAnswer, longestToUse + other.longest)\n    )\n}\n\nclass Hortree(amt: Int) {\n    val length: Int\n    val array: Array<Horval>\n\n    init {\n        var l = 1\n        while (l < amt) {\n            l *= 2\n        }\n        length = l\n        array = Array(length * 2) { HORIZONTAL_IDENTITY }\n    }\n\n    fun update(index: Int, newVal: Horval) {\n        var node = index + length\n        array[node] = newVal\n        node = node shr 1\n        while (node > 0) {\n            array[node] = array[2 * node] + array[(2 * node) + 1]\n            node = node shr 1\n        }\n    }\n\n    fun longest() = array[1].longest1\n    fun posAnswer() = max(array[1].longest1 + array[1].longest2, array[1].posAnswer)\n}\n\nclass Vertree(val topNode: Node, amt: Int) {\n    val length: Int\n    val array: Array<Verval>\n\n    init {\n        var l = 1\n        while (l < amt) {\n            l *= 2\n        }\n        length = l\n        array = Array(length * 2) { VERTICAL_IDENTITY }\n    }\n\n    fun update(index: Int, newVal: Verval) {\n        //println(\"update($index, $newVal)\")\n        var node = index + length\n        array[node] = newVal\n        //println(\"array[$node] = ${array[node]}\")\n        node = node shr 1\n        while (node > 0) {\n            array[node] = array[2 * node] * array[(2 * node) + 1]\n            //println(\"array[$node] = ${array[node]}\")\n            node = node shr 1\n        }\n    }\n\n    fun longest() = array[1].longest\n    fun posAnswer() = max(array[1].longestToUse, array[1].posAnswer)\n}",
    "ext": ""
  },
  "57821798": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef DEBUG\n\t#define D(x...) printf(x)\n#else\n\t#define D(x...)\n#endif\ntypedef long long ll;\nint n, q;\nll w;\nvector<pair<int, int> > adj[100010];\nint u[100010], v[100010], seen[100010], subtree[20][100010], hei[20][100010], iscentroid[100010], ownedby[20][100010];\npair<int, int> inpre[20][100010];\nset<pair<ll, int> > bestchildren[100010];\nll weight[100010];\nll rangetree[20][100010*4][2];\nll was[20][100010];\nvoid push(int t, int curr)\n{\n\tif (!rangetree[t][curr][1]) return;\n\trangetree[t][2*curr][0] += rangetree[t][curr][1];\n\trangetree[t][2*curr][1] += rangetree[t][curr][1];\n\trangetree[t][2*curr+1][0] += rangetree[t][curr][1];\n\trangetree[t][2*curr+1][1] += rangetree[t][curr][1];\n\trangetree[t][curr][1] = 0;\n}\nvoid update(int t, int s, int e, ll val, int curr = 1, int cstart = 0, int cend = 100000)\n{\n\tif (s <= cstart && cend <= e)\n\t{\n\t\trangetree[t][curr][0] += val;\n\t\trangetree[t][curr][1] += val;\n\t\treturn;\n\t}\n\tpush(t, curr);\n\tint mid = (cstart+cend)/2;\n\tif (e <= mid) update(t, s, e, val, 2*curr, cstart, mid);\n\telse if (s > mid) update(t, s, e, val, 2*curr+1, mid+1, cend);\n\telse\n\t{\n\t\tupdate(t, s, e, val, 2*curr, cstart, mid);\n\t\tupdate(t, s, e, val, 2*curr+1, mid+1, cend);\n\t}\n\trangetree[t][curr][0] = max(rangetree[t][2*curr][0], rangetree[t][2*curr+1][0]);\n}\nll query(int t, int s, int e, int curr = 1, int cstart = 0, int cend = 100000)\n{\n\tif (s <= cstart && cend <= e) return rangetree[t][curr][0];\n\tpush(t, curr);\n\tint mid = (cstart+cend)/2;\n\tif (e <= mid) return query(t, s, e, 2*curr, cstart, mid);\n\telse if (s > mid) return query(t, s, e, 2*curr+1, mid+1, cend);\n\telse\n\t{\n\t\treturn max(query(t, s, e, 2*curr, cstart, mid), query(t, s, e, 2*curr+1, mid+1, cend));\n\t}\n}\nint upto;\nvoid dfs(int t, int a, int c, int centroid, ll w, int h = 1)\n{\n\tif (seen[a] == t) return;\n\tseen[a] = t;\n\thei[t][a] = h;\n\tsubtree[t][a] = c;\n\townedby[t][a] = centroid;\n\tinpre[t][a].first = ++upto;\n\tupdate(t, upto, upto, w);\n\tfor (auto b : adj[a])\n\t{\n\t\tif (seen[b.first] != t && !iscentroid[b.first])\n\t\t{\n\t\t\tdfs(t, b.first, c, centroid, w+weight[b.second], h+1);\n\t\t}\n\t}\n\tinpre[t][a].second = upto;\n}\nll findbest(int a)\n{\n\tauto it = prev(bestchildren[a].end());\n\tauto it2 = prev(it);\n\treturn it->first + it2->first;\t\n}\nint sz[100010];\nint findsz(int a)\n{\n\tif (sz[a]) return sz[a];\n\tsz[a] = 1;\n\tfor (auto b : adj[a])\n\t{\n\t\tif (!iscentroid[b.first] && !sz[b.first]) sz[a] += findsz(b.first);\n\t}\n\treturn sz[a];\n}\nint findcentroid(int a, int par, int all)\n{\n\tpair<int, int> mx = { -1, -1 };\n\tfor (auto b : adj[a])\n\t{\n\t\tif (!iscentroid[b.first] && b.first != par)\n\t\t{\n\t\t\tmx = max(mx, {sz[b.first], b.first});\n\t\t}\n\t}\n\tif (mx.first <= all/2) return a;\n\treturn findcentroid(mx.second, a, all);\n}\npriority_queue<pair<ll, int> > pq;\nint main()\n{\n\tscanf(\"%d%d%lld\", &n, &q, &w);\n\tfor (int i = 0; i < n-1; i++)\n\t{\n\t\tscanf(\"%d%d%lld\", &u[i], &v[i], &weight[i]);\n\t\tadj[u[i]].push_back({ v[i], i });\n\t\tadj[v[i]].push_back({ u[i], i});\n\t}\n\tfor (int i = 1; i <= n; i++) bestchildren[i].insert({0, -1}), bestchildren[i].insert({0, -2});\n\tfor (int t = 1; t < 20; t++)\n\t{\n\t\tfill_n(sz, n+1, 0);\n\t\tupto = 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (!sz[i] && !iscentroid[i])\n\t\t\t{\n\t\t\t\tfindsz(i);\n\t\t\t\tint c = findcentroid(i, i, sz[i]);\n\t\t\t\tiscentroid[c] = 1;\n\t\t\t\tD(\"centroid %d, %d\\n\", c, t);\n\t\t\t\tfor (auto b : adj[c])\n\t\t\t\t{\n\t\t\t\t\tif (iscentroid[b.first]) continue;\n\t\t\t\t\tdfs(t, b.first, b.first, c, weight[b.second]);\n\t\t\t\t\tll best = query(t, inpre[t][b.first].first, inpre[t][b.first].second);\n\t\t\t\t\tbestchildren[c].insert({best, b.first});\n\t\t\t\t\twas[t][b.first] = best;\n\t\t\t\t}\n\t\t\t\tpq.emplace(findbest(c), c);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 0;\n\tD(\"best %lld\\n\", pq.top().first);\n\tfor (int i = 0; i < q; i++)\n\t{\n\t//\tans = 0;\n\t\tint e;\n\t\tll wei;\n\t\tscanf(\"%d%lld\", &e, &wei);\n\t\te = ((ll)(e) + ans)%(ll)(n-1);\n\t\tD(\"%d %lld\\n\", e, wei);\n\t\twei = (wei+ans)%w;\n\t\tll diff = wei-weight[e];\n\t\tfor (int t = 1; t < 20; t++)\n\t\t{\n\t\t\tint a, b;\n\t\t\ta = u[e], b = v[e];\n\t\t\tif ((ownedby[t][a] == ownedby[t][b] && ownedby[t][b] )|| ownedby[t][a] == b || ownedby[t][b] == a)\n\t\t\t{\n\t\t\t\tif (hei[t][a] < hei[t][b]) swap(a, b);\n\t\t\t\tD(\"a %d b %d t %d (%d %d)\\n\", a, b, t, hei[t][a], hei[t][b]);\n\t\t\t\tupdate(t, inpre[t][a].first, inpre[t][a].second, diff);\n\t\t\t\tint c = subtree[t][a];\n\t\t\t\tint owner = ownedby[t][a];\n\t\t\t\tll best = query(t, inpre[t][c].first, inpre[t][c].second);\n\t\t\t\tD(\"best %lld (diff %lld), a %d c %d\\n\", best, diff, a, c);\n\t\t\t\tbestchildren[owner].erase({was[t][c], c});\n\t\t\t\tbestchildren[owner].insert({best, c});\n\t\t\t\twas[t][c] = best;\n\t\t\t\tD(\"%lld\\n\", findbest(owner));\n\t\t\t\tpq.emplace(findbest(owner), owner);\n\t\t\t}\n\t\t}\n\t\tweight[e] = wei;\n\t\twhile (1)\n\t\t{\n\t\t\tif (pq.top().first != findbest(pq.top().second)) pq.pop();\n\t\t\telse break;\n\t\t}\n\t\tans = pq.top().first;\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}",
    "ext": "cpp"
  },
  "57821214": {
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;  \nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nstruct SegTree {\n\tint n;\n\tvector<ll> lazy;\n\tvector<pair<ll,int>> val;\n\n\tvoid _apply(int x,ll by) { lazy[x]+=by; val[x].first+=by; }\n\tvoid _push(int x) { if(lazy[x]!=0) _apply(2*x+1,lazy[x]),_apply(2*x+2,lazy[x]),lazy[x]=0; }\n\tvoid _pull(int x) { val[x]=max(val[2*x+1],val[2*x+2]); }\n\tvoid init(int _n) { n=_n; assert(n>=1); lazy=vector<ll>(4*n,0LL); val=vector<pair<ll,int>>(4*n,MP(0LL,0)); }\n\tvoid _update(int x,int l,int r,int L,int R,pair<ll,int> BY) {\n\t\t//printf(\"_update(%d,%d..%d,%d..%d,%lld)\\n\",x,l,r,L,R,BY);\n\t\tif(L<=l&&r<=R) {\n\t\t\t_apply(x,BY.first); if(BY.second!=-1) { assert(l==r); val[x].second=BY.second; }\n\t\t} else {\n\t\t\tint m=l+(r-l)/2; _push(x);\n\t\t\tif(L<=m) _update(2*x+1,l,m,L,R,BY);\n\t\t\tif(m+1<=R) _update(2*x+2,m+1,r,L,R,BY);\n\t\t\t_pull(x);\n\t\t}\n\t\t//printf(\"_updated(%d,%d..%d,%d..%d,%lld)\\n\",x,l,r,L,R,BY);\n\t}\n\tvoid update(int l,int r,pair<ll,int> by) { assert(n>=1); _update(0,0,n-1,l,r,by); }\n\tvoid update(int l,int r,ll by) { assert(n>=1); _update(0,0,n-1,l,r,MP(by,-1)); }\n\tpair<ll,int> _get(int x,int l,int r,int L,int R) {\n\t\tif(L<=l&&r<=R) {\n\t\t\treturn val[x];\n\t\t} else {\n\t\t\tint m=l+(r-l)/2; _push(x);\n\t\t\tif(m+1>R) return _get(2*x+1,l,m,L,R);\n\t\t\tif(L>m) return _get(2*x+2,m+1,r,L,R);\n\t\t\treturn max(_get(2*x+1,l,m,L,R),_get(2*x+2,m+1,r,L,R));\n\t\t}\n\t}\n\tpair<ll,int> get(int l,int r) { assert(n>=1); return _get(0,0,n-1,l,r); }\n\tpair<ll,int> best() { assert(n>=1); return val[0]; }\n};\n\nconst int MAXN=100000;\nconst int MAXLG=16;\nconst int MAXM=MAXN-1;\nconst int MAXQ=100000;\n\nint n,nq; ll wlim;\nint e[MAXM][2];\nvector<int> adj[MAXN];\nint exor[MAXM];\nll winit[MAXM];\nint qidx[MAXQ]; ll qw[MAXQ]; ll qans[MAXQ];\n\n\nll wcur[MAXM];\n\nint root[MAXN][MAXLG+1],subtree[MAXN][MAXLG+1],par[MAXN][MAXLG+1]; ll dist[MAXN][MAXLG+1]; int lpre[MAXN][MAXLG+1],rpre[MAXN][MAXLG+1];\nint npre[MAXN][MAXLG+1]; SegTree subtreedist[MAXN][MAXLG+1];\nset<pair<ll,int>> bestdist[MAXN][MAXLG+1];\n\nbool alive[MAXN]; int sz[MAXN];\nvoid dfssz(int at,int p) { sz[at]=1; REPSZ(i,adj[at]) { int id=adj[at][i],to=at^exor[id]; if(to==p||!alive[to]) continue; dfssz(to,at); sz[at]+=sz[to]; } }\nint dfscentroid(int at,int p,int rootsz) { REPSZ(i,adj[at]) { int id=adj[at][i],to=at^exor[id]; if(to==p||!alive[to]) continue; if(2*sz[to]>rootsz) return dfscentroid(to,at,rootsz); } return at; }\nint centroid(int at) { dfssz(at,-1); return dfscentroid(at,-1,sz[at]); }\nvoid dfsinit(int at,int rt,int st,int k) {\n\troot[at][k]=rt,subtree[at][k]=st; lpre[at][k]=npre[st][k]++; subtreedist[st][k].update(lpre[at][k],lpre[at][k],MP(dist[at][k],at));\n\t//printf(\"\\t\\tdist %d=%lld\\n\",at,dist[at][k]);\n\tREPSZ(i,adj[at]) {\n\t\tint id=adj[at][i],to=at^exor[id]; if(to==par[at][k]||!alive[to]) continue;\n\t\tpar[to][k]=at,dist[to][k]=dist[at][k]+wcur[id]; dfsinit(to,rt,st,k);\n\t}\n\trpre[at][k]=npre[st][k]-1;\n}\nvoid decompose(int at,int k) {\n\tat=centroid(at);\n\tdfssz(at,-1);\n\t//printf(\"centroid at level %d = %d\\n\",k,at+1);\n\t\n\troot[at][k]=at,subtree[at][k]=at,par[at][k]=-1,dist[at][k]=0,lpre[at][k]=rpre[at][k]=0;\n\tbestdist[at][k].clear(); npre[at][k]=1; subtreedist[at][k].init(1); subtreedist[at][k].update(lpre[at][k],rpre[at][k],MP(dist[at][k],at)); bestdist[at][k].insert(subtreedist[at][k].best());\n\tREPSZ(i,adj[at]) {\n\t\tint id=adj[at][i],to=at^exor[id]; if(!alive[to]) continue;\n\t\tnpre[to][k]=0; subtreedist[to][k].init(sz[to]); par[to][k]=at; dist[to][k]=wcur[id]; dfsinit(to,at,to,k); assert(npre[to][k]==sz[to]);\n\t\tbestdist[at][k].insert(subtreedist[to][k].best());\n\t}\n\t//printf(\"\\tbestdist:\"); for(auto it=bestdist[at][k].begin();it!=bestdist[at][k].end();++it) printf(\" %d=%lld\",it->second+1,it->first); puts(\"\");\n\talive[at]=false;\n\tREPSZ(i,adj[at]) { int id=adj[at][i],to=at^exor[id]; if(!alive[to]) continue; decompose(to,k+1); }\n}\n\nvoid update(int id,ll nval) {\n\t//printf(\"update (%d-%d) %lld\\n\",e[id][0]+1,e[id][1]+1,nval);\n\tll delta=nval-wcur[id]; wcur[id]=nval;\n\tREP(side,2) { \n\t\tint at=e[id][side];\n\t\tREPE(k,MAXLG) if(root[at][k]!=-1&&par[at][k]==e[id][1-side]) {\n\t\t\tint rt=root[at][k],st=subtree[at][k];\n\t\t\tpair<ll,int> oldbest=subtreedist[st][k].best();\n\t\t\tsubtreedist[st][k].update(lpre[at][k],rpre[at][k],delta);\n\t\t\tpair<ll,int> newbest=subtreedist[st][k].best();\n\t\t\tif(newbest!=oldbest) { auto bestit=bestdist[rt][k].find(oldbest); assert(bestit!=bestdist[rt][k].end()); bestdist[rt][k].erase(bestit); bestdist[rt][k].insert(newbest); }\n\t\t\t//printf(\"updated %d on level %d: oldbest=(%lld,%d) newbest=(%lld,%d)\\n\",at+1,k,oldbest.first,oldbest.second+1,newbest.first,newbest.second+1);\n\t\t}\n\t}\n}\npair<ll,int> farthest(int at) {\n\tpair<ll,int> ret=MP(0LL,at);\n\tREPE(k,MAXLG) if(root[at][k]!=-1) {\n\t\tint rt=root[at][k],st=subtree[at][k];\n\t\tpair<ll,int> skip=subtreedist[st][k].best();\n\t\tauto bestit=bestdist[rt][k].rbegin(); assert(bestit!=bestdist[rt][k].rend()); if(*bestit==skip) ++bestit; if(bestit==bestdist[rt][k].rend()) continue;\n\t\t//printf(\"farthest(%d) on level %d: skip=(%lld,%d) best=(%lld,%d)\\n\",at+1,k,skip.first,skip.second+1,bestit->first,bestit->second+1);\n\t\tassert(subtree[bestit->second][k]!=st); ll cdist=subtreedist[st][k].get(lpre[at][k],lpre[at][k]).first+bestit->first; if(cdist>ret.first) ret=MP(cdist,bestit->second);\n\t}\n\treturn ret;\n}\n\n\nvoid solve() {\n\tREP(i,n) alive[i]=true;\n\tREP(i,n-1) wcur[i]=winit[i];\n\tmemset(root,-1,sizeof(root)); decompose(0,0);\n\tll last=0;\n\tREP(i,nq) {\n\t\tint id=(qidx[i]+last)%(n-1); ll w=(qw[i]+last)%wlim;\n\t\tupdate(id,w);\n\t\tpair<ll,int> a=farthest(0);\n\t\tpair<ll,int> b=farthest(a.second);\n\t\tlast=qans[i]=b.first;\n\t\t//printf(\"farthest=(%d..%d)\\n\",a.second+1,b.second+1);\n\t}\n}\n\nvoid run() {\n\tscanf(\"%d%d%lld\",&n,&nq,&wlim);\n\tREP(i,n-1) { int a,b; scanf(\"%d%d%lld\",&a,&b,&winit[i]); --a,--b; e[i][0]=a,e[i][1]=b,exor[i]=a^b; adj[a].PB(i),adj[b].PB(i); }\n\tREP(i,nq) scanf(\"%d%lld\",&qidx[i],&qw[i]);\n\tsolve();\n\tREP(i,nq) printf(\"%lld\\n\",qans[i]);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57820094": {
    "code": "#include <bits/stdc++.h>\n#define FOR(i, n) for(int i = 0; i < (n); ++i)\n#define REP(i, a, b) for(int i = (a); i < (b); ++i)\n#define TRAV(i, n) for(auto &i : n)\n#define SZ(x) (int)(x).size()\n#define PR std::pair\n#define MP std::make_pair\n#define X first\n#define Y second\ntypedef long long ll;\ntypedef std::pair<int, int> PII;\ntypedef std::vector<int> VI;\n\nstruct MaxTree{\n        std::vector<ll> t, u;\n        int BOTTOM;\n        void build(const std::vector<ll> &vec){\n                BOTTOM = 1;\n                while(BOTTOM < SZ(vec)) BOTTOM *= 2;\n                t.resize(BOTTOM*2);\n                u.resize(BOTTOM*2);\n                FOR(i, SZ(vec)) t[BOTTOM+i] = vec[i];\n                for(int i = BOTTOM-1; i >= 1; --i) t[i] = std::max(t[i<<1], t[(i<<1)|1]);\n        }\n        void upd(int v){\n                if(u[v] != 0){\n                        t[v] += u[v];\n                        if(v < BOTTOM){\n                                u[v<<1] += u[v];\n                                u[(v<<1)|1] += u[v];\n                        }\n                        u[v] = 0;\n                }\n        }\n        void add(int a, int b, ll w, int v=1, int lo=0, int hi=-2){\n                if(hi == -2) hi = BOTTOM-1;\n                upd(v);\n                if(a > b) return;\n                if(a == lo && b == hi){\n                        u[v] += w;\n                        upd(v);\n                        return;\n                }\n                int mid = (lo+hi)/2;\n                add(a, std::min(b, mid), w, v<<1, lo, mid);\n                add(std::max(a, mid+1), b, w, (v<<1)|1, mid+1, hi);\n                t[v] = std::max(t[v<<1],t[(v<<1)|1]);\n        }\n        ll query(int a, int b, int v=1, int lo=0, int hi=-2){\n                if(hi == -2) hi = BOTTOM-1;\n                upd(v);\n                if(a > b) return 0;\n                if(a == lo && b == hi) return t[v];\n                int mid = (lo+hi)/2;\n                return std::max(query(a, std::min(b, mid), v<<1, lo, mid),\n                                                query(std::max(a, mid+1), b, (v<<1)|1, mid+1, hi));\n        }\n};\n\nstruct Tree;\n\nstruct Edge{\n        int a, b;\n        ll w;\n        int id;\n        std::vector<PR<Tree*, PII> > trees;\n        Edge(int _a, int _b, ll _w, int _id) : a(_a), b(_b), w(_w), id(_id) {}\n};\n\nint n, q;\nll w;\nstd::vector<VI> g;\nstd::vector<Edge> edges;\n\n\nll last;\nstd::multiset<ll> all_ans;\n\nstd::vector<bool> blocked;\nstruct Tree{\n        int root;\n        MaxTree mt;\n        std::multiset<ll> ans;\n        std::vector<ll> dist;\n        std::unordered_map<int, int> roz, pre, post;\n\n        Tree(int r, int sz){\n                root = r;\n                tick = 0;\n                dfs(root);\n                mt.build(dist);\n                blocked[root] = true;\n                TRAV(ch, g[root]){\n                        auto &ed = edges[ch];\n                        int to = (ed.a == root ? ed.b : ed.a);\n                        if(blocked[to]) continue;\n                        ans.insert(mt.query(pre[to], post[to]));\n                        N = roz[to];\n                        int cent = centroid(to);\n                        new Tree(cent, N);\n                }\n                if(sz > 1){\n                        ll best = *std::next(ans.end(), -1);\n                        if(SZ(ans) > 1) best += *std::next(ans.end(), -2);\n                        all_ans.insert(best);\n                }\n        }\n\n        int N;\n\n        int centroid(int v, int par=-1){\n                bool cent = 2*roz[v] >= N;\n                TRAV(ch, g[v]){\n                        auto &ed = edges[ch];\n                        int to = (ed.a == v ? ed.b : ed.a);\n                        if(to == par || blocked[to]) continue;\n                        int xd = centroid(to, v);\n                        if(xd != -1) return xd;\n                        if(2*roz[to] > N) cent = false;\n                }\n                if(cent) return v;\n                return -1;\n        }\n\n        int tick, kto;\n        void dfs(int v, int par=-1, ll dst=0){\n                roz[v] = 1;\n                pre[v] = tick++;\n                dist.push_back(dst);\n                TRAV(ch, g[v]){\n                        auto &ed = edges[ch];\n                        int to = (ed.a == v ? ed.b : ed.a);\n                        if(to == par || blocked[to]) continue;\n                        if(v == root) kto = to;\n                        ed.trees.push_back(MP(this, MP(to, kto)));\n                        dfs(to, v, dst+ed.w);\n                        roz[v] += roz[to];\n                }\n                post[v] = tick++;\n                dist.push_back(dst);\n        }\n};\n\n\nvoid answer(int d, ll e){\n        auto &ed = edges[d];\n        ll delta = e - ed.w;\n        TRAV(pr, ed.trees){\n                Tree *tree = pr.X;\n                int v = pr.Y.X;\n                int kto = pr.Y.Y;\n                ll old_ans = *std::next(tree->ans.end(), -1);\n                if(SZ(tree->ans) > 1) old_ans += *std::next(tree->ans.end(), -2);\n                all_ans.erase(all_ans.find(old_ans));\n                ll old = tree->mt.query(tree->pre[kto], tree->post[kto]);\n                tree->ans.erase(tree->ans.find(old));\n                tree->mt.add(tree->pre[v], tree->post[v], delta);\n                tree->ans.insert(tree->mt.query(tree->pre[kto], tree->post[kto]));\n                ll nw = *std::next(tree->ans.end(), -1);\n                if(SZ(tree->ans) > 1) nw += *std::next(tree->ans.end(), -2);\n                all_ans.insert(nw);\n        }\n        ed.w = e;\n        last = *std::next(all_ans.end(), -1);\n}\n\nint main(){\n        std::ios_base::sync_with_stdio(false);\n        std::cin.tie(0);\n        std::cin >> n >> q >> w;\n        g.resize(n);\n        FOR(i, n-1){\n                int a, b;\n                ll c;\n                std::cin >> a >> b >> c;\n                a--;b--;\n                edges.push_back(Edge(a, b, c, i));\n                g[a].push_back(i);\n                g[b].push_back(i);\n        }\n\n        blocked.resize(n);\n        new Tree(0, n);\n\n        while(q--){\n                int d;\n                ll e;\n                std::cin >> d >> e;\n                d = (d+last)%(n-1);\n                e = (e+last)%w;\n                answer(d, e);\n                std::cout << last << \"\\n\";\n        }\n        return 0;\n}\n",
    "ext": "cpp"
  },
  "57817087": {
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n//#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"fast-math\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,popcnt,abm,mmx,tune=native\")\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stdio.h>\n#include <cstdio>\n#include <math.h>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <deque>\n#include <random>\n#include <iomanip>\n#include <bitset>\n                        \nusing namespace std;\n                        \ntemplate<typename T> void uin(T &a, T b) {\n    if (b < a) {\n        a = b;\n    }\n}\n                        \ntemplate<typename T> void uax(T &a, T b) {\n    if (b > a) {\n        a = b;\n    }\n}\n \n#define int long long\n#define ghost signed\n#define left left228\n#define right right228\n#define complex complex228\n#define count count228\n#define sin sin228\n#define list list228\n\nvector<int> iik;\n \nstruct ST\n{\n    struct node\n    {\n        pair<int, int> mx;\n        int mod;\n        int l, r;\n        node() {\n            mx.first = mx.second = mod = l = r = 0;\n        }\n    };\n \n    vector< node > d;\n \n    void build(int l, int r, int v = 1) {\n        d[v].l = l;\n        d[v].r = r;\n        // d[v].mx.second = l;\n        if (l == r) {\n            d[v].mx.first = iik[l - 1];\n            d[v].mx.second = l;\n            return;\n        }\n        int m = (l + r) >> 1;\n        build(l, m, v << 1);\n        build(m + 1, r, v << 1 | 1);\n        d[v].mx = max(d[v << 1].mx, d[v << 1 | 1].mx);\n    }\n \n    ST() {d.clear();}\n \n    ST(int n) {\n        int ss = 1;\n        while (ss < n) ss <<= 1;\n        ss <<= 1;\n        d.resize(ss + 1, node());\n        build(1, n);\n    }\n \n    pair<int, int> gets(int v) {\n        return make_pair(d[v].mx.first + d[v].mod, d[v].mx.second);\n    }\n \n    void push(int v) {\n        if (d[v].mod) {\n            d[v << 1].mod += d[v].mod;\n            d[v << 1 | 1].mod += d[v].mod;\n            d[v].mod = 0;\n        }\n        d[v].mx = max(gets(v << 1), gets(v << 1 | 1));\n    }\n \n    void update(int l, int r, int x, int v = 1) {\n        if (l > r || d[v].l > r || d[v].r < l) return;\n        if (l <= d[v].l && d[v].r <= r) {\n            d[v].mod += x;\n        } else {\n            push(v);\n            update(l, r, x, v << 1);\n            update(l, r, x, v << 1 | 1);\n            d[v].mx = max(gets(v << 1), gets(v << 1 | 1));\n        }\n    }\n \n    pair<int, int> get(int l, int r, int v = 1) {\n        if (l > r || d[v].l > r || d[v].r < l) return {0, 0};\n        if (l <= d[v].l && d[v].r <= r) return gets(v);\n        push(v);\n        return max(get(l, r, v << 1), get(l, r, v << 1 | 1));\n    }\n};\n \nconst int N = 100 * 1000 + 228;\n \nvector< pair<int, int> > g[N];\nbool used[N];\nint pc[N], sz[N];\nint centroid = 0;\nvector<int> order;\n \nvoid ffs(int v, int par = -1) {\n    order.push_back(v);\n    sz[v] = 1;\n    for (pair<int, int> go : g[v]) {\n        int to = go.first;\n        if (to == par || used[to]) continue;\n        ffs(to, v);\n        sz[v] += sz[to];\n    }\n}\n \nint FindCentroid(int s) {\n    order.clear();\n    ffs(s);\n    int SZ = (int)order.size();\n    for (int v : order) {\n        if (sz[v] >= SZ / 2) {\n            bool OK = 1;\n            for (pair<int, int> go : g[v]) {\n                int to = go.first;\n                if (sz[to] < sz[v] && sz[to] > SZ / 2) {\n                    OK = 0;\n                    break;\n                }\n            }\n            if (OK) return v;\n        }\n    }\n    return -1;\n}\n \nvector<int> tout[N], dist[N], whatson[N];\nmultiset<int> ms[N];\nmap< pair<int, int> , vector<int> > list;\nmap<int, int> met[N];\nvector<int> vertices;\nST st[N];\nint timer = 0;\nint GC = 0;\nint id[N];\n \nvoid jfs(int v, int dst = 0, int par = 0) {\n    if (par) {\n        list[make_pair(par, v)].push_back(centroid);\n    }\n    order.push_back(v);\n    id[v] = timer;\n    int i = timer;\n    met[centroid][v] = i;\n    dist[centroid][i] = dst;\n    ++timer;\n    for (pair<int, int> go : g[v]) {\n        int to = go.first;\n        int w = go.second;\n        if (to == par || used[to]) continue;\n        jfs(to, dst + w, v);\n    }\n    tout[centroid][i] = timer;\n}\n \nvoid godfs(int v, int s, int par = -1) {\n    whatson[centroid][id[v]] = s;\n    for (pair<int, int> go : g[v]) {\n        int to = go.first;\n        if (to == par || used[to]) continue;\n        godfs(to, s, v);\n    }\n}\n \nvoid haha(int c, int SZ) {\n    dist[c].resize(SZ + 1);\n    tout[c].resize(SZ + 1);\n    whatson[c].resize(SZ + 1);\n    timer = 0;\n    order.clear();\n    jfs(c);\n    iik = dist[c];\n    st[c] = ST(timer);\n    if (c == GC) vertices = order;\n    vector<int> a;\n    // for (int i = 0; i < (int)order.size(); ++i) st[c].update(i + 1, i + 1, dist[c][i]);\n    //st[c] = ST(dist[c]);\n    for (pair<int, int> go : g[c]) {\n        int to = go.first;\n        if (used[to]) continue;\n        int i = met[c][to];\n        godfs(to, i, c);\n        ms[c].insert(st[c].get(i + 1, tout[c][i]).first);\n    }\n}\n \nvoid build_cd(int v, int parc = 0) {\n    int c = FindCentroid(v);\n    centroid = c;\n    if (parc == 0) GC = c;\n    pc[c] = parc;\n    haha(c, sz[v]);\n    used[c] = 1;\n    for (pair<int, int> go : g[c]) {\n        int to = go.first;\n        if (!used[to]) build_cd(to, c);\n    }\n}\n \nstruct edge\n{\n    int from, to, w;\n    edge() {}\n    edge(int _from, int _to, int _w) {\n        from = _from, to = _to, w = _w;\n    }\n};\n \nvoid change(int a, int b, int delta) {\n    for (int c : list[make_pair(a, b)]) {\n        int i = met[c][b];\n        int ws = whatson[c][i];\n        int D = st[c].get(ws + 1, tout[c][ws]).first;\n        ms[c].erase(ms[c].find(D));\n        st[c].update(i + 1, tout[c][i], delta);\n        D = st[c].get(ws + 1, tout[c][ws]).first;\n        ms[c].insert(D);\n    }\n}\n \nint answer() {\n    pair<int, int> p = st[GC].get(1, tout[GC][0]);\n    int s = vertices[p.second - 1];\n    int ans = 0;\n    int cur = 0;\n    while (s) {\n        if (ms[s].empty()) ;\n        else if ((int)ms[s].size() == 1) uax(ans, *ms[s].begin());\n        else {\n            cur = *ms[s].rbegin();\n            int kek = cur;\n            ms[s].erase(ms[s].find(cur));\n            cur += *ms[s].rbegin();\n            ms[s].insert(kek);\n            uax(ans, cur);\n        }\n        s = pc[s];\n    }\n    return ans;\n}\n \nghost main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n, q, W;\n    cin >> n >> q >> W;\n    vector< edge > edges;\n    for (int i = 0; i < n - 1; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        edges.emplace_back(a, b, c);\n        g[a].emplace_back(b, c);\n        g[b].emplace_back(a, c);\n    }\n    build_cd(1);\n    int last = 0;\n    while(q--) {\n        int D, E;\n        cin >> D >> E;\n        D = (D + last) % (n - 1);\n        E = (E + last) % W;\n        int delta = E - edges[D].w;\n        edges[D].w = E;\n        int a = edges[D].from;\n        int b = edges[D].to;\n        change(a, b, delta);\n        change(b, a, delta);\n        last = answer();\n        cout << last << '\\n';\n    }\n    return 0;\n} // kek ;\n// \u041e\u0433\u043e! \u041a\u0430\u0436\u0435\u0442\u0441\u044c\u044f \u044d\u0442\u043e $#@!\n \n \n \n \n \n",
    "ext": "cpp"
  },
  "57817022": {
    "code": "#include <iostream>\n#include <vector>\n#define int long long\nusing namespace std;\n\nconst int INFINI = 1000ll * 1000 * 1000 * 1000 * 1000 * 1000ll;\n\nvector<pair<int, int>> voisins[200 * 1000];\nint curDist[200 * 1000];\n\nint curEvent = 0;\nint debuts[200 * 1000], fins[200 * 1000];\n\nvoid construit_inters(int noeud, int parent) {\n\tdebuts[parent] = curEvent++;\n\n\tfor(pair<int, int> voisin : voisins[noeud]) {\n\t\tif(voisin.second == parent)\n\t\t\tcontinue;\n\t\tconstruit_inters(voisin.first, voisin.second);\n\t\tcurEvent++;\n\t}\n\n\tfins[parent] = curEvent;\n}\n\nint doitAjouter[(1 << 20)];\nint maxDiam[(1 << 20)];\nint maxi[(1 << 20)];\nint mini[(1 << 20)];\nint maxDec[(1 << 20)];\nint maxInc[(1 << 20)];\n\nvoid update(int n) {\n\tif(n < (1 << 19)) {\n\t\tdoitAjouter[2 * n] += doitAjouter[n];\n\t\tdoitAjouter[2 * n + 1] += doitAjouter[n];\n\t\tdoitAjouter[n] = 0;\n\t}\n\telse {\n\t\tmaxi[n] += doitAjouter[n];\n\t\tmini[n] += doitAjouter[n];\n\t\tdoitAjouter[n] = 0;\n\t\treturn;\n\t}\n\n\tmaxi[n] = max(\n\t\tmaxi[2 * n] + doitAjouter[2 * n],\n\t\tmaxi[2 * n + 1] + doitAjouter[2 * n + 1]\n\t);\n\n\tmaxDiam[n] = max(\n\t\tmax(maxDiam[2 * n], maxDiam[2 * n + 1]),\n\t\tmax(maxDec[2 * n] - doitAjouter[2 * n] + maxi[2 * n + 1] + doitAjouter[2 * n + 1], \n\t\t\tmaxi[2 * n] + doitAjouter[2 * n] + maxInc[2 * n + 1] - doitAjouter[2 * n + 1])\n\t);\n\n\tmini[n] = min(\n\t\tmini[2 * n] + doitAjouter[2 * n],\n\t\tmini[2 * n + 1] + doitAjouter[2 * n + 1]\n\t);\n\n\tmaxDec[n] = max(\n\t\tmax(maxDec[2 * n] - doitAjouter[2 * n], maxDec[2 * n + 1] - doitAjouter[2 * n + 1]),\n\t\tmaxi[2 * n] + doitAjouter[2 * n] - 2 * (mini[2 * n + 1] + doitAjouter[2 * n + 1])\n\t);\n\n\tmaxInc[n] = max(\n\t\tmax(maxInc[2 * n] - doitAjouter[2 * n], maxInc[2 * n + 1] - doitAjouter[2 * n + 1]),\n\t\tmaxi[2 * n + 1] + doitAjouter[2 * n + 1] - 2 * (mini[2 * n] + doitAjouter[2 * n])\n\t);\n}\n\nvoid ajoute_dist(int deb, int fin, int val, int n = 1, int d = 0, int f = (1 << 19)) {\n\tupdate(n);\n\n\tif(deb >= f || d >= fin)\n\t\treturn;\n\tif(deb <= d && f <= fin) {\n\t\tdoitAjouter[n] += val;\n\t\tupdate(n);\n\t\treturn;\n\t}\n\n\tint m = (d + f) / 2;\n\tajoute_dist(deb, fin, val, 2 * n, d, m);\n\tajoute_dist(deb, fin, val, 2 * n + 1, m, f);\n\tupdate(n);\n}\n\n/*void affiche(int noeud, int d, int f) {\n\tif(noeud >= (1 << 20))\n\t\treturn;\n\n\tupdate(noeud);\n\n\tint m = (d + f) / 2;\n\taffiche(2 * noeud, d, m);\n\taffiche(2 * noeud + 1, m, f);\n\tupdate(noeud);\n}*/\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\n\tint nbVilles, nbReqs;\n\tint maxDist;\n\n\tcin >> nbVilles >> nbReqs >> maxDist;\n\n\tfor(int iVille = 0;iVille < nbVilles - 1;iVille++) {\n\t\tint deb, fin;\n\t\tint dist;\n\t\tcin >> deb >> fin >> dist;\n\t\tdeb--; fin--;\n\n\t\tvoisins[deb].push_back({fin, iVille});\n\t\tvoisins[fin].push_back({deb, iVille});\n\t\tcurDist[iVille] = dist;\n\t}\n\n\tfor(int iNoeud = 0;iNoeud < (1 << 20);iNoeud++) {\n\t\tmaxDec[iNoeud] = maxInc[iNoeud] = -INFINI;\n\t}\n\n\tconstruit_inters(0, nbVilles);\n\n\tfor(int iVille = 0;iVille < nbVilles - 1;iVille++) {\n\t\tajoute_dist(debuts[iVille], fins[iVille], curDist[iVille]);\n\t}\n\n\tint last = 0;\n\n\tfor(int iReq = 0;iReq < nbReqs;iReq++) {\n\t\tint d, e;\n\t\tcin >> d >> e;\n\n\t\td = (d + last) % (nbVilles - 1);\n\t\te = (e + last) % maxDist;\n\n\t\tajoute_dist(debuts[d], fins[d], e - curDist[d]);\n\n\t\tcurDist[d] = e;\n\n\t\tcout << (last = max(maxDiam[1], maxi[1])) << endl;\n\t}\n\treturn 0;\n}",
    "ext": "cpp"
  },
  "57816530": {
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,q,scen;\nlong long w;\nstruct edge{\n    int a;\n    int ap;\n    int b;\n    int bp;\n    long long c;\n};\nvector<edge> edges;\nstruct node{\n    vector<int> ne;\n    vector<long long> c;\n    int nc=0;\n    vector<int> cdch;\n    int cdpr;\n    set<pair<long long,int> > st;\n    vector<long long> prvl;\n    int cdd;\n    int prcpos;\n    vector<vector<int> > tours;\n    vector<map<int,int> > fp;\n    vector<map<int,int> > lp;\n    int tc=0;\n    map<int,int> cnmp;\n    vector<vector<long long> > dst;\n    vector<vector<long long> > segs;\n    vector<vector<long long> > lzs;\n    vector<int> pw;\n};\nvector<node> nodes;\nint ndi,ndps;\ninline long long get(int ind){\n    return nodes[ndi].lzs[ndps][ind]+nodes[ndi].segs[ndps][ind];\n}\nvoid segUP(int ind,int l,int r,int b,int e,long long v){\n    if(l>=e||r<=b)return;\n    if(l>=b&&r<=e){\n        nodes[ndi].lzs[ndps][ind]+=v;\n        return;\n    }\n    int m=(l+r)/2;\n    segUP(ind*2+1,l,m,b,e,v);\n    segUP(ind*2+2,m,r,b,e,v);\n    nodes[ndi].segs[ndps][ind]=max(get(ind*2+1),get(ind*2+2));\n}\nvector<int> picked;\nvector<int> vis;\nvector<int> sz;\nvector<int> bd;\nint vtrue=0;\nint ms;\nint centroid(int ind,int dep){\n    sz[ind]=1;bd[ind]=dep;\n    int msz=0,ctr=-1;\n    for(int i = 0 ; i < nodes[ind].ne.size() ; i ++){\n        int ne=nodes[ind].ne[i];\n        if(picked[ne]||vis[ne]==vtrue)continue;\n        vis[ne]=vtrue;\n        int ng=centroid(ne,dep+1);\n        if(ng!=-1)ctr=ng;\n        sz[ind]+=sz[ne];\n        if(sz[ne]>msz)msz=sz[ne];\n    }\n    if(ctr!=-1)return ctr;\n    if(2*sz[ind]>=ms&&2*msz<=ms)\n        return ind;\n    return -1;\n}\nint ndc,aps;\nvoid tour(int ind,int p,long long d){\n    ///IT WOULD HAVE BEEN SO EASY IF THERE WASN'T CALL STACK LIMIT\n//    nodes[ndc].cnmp[ind]=aps;\n//    nodes[ndc].fp[aps][ind]=nodes[ndc].tours[aps].size();\n//    nodes[ndc].tours[aps].push_back(ind);\n//\n//    for(int i = 0 ; i < nodes[ind].ne.size() ; i ++){\n//        int ne=nodes[ind].ne[i];\n//        if(ne==p||nodes[ne].cdd<=nodes[ndc].cdd)continue;\n//        tour(ne,ind);\n//    }\n//\n//    nodes[ndc].lp[aps][ind]=nodes[ndc].tours[aps].size();\n//    nodes[ndc].tours[aps].push_back(ind);\n    ///THEREFORE SAME THING BUT WITHOUT RECURSION, d WAS ADDED LATER\n//    cout<<\"asd \"<<ind<<\" \"<<p<<\" \"<<d<<endl;\n    stack<int> idx;\n    stack<int> prt;\n    stack<int> pos;\n    stack<long long> dst;\n    idx.push(ind);\n    pos.push(0);\n    prt.push(p);\n    dst.push(d);\n    int i;\n    while(idx.size()){\n        ind=idx.top();\n        p=prt.top();\n        i=pos.top();\n        d=dst.top();\n        pos.top()++;\n        if(i==0){\n            nodes[ndc].cnmp[ind]=aps;\n            nodes[ndc].fp[aps][ind]=nodes[ndc].tours[aps].size();\n            nodes[ndc].tours[aps].push_back(ind);\n            nodes[ndc].dst[aps].push_back(d);\n        }\n        if(i==nodes[ind].ne.size()){\n            nodes[ndc].lp[aps][ind]=nodes[ndc].tours[aps].size()-1;\n//            nodes[ndc].tours[aps].push_back(ind);\n//            nodes[ndc].dst[aps].push_back(d);\n            idx.pop();\n            prt.pop();\n            pos.pop();\n            dst.pop();\n            continue;\n        }\n        int ne=nodes[ind].ne[i];\n        if(ne==p||nodes[ne].cdd<=nodes[ndc].cdd)continue;\n        idx.push(ne);\n        prt.push(ind);\n        pos.push(0);\n        dst.push(d+nodes[ind].c[i]);\n    }\n}\nint pw=1<<17;\nvector<long long> ansSeg(2*pw);\nvoid ansSegSet(int ind,int l,int r,int p,long long v){\n    if(l==r-1){\n        ansSeg[ind]=v;\n        return;\n    }\n    int m=(l+r)/2;\n    if(p<m)ansSegSet(ind*2+1,l,m,p,v);\n    else ansSegSet(ind*2+2,m,r,p,v);\n    ansSeg[ind]=max(ansSeg[ind*2+1],ansSeg[ind*2+2]);\n}\nvoid setset(int nc){\n    long long rz=0;\n    if(nodes[nc].st.size()==1){\n//        cout<<\"DSA\";\n        pair<long long,int> g=*nodes[nc].st.rbegin();\n        rz=g.first;\n    }else if(nodes[nc].st.size()>1){\n//        cout<<\"ASD\";\n        pair<long long,int> g=*nodes[nc].st.rbegin();\n        pair<long long,int> h=*next(nodes[nc].st.rbegin());\n//        cout<<g.first<<\" \"<<g.second<<endl;\n//        cout<<h.first<<\" \"<<h.second<<endl;\n        rz=g.first+h.first;\n    }\n//    cout<<\"NCRZ \"<<nc<<\" \"<<rz<<endl;\n    ansSegSet(0,0,pw,nc,rz);\n}\nvector<long long> eml;\nvector<int> emi;\nmap<int,int> emm;\nint build(int ind,int d,int s,int p){\n    vtrue++;ms=s;\n    vis[ind]=vtrue;\n    int nc=centroid(ind,0);\n//    cout<<ind<<\" \"<<d<<\" \"<<s<<\" \"<<p<<\" \"<<nc<<endl;\n    nodes[nc].cdd=d;\n    nodes[nc].cdpr=p;\n    picked[nc]=true;\n    if(p!=-1){\n        nodes[nc].prcpos=nodes[p].cdch.size();\n        nodes[p].cdch.push_back(nc);\n    }\n    for(int i = 0 ; i < nodes[nc].ne.size() ; i ++){\n        int ne=nodes[nc].ne[i];\n        if(picked[ne])continue;\n        if(bd[ne]>bd[nc])build(ne,d+1,sz[ne],nc);\n        else build(ne,d+1,s-sz[nc],nc);\n        ndc=nc;\n        aps=nodes[nc].tc;\n        nodes[nc].tours.push_back(emi);\n        nodes[nc].fp.push_back(emm);\n        nodes[nc].lp.push_back(emm);\n        nodes[nc].dst.push_back(eml);\n        tour(ne,nc,nodes[nc].c[i]);\n        nodes[nc].segs.push_back(eml);\n        nodes[nc].lzs.push_back(eml);\n        nodes[nc].pw.push_back(1);\n        while(nodes[nc].pw.back()<nodes[nc].tours.back().size())\n            nodes[nc].pw.back()*=2;\n        nodes[nc].segs.back().resize(nodes[nc].pw.back()*2);\n        nodes[nc].lzs.back().resize(nodes[nc].pw.back()*2);\n        for(int j = 0,fp=nodes[nc].pw.back()-1 ; j < nodes[nc].dst[aps].size() ; j ++,fp++)\n            nodes[nc].segs.back()[fp]=nodes[nc].dst.back()[j];\n        for(int fp=nodes[nc].pw.back()-2 ; fp>=0 ; fp--)\n            nodes[nc].segs.back()[fp]=max(nodes[nc].segs.back()[fp*2+1],nodes[nc].segs.back()[fp*2+2]);\n\n        nodes[nc].prvl.resize(aps+1);\n\n        ndi=ndc;\n        ndps=aps;\n        nodes[nc].prvl[aps]=get(0);\n        pair<long long,int> g;\n        g.first=nodes[nc].prvl[aps];\n        g.second=aps;\n        nodes[nc].st.insert(g);\n        nodes[nc].tc++;\n    }\n    setset(nc);\n    scen=nc;\n}\n\nlong long rrr;\nint rrrr;\ninline void read(bool sh){\n    if(sh){\n    rrrr=0;\n    char c;\n    c=getchar();\n    while(c<'0'||c>'9')\n        c=getchar();\n    while(c>='0'&&c<='9'){\n        rrrr=(rrrr<<3)+(rrrr<<1)+c-'0';\n        c=getchar();\n    }\n    }else{\n    rrr=0;\n    char c;\n    c=getchar();\n    while(c<'0'||c>'9')\n        c=getchar();\n    while(c>='0'&&c<='9'){\n        rrr=(rrr<<3)+(rrr<<1)+c-'0';\n        c=getchar();\n    }\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\nread(1);n=rrrr;\nread(1);q=rrrr;\nread(0);w=rrr;\n//    cin>>n>>q>>w;\n    edges.resize(n-1);\n    nodes.resize(n);\n    long long c;\n    for(int i = 0,a,b ; i < n-1 ; i ++){\n//        cin>>a>>b>>c;\n        read(1);a=rrrr;\n        read(1);b=rrrr;\n        read(0);c=rrr;\n        a--;b--;\n        edges[i].a=a;edges[i].ap=nodes[a].nc;edges[i].b=b;edges[i].bp=nodes[b].nc;edges[i].c=c;\n        nodes[a].ne.push_back(b);\n        nodes[a].c.push_back(c);\n        nodes[a].nc++;\n        nodes[b].ne.push_back(a);\n        nodes[b].c.push_back(c);\n        nodes[b].nc++;\n    }\n    sz.resize(n);\n    bd.resize(n);\n    picked.resize(n);\n    vis.resize(n);\n    scen=build(0,0,n,-1);\n    long long last=0,pc,cu;\n    for(int i = 0,e,a,b,ap,bp,ch,p,hr ; i < q ; i ++){\n//        cin>>e>>c;\n        read(1);e=rrrr;\n        read(0);c=rrr;\n        e=(e+last)%(n-1);\n        c=(c+last)%w;\n        pc=edges[e].c;\n        cu=c-pc;\n        edges[e].c=c;\n        a=edges[e].a;\n        ap=edges[e].ap;\n        b=edges[e].b;\n        bp=edges[e].bp;\n        nodes[a].c[ap]=c;\n        nodes[b].c[bp]=c;\n        if(nodes[a].cdd<nodes[b].cdd){\n            swap(a,b);\n            swap(ap,bp);\n        }\n        ch=a;\n        hr=b;\n        while(nodes[ch].cdpr!=hr)\n            ch=nodes[ch].cdpr;\n        while(ch!=scen){\n            hr=nodes[ch].cdpr;\n            int gh=nodes[ch].prcpos;\n            int l,r;\n            if(hr!=b){\n                l=max(nodes[hr].fp[gh][b],nodes[hr].fp[gh][a]);\n                r=min(nodes[hr].lp[gh][b],nodes[hr].lp[gh][a]);\n            }else{\n                l=nodes[hr].fp[gh][a];\n                r=nodes[hr].lp[gh][a];\n            }\n            ndi=hr;\n            ndps=gh;\n            long long psegR=get(0);\n            segUP(0,0,nodes[ndi].pw[ndps],l,r+1,cu);\n            long long nsegR=get(0);\n            if(psegR!=nsegR){\n                pair<long long,int> er;\n                er.first=psegR;\n                er.second=gh;\n                nodes[hr].st.erase(er);\n                er.first=nsegR;\n                nodes[hr].st.insert(er);\n                setset(hr);\n            }\n            ch=hr;\n        }\n        last=ansSeg[0];\n        rrr=last;\n        vector<char> g;\n        do{\n            g.push_back(rrr%10+'0');\n        }while(rrr/=10);\n        for(int i = 0 ; i < g.size() ; i ++)\n            putchar(g[g.size()-1-i]);\n        putchar(' ');\n//        cout<<last<<\" \";\n    }\n}\n",
    "ext": "cpp"
  },
  "57816432": {
    "code": "#include <bits/stdc++.h>\n#define db(x) cout << (x) << '\\n';\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> pii;\ntypedef pair<ll,pii> pip;\ntypedef pair<pii,ll> ppi;\ntypedef pair<pii,pii> ppp;\ntypedef pair<ld,ll> pli;\ntypedef pair<pii,string> pps;\ntypedef pair<char,ll> pci;\ntypedef complex<double> point;\ntypedef vector<point> polygon;\n#define pi (acos(-1))\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<ll, null_type, less<ll>,rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n#define MAXN 200005\n#define oo (ll(1ll<<62))\n#define x 450\n\nvector<ppi> g[MAXN];\nll t[MAXN],lims[MAXN][2],sz[MAXN],mk[MAXN],a[MAXN],bucket[x][5],ma[x][2],lazy[x],res,n;\nvector<ll> euler;\n\nvoid dfs(ll u,ll d)\n{\n    mk[u]=1;\n    lims[u][0]=euler.size();\n    a[euler.size()]=d;\n    euler.push_back(u);\n    for(auto y : g[u])\n    {\n        ll id=y.second;\n        ll w=y.first.second;\n        ll v=y.first.first;\n        if(!mk[v])\n        {\n            t[id]=v;\n            dfs(v,d+w);\n            a[euler.size()]=d;\n            euler.push_back(u);\n        }\n    }\n    lims[u][1]=euler.size();\n}\n\nvoid recalc(ll b,ll l,ll r)\n{\n    bucket[b][0]=oo;\n    bucket[b][1]=-oo;\n    bucket[b][2]=-oo;\n    bucket[b][3]=-oo;\n    bucket[b][4]=0;\n\n    vector<ll> aux;\n    for(ll i=l;i<=r;i++)\n    {\n        a[i]+=lazy[b];\n        bucket[b][4]=max(bucket[b][4],a[i]);\n        bucket[b][0]=min(bucket[b][0],a[i]);\n        bucket[b][1]=max(bucket[b][1],bucket[b][4]-2*a[i]);\n        aux.push_back(bucket[b][1]);\n    }\n\n    bucket[b][4]=0;\n    for(ll i=r;i>=l;i--)\n    {\n        bucket[b][4]=max(bucket[b][4],a[i]);\n        bucket[b][2]=max(bucket[b][2],bucket[b][4]-2ll*a[i]);\n        bucket[b][3]=max(bucket[b][3],aux[i-l]+bucket[b][4]);\n    }\n    lazy[b]=0;\n}\n\nll marcelo()\n{\n    res=0;\n    for(ll i=0;i<(n+x);i+=x)\n        ma[i/x][0]=ma[i/x][1]=0;\n\n    for(ll i=0;i<n;i+=x)\n    {\n        ma[i/x][0]=max(ma[i/x][0],bucket[i/x][4]+lazy[i/x]);\n        ma[(i/x)+1][0]=ma[i/x][0];\n    }\n\n    for(ll i=n-1;i>=0;i-=x)\n    {\n        ma[i/x][1]=max(ma[i/x][1],bucket[i/x][4]+lazy[i/x]);\n        if(i>=x)\n            ma[(i/x)-1][1]=ma[i/x][1];\n    }\n\n    for(ll i=0;i<=((n-1)/x);i++)\n    {\n        ll ml=0,mr=0;\n        if(i)\n            ml=ma[i-1][0];\n        if(i<((n-1)/x))\n            mr=ma[i+1][1];\n        res=max(res,ml+mr-2ll*(bucket[i][0]+lazy[i]));\n        res=max(res,mr+bucket[i][1]-lazy[i]);\n        res=max(res,ml+bucket[i][2]-lazy[i]);\n        res=max(res,bucket[i][3]);\n    }\n\n    return res;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    ll q,wt,u,v,w;\n    cin >> n >> q >> wt;\n    for(ll i=0;i<n-1;i++)\n    {\n        cin >> u >> v >> w;\n        sz[i]=w;\n        u--,v--;\n        g[u].push_back(ppi(pii(v,w),i));\n        g[v].push_back(ppi(pii(u,w),i));\n    }\n\n    dfs(0,0);\n\n    ll nn=n;\n    n=euler.size();\n    for(ll i=0;i<n;i+=x)\n    {\n        if(i/x!=(n-1)/x)\n            recalc(i/x,i,i+x-1);\n        else\n            recalc(i/x,i,n-1);\n    }\n\n    ll last=0;\n    while(q--)\n    {\n        ll e,d;\n        cin >> d >> e;\n        d=(d+last)%(nn-1);\n        e=(e+last)%wt;\n\n        ll mul=e-sz[d];\n        sz[d]=e;\n        ll l=lims[t[d]][0],r=lims[t[d]][1]-1;\n        if(l/x==r/x)\n        {\n            for(ll i=l;i<=r;i++)\n                a[i]+=mul;\n            recalc(l/x,(l/x)*x,min(((l/x)*x)+x-1,n-1));\n        }\n        else\n        {\n            for(ll i=(l/x)+1;i<(r/x);i++)\n                lazy[i]+=mul;\n\n            for(ll i=l;i/x==l/x;i++)\n                a[i]+=mul;\n            recalc(l/x,(l/x)*x,min(((l/x)*x)+x-1,n-1));\n\n            for(ll i=r;i/x==r/x;i--)\n                a[i]+=mul;\n            recalc(r/x,(r/x)*x,min(((r/x)*x)+x-1,n-1));\n        }\n        last=marcelo();\n        db(last)\n    }\n\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57810300": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << a << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nstruct elem {\n    ll min, max, prefix, suffix, diam, delta;\n    void clear() { min = max = prefix = suffix = delta = 0; }\n};\n\nelem operator*(const elem &x, const elem &y) {\n    elem res;\n    res.min = min(x.min + x.delta, y.min + y.delta);\n    res.max = max(x.max + x.delta, y.max + y.delta);\n    res.prefix = max(x.prefix - x.delta, y.prefix - y.delta);\n    res.prefix = max(res.prefix, (y.max+y.delta) - 2*(x.min+x.delta));\n    res.suffix = max(x.suffix - x.delta, y.suffix - y.delta);\n    res.suffix = max(res.suffix, (x.max+x.delta) - 2*(y.min+y.delta));\n\n    res.diam = max(x.diam, y.diam);\n    res.diam = max(res.diam, (x.max+x.delta) + (y.prefix-y.delta));\n    res.diam = max(res.diam, (x.suffix-x.delta) + (y.max+y.delta));\n    res.delta = 0;\n    return res;\n}\n\nelem ZERO = {0,0,0,0,0,0};\n\nstruct node {\n    int a,b;\n    node *l,*r;\n    elem value;\n\n    node(int aa, int bb) {\n        a = aa; b = bb;\n        if (aa+1 == b) {\n            l = r = nullptr;\n            value = ZERO;\n        }\n        else {\n            auto m = (aa+bb)/2;\n            l = new node(aa,m);\n            r = new node(m,bb);\n            pull();\n        }\n    }\n\n    void pull() { if (l && r) value = (l->value) * (r->value); }\n\n    void push() {\n        if (l) l->value.delta += this->value.delta;\n        if (r) r->value.delta += this->value.delta;\n        this->value.delta = 0;\n    }\n\n    void upd(int aa, int bb, ll d) {\n        if (b <= aa || bb <= a) return;\n        if (aa <= a && b <= bb) { // whole\n            this->value.delta += d;\n        }\n        else {\n            push();\n            l->upd(aa,bb,d);\n            r->upd(aa,bb,d);\n            pull();\n        }\n    }\n};\n\nstruct edge;\n\nint n,q;\nll w;\nvector<vi> adj;\nvector<edge> e;\n\nstruct edge {\n    int u,v,id;\n    ll c;\n    vi idx;\n    \n    edge(int u, int v, ll c, int id): u(u), v(v), c(c), id(id), idx() {\n        adj[u].pb(id);\n        adj[v].pb(id);\n    }\n};\n\nint t;\nvoid dfs(int u, int p) {\n    for (auto i : adj[u]) {\n        auto &ei = e[i];\n        int v = ei.u ^ ei.v ^ u;\n        if (v != p) {\n            ei.idx.pb(t++);\n            dfs(v,u);\n            ei.idx.pb(t++);\n        }\n    }\n}\n\n\nint main() {\n    scanf(\"%d %d %lld\", &n, &q, &w);\n    adj.resize(n);\n    forn(id, n-1) {\n        int u,v; ll c;\n        scanf(\"%d %d %lld\", &u, &v, &c);\n        u--; v--;\n        e.eb(u,v,c,id);\n    }\n\n    dfs(0,0);\n\n    int len = 2*n-2;\n    ll last = 0;\n    node *tree = new node(0,len);\n    forn(i,n-1) {\n        tree->upd(e[i].idx[0], len, +e[i].c);\n        tree->upd(e[i].idx[1], len, -e[i].c);\n    }\n\n    while (q--) {\n        ll d,c; scanf(\"%lld %lld\", &d, &c);\n        d = (d+last)%(n-1);\n        c = (c+last)%w;\n        auto diff = c - e[d].c;\n        e[d].c = c;\n        tree->upd(e[d].idx[0], len, +diff); \n        tree->upd(e[d].idx[1], len, -diff); \n        last = tree->value.diam;\n        cout <<(last) << endl;\n    }\n    \n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57809774": {
    "code": "/*input\n10 10 10000\n1 9 1241\n5 6 1630\n10 5 1630\n2 6 853\n10 1 511\n5 3 760\n8 3 1076\n4 10 1483\n7 10 40\n8 2051\n5 6294\n5 4168\n7 1861\n0 5244\n6 5156\n3 3001\n8 5267\n5 3102\n8 3623\n\n\n4 3 2000\n1 2 100\n2 3 1000\n2 4 1000\n2 1030\n1 1020\n1 890\n*/\n#include \"bits/stdc++.h\"\nusing namespace std;\n\nstruct node{\n\tlong long best_a2bc = 0;\n\tlong long best_a = 0;\n\tlong long best_2b = 0;\n\tlong long best_a2b = 0;\n\tlong long best_2bc = 0;\n\tlong long lazy_val = 0;\n\tnode *l = NULL, *r = NULL;\n};\n\nvoid lazy(node* &u, int a, int b){\n\tif(!u->lazy_val) return;\n\tu->best_a += u->lazy_val;\n\tu->best_2b -= 2*u->lazy_val;\n\tu->best_a2b -= u->lazy_val;\n\tu->best_2bc -= u->lazy_val;\n\tif(a!=b){\n\t\tif(!u->l) u->l = new node();\n\t\tif(!u->r) u->r = new node();\n\t\tu->l->lazy_val += u->lazy_val, u->r->lazy_val += u->lazy_val;\n\t}\n\tu->lazy_val = 0;\n}\n\nvoid combine(node* &u, node* &l, node* &r) {\n\tu->best_2b = max(l->best_2b,r->best_2b);\n\tu->best_a = max(l->best_a,r->best_a);\n\tu->best_2bc = max({l->best_2bc,r->best_2bc,l->best_2b+r->best_a});\n\tu->best_a2b = max({l->best_a2b,r->best_a2b,l->best_a+r->best_2b});\n\tu->best_a2bc = max({l->best_a2bc,r->best_a2bc,l->best_a+r->best_2bc,l->best_a2b+r->best_a});\n}\n\nvoid update(node* &u, int a, int b, int l, int r, long long val){\n\tif(!u) u = new node();\n\tlazy(u,a,b);\n\tif(b<l || a>r) return;\n\tif(l<=a && b<=r){\n\t\tu->lazy_val += val;\n\t\tlazy(u,a,b);\n\t\treturn;\n\t}\n\n\tupdate(u->l,a,(a+b)/2,l,r,val);\n\tupdate(u->r,(a+b)/2+1,b,l,r,val);\n\n\tcombine(u,u->l,u->r);\n}\n\nnode *ST = new node();\nvector<pair<pair<int,int>,long long>> edges;\nvector<pair<int,long long>> v[100005];\n\nint tin[100005],tout[100005],CLK,n;\nvoid dfspre(int u, int dad, long long d){\n\ttout[u] = tin[u] = CLK++;\n\tfor(auto i:v[u]) if(i.first!=dad){\n\t\tdfspre(i.first,u,i.second);\n\t\ttout[u]=CLK++;\n\t}\n\tupdate(ST,0,2*n,tin[u],tout[u],d);\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);cout.tie(0);\n\n\tlong long q,w; cin >> n >> q >> w;\n\n\tfor(long long i=n,a,b,c;--i;){\n\t\tcin >> a >> b >> c;\n\t\tedges.emplace_back(make_pair(a,b),c);\n\t\tv[a].emplace_back(b,c);\n\t\tv[b].emplace_back(a,c);\n\t}\n\tdfspre(1,0,0);\n\n\tfor(long long last=0,d,e;q--;cout<<last<<'\\n'){\n\t\tcin >> d >> e;\n\t\td = (d+last) % (n-1);\n\t\te = (e+last) % w;\n\t\tint x,y; tie(x,y) = edges[d].first;\n\t\tif(tin[x]>tin[y]) swap(x,y);\n\t\tupdate(ST,0,2*n,tin[y],tout[y],e-edges[d].second);\n\t\tedges[d].second = e;\n\t\tlast = ST->best_a2bc;\n\t}\n}",
    "ext": "cpp"
  },
  "57808570": {
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll inf=2e18;\n#define F for(int i=0;i<3;i++) for(int j=0;j<3;j++)\n#define R for(int i=0;i<3;i++)\nvoid mul(ll a[][3],ll b[][3],ll c[][3]){\n\tll d[3][3]={0};\n\tF d[i][j]=-inf;\n\tfor(int k=0;k<3;k++)\n\t\tF d[i][j]=max(a[i][k]+b[k][j],d[i][j]);\n\tF c[i][j]=d[i][j];\n}\nconst int N=100010;\nint n,q; ll lim;\nint hd[N],to[N<<1],nx[N<<1],t=1; ll w[N<<1],fw[N];\nvoid add(int u,int v,ll c){\n\tt++; to[t]=v; nx[t]=hd[u]; hd[u]=t; w[t]=c;\n}\nint fa[N],id[N],dp[N],sz[N],sn[N],dn[N],dx[N],tp[N],ls[N],c;\nll h[N],s[N],wl[N],g[N],f[N];\nmultiset<ll>sg[N],sf[N];\n#define E erase\n#define S insert\n#define D find\n#define U ans[i]=0\n#define V tmp[i]=ans[i]\nvoid d1(int u){\n\tsz[u]=1;\n\tfor(int e=hd[u];e;e=nx[e]) if(to[e]!=fa[u]){\n\t\tint v=to[e];\n\t\tid[e>>1]=v,fa[v]=u,dp[v]=dp[u]+1,fw[v]=w[e],d1(v),sz[u]+=sz[v];\n\t\tif(sz[v]>sz[sn[u]]) sn[u]=v,wl[u]=w[e];\n\t}\n}\nvoid cal(int u){\n\tmultiset<ll>:: iterator it=sg[u].end(); it--; \n\th[u]=s[u]=*it,sg[u].E(it); ll tmp=*it;\n\tif(!sg[u].empty()) it=sg[u].end(),it--,s[u]+=*it;\n\tsg[u].S(tmp); it=sf[u].end(),it--; s[u]=max(s[u],*it);\n}\nvoid d2(int u){\n\tdn[u]=++c; dx[c]=u;\n\tif(sn[u]) tp[sn[u]]=tp[u],d2(sn[u]);\n\telse{ls[tp[u]]=c; return;}\n\tbool is=0;\n\tfor(int e=hd[u];e;e=nx[e]){\n\t\tint v=to[e]; if(v==fa[u] || v==sn[u]) continue;\n\t\tis=1; tp[v]=v; d2(v);\n\t\tsg[u].insert(g[v]+w[e]); sf[u].insert(f[v]);\n\t}\n\tif(is) cal(u);\n\tll x=g[sn[u]]+wl[u];\n\tg[u]=max(h[u],x),f[u]=max(max(s[u],f[sn[u]]),x+h[u]);\n}\nll sm[N<<2][3][3];\n#define mid ((l+r)>>1)\n#define lc (u<<1)\n#define rc ((u<<1)|1)\n#define su sm[u]\nvoid cnt(int p,int u){\n\tsu[0][0]=wl[p]; su[0][2]=h[p];\n\tsu[1][0]=wl[p]+h[p]; su[1][2]=s[p];\n\tsu[0][1]=su[2][0]=su[2][1]=-inf;\n}\nvoid B(int u,int l,int r){\n\tif(l==r){cnt(dx[l],u); return;}\n\tB(lc,l,mid),B(rc,mid+1,r);\n\tmul(sm[lc],sm[rc],su);\n}\nvoid A(int u,int l,int r,int x){\n\tif(l==r){cnt(dx[l],u); return;}\n\t(x<=mid)?A(lc,l,mid,x):A(rc,mid+1,r,x);\n\tmul(sm[lc],sm[rc],su);\n}\nll ans[3];\nvoid C(int u){\n\tll mx[3]={0};\n\tR mx[i]=-inf;\n\tF mx[i]=max(mx[i],su[i][j]+ans[j]);\n\tR ans[i]=mx[i];\n}\nvoid Q(int u,int l,int r,int a,int b){\n\tif(a<=l && r<=b){C(u); return;}\n\tif(b>mid) Q(rc,mid+1,r,a,b);\n\tif(a<=mid) Q(lc,l,mid,a,b);\n}\nint main()\n{\n\tcin>>n>>q>>lim; ll c;\n\tfor(int u,v,i=1;i<n;i++)\n\t\tscanf(\"%d %d %I64d\",&u,&v,&c),add(u,v,c),add(v,u,c);\n\tdp[1]=1; d1(1); tp[1]=1; d2(1);\n\tfor(int i=1;i<=n;i++) ls[i]=ls[tp[i]];\n\tB(1,1,n);\n\twhile(q--){\n\t\tint d; ll e; scanf(\"%d %I64d\",&d,&e);\n\t\td=(int)((ans[1]+d)%(ll)(n-1))+1; e=(e+ans[1])%lim;\n\t\tint v=id[d],u=fa[v]; ll tmp[3];\n\t\tR U; Q(1,1,n,dn[tp[u]],ls[u]); R V;\n\t\tif(sn[u]==v) wl[u]=e;\n\t\telse{\n\t\t\tR U; Q(1,1,n,dn[v],ls[v]);\n\t\t\tsg[u].E(sg[u].D(ans[0]+fw[v]));\n\t\t\tsg[u].S(ans[0]+e); cal(u);\n\t\t}\n\t\tfw[v]=e,A(1,1,n,dn[u]);\n\t\tfor(v=tp[u],u=fa[v];u;v=tp[u],u=fa[v]){\n\t\t\tR U; Q(1,1,n,dn[v],ls[v]);\n\t\t\tsg[u].E(sg[u].find(tmp[0]+fw[v]));\n\t\t\tsf[u].E(sf[u].find(tmp[1]));\n\t\t\tsg[u].S(ans[0]+fw[v]);\n\t\t\tsf[u].S(ans[1]);\n\t\t\tR U; Q(1,1,n,dn[tp[u]],ls[u]); R V;\n\t\t\tcal(u); A(1,1,n,dn[u]);\n\t\t}\n\t\tR U; Q(1,1,n,1,ls[1]); printf(\"%I64d\\n\",ans[1]);\n\t}\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57807972": {
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll inf=2e18;\nvoid mul(ll a[][3],ll b[][3],ll c[][3]){\n\tll d[3][3]={0};\n\tfor(int i=0;i<3;i++)\n\t\t\tfor(int j=0;j<3;j++) d[i][j]=-inf;\n\tfor(int k=0;k<3;k++)\n\t\tfor(int i=0;i<3;i++)\n\t\t\tfor(int j=0;j<3;j++) d[i][j]=max(a[i][k]+b[k][j],d[i][j]);\n\tfor(int i=0;i<3;i++)\n\t\t\tfor(int j=0;j<3;j++) c[i][j]=d[i][j];\n}\nconst int N=100010;\nint n,q; ll lim;\nint hd[N],to[N<<1],nx[N<<1],t=1; ll w[N<<1],fw[N];\nvoid add(int u,int v,ll c){\n\tt++; to[t]=v; nx[t]=hd[u]; hd[u]=t; w[t]=c;\n}\nint fa[N],id[N],dp[N],sz[N],sn[N],dn[N],dx[N],tp[N],ls[N],c;\nll h[N],s[N],wl[N],g[N],f[N];\nmultiset<ll>sg[N],sf[N];\nvoid d1(int u){\n\tsz[u]=1;\n\tfor(int e=hd[u];e;e=nx[e]) if(to[e]!=fa[u]){\n\t\tint v=to[e]; id[e>>1]=v;\n\t\tfa[v]=u; dp[v]=dp[u]+1; fw[v]=w[e];\n\t\td1(v); sz[u]+=sz[v];\n\t\tif(sz[v]>sz[sn[u]]) sn[u]=v,wl[u]=w[e];\n\t}\n}\nvoid cal(int u){\n\tmultiset<ll>:: iterator it=sg[u].end();\n\tit--; h[u]=s[u]=*it; sg[u].erase(it);\n\tll tmp=*it;\n\tif(!sg[u].empty()){\n\t\tit=sg[u].end(); it--; s[u]+=*it;\n\t}\n\tsg[u].insert(tmp);\n\tit=sf[u].end(); it--;\n\ts[u]=max(s[u],*it);\n}\nvoid d2(int u){\n\tdn[u]=++c; dx[c]=u;\n\tif(sn[u]){\n\t\ttp[sn[u]]=tp[u]; d2(sn[u]);\n\t}\n\telse{\n\t\tls[tp[u]]=c; return;\n\t}\n\tbool is=0;\n\tfor(int e=hd[u];e;e=nx[e]){\n\t\tint v=to[e]; if(v==fa[u] || v==sn[u]) continue;\n\t\tis=1; tp[v]=v; d2(v);\n\t\tsg[u].insert(g[v]+w[e]); sf[u].insert(f[v]);\n\t}\n\tif(is) cal(u);\n\tll x=g[sn[u]]+wl[u];\n\tg[u]=max(h[u],x);\n\tf[u]=max(max(s[u],f[sn[u]]),x+h[u]);\n}\nll sm[N<<2][3][3];\n#define mid ((l+r)>>1)\n#define lc (u<<1)\n#define rc ((u<<1)|1)\n#define su sm[u]\nvoid cnt(int p,int u){\n\tsu[0][0]=wl[p]; su[0][2]=h[p];\n\tsu[1][0]=wl[p]+h[p]; su[1][2]=s[p];\n\tsu[0][1]=su[2][0]=su[2][1]=-inf;\n}\nvoid B(int u,int l,int r){\n\tif(l==r){\n\t\tcnt(dx[l],u);\n\t\t//cout<<\"B\"<<endl;\n\t\t//cout<<l<<\" \"<<dx[l]<<endl;\n\t\t/*for(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<3;j++) cout<<su[i][j]<<\" \";\n\t\t\tcout<<endl;\n\t\t}*/\n\t\treturn;\n\t}\n\tB(lc,l,mid); B(rc,mid+1,r);\n\tmul(sm[lc],sm[rc],su);\n}\nvoid A(int u,int l,int r,int x){\n\tif(l==r){\n\t\tcnt(dx[l],u); return;\n\t}\n\t(x<=mid)?A(lc,l,mid,x):A(rc,mid+1,r,x);\n\tmul(sm[lc],sm[rc],su);\n}\nll ans[3];\nvoid C(int u){\n\tll mx[3]={0};\n\tfor(int i=0;i<3;i++) mx[i]=-inf;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int j=0;j<3;j++)\n\t\t\tmx[i]=max(mx[i],su[i][j]+ans[j]);//cout<<su[i][j]<<\" \";\n\t\t//cout<<endl;\n\t}\n\tfor(int i=0;i<3;i++) ans[i]=mx[i];\n}\nvoid Q(int u,int l,int r,int a,int b){ //cout<<\"Q:\"<<a<<\" \"<<b<<\" l=\"<<l<<\" r=\"<<r<<endl;\n\tif(a<=l && r<=b){ //cout<<l<<\" \"<<r<<endl;\n\t\tC(u); return;\n\t}\n\tif(b>mid) Q(rc,mid+1,r,a,b);\n\tif(a<=mid) Q(lc,l,mid,a,b);\n}\nint main()\n{\n    //freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tcin>>n>>q>>lim; ll c;\n\tfor(int u,v,i=1;i<n;i++)\n\t\tscanf(\"%d %d %I64d\",&u,&v,&c),add(u,v,c),add(v,u,c);\n\tdp[1]=1; d1(1); tp[1]=1; d2(1);\n\tfor(int i=1;i<=n;i++) ls[i]=ls[tp[i]];\n\t//for(int u=1;u<=n;u++) printf(\"u=%d sn=%d ls=%d g=%lld f=%lld\\n\",u,sn[u],ls[u],g[u],f[u]);\n\tB(1,1,n);\n\twhile(q--){\n\t\tint d; ll e; scanf(\"%d %I64d\",&d,&e);\n\t\td=(int)((ans[1]+d)%(ll)(n-1))+1; e=(e+ans[1])%lim;\n\t\t//cout<<\"d=\"<<d<<\" e=\"<<e<<endl;\n\t\tint v=id[d],u=fa[v]; ll tmp[3];\n\t\t//cout<<\"u=\"<<u<<\" v=\"<<v<<endl;\n\t\tfor(int i=0;i<3;i++) ans[i]=0;\n\t\tQ(1,1,n,dn[tp[u]],ls[u]);\n\t\tfor(int i=0;i<3;i++) tmp[i]=ans[i];\n\t\t//for(int i=0;i<3;i++) tmp[i]=ans[i],cout<<tmp[i]<<\" \"; cout<<endl;\n\t\t//modify u\n\t\tif(sn[u]==v) wl[u]=e;\n\t\telse{\n\t\t\tfor(int i=0;i<3;i++) ans[i]=0;\n\t\t\tQ(1,1,n,dn[v],ls[v]);\n\t\t\t//for(int i=0;i<3;i++) cout<<ans[i]<<\" \"; cout<<endl;\n\t\t\tsg[u].erase(sg[u].find(ans[0]+fw[v]));\n\t\t\tsg[u].insert(ans[0]+e);\n\t\t\tcal(u);\n\t\t}\n\t\tfw[v]=e;\n\t\tA(1,1,n,dn[u]);\n\t\t//end\n\t\tfor(v=tp[u],u=fa[v];u;v=tp[u],u=fa[v]){\n\t\t\t//cout<<\"u=\"<<u<<\" v=\"<<v<<endl;\n\t\t\t//cnt u\n\t\t\tfor(int i=0;i<3;i++) ans[i]=0;\n\t\t\tQ(1,1,n,dn[v],ls[v]);\n\t\t\t//for(int i=0;i<3;i++) cout<<ans[i]<<\" \"; cout<<endl;\n\t\t\t//modify u\n\t\t\tsg[u].erase(sg[u].find(tmp[0]+fw[v]));\n\t\t\tsf[u].erase(sf[u].find(tmp[1]));\n\t\t\tsg[u].insert(ans[0]+fw[v]);\n\t\t\tsf[u].insert(ans[1]);\n\t\t\t//pre\n\t\t\tfor(int i=0;i<3;i++) ans[i]=0;\n\t\t\tQ(1,1,n,dn[tp[u]],ls[u]);\n\t\t\tfor(int i=0;i<3;i++) tmp[i]=ans[i];\n\t\t\t//update u\n\t\t\tcal(u); A(1,1,n,dn[u]);\n\t\t}\n\t\tfor(int i=0;i<3;i++) ans[i]=0;\n\t\tQ(1,1,n,1,ls[1]);\n\t\tprintf(\"%I64d\\n\",ans[1]);\n\t}\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57806467": {
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2,fma\")\nusing namespace std;\nusing namespace __gnu_pbds;\n#define ll long long\n#define ff first\n#define ss second\n#define pb push_back\n#define N 100005\nvector<pair<ll, pair<int, int> > > edge;\nvector<int> adj[N];\nll wmax;\nint n;\nconst int RANDOM = chrono::high_resolution_clock::now().time_since_epoch().count();\nstruct chash {\n    int operator()(int x) const { return x ^ RANDOM; }\n};\n\nbool ooo = 0;\n\ninline int get(int v, int i){\n   return edge[i].ss.ss + edge[i].ss.ff - v;\n}\n\n\nint sz[N];\nbool used[N];\n\nint get_size(int v, int p){\n   sz[v] = 1;\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u] || u == p) continue;\n      sz[v] += get_size(u, v);\n   }\n   return sz[v];\n}\n\nint get_center(int v, int p, int s){\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u] || u == p) continue;\n      if(sz[u] > s) return get_center(u, v, s);\n   }\n   return v;\n}\n\nstruct Segtree{\n   int t;\n   vector<long long> seg, laz;\n\n   void resize(int _t){\n      t = _t;\n      seg.resize(t << 2);\n      laz.resize(t << 2);\n   }\n   void push(int id, int l, int r){\n      seg[id] += laz[id];\n      if(l != r){\n         laz[id << 1] += laz[id];\n         laz[id << 1 | 1] += laz[id];\n      }\n      laz[id] = 0;\n   }\n   void update(int id, int l, int r, int L, int R, ll val){\n      if(L <= l && r <= R){\n         laz[id] += val;\n         push(id, l, r);\n         return;\n      }\n      push(id, l, r);\n      if(r < L || l > R) return;\n      int m = (l + r) >> 1;\n      update(id << 1, l, m, L, R, val);\n      update(id << 1 | 1, m + 1, r, L, R, val);\n      seg[id] = max(seg[id << 1], seg[id << 1 | 1]);\n   }\n\n   long long query(int id, int l, int r, int L, int R){\n      push(id, l, r);\n      if(r < L || l > R) return 0;\n      if(L <= l && r <= R) return seg[id];\n      int m = (l + r) >> 1;\n      return max(query(id << 1, l, m, L, R), query(id << 1 | 1, m + 1, r, L, R));\n   }\n} pls;\n\nstruct Tree{\n   int root;\n   multiset<ll> ans;\n   vector<int> e, L, R, pp;\n   vector<vector<int> > adj;\n   gp_hash_table<int, int, chash> comp;\n   int t = 0;\n   Segtree ss;\n\n\n   void dfs(int v, int p){\n      L[v] = t + 1;\n      int ch = 0;\n      for(int& x : adj[v]){\n         if(x == p) continue;\n         if(v == root){\n            pp[x] = x;\n            ans.insert(0);\n         }\n         else pp[x] = pp[v];\n         ch++;\n         dfs(x, v);\n      }\n      if(ch == 0) t++;\n      R[v] = t;\n   }\n\n   void build(int _r){\n      root = _r;\n      for(int& x : e){\n         comp[edge[x].ss.ss] = 0;\n         comp[edge[x].ss.ff] = 0;\n      }\n      int f = 1;\n      for(auto& x : comp)\n         x.ss = f++;\n      pp.resize(f);\n      L.resize(f);\n      R.resize(f);\n      adj.resize(f);\n      for(int& x : e){\n         int v = comp[edge[x].ss.ss];\n         int u = comp[edge[x].ss.ff];\n         adj[v].push_back(u);\n         adj[u].push_back(v);\n      }\n      root = comp[root];\n      dfs(root, -1);\n      ss.resize(t);\n   }\n\n\n   void updater(int v, int u, ll val){\n      v = comp[v];\n      u = comp[u];\n      int le = max(L[v], L[u]);\n      int ri = min(R[v], R[u]);\n      int q;\n      if(v == root) q = pp[u];\n      else q = pp[v];\n      ans.erase(ans.find(-ss.query(1, 1, t, L[q], R[q])));\n      ss.update(1, 1, t, le, ri, val);\n      ans.insert(-ss.query(1, 1, t, L[q], R[q]));\n   }\n   long long getter(){\n      auto it = ans.begin();\n      if(ans.size() == 1) return *it;\n      return *it + (*(++it));\n   }\n} trees[N];\n\nint d[N];\nint par[N];\nvector<int> ch[N];\nint decomp(int v){\n   v = get_center(v, -1, get_size(v, -1) / 2);\n   used[v] = 1;\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u]) continue;\n      trees[v].e.push_back(x);\n      u = decomp(u);\n      par[u] = v;\n      ch[v].push_back(u);\n      for(int& x : trees[u].e)\n         trees[v].e.push_back(x);\n   }\n   return v;\n}\n\nvoid useless(int v){\n   ++d[v];\n   for(auto& x : ch[v]){\n      d[x] = d[v];\n      useless(x);\n   }\n}\n\nvoid update(int v, int u, ll val){\n   if(d[v] > d[u]) swap(v, u);\n   int ov = v;\n   ll bef;\n   while(v != 0){\n      bef = trees[v].getter();\n      trees[v].updater(ov, u, val);\n      pls.update(1, 1, n, v, v, bef-trees[v].getter());\n      v = par[v];\n   }\n}\n\nlong long get(){\n   char c;\n   ll res = 0;\n   c = _getchar_nolock();\n   while(c > 47 && c < 58){\n      res = res * 10 + c - 48;\n      c = _getchar_nolock();\n   }\n   return res;\n}\n\nvoid put(long long res){\n   if(res < 10){\n      _putchar_nolock(res + '0');\n   } else {\n      put(res / 10);\n      _putchar_nolock(res % 10 + '0');\n   }\n}\n\n\nint main(){\n   int q;\n   n = get();\n   q = get();\n   wmax = get();\n   for(int i = 1; i < n; i++){\n      int v, u;\n      ll w;\n      v = get();\n      u = get();\n      w = get();\n      edge.pb({w, {v, u}});\n      adj[v].push_back(i - 1);\n      adj[u].push_back(i - 1);\n   }\n\n   pls.resize(n);\n\n   int cen = decomp(1);\n   useless(cen);\n\n   for(int i = 1; i <= n; i++){\n      trees[i].build(i);\n   }\n   for(auto& x : edge){\n      update(x.ss.ff, x.ss.ss, x.ff);\n   }\n   ll last = 0;\n   while(q--){\n      ll ww;\n      int ee;\n      ee = get();\n      ww = get();\n      ee = (ee + last) % (n - 1);\n      ww = (ww + last) % wmax;\n      update(edge[ee].ss.ff, edge[ee].ss.ss, ww - edge[ee].ff);\n      edge[ee].ff = ww;\n      last = pls.query(1, 1, n, 1, n);\n      put(last);\n      _putchar_nolock('\\n');\n   }\n}\n",
    "ext": "cpp"
  },
  "57806329": {
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2,fma\")\nusing namespace std;\nusing namespace __gnu_pbds;\n#define ll long long\n#define ff first\n#define ss second\n#define pb push_back\n#define N 100005\nvector<pair<ll, pair<int, int> > > edge;\nvector<int> adj[N];\nll wmax;\nint n;\n\nbool ooo = 0;\n\ninline int get(int v, int i){\n   return edge[i].ss.ss + edge[i].ss.ff - v;\n}\n\n\nint sz[N];\nbool used[N];\n\nint get_size(int v, int p){\n   sz[v] = 1;\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u] || u == p) continue;\n      sz[v] += get_size(u, v);\n   }\n   return sz[v];\n}\n\nint get_center(int v, int p, int s){\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u] || u == p) continue;\n      if(sz[u] > s) return get_center(u, v, s);\n   }\n   return v;\n}\n\nstruct Segtree{\n   int t;\n   vector<long long> seg, laz;\n\n   void resize(int _t){\n      t = _t;\n      seg.resize(t << 2);\n      laz.resize(t << 2);\n   }\n   void push(int id, int l, int r){\n      seg[id] += laz[id];\n      if(l != r){\n         laz[id << 1] += laz[id];\n         laz[id << 1 | 1] += laz[id];\n      }\n      laz[id] = 0;\n   }\n   void update(int id, int l, int r, int L, int R, ll val){\n      if(L <= l && r <= R){\n         laz[id] += val;\n         push(id, l, r);\n         return;\n      }\n      push(id, l, r);\n      if(r < L || l > R) return;\n      int m = (l + r) >> 1;\n      update(id << 1, l, m, L, R, val);\n      update(id << 1 | 1, m + 1, r, L, R, val);\n      seg[id] = max(seg[id << 1], seg[id << 1 | 1]);\n   }\n\n   long long query(int id, int l, int r, int L, int R){\n      push(id, l, r);\n      if(r < L || l > R) return 0;\n      if(L <= l && r <= R) return seg[id];\n      int m = (l + r) >> 1;\n      return max(query(id << 1, l, m, L, R), query(id << 1 | 1, m + 1, r, L, R));\n   }\n} pls;\n\nstruct Tree{\n   int root;\n   multiset<ll> ans;\n   vector<int> e, L, R, pp;\n   vector<vector<int> > adj;\n   gp_hash_table<int, int> comp;\n   int t = 0;\n   Segtree ss;\n\n\n   void dfs(int v, int p){\n      L[v] = t + 1;\n      int ch = 0;\n      for(int& x : adj[v]){\n         if(x == p) continue;\n         if(v == root){\n            pp[x] = x;\n            ans.insert(0);\n         }\n         else pp[x] = pp[v];\n         ch++;\n         dfs(x, v);\n      }\n      if(ch == 0) t++;\n      R[v] = t;\n   }\n\n   void build(int _r){\n      root = _r;\n      for(int& x : e){\n         comp[edge[x].ss.ss] = 0;\n         comp[edge[x].ss.ff] = 0;\n      }\n      int f = 1;\n      for(auto& x : comp)\n         x.ss = f++;\n      pp.resize(f);\n      L.resize(f);\n      R.resize(f);\n      adj.resize(f);\n      for(int& x : e){\n         int v = comp[edge[x].ss.ss];\n         int u = comp[edge[x].ss.ff];\n         adj[v].push_back(u);\n         adj[u].push_back(v);\n      }\n      root = comp[root];\n      dfs(root, -1);\n      ss.resize(t);\n   }\n\n\n   void updater(int v, int u, ll val){\n      v = comp[v];\n      u = comp[u];\n      int le = max(L[v], L[u]);\n      int ri = min(R[v], R[u]);\n      int q;\n      if(v == root) q = pp[u];\n      else q = pp[v];\n      ans.erase(ans.find(-ss.query(1, 1, t, L[q], R[q])));\n      ss.update(1, 1, t, le, ri, val);\n      ans.insert(-ss.query(1, 1, t, L[q], R[q]));\n   }\n   long long getter(){\n      auto it = ans.begin();\n      if(ans.size() == 1) return *it;\n      return *it + (*(++it));\n   }\n} trees[N];\n\nint d[N];\nint par[N];\nvector<int> ch[N];\nint decomp(int v){\n   v = get_center(v, -1, get_size(v, -1) / 2);\n   used[v] = 1;\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u]) continue;\n      trees[v].e.push_back(x);\n      u = decomp(u);\n      par[u] = v;\n      ch[v].push_back(u);\n      for(int& x : trees[u].e)\n         trees[v].e.push_back(x);\n   }\n   return v;\n}\n\nvoid useless(int v){\n   ++d[v];\n   for(auto& x : ch[v]){\n      d[x] = d[v];\n      useless(x);\n   }\n}\n\nvoid update(int v, int u, ll val){\n   if(d[v] > d[u]) swap(v, u);\n   int ov = v;\n   ll bef;\n   while(v != 0){\n      bef = trees[v].getter();\n      trees[v].updater(ov, u, val);\n      pls.update(1, 1, n, v, v, bef-trees[v].getter());\n      v = par[v];\n   }\n}\n\nlong long get(){\n   char c;\n   ll res = 0;\n   c = _getchar_nolock();\n   while(c > 47 && c < 58){\n      res = res * 10 + c - 48;\n      c = _getchar_nolock();\n   }\n   return res;\n}\n\nvoid put(long long res){\n   if(res < 10){\n      _putchar_nolock(res + '0');\n   } else {\n      put(res / 10);\n      _putchar_nolock(res % 10 + '0');\n   }\n}\n\n\nint main(){\n   int q;\n   n = get();\n   q = get();\n   wmax = get();\n   for(int i = 1; i < n; i++){\n      int v, u;\n      ll w;\n      v = get();\n      u = get();\n      w = get();\n      edge.pb({w, {v, u}});\n      adj[v].push_back(i - 1);\n      adj[u].push_back(i - 1);\n   }\n\n   pls.resize(n);\n\n   int cen = decomp(1);\n   useless(cen);\n\n   for(int i = 1; i <= n; i++){\n      trees[i].build(i);\n   }\n   for(auto& x : edge){\n      update(x.ss.ff, x.ss.ss, x.ff);\n   }\n   ll last = 0;\n   while(q--){\n      ll ww;\n      int ee;\n      ee = get();\n      ww = get();\n      ee = (ee + last) % (n - 1);\n      ww = (ww + last) % wmax;\n      update(edge[ee].ss.ff, edge[ee].ss.ss, ww - edge[ee].ff);\n      edge[ee].ff = ww;\n      last = pls.query(1, 1, n, 1, n);\n      put(last);\n      _putchar_nolock('\\n');\n   }\n}\n",
    "ext": "cpp"
  },
  "57806180": {
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n#include <bits/stdc++.h>\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 1e5 + 5;\n\nstruct SEG {\n\tint SZ;\n\tll *seg, *lz, *disc, *st, *en, *depth, *mxd;\n\tint *root, *par;\n\tmap<int,int> ind;\n\tmultiset<ll> mx;\n\n\tvoid init(int SZ) {\n\t\tseg = new ll[SZ*4], lz = new ll[SZ*4];\n\t\tdisc = new ll[SZ], depth = new ll[SZ];\n\t\tst = new ll[SZ], en = new ll[SZ];\n\t\tmxd = new ll[SZ];\n\t\troot = new int[SZ], par = new int[SZ]{};\n\t\tSEG::SZ = SZ;\n\t}\n\n\tvoid build(int l, int r, int k) {\n\t\tlz[k] = 0;\n\t\tif (l == r) {\n\t\t\tseg[k] = depth[disc[l]];\n\t\t\treturn;\n\t\t}\n\t\tint m = (l+r) / 2;\n\t\tbuild(l,m,k*2);\n\t\tbuild(m+1,r,k*2+1);\n\t\tseg[k] = max(seg[k*2],seg[k*2+1]);\n\t}\n\n\tvoid prop(int l, int r, int k) {\n\t\tif (l != r) {\n\t\t\tlz[k*2] += lz[k];\n\t\t\tlz[k*2+1] += lz[k];\n\t\t}\n\t\tseg[k] += lz[k];\n\t\tlz[k] = 0;\n\t}\n\n\tvoid upd(int l, int r, int k, int a, int b, ll v) {\n\t\tif (lz[k]) prop(l,r,k);\n\t\tif (b < l || r < a) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlz[k] += v;\n\t\t\tprop(l,r,k);\n\t\t\treturn;\n\t\t}\n\t\tint m = (l+r) / 2;\n\t\tupd(l,m,k*2,a,b,v);\n\t\tupd(m+1,r,k*2+1,a,b,v);\n\t\tseg[k] = max(seg[k*2],seg[k*2+1]);\n\t}\n\n\tll qry(int l, int r, int k, int a, int b) {\n\t\tif (lz[k]) prop(l,r,k);\n\t\tif (b < l || r < a) return 0;\n\t\tif (a <= l && r <= b) return seg[k];\n\t\tint m = (l+r) / 2;\n\t\treturn max(qry(l,m,k*2,a,b),qry(m+1,r,k*2+1,a,b));\n\t}\n};\n\ntemplate<int SZ> struct CD {\n\tvi adj[SZ];\n\tint sz[SZ], depth[SZ], par[SZ], U[SZ], V[SZ], m = 0, vis[SZ], tt = 0;\n\tll W[SZ];\n\tSEG seg[SZ];\n\tmultiset<ll> ans;\n\n\tvoid addEdge(int u, int v, ll w = 0) {\n\t\tadj[u].pb(m); adj[v].pb(m);\n\t\tU[m] = u, V[m] = v;\n\t\tW[m++] = w;\n\t}\n\n\tint getSz(int u, int p = -1) {\n\t\tsz[u] = 1;\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (v != p && !vis[v])\n\t\t\t\tsz[u] += getSz(v, u);\n\t\t}\n\t\treturn sz[u];\n\t}\n\n\tint findCen(int u, int n, int p = -1) {\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (v != p && !vis[v] && sz[v] > n/2)\n\t\t\t\treturn findCen(v, n, u);\n\t\t}\n\t\treturn u;\n\t}\n\n\tll euler(int u, ll d, int root, int root2, int p) {\n\t\tll ret = d;\n\t\tint cur = tt;\n\t\tseg[root].depth[cur] = d;\n\t\tseg[root].ind[u] = cur;\n\t\tseg[root].disc[tt] = cur;\n\t\tseg[root].st[cur] = tt++;\n\t\tseg[root].root[cur] = root2;\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (vis[v] || v == p) continue;\n\t\t\tseg[root].par[tt] = cur;\n\t\t\tret = max(ret, euler(v, d+W[i], root, root2, u));\n\t\t}\n\t\tseg[root].en[cur] = tt;\n\t\treturn ret;\n\t}\n\n\tvoid decompose(int u, int p = -1) {\n\t\tint n = getSz(u);\n\t\tu = findCen(u, n);\n\t\tif (~p) depth[u] = depth[p] + 1;\n\t\tpar[u] = p;\n\t\tvis[u] = 1;\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (!vis[v])\n\t\t\t\tdecompose(v, u);\n\t\t}\n\t\tvis[u] = 0;\n\t\tif (n != 1) {\n\t\t\tseg[u].init(n);\n\t\t\ttt = 0;\n\t\t\tseg[u].ind[u] = 0;\n\t\t\tseg[u].disc[0] = 0;\n\t\t\tseg[u].st[0] = tt++;\n\t\t\tfor (int i: adj[u]) {\n\t\t\t\tint v = U[i]^V[i]^u;\n\t\t\t\tif (vis[v]) continue;\n\t\t\t\tll tmp = euler(v, W[i], u, tt, u);\n\t\t\t\tseg[u].mxd[seg[u].ind[v]] = tmp;\n\t\t\t\tseg[u].mx.insert(tmp);\n\t\t\t}\n\t\t\tseg[u].en[0] = tt;\n\t\t\tseg[u].build(0,tt-1,1);\n\t\t\tans.insert(calc(u));\n\t\t}\n\t}\n\n\tll calc(int x) {\n\t\tif (seg[x].mx.empty()) return 0;\n\t\tauto it = --seg[x].mx.end();\n\t\tll ret = *it;\n\t\tif (it != seg[x].mx.begin())\n\t\t\tret += *prev(it);\n\t\treturn ret;\n\t}\n\n\tvoid upd(int d, ll e) {\n\t\tint u = U[d], v = V[d];\n\t\tll del = e - W[d];\n\t\tW[d] = e;\n\t\tif (del == 0) return;\n\t\tint x = u, y = v;\n\t\twhile (depth[x] > depth[y]) x = par[x];\n\t\twhile (depth[x] < depth[y]) y = par[y];\n\t\tfor (; x != -1; x = par[x]) {\n\t\t\tif (seg[x].par[seg[x].ind[u]] == seg[x].ind[v]) swap(u, v);\n\t\t\tint nv = seg[x].ind[v];\n\t\t\tint r = seg[x].root[nv];\n\t\t\tans.erase(ans.find(calc(x)));\n\t\t\tseg[x].mx.erase(seg[x].mx.find(seg[x].mxd[r]));\n\t\t\tseg[x].upd(0,seg[x].SZ-1,1,seg[x].st[nv],seg[x].en[nv]-1,del);\n\t\t\tseg[x].mxd[r] = seg[x].qry(0,seg[x].SZ-1,1,seg[x].st[r],seg[x].en[r]-1);\n\t\t\tseg[x].mx.insert(seg[x].mxd[r]);\n\t\t\tans.insert(calc(x));\n\t\t}\n\t}\n\n\tll qry() {\n\t\treturn *(--ans.end());\n\t}\n};\n\nCD<MAXN> cd;\n\nint main() {\n\tint n, q; ll w; scanf(\"%d %d %I64d\", &n, &q, &w);\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v; ll c; scanf(\"%d %d %I64d\", &u, &v, &c);\n\t\tu--, v--;\n\t\tcd.addEdge(u,v,c);\n\t}\n\tcd.decompose(0);\n\tll ans = 0;\n\twhile (q--) {\n\t\tint d; ll e; scanf(\"%d %I64d\", &d, &e);\n\t\td = ((ll)d + ans) % (n-1);\n\t\te = (e + ans) % w;\n\t\tcd.upd(d, e);\n\t\tans = cd.qry();\n\t\tprintf(\"%I64d\\n\", ans);\n\t}\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57806030": {
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef cc_hash_table<int,int,hash<int>> hsh;\ntypedef long long ll;\nconst int MAXN = 1e5 + 5;\n\nstruct SEG {\n\tint SZ;\n\tll *seg, *lz, *disc, *st, *en, *depth, *mxd;\n\tint *root, *par;\n\thsh ind;\n\tmultiset<ll> mx;\n\n\tvoid init(int SZ) {\n\t\t//SZ++;\n\t\t/*seg.resize(SZ*4); lz.resize(SZ*4);\n\t\tdisc.resize(SZ); depth.resize(SZ);\n\t\tst.resize(SZ); en.resize(SZ);\n\t\tmxd.resize(SZ); root.resize(SZ);\n\t\tpar.resize(SZ);*/\n\t\tseg = new ll[SZ*4], lz = new ll[SZ*4];\n\t\tdisc = new ll[SZ], depth = new ll[SZ];\n\t\tst = new ll[SZ], en = new ll[SZ];\n\t\tmxd = new ll[SZ];\n\t\troot = new int[SZ], par = new int[SZ]{};\n\t\tSEG::SZ = SZ;\n\t}\n\n\tvoid build(int l, int r, int k) {\n\t\tlz[k] = 0;\n\t\tif (l == r) {\n\t\t\tseg[k] = depth[disc[l]];\n\t\t\treturn;\n\t\t}\n\t\tint m = (l+r) / 2;\n\t\tbuild(l,m,k*2);\n\t\tbuild(m+1,r,k*2+1);\n\t\tseg[k] = max(seg[k*2],seg[k*2+1]);\n\t}\n\n\tvoid prop(int l, int r, int k) {\n\t\tif (l != r) {\n\t\t\tlz[k*2] += lz[k];\n\t\t\tlz[k*2+1] += lz[k];\n\t\t}\n\t\tseg[k] += lz[k];\n\t\tlz[k] = 0;\n\t}\n\n\tvoid upd(int l, int r, int k, int a, int b, ll v) {\n\t\tif (lz[k]) prop(l,r,k);\n\t\tif (b < l || r < a) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlz[k] += v;\n\t\t\tprop(l,r,k);\n\t\t\treturn;\n\t\t}\n\t\tint m = (l+r) / 2;\n\t\tupd(l,m,k*2,a,b,v);\n\t\tupd(m+1,r,k*2+1,a,b,v);\n\t\tseg[k] = max(seg[k*2],seg[k*2+1]);\n\t}\n\n\tll qry(int l, int r, int k, int a, int b) {\n\t\tif (lz[k]) prop(l,r,k);\n\t\tif (b < l || r < a) return 0;\n\t\tif (a <= l && r <= b) return seg[k];\n\t\tint m = (l+r) / 2;\n\t\treturn max(qry(l,m,k*2,a,b),qry(m+1,r,k*2+1,a,b));\n\t}\n};\n\ntemplate<int SZ> struct CD {\n\tvi adj[SZ];\n\tint sz[SZ], depth[SZ], par[SZ], U[SZ], V[SZ], m = 0, vis[SZ], tt = 0;\n\tll W[SZ];\n\tSEG seg[SZ];\n\tmultiset<ll> ans;\n\n\tvoid addEdge(int u, int v, ll w = 0) {\n\t\tadj[u].pb(m); adj[v].pb(m);\n\t\tU[m] = u, V[m] = v;\n\t\tW[m++] = w;\n\t}\n\n\tint getSz(int u, int p = -1) {\n\t\tsz[u] = 1;\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (v != p && !vis[v])\n\t\t\t\tsz[u] += getSz(v, u);\n\t\t}\n\t\treturn sz[u];\n\t}\n\n\tint findCen(int u, int n, int p = -1) {\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (v != p && !vis[v] && sz[v] > n/2)\n\t\t\t\treturn findCen(v, n, u);\n\t\t}\n\t\treturn u;\n\t}\n\n\tll euler(int u, ll d, int root, int root2, int p) {\n\t\tll ret = d;\n\t\tint cur = tt;\n\t\tseg[root].depth[cur] = d;\n\t\tseg[root].ind[u] = cur;\n\t\tseg[root].disc[tt] = cur;\n\t\tseg[root].st[cur] = tt++;\n\t\tseg[root].root[cur] = root2;\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (vis[v] || v == p) continue;\n\t\t\tseg[root].par[tt] = cur;\n\t\t\tret = max(ret, euler(v, d+W[i], root, root2, u));\n\t\t}\n\t\tseg[root].en[cur] = tt;\n\t\treturn ret;\n\t}\n\n\tvoid decompose(int u, int p = -1) {\n\t\tint n = getSz(u);\n\t\tu = findCen(u, n);\n\t\tif (~p) depth[u] = depth[p] + 1;\n\t\tpar[u] = p;\n\t\tvis[u] = 1;\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (!vis[v])\n\t\t\t\tdecompose(v, u);\n\t\t}\n\t\tvis[u] = 0;\n\t\tif (n != 1) {\n\t\t\tseg[u].init(n);\n\t\t\ttt = 0;\n\t\t\tseg[u].ind[u] = 0;\n\t\t\tseg[u].disc[0] = 0;\n\t\t\tseg[u].st[0] = tt++;\n\t\t\tfor (int i: adj[u]) {\n\t\t\t\tint v = U[i]^V[i]^u;\n\t\t\t\tif (vis[v]) continue;\n\t\t\t\tll tmp = euler(v, W[i], u, tt, u);\n\t\t\t\tseg[u].mxd[seg[u].ind[v]] = tmp;\n\t\t\t\tseg[u].mx.insert(tmp);\n\t\t\t}\n\t\t\tseg[u].en[0] = tt;\n\t\t\tseg[u].build(0,tt-1,1);\n\t\t\tans.insert(calc(u));\n\t\t}\n\t}\n\n\tll calc(int x) {\n\t\tif (seg[x].mx.empty()) return 0;\n\t\tauto it = --seg[x].mx.end();\n\t\tll ret = *it;\n\t\tif (it != seg[x].mx.begin())\n\t\t\tret += *prev(it);\n\t\treturn ret;\n\t}\n\n\tvoid upd(int d, ll e) {\n\t\tint u = U[d], v = V[d];\n\t\tll del = e - W[d];\n\t\tW[d] = e;\n\t\tif (del == 0) return;\n\t\tint x = u, y = v;\n\t\twhile (depth[x] > depth[y]) x = par[x];\n\t\twhile (depth[x] < depth[y]) y = par[y];\n\t\tfor (; x != -1; x = par[x]) {\n\t\t\tif (seg[x].par[seg[x].ind[u]] == seg[x].ind[v]) swap(u, v);\n\t\t\tint nv = seg[x].ind[v];\n\t\t\tint r = seg[x].root[nv];\n\t\t\tans.erase(ans.find(calc(x)));\n\t\t\tseg[x].mx.erase(seg[x].mx.find(seg[x].mxd[r]));\n\t\t\tseg[x].upd(0,seg[x].SZ-1,1,seg[x].st[nv],seg[x].en[nv]-1,del);\n\t\t\tseg[x].mxd[r] = seg[x].qry(0,seg[x].SZ-1,1,seg[x].st[r],seg[x].en[r]-1);\n\t\t\tseg[x].mx.insert(seg[x].mxd[r]);\n\t\t\tans.insert(calc(x));\n\t\t}\n\t}\n\n\tll qry() {\n\t\treturn *(--ans.end());\n\t}\n};\n\nCD<MAXN> cd;\n\nint main() {\n\tint n, q; ll w; scanf(\"%d %d %I64d\", &n, &q, &w);\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v; ll c; scanf(\"%d %d %I64d\", &u, &v, &c);\n\t\tu--, v--;\n\t\tcd.addEdge(u,v,c);\n\t}\n\tcd.decompose(0);\n\tll ans = 0;\n\twhile (q--) {\n\t\tint d; ll e; scanf(\"%d %I64d\", &d, &e);\n\t\td = ((ll)d + ans) % (n-1);\n\t\te = (e + ans) % w;\n\t\tcd.upd(d, e);\n\t\tans = cd.qry();\n\t\tprintf(\"%I64d\\n\", ans);\n\t}\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57806002": {
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2,fma\")\nusing namespace std;\nusing namespace __gnu_pbds;\n#define ll long long\n#define ff first\n#define ss second\n#define pb push_back\n#define N 100005\nvector<pair<ll, pair<int, int> > > edge;\nvector<int> adj[N];\nll wmax;\nint n;\n\nbool ooo = 0;\n\ninline int get(int v, int i){\n   return edge[i].ss.ss + edge[i].ss.ff - v;\n}\n\n\nint sz[N];\nbool used[N];\n\nint get_size(int v, int p){\n   sz[v] = 1;\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u] || u == p) continue;\n      sz[v] += get_size(u, v);\n   }\n   return sz[v];\n}\n\nint get_center(int v, int p, int s){\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u] || u == p) continue;\n      if(sz[u] > s) return get_center(u, v, s);\n   }\n   return v;\n}\n\nstruct Segtree{\n   int t;\n   vector<long long> seg, laz;\n\n   void resize(int _t){\n      t = _t;\n      seg.resize(t << 2);\n      laz.resize(t << 2);\n   }\n   void push(int id, int l, int r){\n      seg[id] += laz[id];\n      if(l != r){\n         laz[id << 1] += laz[id];\n         laz[id << 1 | 1] += laz[id];\n      }\n      laz[id] = 0;\n   }\n   void update(int id, int l, int r, int L, int R, ll val){\n      if(L <= l && r <= R){\n         laz[id] += val;\n         push(id, l, r);\n         return;\n      }\n      push(id, l, r);\n      if(r < L || l > R) return;\n      int m = (l + r) >> 1;\n      update(id << 1, l, m, L, R, val);\n      update(id << 1 | 1, m + 1, r, L, R, val);\n      seg[id] = max(seg[id << 1], seg[id << 1 | 1]);\n   }\n\n   long long query(int id, int l, int r, int L, int R){\n      push(id, l, r);\n      if(r < L || l > R) return 0;\n      if(L <= l && r <= R) return seg[id];\n      int m = (l + r) >> 1;\n      return max(query(id << 1, l, m, L, R), query(id << 1 | 1, m + 1, r, L, R));\n   }\n} pls;\n\nstruct Tree{\n   int root;\n   multiset<ll> ans;\n   vector<int> e, L, R, pp;\n   vector<vector<int> > adj;\n   gp_hash_table<int, int> comp;\n   int t = 0;\n   Segtree ss;\n\n\n   void dfs(int v, int p){\n      L[v] = t + 1;\n      int ch = 0;\n      for(int& x : adj[v]){\n         if(x == p) continue;\n         if(v == root){\n            pp[x] = x;\n            ans.insert(0);\n         }\n         else pp[x] = pp[v];\n         ch++;\n         dfs(x, v);\n      }\n      if(ch == 0) t++;\n      R[v] = t;\n   }\n\n   void build(int _r){\n      root = _r;\n      for(int& x : e){\n         comp[edge[x].ss.ss] = 0;\n         comp[edge[x].ss.ff] = 0;\n      }\n      int f = 1;\n      for(auto& x : comp)\n         x.ss = f++;\n      pp.resize(f);\n      L.resize(f);\n      R.resize(f);\n      adj.resize(f);\n      for(int& x : e){\n         int v = comp[edge[x].ss.ss];\n         int u = comp[edge[x].ss.ff];\n         adj[v].emplace_back(u);\n         adj[u].emplace_back(v);\n      }\n      root = comp[root];\n      dfs(root, -1);\n      ss.resize(t);\n   }\n\n\n   void updater(int v, int u, ll val){\n      v = comp[v];\n      u = comp[u];\n      int le = max(L[v], L[u]);\n      int ri = min(R[v], R[u]);\n      int q;\n      if(v == root) q = pp[u];\n      else q = pp[v];\n      ans.erase(ans.find(-ss.query(1, 1, t, L[q], R[q])));\n      ss.update(1, 1, t, le, ri, val);\n      ans.insert(-ss.query(1, 1, t, L[q], R[q]));\n   }\n   long long getter(){\n      auto it = ans.begin();\n      if(ans.size() == 1) return *it;\n      return *it + (*(++it));\n   }\n} trees[N];\n\nint d[N];\nint par[N];\nvector<int> ch[N];\nint decomp(int v){\n   v = get_center(v, -1, get_size(v, -1) / 2);\n   used[v] = 1;\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u]) continue;\n      trees[v].e.emplace_back(x);\n      u = decomp(u);\n      par[u] = v;\n      ch[v].emplace_back(u);\n      for(int& x : trees[u].e)\n         trees[v].e.emplace_back(x);\n   }\n   return v;\n}\n\nvoid useless(int v){\n   ++d[v];\n   for(auto& x : ch[v]){\n      d[x] = d[v];\n      useless(x);\n   }\n}\n\nvoid update(int v, int u, ll val){\n   if(d[v] > d[u]) swap(v, u);\n   int ov = v;\n   ll bef;\n   while(v != 0){\n      bef = trees[v].getter();\n      trees[v].updater(ov, u, val);\n      pls.update(1, 1, n, v, v, bef-trees[v].getter());\n      v = par[v];\n   }\n}\n\nlong long get(){\n   char c;\n   ll res = 0;\n   c = _getchar_nolock();\n   while(c > 47 && c < 58){\n      res = res * 10 + c - 48;\n      c = _getchar_nolock();\n   }\n   return res;\n}\n\nvoid put(long long res){\n   if(res < 10){\n      _putchar_nolock(res + '0');\n   } else {\n      put(res / 10);\n      _putchar_nolock(res % 10 + '0');\n   }\n}\n\n\nint main(){\n   int q;\n   n = get();\n   q = get();\n   wmax = get();\n   for(int i = 1; i < n; i++){\n      int v, u;\n      ll w;\n      v = get();\n      u = get();\n      w = get();\n      edge.pb({w, {v, u}});\n      adj[v].emplace_back(i - 1);\n      adj[u].emplace_back(i - 1);\n   }\n\n   pls.resize(n);\n\n   int cen = decomp(1);\n   useless(cen);\n\n   for(int i = 1; i <= n; i++){\n      trees[i].build(i);\n   }\n   for(auto& x : edge){\n      update(x.ss.ff, x.ss.ss, x.ff);\n   }\n   ll last = 0;\n   while(q--){\n      ll ww;\n      int ee;\n      ee = get();\n      ww = get();\n      ee = (ee + last) % (n - 1);\n      ww = (ww + last) % wmax;\n      update(edge[ee].ss.ff, edge[ee].ss.ss, ww - edge[ee].ff);\n      edge[ee].ff = ww;\n      last = pls.query(1, 1, n, 1, n);\n      put(last);\n      _putchar_nolock('\\n');\n   }\n}\n",
    "ext": "cpp"
  },
  "57805534": {
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"avx2\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef cc_hash_table<int,int,hash<int>> hsh;\ntypedef long long ll;\nconst int MAXN = 1e5 + 5;\n\nstruct SEG {\n\tint SZ;\n\tvector<ll> seg, lz, disc, st, en, depth, mxd;\n\tvector<int> root, par;\n\tunordered_map<int,int> ind;\n\tmultiset<ll> mx;\n\n\tvoid init(int SZ) {\n\t\tSZ++;\n\t\tseg.resize(SZ*4); lz.resize(SZ*4);\n\t\tdisc.resize(SZ); depth.resize(SZ);\n\t\tst.resize(SZ); en.resize(SZ);\n\t\tmxd.resize(SZ); root.resize(SZ);\n\t\tpar.resize(SZ);\n\t\tSEG::SZ = --SZ;\n\t}\n\n\tvoid build(int l, int r, int k) {\n\t\tif (l == r) {\n\t\t\tseg[k] = depth[disc[l]];\n\t\t\treturn;\n\t\t}\n\t\tint m = (l+r) / 2;\n\t\tbuild(l,m,k*2);\n\t\tbuild(m+1,r,k*2+1);\n\t\tseg[k] = max(seg[k*2],seg[k*2+1]);\n\t}\n\n\tvoid prop(int l, int r, int k) {\n\t\tif (l != r) {\n\t\t\tlz[k*2] += lz[k];\n\t\t\tlz[k*2+1] += lz[k];\n\t\t}\n\t\tseg[k] += lz[k];\n\t\tlz[k] = 0;\n\t}\n\n\tvoid upd(int l, int r, int k, int a, int b, ll v) {\n\t\tif (lz[k]) prop(l,r,k);\n\t\tif (b < l || r < a) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlz[k] += v;\n\t\t\tprop(l,r,k);\n\t\t\treturn;\n\t\t}\n\t\tint m = (l+r) / 2;\n\t\tupd(l,m,k*2,a,b,v);\n\t\tupd(m+1,r,k*2+1,a,b,v);\n\t\tseg[k] = max(seg[k*2],seg[k*2+1]);\n\t}\n\n\tll qry(int l, int r, int k, int a, int b) {\n\t\tif (lz[k]) prop(l,r,k);\n\t\tif (b < l || r < a) return 0;\n\t\tif (a <= l && r <= b) return seg[k];\n\t\tint m = (l+r) / 2;\n\t\treturn max(qry(l,m,k*2,a,b),qry(m+1,r,k*2+1,a,b));\n\t}\n};\n\ntemplate<int SZ> struct CD {\n\tvi adj[SZ];\n\tint sz[SZ], depth[SZ], par[SZ], U[SZ], V[SZ], m = 0, vis[SZ], tt = 0;\n\tll W[SZ];\n\tSEG seg[SZ];\n\tmultiset<ll> ans;\n\n\tvoid addEdge(int u, int v, ll w = 0) {\n\t\tadj[u].pb(m); adj[v].pb(m);\n\t\tU[m] = u, V[m] = v;\n\t\tW[m++] = w;\n\t}\n\n\tint getSz(int u, int p = -1) {\n\t\tsz[u] = 1;\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (v == p || vis[v]) continue;\n\t\t\tsz[u] += getSz(v, u);\n\t\t}\n\t\treturn sz[u];\n\t}\n\n\tint findCen(int u, int n, int p = -1) {\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (v == p || vis[v]) continue;\n\t\t\tif (sz[v] > n/2) return findCen(v, n, u);\n\t\t}\n\t\treturn u;\n\t}\n\n\tll euler(int u, ll d, int root, int root2, int p) {\n\t\tll ret = d;\n\t\tint cur = tt;\n\t\tseg[root].depth[cur] = d;\n\t\tseg[root].ind[u] = cur;\n\t\tseg[root].disc[tt] = cur;\n\t\tseg[root].st[cur] = tt++;\n\t\tseg[root].root[cur] = root2;\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (vis[v] || v == p) continue;\n\t\t\tseg[root].par[tt] = cur;\n\t\t\tret = max(ret, euler(v, d+W[i], root, root2, u));\n\t\t}\n\t\tseg[root].en[cur] = tt;\n\t\treturn ret;\n\t}\n\n\tvoid decompose(int u, int p = -1) {\n\t\tint n = getSz(u);\n\t\tu = findCen(u, n);\n\t\tif (~p) depth[u] = depth[p] + 1;\n\t\tpar[u] = p;\n\t\tvis[u] = 1;\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (!vis[v])\n\t\t\t\tdecompose(v, u);\n\t\t}\n\t\tvis[u] = 0;\n\t\tif (n != 1) {\n\t\t\tseg[u].init(n);\n\t\t\ttt = 0;\n\t\t\tseg[u].ind[u] = 0;\n\t\t\tseg[u].disc[0] = 0;\n\t\t\tseg[u].st[0] = tt++;\n\t\t\tfor (int i: adj[u]) {\n\t\t\t\tint v = U[i]^V[i]^u;\n\t\t\t\tif (vis[v]) continue;\n\t\t\t\tll tmp = euler(v, W[i], u, tt, u);\n\t\t\t\tseg[u].mxd[seg[u].ind[v]] = tmp;\n\t\t\t\tseg[u].mx.insert(tmp);\n\t\t\t}\n\t\t\tseg[u].en[0] = tt;\n\t\t\tseg[u].build(0,tt-1,1);\n\t\t\tans.insert(calc(u));\n\t\t}\n\t}\n\n\tll calc(int x) {\n\t\tif (seg[x].mx.empty()) return 0;\n\t\tauto it = --seg[x].mx.end();\n\t\tll ret = *it;\n\t\tif (it != seg[x].mx.begin())\n\t\t\tret += *prev(it);\n\t\treturn ret;\n\t}\n\n\tvoid upd(int d, ll e) {\n\t\tint u = U[d], v = V[d];\n\t\tll del = e - W[d];\n\t\tW[d] = e;\n\t\tif (del == 0) return;\n\t\tint x = u, y = v;\n\t\twhile (depth[x] > depth[y]) x = par[x];\n\t\twhile (depth[x] < depth[y]) y = par[y];\n\t\tfor (; x != -1; x = par[x]) {\n\t\t\tif (seg[x].par[seg[x].ind[u]] == seg[x].ind[v]) swap(u, v);\n\t\t\tint nv = seg[x].ind[v];\n\t\t\tint r = seg[x].root[nv];\n\t\t\tans.erase(ans.find(calc(x)));\n\t\t\tseg[x].mx.erase(seg[x].mx.find(seg[x].mxd[r]));\n\t\t\tseg[x].upd(0,seg[x].SZ-1,1,seg[x].st[nv],seg[x].en[nv]-1,del);\n\t\t\tseg[x].mxd[r] = seg[x].qry(0,seg[x].SZ-1,1,seg[x].st[r],seg[x].en[r]-1);\n\t\t\tseg[x].mx.insert(seg[x].mxd[r]);\n\t\t\tans.insert(calc(x));\n\t\t}\n\t}\n\n\tll qry() {\n\t\treturn *(--ans.end());\n\t}\n};\n\nCD<MAXN> cd;\n\nint main() {\n\tint n, q; ll w; scanf(\"%d %d %I64d\", &n, &q, &w);\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v; ll c; scanf(\"%d %d %I64d\", &u, &v, &c);\n\t\tu--, v--;\n\t\tcd.addEdge(u,v,c);\n\t}\n\tcd.decompose(0);\n\tll ans = 0;\n\twhile (q--) {\n\t\tint d; ll e; scanf(\"%d %I64d\", &d, &e);\n\t\td = ((ll)d + ans) % (n-1);\n\t\te = (e + ans) % w;\n\t\tcd.upd(d, e);\n\t\tans = cd.qry();\n\t\tprintf(\"%I64d\\n\", ans);\n\t}\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57805278": {
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"avx2\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef cc_hash_table<int,int,hash<int>> hsh;\ntypedef long long ll;\nconst int MAXN = 1e5 + 5;\n\nstruct SEG {\n\tint SZ;\n\tvector<ll> seg, lz, disc, st, en, depth, mxd;\n\tvector<int> root, par;\n\thsh ind;\n\tmultiset<ll> mx;\n\n\tvoid init(int SZ) {\n\t\tSZ++;\n\t\tseg.resize(SZ*4); lz.resize(SZ*4);\n\t\tdisc.resize(SZ); depth.resize(SZ);\n\t\tst.resize(SZ); en.resize(SZ);\n\t\tmxd.resize(SZ); root.resize(SZ);\n\t\tpar.resize(SZ);\n\t\tSEG::SZ = --SZ;\n\t}\n\n\tvoid build(int l, int r, int k) {\n\t\tif (l == r) {\n\t\t\tseg[k] = depth[disc[l]];\n\t\t\treturn;\n\t\t}\n\t\tint m = (l+r) / 2;\n\t\tbuild(l,m,k*2);\n\t\tbuild(m+1,r,k*2+1);\n\t\tseg[k] = max(seg[k*2],seg[k*2+1]);\n\t}\n\n\tvoid prop(int l, int r, int k) {\n\t\tif (l != r) {\n\t\t\tlz[k*2] += lz[k];\n\t\t\tlz[k*2+1] += lz[k];\n\t\t}\n\t\tseg[k] += lz[k];\n\t\tlz[k] = 0;\n\t}\n\n\tvoid upd(int l, int r, int k, int a, int b, ll v) {\n\t\tif (lz[k]) prop(l,r,k);\n\t\tif (b < l || r < a) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlz[k] += v;\n\t\t\tprop(l,r,k);\n\t\t\treturn;\n\t\t}\n\t\tint m = (l+r) / 2;\n\t\tupd(l,m,k*2,a,b,v);\n\t\tupd(m+1,r,k*2+1,a,b,v);\n\t\tseg[k] = max(seg[k*2],seg[k*2+1]);\n\t}\n\n\tll qry(int l, int r, int k, int a, int b) {\n\t\tif (lz[k]) prop(l,r,k);\n\t\tif (b < l || r < a) return 0;\n\t\tif (a <= l && r <= b) return seg[k];\n\t\tint m = (l+r) / 2;\n\t\treturn max(qry(l,m,k*2,a,b),qry(m+1,r,k*2+1,a,b));\n\t}\n};\n\ntemplate<int SZ> struct CD {\n\tvi adj[SZ];\n\tint sz[SZ], depth[SZ], par[SZ], U[SZ], V[SZ], m = 0, vis[SZ], tt = 0;\n\tll W[SZ];\n\tSEG seg[SZ];\n\tmultiset<ll> ans;\n\n\tvoid addEdge(int u, int v, ll w = 0) {\n\t\tadj[u].pb(m); adj[v].pb(m);\n\t\tU[m] = u, V[m] = v;\n\t\tW[m++] = w;\n\t}\n\n\tint getSz(int u, int p = -1) {\n\t\tsz[u] = 1;\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (v == p || vis[v]) continue;\n\t\t\tsz[u] += getSz(v, u);\n\t\t}\n\t\treturn sz[u];\n\t}\n\n\tint findCen(int u, int n, int p = -1) {\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (v == p || vis[v]) continue;\n\t\t\tif (sz[v] > n/2) return findCen(v, n, u);\n\t\t}\n\t\treturn u;\n\t}\n\n\tll euler(int u, ll d, int root, int root2, int p = -1) {\n\t\tll ret = d;\n\t\tint cur = tt;\n\t\tseg[root].depth[cur] = d;\n\t\tseg[root].ind[u] = cur;\n\t\tseg[root].disc[tt] = cur;\n\t\tseg[root].st[cur] = tt++;\n\t\tseg[root].root[cur] = seg[root].ind[root2];\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (vis[v] || v == p) continue;\n\t\t\tret = max(ret, euler(v, d+W[i], root, root2, u));\n\t\t\tseg[root].par[seg[root].ind[v]] = cur;\n\t\t}\n\t\tseg[root].en[cur] = tt;\n\t\treturn ret;\n\t}\n\n\tvoid decompose(int u, int p = -1) {\n\t\tint n = getSz(u);\n\t\tu = findCen(u, n);\n\t\tif (~p) depth[u] = depth[p] + 1;\n\t\tpar[u] = p;\n\t\tvis[u] = 1;\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (!vis[v])\n\t\t\t\tdecompose(v, u);\n\t\t}\n\t\tvis[u] = 0;\n\t\tif (n != 1) {\n\t\t\tseg[u].init(n);\n\t\t\ttt = 0;\n\t\t\tseg[u].ind[u] = 0;\n\t\t\tseg[u].disc[0] = 0;\n\t\t\tseg[u].st[0] = tt++;\n\t\t\tfor (int i: adj[u]) {\n\t\t\t\tint v = U[i]^V[i]^u;\n\t\t\t\tif (vis[v]) continue;\n\t\t\t\tll tmp = euler(v, W[i], u, v, u);\n\t\t\t\tseg[u].mxd[seg[u].ind[v]] = tmp;\n\t\t\t\tseg[u].mx.insert(tmp);\n\t\t\t}\n\t\t\tseg[u].en[0] = tt;\n\t\t\tseg[u].build(0,tt-1,1);\n\t\t}\n\t\tans.insert(calc(u));\n\t}\n\n\tll calc(int x) {\n\t\tif (seg[x].mx.empty()) return 0;\n\t\tauto it = --seg[x].mx.end();\n\t\tll ret = *it;\n\t\tif (it != seg[x].mx.begin())\n\t\t\tret += *prev(it);\n\t\treturn ret;\n\t}\n\n\tvoid upd(int d, ll e) {\n\t\tint u = U[d], v = V[d];\n\t\tll del = e - W[d];\n\t\tW[d] = e;\n\t\tif (del == 0) return;\n\t\tint x = u, y = v;\n\t\twhile (depth[x] > depth[y]) x = par[x];\n\t\twhile (depth[x] < depth[y]) y = par[y];\n\t\tfor (; x != -1; x = par[x]) {\n\t\t\tif (seg[x].par[seg[x].ind[u]] == seg[x].ind[v]) swap(u, v);\n\t\t\tint nv = seg[x].ind[v];\n\t\t\tint r = seg[x].root[nv];\n\t\t\tans.erase(ans.find(calc(x)));\n\t\t\tseg[x].mx.erase(seg[x].mx.find(seg[x].mxd[r]));\n\t\t\tseg[x].upd(0,seg[x].SZ-1,1,seg[x].st[nv],seg[x].en[nv]-1,del);\n\t\t\tseg[x].mxd[r] = seg[x].qry(0,seg[x].SZ-1,1,seg[x].st[r],seg[x].en[r]-1);\n\t\t\tseg[x].mx.insert(seg[x].mxd[r]);\n\t\t\tans.insert(calc(x));\n\t\t}\n\t}\n\n\tll qry() {\n\t\treturn *(--ans.end());\n\t}\n};\n\nCD<MAXN> cd;\n\nint main() {\n\tint n, q; ll w; scanf(\"%d %d %I64d\", &n, &q, &w);\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v; ll c; scanf(\"%d %d %I64d\", &u, &v, &c);\n\t\tu--, v--;\n\t\tcd.addEdge(u,v,c);\n\t}\n\tcd.decompose(0);\n\tll ans = 0;\n\twhile (q--) {\n\t\tint d; ll e; scanf(\"%d %I64d\", &d, &e);\n\t\td = ((ll)d + ans) % (n-1);\n\t\te = (e + ans) % w;\n\t\tcd.upd(d, e);\n\t\tans = cd.qry();\n\t\tprintf(\"%I64d\\n\", ans);\n\t}\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57804600": {
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2,fma\")\nusing namespace std;\n#define ll long long\n#define ff first\n#define ss second\n#define pb push_back\n#define N 100005\nvector<pair<ll, pair<int, int> > > edge;\nvector<int> adj[N];\nll wmax;\nint n;\n\nbool ooo = 0;\n\ninline int get(int v, int i){\n   return edge[i].ss.ss + edge[i].ss.ff - v;\n}\n\n\nint sz[N];\nbool used[N];\n\nint get_size(int v, int p){\n   sz[v] = 1;\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u] || u == p) continue;\n      sz[v] += get_size(u, v);\n   }\n   return sz[v];\n}\n\nint get_center(int v, int p, int s){\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u] || u == p) continue;\n      if(sz[u] > s) return get_center(u, v, s);\n   }\n   return v;\n}\n\nstruct Segtree{\n   int t;\n   vector<long long> seg, laz;\n\n   void resize(int _t){\n      t = _t;\n      seg.resize(t << 2);\n      laz.resize(t << 2);\n   }\n   void push(int id, int l, int r){\n      seg[id] += laz[id];\n      if(l != r){\n         laz[id << 1] += laz[id];\n         laz[id << 1 | 1] += laz[id];\n      }\n      laz[id] = 0;\n   }\n   void update(int id, int l, int r, int L, int R, ll val){\n      if(L <= l && r <= R){\n         laz[id] += val;\n         push(id, l, r);\n         return;\n      }\n      push(id, l, r);\n      if(r < L || l > R) return;\n      int m = (l + r) >> 1;\n      update(id << 1, l, m, L, R, val);\n      update(id << 1 | 1, m + 1, r, L, R, val);\n      seg[id] = max(seg[id << 1], seg[id << 1 | 1]);\n   }\n\n   long long query(int id, int l, int r, int L, int R){\n      push(id, l, r);\n      if(r < L || l > R) return 0;\n      if(L <= l && r <= R) return seg[id];\n      int m = (l + r) >> 1;\n      return max(query(id << 1, l, m, L, R), query(id << 1 | 1, m + 1, r, L, R));\n   }\n} pls;\n\nstruct Tree{\n   int root;\n   multiset<ll> ans;\n   vector<int> e, L, R, pp;\n   vector<vector<int> > adj;\n   unordered_map<int, int> comp;\n   int t = 0;\n   Segtree ss;\n\n\n   void dfs(int v, int p){\n      L[v] = t + 1;\n      int ch = 0;\n      for(int& x : adj[v]){\n         if(x == p) continue;\n         if(v == root){\n            pp[x] = x;\n            ans.insert(0);\n         }\n         else pp[x] = pp[v];\n         ch++;\n         dfs(x, v);\n      }\n      if(ch == 0) t++;\n      R[v] = t;\n   }\n\n   void build(int _r){\n      root = _r;\n      for(int& x : e){\n         comp[edge[x].ss.ss] = 0;\n         comp[edge[x].ss.ff] = 0;\n      }\n      int f = 1;\n      for(auto& x : comp)\n         x.ss = f++;\n      pp.resize(f);\n      L.resize(f);\n      R.resize(f);\n      adj.resize(f);\n      for(int& x : e){\n         int v = comp[edge[x].ss.ss];\n         int u = comp[edge[x].ss.ff];\n         adj[v].emplace_back(u);\n         adj[u].emplace_back(v);\n      }\n      root = comp[root];\n      dfs(root, -1);\n      ss.resize(t);\n   }\n\n\n   void updater(int v, int u, ll val){\n      v = comp[v];\n      u = comp[u];\n      int le = max(L[v], L[u]);\n      int ri = min(R[v], R[u]);\n      int q;\n      if(v == root) q = pp[u];\n      else q = pp[v];\n      ans.erase(ans.find(-ss.query(1, 1, t, L[q], R[q])));\n      ss.update(1, 1, t, le, ri, val);\n      ans.insert(-ss.query(1, 1, t, L[q], R[q]));\n   }\n   long long getter(){\n      auto it = ans.begin();\n      if(ans.size() == 1) return *it;\n      return *it + (*(++it));\n   }\n} tree[N];\n\nint d[N];\nint par[N];\nvector<int> ch[N];\nint decomp(int v){\n   v = get_center(v, -1, get_size(v, -1) / 2);\n   used[v] = 1;\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u]) continue;\n      tree[v].e.emplace_back(x);\n      u = decomp(u);\n      par[u] = v;\n      ch[v].emplace_back(u);\n      for(int& x : tree[u].e)\n         tree[v].e.emplace_back(x);\n   }\n   return v;\n}\n\nvoid useless(int v){\n   ++d[v];\n   for(auto& x : ch[v]){\n      d[x] = d[v];\n      useless(x);\n   }\n}\n\nvoid update(int v, int u, ll val){\n   if(d[v] > d[u]) swap(v, u);\n   int ov = v;\n   ll bef;\n   while(v != 0){\n      bef = tree[v].getter();\n      tree[v].updater(ov, u, val);\n      pls.update(1, 1, n, v, v, bef-tree[v].getter());\n      v = par[v];\n   }\n}\n\nlong long get(){\n   char c;\n   ll res = 0;\n   c = _getchar_nolock();\n   while(c > 47 && c < 58){\n      res = res * 10 + c - 48;\n      c = _getchar_nolock();\n   }\n   return res;\n}\n\nvoid put(long long res){\n   if(res < 10){\n      _putchar_nolock(res + '0');\n   } else {\n      put(res / 10);\n      _putchar_nolock(res % 10 + '0');\n   }\n}\n\n\nint main(){\n   int q;\n   n = get();\n   q = get();\n   wmax = get();\n   for(int i = 1; i < n; i++){\n      int v, u;\n      ll w;\n      v = get();\n      u = get();\n      w = get();\n      edge.pb({w, {v, u}});\n      adj[v].emplace_back(i - 1);\n      adj[u].emplace_back(i - 1);\n   }\n\n   pls.resize(n);\n\n   int cen = decomp(1);\n   useless(cen);\n\n   for(int i = 1; i <= n; i++){\n      tree[i].build(i);\n   }\n   for(auto& x : edge){\n      update(x.ss.ff, x.ss.ss, x.ff);\n   }\n   ll last = 0;\n   while(q--){\n      ll ww;\n      int ee;\n      ee = get();\n      ww = get();\n      ee = (ee + last) % (n - 1);\n      ww = (ww + last) % wmax;\n      update(edge[ee].ss.ff, edge[ee].ss.ss, ww - edge[ee].ff);\n      edge[ee].ff = ww;\n      last = pls.query(1, 1, n, 1, n);\n      put(last);\n      _putchar_nolock('\\n');\n   }\n}\n",
    "ext": "cpp"
  },
  "57804510": {
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"avx2\")\n#include <bits/stdc++.h>\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 1e5 + 5;\n\nstruct SEG {\n\tint SZ;\n\tvector<ll> seg, lz, disc, st, en, depth, mxd;\n\tvector<int> root, par;\n\tmap<int,int> ind;\n\tmultiset<ll> mx;\n\n\tvoid init(int SZ) {\n\t\tSZ++;\n\t\tseg.resize(SZ*4);\n\t\tlz.resize(SZ*4);\n\t\tdisc.resize(SZ);\n\t\tst.resize(SZ);\n\t\ten.resize(SZ);\n\t\tdepth.resize(SZ);\n\t\tmxd.resize(SZ);\n\t\troot.resize(SZ);\n\t\tpar.resize(SZ);\n\t\tSEG::SZ = --SZ;\n\t}\n\n\tvoid build(int l, int r, int k) {\n\t\tif (l == r) {\n\t\t\tseg[k] = depth[disc[l]];\n\t\t\treturn;\n\t\t}\n\t\tint m = (l+r) / 2;\n\t\tbuild(l,m,k*2);\n\t\tbuild(m+1,r,k*2+1);\n\t\tseg[k] = max(seg[k*2],seg[k*2+1]);\n\t}\n\n\tvoid prop(int l, int r, int k) {\n\t\tif (l != r) {\n\t\t\tlz[k*2] += lz[k];\n\t\t\tlz[k*2+1] += lz[k];\n\t\t}\n\t\tseg[k] += lz[k];\n\t\tlz[k] = 0;\n\t}\n\n\tvoid upd(int l, int r, int k, int a, int b, ll v) {\n\t\tif (lz[k]) prop(l,r,k);\n\t\tif (b < l || r < a) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlz[k] += v;\n\t\t\tprop(l,r,k);\n\t\t\treturn;\n\t\t}\n\t\tint m = (l+r) / 2;\n\t\tupd(l,m,k*2,a,b,v);\n\t\tupd(m+1,r,k*2+1,a,b,v);\n\t\tseg[k] = max(seg[k*2],seg[k*2+1]);\n\t}\n\n\tll qry(int l, int r, int k, int a, int b) {\n\t\tif (lz[k]) prop(l,r,k);\n\t\tif (b < l || r < a) return 0;\n\t\tif (a <= l && r <= b) return seg[k];\n\t\tint m = (l+r) / 2;\n\t\tll ret = max(qry(l,m,k*2,a,b),qry(m+1,r,k*2+1,a,b));\n\t\tseg[k] = max(seg[k*2], seg[k*2+1]);\n\t\treturn ret;\n\t}\n};\n\ntemplate<int SZ> struct CD {\n\tvi adj[SZ];\n\tint sz[SZ], depth[SZ], par[SZ], U[SZ], V[SZ], m = 0, vis[SZ], tt = 0;\n\tll W[SZ];\n\tSEG seg[SZ];\n\tmultiset<ll> ans;\n\n\tvoid addEdge(int u, int v, ll w = 0) {\n\t\tadj[u].pb(m); adj[v].pb(m);\n\t\tU[m] = u, V[m] = v;\n\t\tW[m++] = w;\n\t}\n\n\tint getSz(int u, int p = -1) {\n\t\tsz[u] = 1;\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (v == p || vis[v]) continue;\n\t\t\tsz[u] += getSz(v, u);\n\t\t}\n\t\treturn sz[u];\n\t}\n\n\tint findCen(int u, int n, int p = -1) {\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (v == p || vis[v]) continue;\n\t\t\tif (sz[v] > n/2) return findCen(v, n, u);\n\t\t}\n\t\treturn u;\n\t}\n\n\tll euler(int u, ll d, int root, int root2, int p = -1) {\n\t\tll ret = d;\n\t\tint cur = tt;\n\t\tseg[root].depth[cur] = d;\n\t\tseg[root].ind[u] = cur;\n\t\tseg[root].disc[tt] = cur;\n\t\tseg[root].st[cur] = tt++;\n\t\tseg[root].root[cur] = seg[root].ind[root2];\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (vis[v] || v == p) continue;\n\t\t\tret = max(ret, euler(v, d+W[i], root, root2, u));\n\t\t\tseg[root].par[seg[root].ind[v]] = cur;\n\t\t}\n\t\tseg[root].en[cur] = tt;\n\t\treturn ret;\n\t}\n\n\tvoid decompose(int u, int p = -1) {\n\t\tint n = getSz(u);\n\t\tu = findCen(u, n);\n\t\tif (~p) depth[u] = depth[p] + 1;\n\t\tpar[u] = p;\n\t\tvis[u] = 1;\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (!vis[v])\n\t\t\t\tdecompose(v, u);\n\t\t}\n\t\tvis[u] = 0;\n\t\tif (n != 1) {\n\t\t\tseg[u].init(n);\n\t\t\ttt = 0;\n\t\t\tseg[u].ind[u] = 0;\n\t\t\tseg[u].disc[0] = 0;\n\t\t\tseg[u].st[0] = tt++;\n\t\t\tfor (int i: adj[u]) {\n\t\t\t\tint v = U[i]^V[i]^u;\n\t\t\t\tif (vis[v]) continue;\n\t\t\t\tll tmp = euler(v, W[i], u, v, u);\n\t\t\t\tseg[u].mxd[seg[u].ind[v]] = tmp;\n\t\t\t\tseg[u].mx.insert(tmp);\n\t\t\t}\n\t\t\tseg[u].en[0] = tt;\n\t\t\tseg[u].build(0,tt-1,1);\n\t\t}\n\t\tans.insert(calc(u));\n\t}\n\n\tll calc(int x) {\n\t\tif (seg[x].mx.empty()) return 0;\n\t\tauto it = --seg[x].mx.end();\n\t\tll ret = *it;\n\t\tif (it != seg[x].mx.begin())\n\t\t\tret += *prev(it);\n\t\treturn ret;\n\t}\n\n\tvoid upd(int d, ll e) {\n\t\tint u = U[d], v = V[d];\n\t\tll del = e - W[d];\n\t\tW[d] = e;\n\t\tif (del == 0) return;\n\t\tint x = u, y = v;\n\t\twhile (depth[x] > depth[y]) x = par[x];\n\t\twhile (depth[x] < depth[y]) y = par[y];\n\t\tfor (; x != -1; x = par[x]) {\n\t\t\tif (seg[x].par[seg[x].ind[u]] == seg[x].ind[v]) swap(u, v);\n\t\t\tint nv = seg[x].ind[v];\n\t\t\tint r = seg[x].root[nv];\n\t\t\tans.erase(ans.find(calc(x)));\n\t\t\tseg[x].mx.erase(seg[x].mx.find(seg[x].mxd[r]));\n\t\t\tseg[x].upd(0,seg[x].SZ-1,1,seg[x].st[nv],seg[x].en[nv]-1,del);\n\t\t\tseg[x].mxd[r] = seg[x].qry(0,seg[x].SZ-1,1,seg[x].st[r],seg[x].en[r]-1);\n\t\t\tseg[x].mx.insert(seg[x].mxd[r]);\n\t\t\tans.insert(calc(x));\n\t\t}\n\t}\n\n\tll qry() {\n\t\treturn *(--ans.end());\n\t}\n};\n\nCD<MAXN> cd;\n\nint main() {\n\tint n, q; ll w; scanf(\"%d %d %I64d\", &n, &q, &w);\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v; ll c; scanf(\"%d %d %I64d\", &u, &v, &c);\n\t\tu--, v--;\n\t\tcd.addEdge(u,v,c);\n\t}\n\tcd.decompose(0);\n\tll ans = 0;\n\twhile (q--) {\n\t\tint d; ll e; scanf(\"%d %I64d\", &d, &e);\n\t\td = ((ll)d + ans) % (n-1);\n\t\te = (e + ans) % w;\n\t\tcd.upd(d, e);\n\t\tans = cd.qry();\n\t\tprintf(\"%I64d\\n\", ans);\n\t}\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57804324": {
    "code": "#include <bits/stdc++.h>\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 1e5 + 5;\n\nstruct SEG {\n\tint SZ;\n\tvector<ll> seg, lz, disc, st, en, depth, mxd;\n\tvector<int> root, par;\n\tmap<int,int> ind;\n\tmultiset<ll> mx;\n\n\tvoid init(int SZ) {\n\t\tSZ++;\n\t\tseg.resize(SZ*4);\n\t\tlz.resize(SZ*4);\n\t\tdisc.resize(SZ);\n\t\tst.resize(SZ);\n\t\ten.resize(SZ);\n\t\tdepth.resize(SZ);\n\t\tmxd.resize(SZ);\n\t\troot.resize(SZ);\n\t\tpar.resize(SZ);\n\t\tSEG::SZ = --SZ;\n\t}\n\n\tvoid build(int l, int r, int k) {\n\t\tif (l == r) {\n\t\t\tseg[k] = depth[disc[l]];\n\t\t\treturn;\n\t\t}\n\t\tint m = (l+r) / 2;\n\t\tbuild(l,m,k*2);\n\t\tbuild(m+1,r,k*2+1);\n\t\tseg[k] = max(seg[k*2],seg[k*2+1]);\n\t}\n\n\tvoid prop(int l, int r, int k) {\n\t\tif (l != r) {\n\t\t\tlz[k*2] += lz[k];\n\t\t\tlz[k*2+1] += lz[k];\n\t\t}\n\t\tseg[k] += lz[k];\n\t\tlz[k] = 0;\n\t}\n\n\tvoid upd(int l, int r, int k, int a, int b, ll v) {\n\t\tif (lz[k]) prop(l,r,k);\n\t\tif (b < l || r < a) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlz[k] += v;\n\t\t\tprop(l,r,k);\n\t\t\treturn;\n\t\t}\n\t\tint m = (l+r) / 2;\n\t\tupd(l,m,k*2,a,b,v);\n\t\tupd(m+1,r,k*2+1,a,b,v);\n\t\tseg[k] = max(seg[k*2],seg[k*2+1]);\n\t}\n\n\tll qry(int l, int r, int k, int a, int b) {\n\t\tif (lz[k]) prop(l,r,k);\n\t\tif (b < l || r < a) return 0;\n\t\tif (a <= l && r <= b) return seg[k];\n\t\tint m = (l+r) / 2;\n\t\tll ret = max(qry(l,m,k*2,a,b),qry(m+1,r,k*2+1,a,b));\n\t\tseg[k] = max(seg[k*2], seg[k*2+1]);\n\t\treturn ret;\n\t}\n};\n\ntemplate<int SZ> struct CD {\n\tvi adj[SZ];\n\tint sz[SZ], depth[SZ], par[SZ], U[SZ], V[SZ], m = 0, vis[SZ], tt = 0;\n\tll W[SZ];\n\tSEG seg[SZ];\n\tmultiset<ll> ans;\n\n\tvoid addEdge(int u, int v, ll w = 0) {\n\t\tadj[u].pb(m); adj[v].pb(m);\n\t\tU[m] = u, V[m] = v;\n\t\tW[m++] = w;\n\t}\n\n\tint getSz(int u, int p = -1) {\n\t\tsz[u] = 1;\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (v == p || vis[v]) continue;\n\t\t\tsz[u] += getSz(v, u);\n\t\t}\n\t\treturn sz[u];\n\t}\n\n\tint findCen(int u, int n, int p = -1) {\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (v == p || vis[v]) continue;\n\t\t\tif (sz[v] > n/2) return findCen(v, n, u);\n\t\t}\n\t\treturn u;\n\t}\n\n\tll euler(int u, ll d, int root, int root2, int p = -1) {\n\t\tll ret = d;\n\t\tint cur = tt;\n\t\tseg[root].depth[cur] = d;\n\t\tseg[root].ind[u] = cur;\n\t\tseg[root].disc[tt] = cur;\n\t\tseg[root].st[cur] = tt++;\n\t\tseg[root].root[cur] = seg[root].ind[root2];\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (vis[v] || v == p) continue;\n\t\t\tret = max(ret, euler(v, d+W[i], root, root2, u));\n\t\t\tseg[root].par[seg[root].ind[v]] = cur;\n\t\t}\n\t\tseg[root].en[cur] = tt;\n\t\treturn ret;\n\t}\n\n\tvoid decompose(int u, int p = -1) {\n\t\tint n = getSz(u);\n\t\tu = findCen(u, n);\n\t\tif (~p) depth[u] = depth[p] + 1;\n\t\tpar[u] = p;\n\t\tvis[u] = 1;\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (!vis[v])\n\t\t\t\tdecompose(v, u);\n\t\t}\n\t\tvis[u] = 0;\n\t\tseg[u].init(n);\n\t\ttt = 0;\n\t\tseg[u].ind[u] = 0;\n\t\tseg[u].disc[0] = 0;\n\t\tseg[u].st[0] = tt++;\n\t\tfor (int i: adj[u]) {\n\t\t\tint v = U[i]^V[i]^u;\n\t\t\tif (vis[v]) continue;\n\t\t\tll tmp = euler(v, W[i], u, v, u);\n\t\t\tseg[u].mxd[seg[u].ind[v]] = tmp;\n\t\t\tseg[u].mx.insert(tmp);\n\t\t}\n\t\tseg[u].en[0] = tt;\n\t\tseg[u].build(0,tt-1,1);\n\t\tans.insert(calc(u));\n\t}\n\n\tll calc(int x) {\n\t\tif (seg[x].mx.empty()) return 0;\n\t\tauto it = --seg[x].mx.end();\n\t\tll ret = *it;\n\t\tif (it != seg[x].mx.begin())\n\t\t\tret += *prev(it);\n\t\treturn ret;\n\t}\n\n\tvoid upd(int d, ll e) {\n\t\tint u = U[d], v = V[d];\n\t\tll del = e - W[d];\n\t\tW[d] = e;\n\t\tif (del == 0) return;\n\t\tint x = u, y = v;\n\t\twhile (depth[x] > depth[y]) x = par[x];\n\t\twhile (depth[x] < depth[y]) y = par[y];\n\t\tfor (; x != -1; x = par[x]) {\n\t\t\tif (seg[x].par[seg[x].ind[u]] == seg[x].ind[v]) swap(u, v);\n\t\t\tint nv = seg[x].ind[v];\n\t\t\tint r = seg[x].root[nv];\n\t\t\tans.erase(ans.find(calc(x)));\n\t\t\tseg[x].mx.erase(seg[x].mx.find(seg[x].mxd[r]));\n\t\t\tseg[x].upd(0,seg[x].SZ-1,1,seg[x].st[nv],seg[x].en[nv]-1,del);\n\t\t\tseg[x].mxd[r] = seg[x].qry(0,seg[x].SZ-1,1,seg[x].st[r],seg[x].en[r]-1);\n\t\t\tseg[x].mx.insert(seg[x].mxd[r]);\n\t\t\tans.insert(calc(x));\n\t\t}\n\t}\n\n\tll qry() {\n\t\treturn *(--ans.end());\n\t}\n};\n\nCD<MAXN> cd;\n\nint main() {\n\tint n, q; ll w; scanf(\"%d %d %I64d\", &n, &q, &w);\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v; ll c; scanf(\"%d %d %I64d\", &u, &v, &c);\n\t\tu--, v--;\n\t\tcd.addEdge(u,v,c);\n\t}\n\tcd.decompose(0);\n\tll ans = 0;\n\twhile (q--) {\n\t\tint d; ll e; scanf(\"%d %I64d\", &d, &e);\n\t\td = ((ll)d + ans) % (n-1);\n\t\te = (e + ans) % w;\n\t\tcd.upd(d, e);\n\t\tans = cd.qry();\n\t\tprintf(\"%I64d\\n\", ans);\n\t}\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57803546": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef pair<lint, int> pli;\n\n#define fi first\n#define se second\n\nconst int MAXN = 100005;\n\nstruct NOD {\n\tlint num[8], lazy;\n\n\tvoid addlazy(lint z) {\n\t\tnum[1] += z;\n\t\tnum[2] -= 2 * z;\n\t\tnum[3] -= z;\n\t\tnum[4] += z;\n\t\tnum[5] += 2 * z;\n\t\tnum[6] -= z;\n\t\tlazy += z;\n\t}\n\n\tNOD() {\n\t\tfor(int i = 1; i < 8; i++) num[i] = 0;\n\t\tlazy = 0;\n\t}\n} seg[8 * MAXN];\n\nNOD mergenod(NOD a, NOD b, lint l = 0) {\n\tNOD r;\n\tr.num[1] = max(a.num[1], b.num[1]);\n\tr.num[2] = max(a.num[2], b.num[2]);\n\tr.num[3] = max({a.num[3], b.num[3], a.num[2] + b.num[1]});\n\tr.num[4] = max(a.num[4], b.num[4]);\n\tr.num[5] = max({a.num[5], b.num[5], a.num[4] + b.num[1]});\n\tr.num[6] = max({a.num[6], b.num[6], a.num[4] + b.num[2]});\n\tr.num[7] = max({a.num[7], a.num[6] + b.num[1], a.num[4] + b.num[3], b.num[7]});\n\tr.lazy = 0;\n\tr.addlazy(l);\n\treturn r;\n}\n\nint A[MAXN], B[MAXN], D[MAXN];\nlint C[MAXN], E[MAXN];\nvector<pli> ed[MAXN];\nint et[2 * MAXN], etl[MAXN], etr[MAXN], etn;\nlint dep[MAXN];\n\nvoid dfs(int x) {\n\tet[++etn] = x;\n\tetl[x] = etr[x] = etn;\n\tfor(auto a : ed[x]) if(etl[a.se] == 0) {\n\t\tdep[a.se] = dep[x] + a.fi;\n\t\tdfs(a.se);\n\t\tet[++etn] = x;\n\t\tetr[x] = etn;\n\t}\n}\n\nvoid mkseg(int idx, int l, int r) {\n\tif(l == r) seg[idx].addlazy(dep[et[l]]);\n\telse {\n\t\tint m = (l + r) / 2;\n\t\tmkseg(idx * 2, l, m);\n\t\tmkseg(idx * 2 + 1, m + 1, r);\n\t\tseg[idx] = mergenod(seg[idx * 2], seg[idx * 2 + 1]);\n\t}\n}\n\nvoid updseg(int idx, int l, int r, int x, int y, lint z) {\n\tif(x <= l && r <= y) seg[idx].addlazy(z);\n\telse if(l <= y && x <= r) {\n\t\tint m = (l + r) / 2;\n\t\tupdseg(idx * 2, l, m, x, y, z);\n\t\tupdseg(idx * 2 + 1, m + 1, r, x, y, z);\n\t\tseg[idx] = mergenod(seg[idx * 2], seg[idx * 2 + 1], seg[idx].lazy);\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(0); cin.tie(0);\n\tint N, Q;\n\tlint W;\n\n\tcin >> N >> Q >> W;\n\tfor(int i = 0; i < N - 1; i++) cin >> A[i] >> B[i] >> C[i];\n\tfor(int i = 0; i < Q; i++) cin >> D[i] >> E[i];\n\n\tfor(int i = 0; i < N - 1; i++) {\n\t\ted[A[i]].push_back(make_pair(C[i], B[i]));\n\t\ted[B[i]].push_back(make_pair(C[i], A[i]));\n\t}\n\n\tdfs(1);\n\t//for(int i = 1; i <= etn; i++) printf(\"%d \", et[i]);\n\t//printf(\"\\n\");\n\t//for(int i = 1; i <= N; i++) printf(\"%lld \", dep[i]);\n\t//printf(\"\\n\");\n\t//for(int i = 1; i <= N; i++) printf(\"[%d %d]\", etl[i], etr[i]);\n\tmkseg(1, 1, etn);\n\tfor(int i = 0; i < N - 1; i++) if(etl[A[i]] > etl[B[i]]) swap(A[i], B[i]);\n\t//printf(\"%lld\\n\", seg[1].num[7]);\n\n\tlint last = 0;\n\tfor(int i = 0; i < Q; i++) {\n\t\tD[i] = (D[i] + last) % (N - 1);\n\t\tE[i] = (E[i] + last) % W;\n\t\t//printf(\"d = %d, e = %lld\\n\", D[i], E[i]);\n\t\t//printf(\"(%d)\", B[D[i]]);\n\t\tupdseg(1, 1, etn, etl[B[D[i]]], etr[B[D[i]]], E[i] - C[D[i]]);\n\t\tC[D[i]] = E[i];\n\t\tlast = seg[1].num[7];\n\t\tcout << last << \"\\n\";\n\t}\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57803267": {
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2,fma\")\nusing namespace std;\n#define ll long long\n#define ff first\n#define ss second\n#define pb push_back\n#define N 100005\nvector<pair<ll, pair<int, int> > > edge;\nvector<int> adj[N];\nll wmax;\nint n;\n\nbool ooo = 0;\n\ninline int get(int v, int i){\n   return edge[i].ss.ss + edge[i].ss.ff - v;\n}\n\n\nint sz[N];\nbool used[N];\n\nint get_size(int v, int p){\n   sz[v] = 1;\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u] || u == p) continue;\n      sz[v] += get_size(u, v);\n   }\n   return sz[v];\n}\n\nint get_center(int v, int p, int s){\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u] || u == p) continue;\n      if(sz[u] > s) return get_center(u, v, s);\n   }\n   return v;\n}\n\nstruct Segtree{\n   int t;\n   vector<long long> seg, laz;\n\n   void resize(int _t){\n      t = _t;\n      seg.resize(t << 2);\n      laz.resize(t << 2);\n   }\n   void push(int id, int l, int r){\n      seg[id] += laz[id];\n      if(l != r){\n         laz[id << 1] += laz[id];\n         laz[id << 1 | 1] += laz[id];\n      }\n      laz[id] = 0;\n   }\n   void update(int id, int l, int r, int L, int R, ll val){\n      if(L <= l && r <= R){\n         laz[id] += val;\n         push(id, l, r);\n         return;\n      }\n      push(id, l, r);\n      if(r < L || l > R) return;\n      int m = (l + r) >> 1;\n      update(id << 1, l, m, L, R, val);\n      update(id << 1 | 1, m + 1, r, L, R, val);\n      seg[id] = max(seg[id << 1], seg[id << 1 | 1]);\n   }\n\n   long long query(int id, int l, int r, int L, int R){\n      push(id, l, r);\n      if(r < L || l > R) return 0;\n      if(L <= l && r <= R) return seg[id];\n      int m = (l + r) >> 1;\n      return max(query(id << 1, l, m, L, R), query(id << 1 | 1, m + 1, r, L, R));\n   }\n} pls;\n\nstruct Tree{\n   int root;\n   multiset<ll> ans;\n   vector<int> e, L, R, pp;\n   vector<vector<int> > adj;\n   unordered_map<int, int> comp;\n   int t = 0;\n   Segtree ss;\n\n\n   void dfs(int v, int p){\n      L[v] = t + 1;\n      int ch = 0;\n      for(int& x : adj[v]){\n         if(x == p) continue;\n         if(v == root){\n            pp[x] = x;\n            ans.insert(0);\n         }\n         else pp[x] = pp[v];\n         ch++;\n         dfs(x, v);\n      }\n      if(ch == 0) t++;\n      R[v] = t;\n   }\n\n   void build(int _r){\n      root = _r;\n      for(int& x : e){\n         comp[edge[x].ss.ss] = 0;\n         comp[edge[x].ss.ff] = 0;\n      }\n      int f = 1;\n      for(auto& x : comp)\n         x.ss = f++;\n      pp.resize(f);\n      L.resize(f);\n      R.resize(f);\n      adj.resize(f);\n      for(int& x : e){\n         int v = comp[edge[x].ss.ss];\n         int u = comp[edge[x].ss.ff];\n         adj[v].push_back(u);\n         adj[u].push_back(v);\n      }\n      root = comp[root];\n      dfs(root, -1);\n      ss.resize(t);\n   }\n\n\n   void updater(int v, int u, ll val){\n      v = comp[v];\n      u = comp[u];\n      int le = max(L[v], L[u]);\n      int ri = min(R[v], R[u]);\n      int q;\n      if(v == root) q = pp[u];\n      else q = pp[v];\n      ans.erase(ans.find(-ss.query(1, 1, t, L[q], R[q])));\n      ss.update(1, 1, t, le, ri, val);\n      ans.insert(-ss.query(1, 1, t, L[q], R[q]));\n   }\n   long long getter(){\n      auto it = ans.begin();\n      if(ans.size() == 1) return *it;\n      return *it + (*(++it));\n   }\n} tree[N];\n\nint d[N];\nint par[N];\nvector<int> ch[N];\nint decomp(int v){\n   v = get_center(v, -1, get_size(v, -1) / 2);\n   used[v] = 1;\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u]) continue;\n      tree[v].e.push_back(x);\n      u = decomp(u);\n      par[u] = v;\n      ch[v].push_back(u);\n      for(int& x : tree[u].e)\n         tree[v].e.push_back(x);\n   }\n   return v;\n}\n\nvoid useless(int v){\n   ++d[v];\n   for(auto& x : ch[v]){\n      d[x] = d[v];\n      useless(x);\n   }\n}\n\nvoid update(int v, int u, ll val){\n   if(d[v] > d[u]) swap(v, u);\n   int ov = v;\n   ll bef;\n   while(v != 0){\n      bef = tree[v].getter();\n      tree[v].updater(ov, u, val);\n      pls.update(1, 1, n, v, v, bef-tree[v].getter());\n      v = par[v];\n   }\n}\n\nlong long get(){\n   char c;\n   ll res = 0;\n   c = _getchar_nolock();\n   while(c > 47 && c < 58){\n      res = res * 10 + c - 48;\n      c = _getchar_nolock();\n   }\n   return res;\n}\n\nvoid put(long long res){\n   if(res < 10){\n      _putchar_nolock(res + '0');\n   } else {\n      put(res / 10);\n      _putchar_nolock(res % 10 + '0');\n   }\n}\n\n\nint main(){\n   int q;\n   n = get();\n   q = get();\n   wmax = get();\n   for(int i = 1; i < n; i++){\n      int v, u;\n      ll w;\n      v = get();\n      u = get();\n      w = get();\n      edge.pb({w, {v, u}});\n      adj[v].push_back(i - 1);\n      adj[u].push_back(i - 1);\n   }\n\n   pls.resize(n);\n\n   int cen = decomp(1);\n   useless(cen);\n\n   for(int i = 1; i <= n; i++){\n      tree[i].build(i);\n   }\n   for(auto& x : edge){\n      update(x.ss.ff, x.ss.ss, x.ff);\n   }\n   ll last = 0;\n   while(q--){\n      ll ww;\n      int ee;\n      ee = get();\n      ww = get();\n      ee = (ee + last) % (n - 1);\n      ww = (ww + last) % wmax;\n      update(edge[ee].ss.ff, edge[ee].ss.ss, ww - edge[ee].ff);\n      edge[ee].ff = ww;\n      last = pls.query(1, 1, n, 1, n);\n      put(last);\n      _putchar_nolock('\\n');\n   }\n}\n",
    "ext": "cpp"
  },
  "57803240": {
    "code": "#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma comment(linker, \"/stack:200000000\")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n \n#define X first\n#define Y second\n \n//#include <boost/unordered_map.hpp>\n//using namespace boost;\n \n/*\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> rbtree;\nrbtree T;\n*/\n \nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing f64 = double;\nusing f80 = long double;\n//using i128 = __int128_t;\n//using u128 = __uint128_t;\nusing i128 = i64;\nusing u128 = u64;\n \nll power(ll a, ll b, ll p)\n{\n\tif (!b) return 1;\n\tll t = power(a, b/2, p);\n\tt = t*t%p;\n\tif (b&1) t = t*a%p;\n\treturn t;\n}\n \nll exgcd(ll a, ll b, ll &x, ll &y)\n{\n\tif (b == 0)\n\t{\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn a;\n\t}\n\tll px, py;\n\tll d = exgcd(b, a%b, px, py);\n\tx = py;\n\ty = px-a/b*py;\n\treturn d;\n}\n \ntemplate<class T>\ninline void freshmin(T &a, const T &b)\n{\n\tif (a > b) a = b;\n}\n \ntemplate<class T>\ninline void freshmax(T &a, const T &b)\n{\n\tif (a < b) a = b;\n}\n \n//#define getchar getchar_unlocked\n//#define putchar putchar_unlocked\n \nint inp() {\n\tint x = 0, f = 0; char ch;\n\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\tif(ch == '-') f = 1;\n\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\treturn f ? -x : x;\n}\n \nll inp_ll() {\n\tll x = 0; int f = 0; char ch;\n\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\tif(ch == '-') f = 1;\n\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\treturn f ? -x : x;\n}\n \ntemplate<class T>\nbool read(T &x)\n{\n\tx = 0;\n\tchar ch = getchar();\n\tif (ch == EOF) return 0;\n\tfor(; !isdigit(ch); )\n\t{\n\t\tch = getchar();\n\t\tif (ch == EOF) return 0;\n\t}\n\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\treturn 1;\n}\n \ntemplate<class T>\nvoid write(T x)\n{\n\tstatic char s[22];\n\tstatic char *it = s+20;\n\tstatic char *end = s+20;\n\tif (!x)\n\t\t*-- it = '0';\n\twhile (x)\n\t{\n\t\t*-- it = x%10+'0';\n\t\tx /= 10;\n\t}\n\tfor (; it < end; ++ it)\n\t\tputchar(*it);\n}\n \ntemplate<class T>\nvoid writeln(T x)\n{\n\twrite(x);\n\tputchar('\\n');\n}\n \nconst int MAXN = 100010;\nconst int INF = 1000000000;\nconst int MOD = 998244353;\n\ntemplate<class T>\nstruct segment\n{\n\tstruct\n\t{\n\t\tT val;\n\t\tT tag;\n\t}a[MAXN*4];\n\tint n;\n\tfunction<T(int)> set_value;\n\t\n\tvoid clear(int k)\n\t{\n\t\tif (a[k].tag)\n\t\t{\n\t\t\ta[k<<1].tag += a[k].tag;\n\t\t\ta[k<<1].val += a[k].tag;\n\t\t\ta[k<<1|1].tag += a[k].tag;\n\t\t\ta[k<<1|1].val += a[k].tag;\n\t\t\ta[k].tag = 0;\n\t\t}\n\t}\n\t\n\tvoid update(int k)\n\t{\n\t\ta[k].val = max(a[k<<1].val, a[k<<1|1].val);\n\t}\n\t\n\tvoid build(int k, int L, int R)\n\t{\n\t\tif (L == R)\n\t\t{\n\t\t\ta[k].val = set_value(L);\n\t\t\ta[k].tag = 0;\n\t\t\treturn;\n\t\t}\n\t\tint m = (L+R)>>1;\n\t\tbuild(k<<1, L, m);\n\t\tbuild(k<<1|1, m+1, R);\n\t\tupdate(k);\n\t}\n\tvoid add(int k, int L, int R, int x, int y, T d)\n\t{\n\t\tif (L == x && R == y)\n\t\t{\n\t\t\ta[k].tag += d;\n\t\t\ta[k].val += d;\n\t\t\treturn;\n\t\t}\n\t\tclear(k);\n\t\tint m = (L+R)>>1;\n\t\tif (y <= m)\n\t\t\tadd(k<<1, L, m, x, y, d);\n\t\telse if (x > m)\n\t\t\tadd(k<<1|1, m+1, R, x, y, d);\n\t\telse\n\t\t{\n\t\t\tadd(k<<1, L, m, x, m, d);\n\t\t\tadd(k<<1|1, m+1, R, m+1, y, d);\n\t\t}\n\t\tupdate(k);\n\t}\n\tT get(int k, int L, int R, int x, int y)\n\t{\n\t\tif (L == x && R == y)\n\t\t\treturn a[k].val;\n\t\tclear(k);\n\t\tint m = (L+R)>>1;\n\t\tif (y <= m)\n\t\t\treturn get(k<<1, L, m, x, y);\n\t\tif (x > m)\n\t\t\treturn get(k<<1|1, m+1, R, x, y);\n\t\treturn max(get(k<<1, L, m, x, m), get(k<<1|1, m+1, R, m+1, y));\n\t}\n\tvoid modify(int k, int L, int R, int x, T p)\n\t{\n\t\tif (L == R)\n\t\t{\n\t\t\ta[k].val = p;\n\t\t\treturn;\n\t\t}\n\t\tclear(k);\n\t\tint m = (L+R)>>1;\n\t\tif (x <= m)\n\t\t\tmodify(k<<1, L, m, x, p);\n\t\telse\n\t\t\tmodify(k<<1|1, m+1, R, x, p);\n\t\tupdate(k);\n\t}\n\tint get_pos(int k, int L, int R, T tmp)\n\t{\n\t\tif (L == R)\n\t\t\treturn L;\n\t\tclear(k);\n\t\tint m = (L+R)>>1;\n\t\tif (a[k<<1].val == tmp)\n\t\t\treturn get_pos(k<<1, L, m, tmp);\n\t\telse\n\t\t\treturn get_pos(k<<1|1, m+1, R, tmp);\n\t}\n\t\n\tvoid build(int n, const function<T(int)> &set_value)\n\t{\n\t\tthis->n = n;\n\t\tthis->set_value = set_value;\n\t\tbuild(1, 1, n);\n\t}\n\tvoid add(int x, int y, T d)\n\t{\n\t\tadd(1, 1, n, x, y, d);\n\t}\n\tT get(int x, int y)\n\t{\n\t\treturn get(1, 1, n, x, y);\n\t}\n\tT get(int x)\n\t{\n\t\treturn get(x, x);\n\t}\n\tvoid modify(int x, T p)\n\t{\n\t\tmodify(1, 1, n, x, p);\n\t}\n\tpair<T, int> get_max()\n\t{\n\t\tT ret = a[1].val;\n\t\tint pos = get_pos(1, 1, n, ret);\n\t\treturn {ret, pos};\n\t}\n};\n\nsegment<i64> Td, Tw;\n\nint n;\npii e[MAXN];\nvector<pair<int, i64>> v[MAXN];\nvector<int> son[MAXN];\n\nint pre[MAXN], size[MAXN];\ni64 weight[MAXN];\ni64 dis[MAXN];\n\nvoid dfs1(int x)\n{\n\tsize[x] = 1;\n\tfor (auto p : v[x])\n\t{\n\t\tint y = p.X;\n\t\ti64 z = p.Y;\n\t\tif (y == pre[x]) continue;\n\t\tpre[y] = x;\n\t\tson[x].push_back(y);\n\t\tdis[y] = dis[x]+z;\n\t\tweight[y] = z;\n\t\tdfs1(y);\n\t\tsize[x] += size[y];\n\t}\n}\n\nint times, X[MAXN], Y[MAXN], Z[MAXN], r[MAXN];\nint from[MAXN];\ni64 mdis[MAXN], vdis[MAXN];\n\nvoid dfs2(int x)\n{\n\tX[x] = ++ times;\n\tr[times] = x;\n\tsort(son[x].begin(), son[x].end(), [&](int a, int b)\n\t{\n\t\treturn size[a] > size[b];\n\t});\n\tmdis[x] = vdis[x] = dis[x];\n\tfor (auto y : son[x])\n\t{\n\t\tfrom[y] = y == son[x][0] ? from[x] : y;\n\t\tdfs2(y);\n\t\tfreshmax(vdis[x], vdis[y]);\n\t\tif (y == son[x][0])\n\t\t\tZ[x] = times;\n\t\telse\n\t\t\tfreshmax(mdis[x], vdis[y]);\n\t}\n\tY[x] = times;\n}\n\nvoid modify(int x, i64 w)\n{\n\tTd.add(X[x], Y[x], w-weight[x]);\n\tTw.add(X[x], Y[x], weight[x]-w);\n\tweight[x] = w;\n\t\n\twhile (x)\n\t{\n\t\tint y = from[x];\n\t\tx = pre[y];\n\t\tif (x)\n\t\t{\n\t\t\ti64 maxdis = Td.get(Z[x]+1, Y[x]);\n\t\t\ti64 pdis = Td.get(X[x]);\n\t\t\tTw.modify(X[x], maxdis-2*pdis);\n\t\t}\n\t}\n}\n\ni64 diameter()\n{\n\tauto p = Td.get_max();\n\ti64 maxdis = p.X;\n\tint id = p.Y;\n\tint x = r[id];\n\ti64 ret = maxdis;\n\twhile (x)\n\t{\n\t\tint y = from[x];\n\t\tif (X[y] < X[x])\n\t\t{\n\t\t\ti64 most = Tw.get(X[y], X[x]-1);\n\t\t\tfreshmax(ret, maxdis+most);\n\t\t}\n\t\tx = pre[y];\n\t\tif (x)\n\t\t{\n\t\t\ti64 most = Td.get(X[x], X[y]-1);\n\t\t\tif (Y[y]+1 <= Y[x])\n\t\t\t\tfreshmax(most, Td.get(Y[y]+1, Y[x]));\n\t\t\tfreshmax(ret, maxdis+most-2*Td.get(X[x]));\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\t\n\tn = inp();\n\tint q = inp();\n\ti64 W = inp_ll();\n\t\n\tfor (int i = 1; i < n; ++ i)\n\t{\n\t\tint x = inp();\n\t\tint y = inp();\n\t\ti64 z = inp_ll();\n\t\tv[x].push_back({y, z});\n\t\tv[y].push_back({x, z});\n\t\te[i] = {x, y};\n\t}\n\t\n\tdfs1(1);\n\tfrom[1] = 1;\n\tdfs2(1);\n\t\n\tTd.build(n, [&](int x) -> i64\n\t{\n\t\treturn dis[r[x]];\n\t});\n\tTw.build(n, [&](int x) -> i64\n\t{\n\t\treturn mdis[r[x]]-2*dis[r[x]];\n\t});\n\t\n\ti64 ans = 0;\n\twhile (q --)\n\t{\n\t\tint a = (inp()+ans)%(n-1)+1;\n\t\ti64 b = (inp_ll()+ans)%W;\n\t\tint x = pre[e[a].X] == e[a].Y ? e[a].X : e[a].Y;\n\t\tmodify(x, b);\n\t\tans = diameter();\n\t\twriteln(ans);\n\t}\n\t\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57803062": {
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2\")\nusing namespace std;\n#define ll long long\n#define ff first\n#define ss second\n#define pb push_back\n#define N 100005\nvector<pair<ll, pair<int, int> > > edge;\nvector<int> adj[N];\nll wmax;\nint n;\n\nbool ooo = 0;\n\ninline int get(int v, int i){\n   return edge[i].ss.ss + edge[i].ss.ff - v;\n}\n\n\nint sz[N];\nbool used[N];\n\nint get_size(int v, int p){\n   sz[v] = 1;\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u] || u == p) continue;\n      sz[v] += get_size(u, v);\n   }\n   return sz[v];\n}\n\nint get_center(int v, int p, int s){\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u] || u == p) continue;\n      if(sz[u] > s) return get_center(u, v, s);\n   }\n   return v;\n}\n\nstruct Segtree{\n   int t;\n   vector<long long> seg, laz;\n\n   void resize(int _t){\n      t = _t;\n      seg.resize(t << 2);\n      laz.resize(t << 2);\n   }\n   void push(int id, int l, int r){\n      seg[id] += laz[id];\n      if(l != r){\n         laz[id << 1] += laz[id];\n         laz[id << 1 | 1] += laz[id];\n      }\n      laz[id] = 0;\n   }\n   void update(int id, int l, int r, int L, int R, ll val){\n      if(L <= l && r <= R){\n         laz[id] += val;\n         push(id, l, r);\n         return;\n      }\n      push(id, l, r);\n      if(r < L || l > R) return;\n      int m = (l + r) >> 1;\n      update(id << 1, l, m, L, R, val);\n      update(id << 1 | 1, m + 1, r, L, R, val);\n      seg[id] = max(seg[id << 1], seg[id << 1 | 1]);\n   }\n\n   long long query(int id, int l, int r, int L, int R){\n      push(id, l, r);\n      if(r < L || l > R) return 0;\n      if(L <= l && r <= R) return seg[id];\n      int m = (l + r) >> 1;\n      return max(query(id << 1, l, m, L, R), query(id << 1 | 1, m + 1, r, L, R));\n   }\n} pls;\n\nstruct Tree{\n   int root;\n   multiset<ll> ans;\n   vector<int> e, L, R, pp;\n   vector<vector<int> > adj;\n   unordered_map<int, int> comp;\n   int t = 0;\n   Segtree ss;\n\n\n   void dfs(int v, int p){\n      L[v] = t + 1;\n      int ch = 0;\n      for(int& x : adj[v]){\n         if(x == p) continue;\n         if(v == root){\n            pp[x] = x;\n            ans.insert(0);\n         }\n         else pp[x] = pp[v];\n         ch++;\n         dfs(x, v);\n      }\n      if(ch == 0) t++;\n      R[v] = t;\n   }\n\n   void build(int _r){\n      root = _r;\n      for(int& x : e){\n         comp[edge[x].ss.ss] = 0;\n         comp[edge[x].ss.ff] = 0;\n      }\n      int f = 1;\n      for(auto& x : comp)\n         x.ss = f++;\n      pp.resize(f);\n      L.resize(f);\n      R.resize(f);\n      adj.resize(f);\n      for(int& x : e){\n         int v = comp[edge[x].ss.ss];\n         int u = comp[edge[x].ss.ff];\n         adj[v].push_back(u);\n         adj[u].push_back(v);\n      }\n      root = comp[root];\n      dfs(root, -1);\n      ss.resize(t);\n   }\n\n\n   void updater(int v, int u, ll val){\n      v = comp[v];\n      u = comp[u];\n      int le = max(L[v], L[u]);\n      int ri = min(R[v], R[u]);\n      int q;\n      if(v == root) q = pp[u];\n      else q = pp[v];\n      ans.erase(ans.find(-ss.query(1, 1, t, L[q], R[q])));\n      ss.update(1, 1, t, le, ri, val);\n      ans.insert(-ss.query(1, 1, t, L[q], R[q]));\n   }\n   long long getter(){\n      auto it = ans.begin();\n      if(ans.size() == 1) return *it;\n      return *it + (*(++it));\n   }\n} tree[N];\n\nint d[N];\nint par[N];\nvector<int> ch[N];\nint decomp(int v){\n   v = get_center(v, -1, get_size(v, -1) / 2);\n   used[v] = 1;\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u]) continue;\n      tree[v].e.push_back(x);\n      u = decomp(u);\n      par[u] = v;\n      ch[v].push_back(u);\n      for(int& x : tree[u].e)\n         tree[v].e.push_back(x);\n   }\n   return v;\n}\n\nvoid useless(int v){\n   ++d[v];\n   for(auto& x : ch[v]){\n      d[x] = d[v];\n      useless(x);\n   }\n}\n\nvoid update(int v, int u, ll val){\n   if(d[v] > d[u]) swap(v, u);\n   int ov = v;\n   ll bef;\n   while(v != 0){\n      bef = tree[v].getter();\n      tree[v].updater(ov, u, val);\n      pls.update(1, 1, n, v, v, bef-tree[v].getter());\n      v = par[v];\n   }\n}\n\nlong long get(){\n   char c;\n   ll res = 0;\n   c = _getchar_nolock();\n   while(c > 47 && c < 58){\n      res = res * 10 + c - 48;\n      c = _getchar_nolock();\n   }\n   return res;\n}\n\nvoid put(long long res){\n   if(res < 10){\n      _putchar_nolock(res + '0');\n   } else {\n      put(res / 10);\n      _putchar_nolock(res % 10 + '0');\n   }\n}\n\n\nint main(){\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);\n   cout.tie(0);\n\n   int q;\n   cin>>n>>q>>wmax;\n   for(int i = 1; i < n; i++){\n      int v, u;\n      ll w;\n      cin>>v>>u>>w;\n      edge.pb({w, {v, u}});\n      adj[v].push_back(i - 1);\n      adj[u].push_back(i - 1);\n   }\n\n   pls.resize(n);\n\n   int cen = decomp(1);\n   useless(cen);\n\n   for(int i = 1; i <= n; i++){\n      tree[i].build(i);\n   }\n   for(auto& x : edge){\n      update(x.ss.ff, x.ss.ss, x.ff);\n   }\n   ll last = 0;\n   while(q--){\n      ll ww;\n      int ee;\n      cin>>ee>>ww;\n      ee = (ee + last) % (n - 1);\n      ww = (ww + last) % wmax;\n      update(edge[ee].ss.ff, edge[ee].ss.ss, ww - edge[ee].ff);\n      edge[ee].ff = ww;\n      last = pls.query(1, 1, n, 1, n);\n      cout<<last<<'\\n';\n   }\n}\n",
    "ext": "cpp"
  },
  "57802979": {
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2\")\nusing namespace std;\n#define ll long long\n#define ff first\n#define ss second\n#define pb push_back\n#define N 100005\nvector<pair<ll, pair<int, int> > > edge;\nvector<int> adj[N];\nll wmax;\nint n;\n\nbool ooo = 0;\n\ninline int get(int v, int i){\n   return edge[i].ss.ss + edge[i].ss.ff - v;\n}\n\n\nint sz[N];\nbool used[N];\n\nint get_size(int v, int p){\n   sz[v] = 1;\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u] || u == p) continue;\n      sz[v] += get_size(u, v);\n   }\n   return sz[v];\n}\n\nint get_center(int v, int p, int s){\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u] || u == p) continue;\n      if(sz[u] > s) return get_center(u, v, s);\n   }\n   return v;\n}\n\nstruct Segtree{\n   int t;\n   vector<long long> seg, laz;\n\n   void resize(int _t){\n      t = _t;\n      seg.resize(t << 2);\n      laz.resize(t << 2);\n   }\n   void push(int id, int l, int r){\n      seg[id] += laz[id];\n      if(l != r){\n         laz[id << 1] += laz[id];\n         laz[id << 1 | 1] += laz[id];\n      }\n      laz[id] = 0;\n   }\n   void update(int id, int l, int r, int L, int R, ll val){\n      if(L <= l && r <= R){\n         laz[id] += val;\n         push(id, l, r);\n         return;\n      }\n      push(id, l, r);\n      if(r < L || l > R) return;\n      int m = (l + r) >> 1;\n      update(id << 1, l, m, L, R, val);\n      update(id << 1 | 1, m + 1, r, L, R, val);\n      seg[id] = max(seg[id << 1], seg[id << 1 | 1]);\n   }\n\n   long long query(int id, int l, int r, int L, int R){\n      push(id, l, r);\n      if(r < L || l > R) return 0;\n      if(L <= l && r <= R) return seg[id];\n      int m = (l + r) >> 1;\n      return max(query(id << 1, l, m, L, R), query(id << 1 | 1, m + 1, r, L, R));\n   }\n} pls;\n\nstruct Tree{\n   int root;\n   multiset<ll> ans;\n   vector<int> e, L, R, pp;\n   vector<vector<int> > adj;\n   unordered_map<int, int> comp;\n   int t = 0;\n   Segtree ss;\n\n\n   void dfs(int v, int p){\n      L[v] = t + 1;\n      int ch = 0;\n      for(int& x : adj[v]){\n         if(x == p) continue;\n         if(v == root){\n            pp[x] = x;\n            ans.insert(0);\n         }\n         else pp[x] = pp[v];\n         ch++;\n         dfs(x, v);\n      }\n      if(ch == 0) t++;\n      R[v] = t;\n   }\n\n   void build(int _r){\n      root = _r;\n      for(int& x : e){\n         comp[edge[x].ss.ss] = 0;\n         comp[edge[x].ss.ff] = 0;\n      }\n      int f = 1;\n      for(auto& x : comp)\n         x.ss = f++;\n      pp.resize(f);\n      L.resize(f);\n      R.resize(f);\n      adj.resize(f);\n      for(int& x : e){\n         int v = comp[edge[x].ss.ss];\n         int u = comp[edge[x].ss.ff];\n         adj[v].push_back(u);\n         adj[u].push_back(v);\n      }\n      root = comp[root];\n      dfs(root, -1);\n      ss.resize(t);\n   }\n\n\n   void updater(int v, int u, ll val){\n      v = comp[v];\n      u = comp[u];\n      int le = max(L[v], L[u]);\n      int ri = min(R[v], R[u]);\n      int q;\n      if(v == root) q = pp[u];\n      else q = pp[v];\n      ans.erase(ans.find(-ss.query(1, 1, t, L[q], R[q])));\n      ss.update(1, 1, t, le, ri, val);\n      ans.insert(-ss.query(1, 1, t, L[q], R[q]));\n   }\n   long long getter(){\n      auto it = ans.begin();\n      if(ans.size() == 1) return *it;\n      return *it + (*(++it));\n   }\n} tree[N];\n\nint d[N];\nint par[N];\nvector<int> ch[N];\nint decomp(int v){\n   v = get_center(v, -1, get_size(v, -1) / 2);\n   used[v] = 1;\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u]) continue;\n      tree[v].e.push_back(x);\n      u = decomp(u);\n      par[u] = v;\n      ch[v].push_back(u);\n      for(int& x : tree[u].e)\n         tree[v].e.push_back(x);\n   }\n   return v;\n}\n\nvoid useless(int v){\n   ++d[v];\n   for(auto& x : ch[v]){\n      d[x] = d[v];\n      useless(x);\n   }\n}\n\nvoid update(int v, int u, ll val){\n   if(d[v] > d[u]) swap(v, u);\n   int ov = v;\n   ll bef;\n   while(v != 0){\n      bef = tree[v].getter();\n      tree[v].updater(ov, u, val);\n      pls.update(1, 1, n, v, v, bef-tree[v].getter());\n      v = par[v];\n   }\n}\n\nlong long get(){\n   char c;\n   ll res = 0;\n   c = _getchar_nolock();\n   while(c > 47 && c < 58){\n      res = res * 10 + c - 48;\n      c = _getchar_nolock();\n   }\n   return res;\n}\n\nvoid put(long long res){\n   if(res < 10){\n      _putchar_nolock(res + '0');\n   } else {\n      put(res / 10);\n      _putchar_nolock(res % 10 + '0');\n   }\n}\n\n\nint main(){\n   int q;\n   n = get();\n   q = get();\n   wmax = get();\n   for(int i = 1; i < n; i++){\n      int v, u;\n      ll w;\n      v = get();\n      u = get();\n      w = get();\n      edge.pb({w, {v, u}});\n      adj[v].push_back(i - 1);\n      adj[u].push_back(i - 1);\n   }\n\n   pls.resize(n);\n\n   int cen = decomp(1);\n   useless(cen);\n\n   for(int i = 1; i <= n; i++){\n      tree[i].build(i);\n   }\n   for(auto& x : edge){\n      update(x.ss.ff, x.ss.ss, x.ff);\n   }\n   ll last = 0;\n   while(q--){\n      ll ww;\n      int ee;\n      ee = get();\n      ww = get();\n      ee = (ee + last) % (n - 1);\n      ww = (ww + last) % wmax;\n      update(edge[ee].ss.ff, edge[ee].ss.ss, ww - edge[ee].ff);\n      edge[ee].ff = ww;\n      last = pls.query(1, 1, n, 1, n);\n      put(last);\n      _putchar_nolock('\\n');\n   }\n}\n",
    "ext": "cpp"
  },
  "57802938": {
    "code": "/* cerberus97 - Hanit Banga */\n \n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n \nusing namespace std;\n \n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n \nconst int N = 1e5 + 10, inf = 1e9 + 42;\n \nstruct node_t {\n\tll mx, mn, to_right, to_left, lazy, ans;\n};\n \nnode_t tree[8 * N];\nll d[2 * N], depth[N], c[N];\nvector<pll> g[N];\nint a[N], b[N];\nint ent[N], ext[N];\nint nxt = 0;\n \nvoid dfs(int u, int p);\nvoid update(int i, int l, int r, int ql, int qr, ll x);\nvoid add(int i, ll x);\nvoid combine(int i, int lc, int rc);\nvoid propagate(int i, int lc, int rc);\n \nint main() {\n\tfast_cin();\n\tint n, q; ll w;\n\tcin >> n >> q >> w;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tcin >> a[i] >> b[i] >> c[i];\n\t\tg[a[i]].pb({b[i], c[i]});\n\t\tg[b[i]].pb({a[i], c[i]});\n\t}\n\tdfs(1, 0);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tif (ent[a[i]] < ent[b[i]]) {\n\t\t\tswap(a[i], b[i]);\n\t\t}\n\t}\n\tint m = 2 * n - 1;\n\tfor (int i = 0; i < m; ++i) {\n\t\tupdate(1, 0, m - 1, i, i, d[i]);\n\t}\n\tll last = 0;\n\twhile (q--) {\n\t\tint id; ll e;\n\t\tcin >> id >> e;\n\t\tid = (id + last) % (n - 1);\n\t\te = (e + last) % w;\n\t\tupdate(1, 0, m - 1, ent[a[id]], ext[a[id]] - 1, e - c[id]);\n\t\tc[id] = e;\n\t\tlast = tree[1].ans;\n\t\tcout << last << '\\n';\n\t}\n}\n\nvoid dfs(int u, int p) {\n\td[nxt] = depth[u];\n\tent[u] = nxt++;\n\tfor (auto &e : g[u]) {\n\t\tint v = e.first; ll w = e.second;\n\t\tif (v != p) {\n\t\t\tdepth[v] = depth[u] + w;\n\t\t\tdfs(v, u);\n\t\t\td[nxt++] = depth[u];\n\t\t}\n\t}\n\text[u] = nxt;\n}\n \nvoid update(int i, int l, int r, int ql, int qr, ll x) {\n\tif (l > qr or ql > r) {\n\t\treturn;\n\t} else if (ql <= l and r <= qr) {\n\t\tadd(i, x);\n\t} else {\n\t\tint mid = (l + r) / 2, lc = 2 * i, rc = lc + 1;\n\t\tpropagate(i, lc, rc);\n\t\tupdate(lc, l, mid, ql, qr, x);\n\t\tupdate(rc, mid + 1, r, ql, qr, x);\n\t\tcombine(i, lc, rc);\n\t}\n}\n \nvoid add(int i, ll x) {\n\ttree[i].mx += x;\n\ttree[i].mn += x;\n\ttree[i].to_right -= x;\n\ttree[i].to_left -= x;\n\ttree[i].lazy += x;\n}\n \nvoid combine(int i, int lc, int rc) {\n\ttree[i].mx = max(tree[lc].mx, tree[rc].mx);\n\ttree[i].mn = min(tree[lc].mn, tree[rc].mn);\n\ttree[i].to_right = max(tree[lc].to_right, tree[rc].to_right);\n\ttree[i].to_right = max(tree[i].to_right, tree[rc].mx - 2 * tree[lc].mn);\n\ttree[i].to_left = max(tree[lc].to_left, tree[rc].to_left);\n\ttree[i].to_left = max(tree[i].to_left, tree[lc].mx - 2 * tree[rc].mn);\n\ttree[i].ans = max(tree[lc].ans, tree[rc].ans);\n\ttree[i].ans = max(tree[i].ans, max(tree[lc].mx + tree[rc].to_right, tree[lc].to_left + tree[rc].mx));\n}\n \nvoid propagate(int i, int lc, int rc) {\n\tadd(lc, tree[i].lazy);\n\tadd(rc, tree[i].lazy);\n\ttree[i].lazy = 0;\n}",
    "ext": "cpp"
  },
  "57802820": {
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2\")\nusing namespace std;\n#define ll long long\n#define ff first\n#define ss second\n#define pb push_back\n#define N 100005\nvector<pair<ll, pair<int, int> > > edge;\nvector<int> adj[N];\nll wmax;\nint n;\n\nbool ooo = 0;\n\ninline int get(int v, int i){\n   return edge[i].ss.ss + edge[i].ss.ff - v;\n}\n\n\nint sz[N];\nbool used[N];\n\nint get_size(int v, int p){\n   sz[v] = 1;\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u] || u == p) continue;\n      sz[v] += get_size(u, v);\n   }\n   return sz[v];\n}\n\nint get_center(int v, int p, int s){\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u] || u == p) continue;\n      if(sz[u] > s) return get_center(u, v, s);\n   }\n   return v;\n}\n\nstruct Segtree{\n   int t;\n   vector<long long> seg, laz;\n\n   void resize(int _t){\n      t = _t;\n      seg.resize(t << 2);\n      laz.resize(t << 2);\n   }\n   void push(int id, int l, int r){\n      seg[id] += laz[id];\n      if(l != r){\n         laz[id << 1] += laz[id];\n         laz[id << 1 | 1] += laz[id];\n      }\n      laz[id] = 0;\n   }\n   void update(int id, int l, int r, int L, int R, ll val){\n      if(L <= l && r <= R){\n         laz[id] += val;\n         push(id, l, r);\n         return;\n      }\n      push(id, l, r);\n      if(r < L || l > R) return;\n      int m = (l + r) >> 1;\n      update(id << 1, l, m, L, R, val);\n      update(id << 1 | 1, m + 1, r, L, R, val);\n      seg[id] = max(seg[id << 1], seg[id << 1 | 1]);\n   }\n\n   long long query(int id, int l, int r, int L, int R){\n      push(id, l, r);\n      if(r < L || l > R) return 0;\n      if(L <= l && r <= R) return seg[id];\n      int m = (l + r) >> 1;\n      return max(query(id << 1, l, m, L, R), query(id << 1 | 1, m + 1, r, L, R));\n   }\n} pls;\n\nstruct Tree{\n   int root;\n   multiset<ll> ans;\n   vector<int> e, L, R, pp;\n   vector<vector<int> > adj;\n   unordered_map<int, int> comp;\n   int t = 0;\n   Segtree ss;\n\n\n   void dfs(int v, int p){\n      L[v] = t + 1;\n      int ch = 0;\n      for(int& x : adj[v]){\n         if(x == p) continue;\n         if(v == root){\n            pp[x] = x;\n            ans.insert(0);\n         }\n         else pp[x] = pp[v];\n         ch++;\n         dfs(x, v);\n      }\n      if(ch == 0) t++;\n      R[v] = t;\n   }\n\n   void build(int _r){\n      root = _r;\n      for(int& x : e){\n         comp[edge[x].ss.ss] = 0;\n         comp[edge[x].ss.ff] = 0;\n      }\n      int f = 1;\n      for(auto& x : comp)\n         x.ss = f++;\n      pp.resize(f);\n      L.resize(f);\n      R.resize(f);\n      adj.resize(f);\n      for(int& x : e){\n         int v = comp[edge[x].ss.ss];\n         int u = comp[edge[x].ss.ff];\n         adj[v].push_back(u);\n         adj[u].push_back(v);\n      }\n      root = comp[root];\n      dfs(root, -1);\n      ss.resize(t);\n   }\n\n\n   void updater(int v, int u, ll val){\n      v = comp[v];\n      u = comp[u];\n      int le = max(L[v], L[u]);\n      int ri = min(R[v], R[u]);\n      int q;\n      if(v == root) q = pp[u];\n      else q = pp[v];\n      ans.erase(ans.find(-ss.query(1, 1, t, L[q], R[q])));\n      ss.update(1, 1, t, le, ri, val);\n      ans.insert(-ss.query(1, 1, t, L[q], R[q]));\n   }\n   long long getter(){\n      auto it = ans.begin();\n      if(ans.size() == 1) return *it;\n      return *it + (*(++it));\n   }\n} tree[N];\n\nint d[N];\nint par[N];\nvector<int> ch[N];\nint decomp(int v){\n   v = get_center(v, -1, get_size(v, -1) / 2);\n   used[v] = 1;\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u]) continue;\n      tree[v].e.push_back(x);\n      u = decomp(u);\n      par[u] = v;\n      ch[v].push_back(u);\n      for(int& x : tree[u].e)\n         tree[v].e.push_back(x);\n   }\n   return v;\n}\n\nvoid useless(int v){\n   ++d[v];\n   for(auto& x : ch[v]){\n      d[x] = d[v];\n      useless(x);\n   }\n}\n\nvoid update(int v, int u, ll val){\n   if(d[v] > d[u]) swap(v, u);\n   int ov = v;\n   ll bef;\n   while(v != 0){\n      bef = tree[v].getter();\n      tree[v].updater(ov, u, val);\n      pls.update(1, 1, n, v, v, bef-tree[v].getter());\n      v = par[v];\n   }\n}\n\nlong long get(){\n   char c;\n   ll res = 0;\n   c = _getchar_nolock();\n   while(c > 47 && c < 58){\n      res = res * 10 + c - 48;\n      c = _getchar_nolock();\n   }\n   return res;\n}\n\nvoid put(long long res){\n   if(res < 10){\n      _putchar_nolock(res + '0');\n   } else {\n      put(res / 10);\n      _putchar_nolock(res % 10 + '0');\n   }\n}\n\n\nint main(){\n   int q;\n   n = get();\n   q = get();\n   wmax = get();\n   for(int i = 1; i < n; i++){\n      int v, u;\n      ll w;\n      v = get();\n      u = get();\n      w = get();\n      edge.pb({w, {v, u}});\n      adj[v].push_back(i - 1);\n      adj[u].push_back(i - 1);\n   }\n\n   pls.resize(n);\n\n   int cen = decomp(1);\n   useless(cen);\n\n   for(int i = 1; i <= n; i++){\n      tree[i].build(i);\n   }\n   for(auto& x : edge){\n      update(x.ss.ff, x.ss.ss, x.ff);\n   }\n   ll last = 0;\n   while(q--){\n      ll ww;\n      int ee;\n      ee = get();\n      ww = get();\n      ee = (ee + last) % (n - 1);\n      ww = (ww + last) % wmax;\n      update(edge[ee].ss.ff, edge[ee].ss.ss, ww - edge[ee].ff);\n      edge[ee].ff = ww;\n      last = pls.query(1, 1, n, 1, n);\n      put(last);\n      _putchar_nolock('\\n');\n   }\n}\n",
    "ext": "cpp"
  },
  "57802697": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ff first\n#define ss second\n#define pb push_back\n#define N 100005\nvector<pair<ll, pair<int, int> > > edge;\nvector<int> adj[N];\nll wmax;\nint n;\n \nbool ooo = 0;\n \ninline int get(int v, int i){\n   return edge[i].ss.ss + edge[i].ss.ff - v;\n}\n \n \nint sz[N];\nbool used[N];\n \nint get_size(int v, int p){\n   sz[v] = 1;\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u] || u == p) continue;\n      sz[v] += get_size(u, v);\n   }\n   return sz[v];\n}\n \nint get_center(int v, int p, int s){\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u] || u == p) continue;\n      if(sz[u] > s) return get_center(u, v, s);\n   }\n   return v;\n}\n \nstruct Segtree{\n   int t;\n   vector<long long> seg, laz;\n \n   void resize(int _t){\n      t = _t;\n      seg.resize(t << 2);\n      laz.resize(t << 2);\n   }\n   void push(int id, int l, int r){\n      seg[id] += laz[id];\n      if(l != r){\n         laz[id << 1] += laz[id];\n         laz[id << 1 | 1] += laz[id];\n      }\n      laz[id] = 0;\n   }\n   void update(int id, int l, int r, int L, int R, ll val){\n      if(L <= l && r <= R){\n         laz[id] += val;\n         push(id, l, r);\n         return;\n      }\n      push(id, l, r);\n      if(r < L || l > R) return;\n      int m = (l + r) >> 1;\n      update(id << 1, l, m, L, R, val);\n      update(id << 1 | 1, m + 1, r, L, R, val);\n      seg[id] = max(seg[id << 1], seg[id << 1 | 1]);\n   }\n \n   long long query(int id, int l, int r, int L, int R){\n      push(id, l, r);\n      if(r < L || l > R) return 0;\n      if(L <= l && r <= R) return seg[id];\n      int m = (l + r) >> 1;\n      return max(query(id << 1, l, m, L, R), query(id << 1 | 1, m + 1, r, L, R));\n   }\n} pls;\n \nstruct Tree{\n   int root;\n   multiset<ll> ans;\n   vector<int> e, L, R, pp;\n   vector<vector<int> > adj;\n   unordered_map<int, int> comp;\n   int t = 0;\n   Segtree ss;\n \n \n   void dfs(int v, int p){\n      L[v] = t + 1;\n      int ch = 0;\n      for(int& x : adj[v]){\n         if(x == p) continue;\n         if(v == root){\n            pp[x] = x;\n            ans.insert(0);\n         }\n         else pp[x] = pp[v];\n         ch++;\n         dfs(x, v);\n      }\n      if(ch == 0) t++;\n      R[v] = t;\n   }\n \n   void build(int _r){\n      root = _r;\n      for(int& x : e){\n         comp[edge[x].ss.ss] = 0;\n         comp[edge[x].ss.ff] = 0;\n      }\n      int f = 1;\n      for(auto& x : comp)\n         x.ss = f++;\n      pp.resize(f);\n      L.resize(f);\n      R.resize(f);\n      adj.resize(f);\n      for(int& x : e){\n         int v = comp[edge[x].ss.ss];\n         int u = comp[edge[x].ss.ff];\n         adj[v].push_back(u);\n         adj[u].push_back(v);\n      }\n      root = comp[root];\n      dfs(root, -1);\n      ss.resize(t);\n   }\n \n \n   void updater(int v, int u, ll val){\n      v = comp[v];\n      u = comp[u];\n      int le = max(L[v], L[u]);\n      int ri = min(R[v], R[u]);\n      int q;\n      if(v == root) q = pp[u];\n      else q = pp[v];\n      ans.erase(ans.find(-ss.query(1, 1, t, L[q], R[q])));\n      ss.update(1, 1, t, le, ri, val);\n      ans.insert(-ss.query(1, 1, t, L[q], R[q]));\n   }\n   long long getter(){\n      auto it = ans.begin();\n      if(ans.size() == 1) return *it;\n      return *it + (*(++it));\n   }\n} tree[N];\n \nint d[N];\nint par[N];\nvector<int> ch[N];\nint decomp(int v){\n   v = get_center(v, -1, get_size(v, -1) / 2);\n   used[v] = 1;\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u]) continue;\n      tree[v].e.push_back(x);\n      u = decomp(u);\n      par[u] = v;\n      ch[v].push_back(u);\n      for(int& x : tree[u].e)\n         tree[v].e.push_back(x);\n   }\n   return v;\n}\n \nvoid useless(int v){\n   ++d[v];\n   for(auto& x : ch[v]){\n      d[x] = d[v];\n      useless(x);\n   }\n}\n \nvoid update(int v, int u, ll val){\n   if(d[v] > d[u]) swap(v, u);\n   int ov = v;\n   ll bef;\n   while(v != 0){\n      bef = tree[v].getter();\n      tree[v].updater(ov, u, val);\n      pls.update(1, 1, n, v, v, bef-tree[v].getter());\n      v = par[v];\n   }\n}\n \nlong long get(){\n   char c;\n   ll res = 0;\n   c = _getchar_nolock();\n   while(c > 47 && c < 58){\n      res = res * 10 + c - 48;\n      c = _getchar_nolock();\n   }\n   return res;\n}\n \nvoid put(long long res){\n   if(res < 10){\n      _putchar_nolock(res + '0');\n   } else {\n      put(res / 10);\n      _putchar_nolock(res % 10 + '0');\n   }\n}\n \n \nint main(){\n   int q;\n   n = get();\n   q = get();\n   wmax = get();\n   for(int i = 1; i < n; i++){\n      int v, u;\n      ll w;\n      v = get();\n      u = get();\n      w = get();\n      edge.pb({w, {v, u}});\n      adj[v].push_back(i - 1);\n      adj[u].push_back(i - 1);\n   }\n \n   pls.resize(n);\n \n   int cen = decomp(1);\n   useless(cen);\n \n   for(int i = 1; i <= n; i++){\n      tree[i].build(i);\n   }\n   for(auto& x : edge){\n      update(x.ss.ff, x.ss.ss, x.ff);\n   }\n   ll last = 0;\n   while(q--){\n      ll ww;\n      int ee;\n      ee = get();\n      ww = get();\n      ee = (ee + last) % (n - 1);\n      ww = (ww + last) % wmax;\n      update(edge[ee].ss.ff, edge[ee].ss.ss, ww - edge[ee].ff);\n      edge[ee].ff = ww;\n      last = pls.query(1, 1, n, 1, n);\n      put(last);\n      _putchar_nolock('\\n');\n   }\n}",
    "ext": "cpp"
  },
  "57802581": {
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define ll long long\nconst int N=2e5+5;\nint n,m,to[N],nxt[N],head[N],lk[N],fa[N],dep[N],sz[N],top[N],dfn[N],low[N],tim,id[N];\npair<int,int>p[N<<1];ll w,val[N],bit[N],lst;\nvoid dfs1(int u,int f){\n\tfa[u]=f;dep[u]=dep[f]+1;sz[u]=1;\n\tfor(int e=head[u];e;e=nxt[e])\n\t\tif(to[e]!=f)lk[e>>1]=to[e],dfs1(to[e],u),sz[u]+=sz[to[e]];\n}\nvoid dfs2(int u,int f){\n\ttop[u]=f;id[dfn[u]=++tim]=u;int son=0;\n\tfor(int e=head[u];e;e=nxt[e])\n\t\tif(to[e]!=fa[u]&&sz[to[e]]>sz[son])son=to[e];\n\tif(son)dfs2(son,f);\n\tfor(int e=head[u];e;e=nxt[e])\n\t\tif(to[e]!=fa[u]&&to[e]!=son)dfs2(to[e],to[e]);\n\tlow[u]=tim;\n}\nint lca(int u,int v){\n\twhile(top[u]!=top[v])\n\t\tif(dep[top[u]]>dep[top[v]])u=fa[top[u]];\n\t\telse v=fa[top[v]];\n\treturn dep[u]<dep[v]?u:v;\n}\nvoid modify(int x,ll v){\n\twhile(x<=n)bit[x]+=v,x+=x&-x;\n}\nll query(int x){\n\tll res=0;\n\twhile(x)res+=bit[x],x^=x&-x;\n\treturn res;\n}\nll dist(int u,int v){\n\treturn query(dfn[u])+query(dfn[v])-(query(dfn[lca(u,v)])<<1);\n}\npair<int,int>merge(pair<int,int>a,pair<int,int>b){\n\tstatic int p[4];int x,y;ll z;\n\tp[0]=a.first;p[1]=a.second;p[2]=b.first;p[3]=b.second;\n\tx=p[0];y=p[1];z=dist(x,y);\n\tfor(int i=0;i<4;++i)\n\t\tfor(int j=i+1;j<4;++j){\n\t\t\tll zz=dist(p[i],p[j]);\n\t\t\tif(zz>z)z=zz,x=p[i],y=p[j];\n\t\t}\n\treturn make_pair(x,y);\n}\nvoid build(int x,int l,int r){\n\tif(l==r){p[x]=make_pair(id[l],id[l]);return;}\n\tint mid=l+r>>1;\n\tbuild(x<<1,l,mid);build(x<<1|1,mid+1,r);\n\tp[x]=merge(p[x<<1],p[x<<1|1]);\n}\nvoid modify(int x,int l,int r,int ql,int qr){\n\tif(l>=ql&&r<=qr)return;\n\tint mid=l+r>>1;\n\tif(ql<=mid)modify(x<<1,l,mid,ql,qr);\n\tif(qr>mid)modify(x<<1|1,mid+1,r,ql,qr);\n\tp[x]=merge(p[x<<1],p[x<<1|1]);\n}\nint main(){\n\tscanf(\"%d%d%lld\",&n,&m,&w);\n\tfor(int i=1,j=1,x,y;i<n;++i){\n\t\tscanf(\"%d%d%lld\",&x,&y,&val[i]);\n\t\tto[++j]=y;nxt[j]=head[x];head[x]=j;\n\t\tto[++j]=x;nxt[j]=head[y];head[y]=j;\n\t}\n\tdfs1(1,0);dfs2(1,1);\n\tfor(int i=1;i<n;++i)modify(dfn[lk[i]],val[i]),modify(low[lk[i]]+1,-val[i]);\n\tbuild(1,1,n);\n\twhile(m--){\n\t\tint x;ll y;scanf(\"%d%lld\",&x,&y);\n\t\tx=(x+lst)%(n-1)+1;y=(y+lst)%w;\n\t\tmodify(dfn[lk[x]],y-val[x]);modify(low[lk[x]]+1,val[x]-y);\n\t\tval[x]=y;modify(1,1,n,dfn[lk[x]],low[lk[x]]);\n\t\tprintf(\"%lld\\n\",lst=dist(p[1].first,p[1].second));\n\t}\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57802391": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ff first\n#define ss second\n#define pb push_back\n#define N 100005\nvector<pair<ll, pair<int, int> > > edge;\nvector<int> adj[N];\nll wmax;\nint n;\n\nbool ooo = 0;\n\ninline int get(int v, int i){\n   return edge[i].ss.ss + edge[i].ss.ff - v;\n}\n\n\nint sz[N];\nbool used[N];\n\nint get_size(int v, int p){\n   sz[v] = 1;\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u] || u == p) continue;\n      sz[v] += get_size(u, v);\n   }\n   return sz[v];\n}\n\nint get_center(int v, int p, int s){\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u] || u == p) continue;\n      if(sz[u] > s) return get_center(u, v, s);\n   }\n   return v;\n}\n\nstruct Segtree{\n   int t;\n   vector<long long> seg, laz;\n\n   void resize(int _t){\n      t = _t;\n      seg.resize(t << 2);\n      laz.resize(t << 2);\n   }\n   void push(int id, int l, int r){\n      seg[id] += laz[id];\n      if(l != r){\n         laz[id << 1] += laz[id];\n         laz[id << 1 | 1] += laz[id];\n      }\n      laz[id] = 0;\n   }\n   void update(int id, int l, int r, int L, int R, ll val){\n      if(L <= l && r <= R){\n         laz[id] += val;\n         push(id, l, r);\n         return;\n      }\n      push(id, l, r);\n      if(r < L || l > R) return;\n      int m = (l + r) >> 1;\n      update(id << 1, l, m, L, R, val);\n      update(id << 1 | 1, m + 1, r, L, R, val);\n      seg[id] = max(seg[id << 1], seg[id << 1 | 1]);\n   }\n\n   long long query(int id, int l, int r, int L, int R){\n      push(id, l, r);\n      if(r < L || l > R) return 0;\n      if(L <= l && r <= R) return seg[id];\n      int m = (l + r) >> 1;\n      return max(query(id << 1, l, m, L, R), query(id << 1 | 1, m + 1, r, L, R));\n   }\n} pls;\n\nstruct Tree{\n   int root;\n   multiset<ll> ans;\n   vector<int> e, L, R, pp;\n   vector<vector<int> > adj;\n   unordered_map<int, int> comp;\n   int t = 0;\n   Segtree ss;\n\n\n   void dfs(int v, int p){\n      L[v] = t + 1;\n      int ch = 0;\n      for(int& x : adj[v]){\n         if(x == p) continue;\n         if(v == root){\n            pp[x] = x;\n            ans.insert(0);\n         }\n         else pp[x] = pp[v];\n         ch++;\n         dfs(x, v);\n      }\n      if(ch == 0) t++;\n      R[v] = t;\n   }\n\n   void build(int _r){\n      root = _r;\n      for(int& x : e){\n         comp[edge[x].ss.ss] = 0;\n         comp[edge[x].ss.ff] = 0;\n      }\n      int f = 1;\n      for(auto& x : comp)\n         x.ss = f++;\n      pp.resize(f);\n      L.resize(f);\n      R.resize(f);\n      adj.resize(f);\n      for(int& x : e){\n         int v = comp[edge[x].ss.ss];\n         int u = comp[edge[x].ss.ff];\n         adj[v].push_back(u);\n         adj[u].push_back(v);\n      }\n      root = comp[root];\n      dfs(root, -1);\n      ss.resize(t);\n   }\n\n\n   void updater(int v, int u, ll val){\n      v = comp[v];\n      u = comp[u];\n      int le = max(L[v], L[u]);\n      int ri = min(R[v], R[u]);\n      int q;\n      if(v == root) q = pp[u];\n      else q = pp[v];\n      ans.erase(ans.find(-ss.query(1, 1, t, L[q], R[q])));\n      ss.update(1, 1, t, le, ri, val);\n      ans.insert(-ss.query(1, 1, t, L[q], R[q]));\n   }\n   long long getter(){\n      auto it = ans.begin();\n      if(ans.size() == 1) return *it;\n      return *it + (*(++it));\n   }\n} tree[N];\n\nint d[N];\nint par[N];\nvector<int> ch[N];\nint decomp(int v){\n   v = get_center(v, -1, get_size(v, -1) / 2);\n   used[v] = 1;\n   for(int& x : adj[v]){\n      int u = get(v, x);\n      if(used[u]) continue;\n      tree[v].e.push_back(x);\n      u = decomp(u);\n      par[u] = v;\n      ch[v].push_back(u);\n      for(int& x : tree[u].e)\n         tree[v].e.push_back(x);\n   }\n   return v;\n}\n\nvoid useless(int v){\n   ++d[v];\n   for(auto& x : ch[v]){\n      d[x] = d[v];\n      useless(x);\n   }\n}\n\nvoid update(int v, int u, ll val){\n   if(d[v] > d[u]) swap(v, u);\n   int ov = v;\n   ll bef;\n   while(v != 0){\n      bef = tree[v].getter();\n      tree[v].updater(ov, u, val);\n      pls.update(1, 1, n, v, v, bef-tree[v].getter());\n      v = par[v];\n   }\n}\n\nlong long get(){\n   char c;\n   ll res = 0;\n   c = _getchar_nolock();\n   while(c > 47 && c < 58){\n      res = res * 10 + c - 48;\n      c = _getchar_nolock();\n   }\n   return res;\n}\n\nvoid put(long long res){\n   if(res < 10){\n      _putchar_nolock(res + '0');\n   } else {\n      put(res / 10);\n      _putchar_nolock(res % 10 + '0');\n   }\n}\n\n\nint main(){\n   int q;\n   n = get();\n   q = get();\n   wmax = get();\n   for(int i = 1; i < n; i++){\n      int v, u;\n      ll w;\n      v = get();\n      u = get();\n      w = get();\n      edge.pb({w, {v, u}});\n      adj[v].push_back(i - 1);\n      adj[u].push_back(i - 1);\n   }\n\n   pls.resize(n);\n\n   int cen = decomp(1);\n   useless(cen);\n\n   for(int i = 1; i <= n; i++){\n      tree[i].build(i);\n   }\n   for(auto& x : edge){\n      update(x.ss.ff, x.ss.ss, x.ff);\n   }\n   ll last = 0;\n   while(q--){\n      ll ww;\n      int ee;\n      ee = get();\n      ww = get();\n      ee = (ee + last) % (n - 1);\n      ww = (ww + last) % wmax;\n      update(edge[ee].ss.ff, edge[ee].ss.ss, ww - edge[ee].ff);\n      edge[ee].ff = ww;\n      last = pls.query(1, 1, n, 1, n);\n      put(last);\n      _putchar_nolock('\\n');\n   }\n}\n",
    "ext": "cpp"
  },
  "57802363": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int maxn = (int)2e5 + 7;\n\nstruct edge {\n  int u, v;\n  ll w;\n};\nvector<edge> ed;\n\nint n, q;\nvector <int> gr[maxn];\nll last, w;\nint tiktak;\nint tin[maxn], tout[maxn];\n\nstruct node {\n  ll delta;\n  ll mndep;\n  ll mxdep;\n  ll mxlv;\n  ll mxvr;\n  ll dis;\n};\n\nstruct T {\n  node tree[maxn * 4];\n  T() {\n    for (int i = 0; i < maxn * 4; i++) {\n      tree[i] = {0, 0, 0, 0, 0, 0};\n    }\n  }\n  \n  node shift(node v, ll del) {\n    return {v.delta + del, v.mndep + del, v.mxdep + del, v.mxlv - del, v.mxvr - del, v.dis};\n  }\n  \n  node gather(node l, node r) {\n    node R = shift(r, l.delta);\n    node res;\n    res.delta = R.delta;\n    res.mndep = min(l.mndep, R.mndep);\n    res.mxdep = max(l.mxdep, R.mxdep);\n    res.mxlv = max(l.mxlv, max(R.mxlv, l.mxdep - 2 * R.mndep));\n    res.mxvr = max(l.mxvr, max(R.mxvr, R.mxdep - 2 * l.mndep));\n    res.dis = max(l.dis, max(R.dis, max(l.mxlv + R.mxdep, l.mxdep + R.mxvr)));\n    return res;\n  }\n  \n  void upd(int pos, ll val, int v = 1, int tl = 1, int tr = n + n) {\n    if (tl == tr) {\n      if (val < 0) {\n        tree[v] = {val, val, 0, -(val + val), -val, -val};\n      } else {\n        tree[v] = {val, 0, val, 0, val, val};\n      }\n      return ;\n    }\n    int mid = (tl + tr) >> 1;\n    if (pos <= mid) {\n      upd(pos, val, v + v, tl, mid);\n    } else {\n      upd(pos, val, v + v + 1, mid + 1, tr);\n    }\n    tree[v] = gather(tree[v + v], tree[v + v + 1]);\n  }\n};\nT tr;\n\nvoid dfs(int v, int pr) {\n  tin[v] = ++tiktak;\n  for (int id : gr[v]) {\n    int to = ed[id].v + ed[id].u - v;\n    if (to == pr) continue;\n    dfs(to, v);\n  }\n  tout[v] = ++tiktak;\n}\n\nmain() {\n  scanf(\"%d %d %lld\", &n, &q, &w);\n  for (int i = 1, u, v; i < n; i++) {\n    ll w;\n    scanf(\"%d %d %lld\", &u, &v, &w);\n    gr[u].push_back(ed.size());\n    gr[v].push_back(ed.size());\n    ed.push_back({u, v, w});\n  }\n  dfs(1, 1);\n  for (int i = 0; i < ed.size(); i++) {\n    int a, b;\n    ll w;\n    if (tin[ed[i].u] > tin[ed[i].v]) {\n      swap(ed[i].u, ed[i].v);\n    }\n    tie(a, b, w) = make_tuple(ed[i].u, ed[i].v, ed[i].w);\n    tr.upd(tin[b], w);\n    tr.upd(tout[b], -w);\n  }\n  while (q--) {\n    int d; ll e;\n    scanf(\"%d %lld\", &d, &e);\n    d = (d + last) % (n - 1);\n    e = (e + last) % w;\n    int a, b;\n    tie(a, b) = make_tuple(ed[d].u, ed[d].v);\n    ed[d].w = e;\n    tr.upd(tin[b], ed[d].w);\n    tr.upd(tout[b], -ed[d].w);\n    last = tr.tree[1].dis;\n    printf(\"%lld\\n\", last);\n  }\n}\n",
    "ext": "cpp"
  },
  "57800751": {
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n//#define ll __int128\n#define ll long long int\n#define LEFT(a) ((a)<<1)\n#define RIGHT(a) (LEFT(a) + 1)\n#define MID(a,b) ((a+b)>>1)\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n/*\n#pragma GCC optimize (\"O3\")\n#pragma comment(linker, \"/STACK: 20000000005\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx2,fma\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"unroll-loops\")\n*/\nusing namespace std;\n\nconst int N = 100005, M = 21;\n\nstruct node {\n    node *l, *r;\n    ll x;\n    ll sh;\n    node() {\n        l = r = NULL;\n        x = 0;\n        sh = 0;\n    }\n    void shplit () {\n        if (l == NULL)\n            l = new node();\n        if (r == NULL)\n            r = new node();\n        l->x += sh;\n        l->sh += sh;\n        r->x += sh;\n        r->sh += sh;\n        sh = 0;\n    }\n};\n\nnode *root[N];\n\nint L, R;\nll X;\n\nvoid update (node *&t, int l, int r){\n    if (t == NULL)\n        t = new node();\n    if (max (l, L) >= min (r, R))\n        return;\n    if (L <= l && r <= R){\n        t->sh += X;\n        t->x += X;\n        return;\n    }\n    t->shplit();\n    int mid = l + r >> 1;\n    update (t->l, l, mid);\n    update (t->r, mid, r);\n    t->x = max (t->l->x, t->r->x);\n}\n\nll datvla (node *&t, int l, int r){\n    if (t == NULL)\n        t = new node();\n    if (max (l, L) >= min (r, R))\n        return 0;\n    if (L <= l && r <= R)\n        return t->x;\n    t->shplit();\n    int mid = l + r >> 1;\n    ll x = datvla (t->l, l, mid);\n    ll y = datvla (t->r, mid, r);\n    //t->x = max (t->l->x, t->r->x);\n    return max (x, y);\n}\n\n\nll n, Q, W;\n\nint A[N], B[N];\nll C[N];\n\nvector < int > g[N];\nint TURN;\n\nint st[M][N], in[M][N], out[M][N], par[M][N];\n\nint S[N];\n\nmultiset < ll > Se[N];\nmultiset < ll > ANS;\nll pas[N], ans[M][N];\n\nbool F[N];\n\nvoid dfs_sz (ll k, ll p){\n    S[k] = 1;\n    for (ll u : g[k]){\n        if (F[u] == 1 || u == p)\n            continue;\n        dfs_sz (u, k);\n        S[k] += S[u];\n    }\n}\n\nll find_centroid (ll k, ll p, ll x){\n    for (ll u : g[k]){\n        if (F[u] == 1 || u == p)\n            continue;\n        ll to = find_centroid (u, k, x);\n        if (to)\n            return to;\n    }\n    if (S[k] > x)\n        return k;\n    return 0;\n}\n\nll T = 0;\n\nll parent (ll k, ll p, ll star, ll papa){\n    in[TURN][k] = ++T;\n    if (papa == 0 && k != star)\n        papa = k;\n    st[TURN][k] = star;\n    par[TURN][k] = papa;\n    for (ll u : g[k]){\n        if (u == p || F[u] == 1)\n            continue;\n        parent (u, k, star, papa);\n    }\n    out[TURN][k] = T;\n}\n\nvoid go (int k, int turn){\n    TURN = turn;\n    dfs_sz (k, 0);\n    int to = find_centroid (k, 0, S[k] / 2);\n    k = to;\n    T = 0;\n    parent (k, 0, k, 0);\n    for (int i = 0; i < g[k].size(); i++){\n        int u = g[k][i];\n        if (F[u])\n            continue;\n        Se[k].insert (0);\n    }\n    F[k] = 1;\n    TURN = 0;\n    for (int i = 0; i < g[k].size(); i++){\n        int u = g[k][i];\n        if (F[u])\n            continue;\n        go (u, turn + 1);\n    }\n}\n\nvoid shecvla (ll d, ll e){\n    ll u = A[d], v = B[d], f = C[d];\n    ll delta = e - f;\n    for (int i = 1; ;i++){\n        if (st[i][u] != st[i][v])\n            break;\n        int START = st[i][u];\n        if (START == 0)\n            break;\n        if (in[i][u] > in[i][v])\n            swap (u, v);\n        int papa = par[i][v];\n        auto I = Se[START].find (ans[i][papa]);\n        Se[START].erase (I);\n        L = in[i][v];\n        R = out[i][v] + 1;\n        X = delta;\n        update (root[START], 1, out[i][START] + 1);\n        L = in[i][papa];\n        R = out[i][papa] + 1;\n        ans[i][papa] = datvla (root[START], 1, out[i][START] + 1);\n        Se[START].insert (ans[i][papa]);\n        if ((ll)Se[START].size() > 1){\n            I = Se[START].end();\n            I--;\n            ll p1 = (*I);\n            I--;\n            ll p2 = (*I);\n            I = ANS.find (pas[START]);\n            ANS.erase (I);\n            pas[START] = p1 + p2;\n            ANS.insert (pas[START]);\n        }\n    }\n    C[d] = e;\n}\n\n\nmain()\n{\n    //freopen (\"in.txt\", \"r\", stdin);freopen (\"out.txt\", \"w\", stdout);\n    //ios_base::sync_with_stdio(0);\n    cin >> n >> Q >> W;\n    if (n == 2){\n        cin >> A[1] >> B[1] >> C[1];\n        ll last = 0;\n        while (Q--){\n            ll d, e;\n            scanf (\"%lld %lld\", &d, &e);\n            d = (d + last) % (n - 1);\n            e = (e + last) % W;\n            last = e;\n            cout << last << endl;\n        }\n        return 0;\n    }\n    for (ll i = 0; i < n - 1; i++){\n        int u, v;\n        ll x;\n        scanf (\"%d %d %lld\", &u, &v, &x);\n        A[i] = u;\n        B[i] = v;\n        C[i] = x;\n        g[u].pb (v);\n        g[v].pb (u);\n    }\n    for (ll i = 1; i <= n; i++)\n        ANS.insert (0);\n    go (1, 1);\n    for (ll i = 0; i < n - 1; i++){\n        ll x = C[i];\n        C[i] = 0;\n        shecvla (i, x);\n    }\n    ll last = 0;\n    while (Q--){\n        ll d, e;\n        scanf (\"%lld %lld\", &d, &e);\n        d = (d + last) % (n - 1);\n        e = (e + last) % W;\n        shecvla (d, e);\n        auto I = ANS.end();\n        I--;\n        last = (*I);\n        printf (\"%lld\\n\", last);\n    }\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57800541": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nint N, Q, num;\nint X[101010], L[101010], R[101010];\nLL W[101010], K, ans;\nvector<pii> adj[101010];\n\nstruct Node{\n\tLL P=0, M=0, lazy=0;\n\tLL LM=0, MR=0, LMR=0;\n\n\tNode operator+=(const LL &r){\n\t\tP += r, M -= 2*r;\n\t\tLM -= r, MR -= r, lazy += r;\n\t}\n\tNode operator+(const Node &r)const{\n\t\tNode ret;\n\t\tret.P = max(P, r.P);\n\t\tret.M = max(M, r.M);\n\t\tret.LM = max(LM, r.LM);\n\t\tret.LM = max(ret.LM, P + r.M);\n\t\tret.MR = max(MR, r.MR);\n\t\tret.MR = max(ret.MR, M + r.P);\n\t\tret.LMR = max(LMR, r.LMR);\n\t\tret.LMR = max(ret.LMR, LM + r.P);\n\t\tret.LMR = max(ret.LMR, P + r.MR);\n\t\treturn ret;\n\t}\n} T[808080];\n\nvoid update(int id, int s, int e, int ts, int te, LL v){\n\tif (e < ts || te < s) return;\n\tif (ts <= s && e <= te){\n\t\tT[id] += v;\n\t\treturn;\n\t}\n\tT[id*2] += T[id].lazy;\n\tT[id*2+1] += T[id].lazy;\n\tT[id].lazy = 0;\n\n\tint mid = (s+e)/2;\n\tupdate(id*2, s, mid, ts, te, v);\n\tupdate(id*2+1, mid+1, e, ts, te, v);\n\tT[id] = T[id*2] + T[id*2+1];\n}\n\nvoid dfs(int u, int p){\n\tL[u] = ++num;\n\tfor (pii v : adj[u]){\n\t\tif (v.first == p) continue;\n\t\tX[v.second] = v.first;\n\t\tdfs(v.first, u);\n\t\t++num;\n\t}\n \tR[u] = num;\n}\n\nint main(){\n\tscanf(\"%d %d %lld\", &N, &Q, &K);\n\tfor (int i=1; i<N; i++){\n\t\tint u, v;\n\t\tscanf(\"%d %d %lld\", &u, &v, &W[i]);\n\t\tadj[u].push_back(pii(v, i));\n\t\tadj[v].push_back(pii(u, i));\n\t}\n\tdfs(1, 0);\n\tfor (int i=1; i<N; i++) update(1, 1, 2*N, L[X[i]], R[X[i]], W[i]);\n\twhile (Q--){\n\t\tLL k, w;\n\t\tscanf(\"%lld %lld\", &k, &w);\n\t\tk = (k + ans) % (N-1) + 1;\n\t\tw = (w + ans) % K;\n\n\t\tupdate(1, 1, 2*N, L[X[k]], R[X[k]], w-W[k]);\n\t\tW[k] = w, ans = T[1].LMR;\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57800171": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=1e5+5;\nconst LL F=-2e18;\nint n,q,hd[N],V[N*2],nx[N*2],X[N],Y[N],fa[N],sz[N],son[N],top[N],id[N],df[N],tt,fr[N];\nLL w,W[N*2],ans,Z[N],f[N],g[N],h[N],s[N],hs[N],lk[N];\nmultiset<LL>sf[N],sg[N];\nmultiset<LL>::iterator it;\nstruct O{LL a[3][3];}t[N*4],C,ret;\nO hb(O A,O B){\n\tfor (int i=0;i<3;i++)\n\t\tfor (int j=0;j<3;j++){\n\t\t\tC.a[i][j]=F;\n\t\t\tfor (int k=0;k<3;k++)\n\t\t\t\tC.a[i][j]=max(C.a[i][j],A.a[i][k]+B.a[k][j]);\n\t\t}\n\treturn C;\n}\n#define Ls k<<1\n#define Rs k<<1|1\n#define mid ((l+r)>>1)\nvoid build(int k,int l,int r){\n\tif (l==r){\n\t\tint x=df[l];\n\t\tt[k].a[0][0]=hs[x];\n\t\tt[k].a[0][2]=h[x];\n\t\tt[k].a[1][0]=h[x]+hs[x];\n\t\tt[k].a[1][2]=s[x];\n\t\tt[k].a[0][1]=t[k].a[2][0]=t[k].a[2][1]=F;\n\t\treturn;\n\t}\n\tbuild(Ls,l,mid);build(Rs,mid+1,r);\n\tt[k]=hb(t[Ls],t[Rs]);\n}\nvoid update_hsw(int k,int l,int r,int x,LL v){\n\tif (l==r){\n\t\tt[k].a[0][0]+=v;t[k].a[1][0]+=v;return;\n\t}\n\tif (mid>=x) update_hsw(Ls,l,mid,x,v);\n\telse update_hsw(Rs,mid+1,r,x,v);\n\tt[k]=hb(t[Ls],t[Rs]);\n}\nO query(int k,int l,int r,int L,int R){\n\tif (L==l && r==R) return t[k];\n\tif (mid>=R) return query(Ls,l,mid,L,R);\n\tif (mid<L) return query(Rs,mid+1,r,L,R);\n\treturn hb(query(Ls,l,mid,L,mid),query(Rs,mid+1,r,mid+1,R));\n}\nvoid update_sah(int k,int l,int r,int x){\n\tif (l==r){\n\t\tt[k].a[0][2]=h[x];\n\t\tt[k].a[1][0]=h[x]+hs[x];\n\t\tt[k].a[1][2]=s[x];\n\t\treturn;\n\t}\n\tif (mid>=id[x]) update_sah(Ls,l,mid,x);\n\telse update_sah(Rs,mid+1,r,x);\n\tt[k]=hb(t[Ls],t[Rs]);\n}\nvoid add(int u,int v,LL z){\n\tnx[++tt]=hd[u];V[hd[u]=tt]=v;W[tt]=z;\n}\nvoid dfs(int x){\n\tsz[x]=1;LL z=0;\n\tfor (int v,i=hd[x];i;i=nx[i])\n\t\tif ((v=V[i])!=fa[x]){\n\t\t\tfa[v]=x;lk[v]=W[i];\n\t\t\tdfs(v);sz[x]+=sz[v];\n\t\t\tif (sz[v]>sz[son[x]])\n\t\t\t\tson[x]=v,z=W[i];\n\t\t}\n\tfor (int v,i=hd[x];i;i=nx[i])\n\t\tif ((v=V[i])!=fa[x] && v!=son[x]){\n\t\t\ts[x]=max(s[x],f[v]);\n\t\t\ts[x]=max(s[x],g[v]+W[i]+h[x]);\n\t\t\th[x]=max(h[x],g[v]+W[i]);\n\t\t\tsf[x].insert(f[v]);\n\t\t\tsg[x].insert(g[v]+W[i]);\n\t\t}\n\tg[x]=max(h[x],g[son[x]]+z);hs[x]=z;\n\tf[x]=max(s[x],max(f[son[x]],h[x]+g[son[x]]+z));\n}\nint dfs(int x,int tp){\n\ttop[x]=tp;df[id[x]=++tt]=x;int Id=tt;\n\tif (son[x]) Id=dfs(son[x],tp);\n\tfor (int i=hd[x];i;i=nx[i])\n\t\tif (V[i]!=fa[x] && V[i]!=son[x])\n\t\t\tfr[V[i]]=dfs(V[i],V[i]);\n\treturn Id;\n}\nvoid work(int u,int v,LL z,LL &y){\n\tif (fa[u]==v) swap(u,v);lk[v]=z;\n\tint x=u;bool J=0;LL fv,gv;\n\tif (son[u]==v) J=1,hs[u]=z;\n\telse{\n\t\tret=query(1,1,n,id[v],fr[v]);\n\t\tgv=max(ret.a[0][0],max(ret.a[0][1],ret.a[0][2]));\n\t\tit=sg[u].lower_bound(gv+y);\n\t\tsg[u].erase(it);sg[u].insert(gv+z);\n\t\tit=sf[u].end(),it--,s[u]=*it;\n\t\tit=sg[u].end(),it--,s[u]=max(s[u],h[u]=*it);\n\t\tif (it!=sg[u].begin())\n\t\t\tit--,s[u]=max(s[u],h[u]+*it);\n\t}\n\tv=top[u];u=fa[v];\n\twhile(u){\n\t\tret=query(1,1,n,id[v],fr[v]);\n\t\tfv=max(ret.a[1][0],max(ret.a[1][1],ret.a[1][2]));\n\t\tgv=max(ret.a[0][0],max(ret.a[0][1],ret.a[0][2]));\n\t\tit=sf[u].lower_bound(fv);sf[u].erase(it);\n\t\tit=sg[u].lower_bound(gv+lk[v]);sg[u].erase(it);\n\t\tif (J) update_hsw(1,1,n,id[x],z-y),J=0;\n\t\telse update_sah(1,1,n,x);ret=query(1,1,n,id[v],fr[v]);\n\t\tfv=max(ret.a[1][0],max(ret.a[1][1],ret.a[1][2]));\n\t\tgv=max(ret.a[0][0],max(ret.a[0][1],ret.a[0][2]));\n\t\tsf[u].insert(fv);sg[u].insert(gv+lk[v]);\n\t\tit=sf[u].end(),it--,s[u]=*it;\n\t\tit=sg[u].end(),it--,s[u]=max(s[u],h[u]=*it);\n\t\tif (it!=sg[u].begin())\n\t\t\tit--,s[u]=max(s[u],h[u]+*it);\n\t\tv=top[x=u];u=fa[v];\n\t}\n\tif (J) update_hsw(1,1,n,id[x],z-y);\n\telse update_sah(1,1,n,x);y=z;\n\tret=query(1,1,n,id[1],fr[1]);\n\tans=max(ret.a[1][0],max(ret.a[1][1],ret.a[1][2]));\n\tprintf(\"%I64d\\n\",ans);\n}\nint main(){\n\tscanf(\"%d%d%I64d\",&n,&q,&w);\n\tfor (int i=0;i<n-1;i++)\n\t\tscanf(\"%d%d%I64d\",&X[i],&Y[i],&Z[i]),\n\t\tadd(X[i],Y[i],Z[i]),add(Y[i],X[i],Z[i]);\n\ttt=0;dfs(1);fr[1]=dfs(1,1);build(1,1,n);\n\tLL e;for (int d;q--;){\n\t\tscanf(\"%d%I64d\",&d,&e);\n\t\td=1ll*(ans+d)%(n-1);\n\t\twork(X[d],Y[d],(ans+e)%w,Z[d]);\n\t}\n\treturn 0;\n}\n",
    "ext": "cpp"
  },
  "57799151": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace fastIO{\n\t#define BUF_SIZE 100000\n\t#define OUT_SIZE 100000\n\t//fread->read\n\tbool IOerror=0;\n//  inline char nc(){char ch=getchar();if(ch==-1)IOerror=1;return ch;}\n\tinline char nc(){\n\t\tstatic char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;\n\t\tif(p1==pend){\n\t\t\tp1=buf;pend=buf+fread(buf,1,BUF_SIZE,stdin);\n\t\t\tif(pend==p1){IOerror=1;return -1;}\n\t\t}\n\t\treturn *p1++;\n\t}\n\tinline bool blank(char ch){return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t';}\n\ttemplate<class T> inline bool read(T &x){\n\t\tbool sign=0;char ch=nc();x=0;\n\t\tfor(;blank(ch);ch=nc());\n\t\tif(IOerror)return false;\n\t\tif(ch=='-')sign=1,ch=nc();\n\t\tfor(;ch>='0'&&ch<='9';ch=nc())x=x*10+ch-'0';\n\t\tif(sign)x=-x;\n\t\treturn true;\n\t}\n\tinline bool read(double &x){\n\t\tbool sign=0;char ch=nc();x=0;\n\t\tfor(;blank(ch);ch=nc());\n\t\tif(IOerror)return false;\n\t\tif(ch=='-')sign=1,ch=nc();\n\t\tfor(;ch>='0'&&ch<='9';ch=nc())x=x*10+ch-'0';\n\t\tif(ch=='.'){\n\t\t\tdouble tmp=1; ch=nc();\n\t\t\tfor(;ch>='0'&&ch<='9';ch=nc())tmp/=10.0,x+=tmp*(ch-'0');\n\t\t}\n\t\tif(sign)x=-x;\n\t\treturn true;\n\t}\n\tinline bool read(char *s){\n\t\tchar ch=nc();\n\t\tfor(;blank(ch);ch=nc());\n\t\tif(IOerror)return false;\n\t\tfor(;!blank(ch)&&!IOerror;ch=nc())*s++=ch;\n\t\t*s=0;\n\t\treturn true;\n\t}\n\tinline bool read(char &c){\n\t\tfor(c=nc();blank(c);c=nc());\n\t\tif(IOerror){c=-1;return false;}\n\t\treturn true;\n\t}\n\ttemplate<class T,class... U>bool read(T& h,U&... t){return read(h)&&read(t...);}\n\t#undef OUT_SIZE\n\t#undef BUF_SIZE\n};\nusing namespace fastIO;\n/************* debug begin *************/\nstring to_string(string s){return '\"'+s+'\"';}\nstring to_string(const char* s){return to_string((string)s);}\nstring to_string(const bool& b){return(b?\"true\":\"false\");}\ntemplate<class T>string to_string(T x){ostringstream sout;sout<<x;return sout.str();}\ntemplate<class A,class B>string to_string(pair<A,B> p){return \"(\"+to_string(p.first)+\", \"+to_string(p.second)+\")\";}\ntemplate<class A>string to_string(const vector<A> v){\n\tint f=1;string res=\"{\";for(const auto x:v){if(!f)res+= \", \";f=0;res+=to_string(x);}res+=\"}\";\n\treturn res;\n}\nvoid debug_out(){puts(\"\");}\ntemplate<class T,class... U>void debug_out(const T& h,const U&... t){cout<<\" \"<<to_string(h);debug_out(t...);}\n#ifdef tokitsukaze\n#define debug(...) cout<<\"[\"<<#__VA_ARGS__<<\"]:\",debug_out(__VA_ARGS__);\n#else\n#define debug(...) 233;\n#endif\n/*************  debug end  *************/\n#define mem(a,b) memset((a),(b),sizeof(a))\n#define MP make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(x) (int)x.size()\n#define all(x) x.begin(),x.end()\n#define sqr(x) (x)*(x)\nusing namespace __gnu_cxx;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\ntypedef pair<int,ll> PIL;\ntypedef pair<ll,int> PLI;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\n/************* define end  *************/\nvoid read(int *x,int l,int r){for(int i=l;i<=r;i++) read(x[i]);}\nvoid read(ll *x,int l,int r){for(int i=l;i<=r;i++) read(x[i]);}\nvoid read(double *x,int l,int r){for(int i=l;i<=r;i++) read(x[i]);}\nvoid println(VI x){for(int i=0;i<sz(x);i++) printf(\"%d%c\",x[i],\" \\n\"[i==sz(x)-1]);}\nvoid println(VL x){for(int i=0;i<sz(x);i++) printf(\"%lld%c\",x[i],\" \\n\"[i==sz(x)-1]);}\nvoid println(int *x,int l,int r){for(int i=l;i<=r;i++) printf(\"%d%c\",x[i],\" \\n\"[i==r]);}\nvoid println(ll *x,int l,int r){for(int i=l;i<=r;i++) printf(\"%lld%c\",x[i],\" \\n\"[i==r]);}\n/*************** IO end  ***************/\nvoid go();\nint main(){\n\t#ifdef tokitsukaze\n\t\tfreopen(\"TEST.txt\",\"r\",stdin);\n\t#endif\n\tgo();return 0;\n}\nconst int INF=0x3f3f3f3f;\nconst ll LLINF=0x3f3f3f3f3f3f3f3fLL;\nconst double PI=acos(-1.0);\nconst double eps=1e-8;\nconst int MAX=1e5+10;\nconst int mod=1e9+7;\n/*********************************  head  *********************************/\nstruct LCA\n{\n\t#define type int\n\tstruct node{int to;type w;node(){}node(int _to,type _w):to(_to),w(_w){}};\n\ttype dis[MAX];\n\tint path[2*MAX],deep[2*MAX],first[MAX],len[MAX],tot,n;\n\tint dp[2*MAX][22];\n\tvector<node> mp[MAX];\n\tvoid dfs(int x,int pre,int h)\n\t{\n\t\tint i;\n\t\tpath[++tot]=x;\n\t\tfirst[x]=tot;\n\t\tdeep[tot]=h;\n\t\tfor(i=0;i<mp[x].size();i++)\n\t\t{\n\t\t\tint to=mp[x][i].to;\n\t\t\tif(to==pre) continue;\n\t\t\tdis[to]=dis[x]+mp[x][i].w;\n\t\t\tlen[to]=len[x]+1;\n\t\t\tdfs(to,x,h+1);\n\t\t\tpath[++tot]=x;\n\t\t\tdeep[tot]=h;\n\t\t}\n\t}\n\tvoid ST(int n)\n\t{\n\t\tint i,j,x,y;\n\t\tfor(i=1;i<=n;i++) dp[i][0]=i;\n\t\tfor(j=1;(1<<j)<=n;j++)\n\t\t{\n\t\t\tfor(i=1;i+(1<<j)-1<=n;i++)\n\t\t\t{\n\t\t\t\tx=dp[i][j-1];\n\t\t\t\ty=dp[i+(1<<(j-1))][j-1];\n\t\t\t\tdp[i][j]=deep[x]<deep[y]?x:y;\n\t\t\t}\n\t\t}\n\t}\n\tint query(int l,int r)\n\t{\n\t\tint len,x,y;\n\t\tlen=(int)log2(r-l+1); \n\t\tx=dp[l][len];\n\t\ty=dp[r-(1<<len)+1][len];\n\t\treturn deep[x]<deep[y]?x:y;\n\t}\n\tint lca(int x,int y)\n\t{\n\t\tint l,r,pos;\n\t\tl=first[x];\n\t\tr=first[y];\n\t\tif(l>r) swap(l,r);\n\t\tpos=query(l,r);\n\t\treturn path[pos];\n\t} \n\ttype get_dis(int a,int b){return dis[a]+dis[b]-2*dis[lca(a,b)];}\n\tint get_len(int a,int b){return len[a]+len[b]-2*len[lca(a,b)];}\n\tvoid init(int _n)\n\t{\n\t\tn=_n;\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tdis[i]=0;\n\t\t\tlen[i]=0;\n\t\t\tmp[i].clear();\n\t\t}\n\t}\n\tvoid add_edge(int a,int b,type w=1)\n\t{\n\t\tmp[a].pb(node(b,w));\n\t\tmp[b].pb(node(a,w));\n\t}\n\tvoid work(int rt)\n\t{\n\t\ttot=0;\n\t\tdfs(rt,0,0);\n\t\tST(2*n-1);\n\t}\n\t#undef type\n}lca;\nstruct Fenwick_Tree\n{\n\t#define type ll\n\ttype bit[MAX][2];\n\tint n;\n\tvoid init(int _n){n=_n;mem(bit,0);}\n\tint lowbit(int x){return x&(-x);}\n\tvoid insert(int x,type v)\n\t{\n\t\tfor(int i=x;i<=n;i+=lowbit(i))\n\t\t{\n\t\t\tbit[i][0]+=v;\n\t\t\tbit[i][1]+=v*(x-1);\n\t\t}\n\t}\n\tvoid upd(int l,int r,type v)\n\t{\n\t\tinsert(l,v);\n\t\tinsert(r+1,-v);\n\t}\n\ttype get(int x)\n\t{\n\t\ttype res=0;\n\t\tfor(int i=x;i;i-=lowbit(i))\n\t\t{\n\t\t\tres+=x*bit[i][0]-bit[i][1];\n\t\t}\n\t\treturn res;\n\t}\n\ttype ask(int l,int r)\n\t{\n\t\treturn get(r)-get(l-1);\n\t}\n\t#undef type\n}bit;\nint l[MAX],r[MAX],dfn[MAX],eid[MAX],tot;\nll val[MAX];\nstruct edge{int to;ll w;int id;};\nvector<edge> mp[MAX];\nvoid dfs(int x,int fa,ll now)\n{\n\tl[x]=++tot;\n\tdfn[tot]=x;\n//\tdebug(x,tot)\n\tbit.upd(l[x],l[x],now);\n\tfor(auto to:mp[x])\n\t{\n\t\tif(to.to==fa) continue;\n\t\tval[to.to]=to.w;\n\t\teid[to.id]=to.to;\n\t\tdfs(to.to,x,now+to.w);\n\t}\n\tr[x]=tot;\n}\nstruct Segment_Tree\n{\n\t#define type ll\n\t#define ls (id<<1)\n\t#define rs (id<<1|1)\n\tint n,ql,qr;\n\ttype v[MAX<<2],qv,tag[MAX<<2];\n\tPII node[MAX<<2];\n\tvoid up(type &mx,PII &res,int a,int b)\n\t{\n\t\tint lc=lca.lca(dfn[a],dfn[b]);\n\t//\tdebug(dfn[a],dfn[b],lc,l[lc])\n\t\ttype tmp=bit.ask(a,a)+bit.ask(b,b)-2*bit.ask(l[lc],l[lc]);\n\t//\tdebug(dfn[a],dfn[b],lc,tmp)\n\t//\tdebug(a,bit.ask(a,a))\n\t//\tdebug(b,bit.ask(b,b))\n\t//\tdebug(l[lc],bit.ask(l[lc],l[lc]))\n\t\tif(tmp>mx)\n\t\t{\n\t\t\tmx=tmp;\n\t\t\tres=MP(a,b);\n\t\t}\n\t}\n\tvoid pushup(int id)\n\t{\n\t\tv[id]=0;\n\t\tup(v[id],node[id],node[ls].fi,node[rs].fi);\n\t\tup(v[id],node[id],node[ls].fi,node[rs].se);\n\t\tup(v[id],node[id],node[ls].se,node[rs].fi);\n\t\tup(v[id],node[id],node[ls].se,node[rs].se);\n\t\tup(v[id],node[id],node[ls].fi,node[ls].se);\n\t\tup(v[id],node[id],node[rs].fi,node[rs].se);\n\t}\n\tvoid pushdown(int id)\n\t{\n\t\tif(!tag[id]) return;\n\t\tv[ls]+=tag[id];\n\t\tv[rs]+=tag[id];\n\t\ttag[ls]+=tag[id];\n\t\ttag[rs]+=tag[id];\n\t\ttag[id]=0;\n\t}\n\tvoid build(int l,int r,int id)\n\t{\n\t\ttag[id]=0;\n\t\tif(l==r)\n\t\t{\n\t\t\tv[id]=0;\n\t\t\tnode[id]=MP(l,l);\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tbuild(l,mid,ls);\n\t\tbuild(mid+1,r,rs);\n\t\tpushup(id);\n\t}\n\tvoid update(int l,int r,int id)\n\t{\n\t\tif(l>=ql&&r<=qr)\n\t\t{\n\t\t\tv[id]+=qv;\n\t\t\ttag[id]+=qv;\n\t\t\treturn;\n\t\t}\n\t\tpushdown(id);\n\t\tint mid=(l+r)>>1;\n\t\tif(ql<=mid) update(l,mid,ls);\n\t\tif(qr>mid) update(mid+1,r,rs);\n\t\tpushup(id);\n\t}\n\tvoid build(int _n){n=_n;build(1,n,1);}\n\tvoid upd(int x,type v)\n\t{\n\t\tbit.upd(l[x],r[x],v-val[x]);\n\t\tql=l[x];\n\t\tqr=r[x];\n\t\tqv=v-val[x];\n\t\tupdate(1,n,1);\n\t\tval[x]=v;\n\t}\n\t#undef type\n\t#undef ls\n\t#undef rs\n}tr;\nvoid go()\n{\n\tint n,q,i,a,b;\n\tll p,w,ans;\n\twhile(read(n,q,p))\n\t{\n\t\tfor(i=1;i<=n;i++) mp[i].clear();\n\t\tlca.init(n);\n\t\tfor(i=0;i<n-1;i++)\n\t\t{\n\t\t\tread(a,b,w);\n\t\t\tmp[a].pb(edge{b,w,i});\n\t\t\tmp[b].pb(edge{a,w,i});\n\t\t\tlca.add_edge(a,b);\n\t\t}\n\t\tlca.work(1);\n\t\ttot=0;\n\t\tval[1]=0;\n\t\tbit.init(n);\n\t\tdfs(1,0,0);\n\t\ttr.build(n);\n\t\tans=0;\n\t//\tdebug(tr.v[1])\n\t\twhile(q--)\n\t\t{\n\t\t\tread(a,w);\n\t\t\ta=(a+ans)%(n-1);\n\t\t\tw=(w+ans)%p;\n\t\t\ttr.upd(eid[a],w);\n\t\t\tans=tr.v[1];\n\t\t\tprintf(\"%lld\\n\",ans);\n\t\t}\n\t}\n}\n/*\n10 1 10000\n1 9 1\n1 10 1\n10 4 1\n10 5 1\n10 7 1\n5 6 1\n5 3 1\n6 2 1\n3 8 1\n2 100\n*/\n",
    "ext": "cpp"
  },
  "57795056": {
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pll;\ntypedef vector<pi> vpi;\ntypedef vector<pll> vpll;\ntypedef vector<vpll> vvpll;\ntypedef vector<int> vi;\n\nstruct SegmentTree {\n\n  vector<ll> T, lazy;\n  int n;\n\n  SegmentTree() {\n    n = 0;\n  }\n\n  SegmentTree(int _n) {\n    n = _n;\n    T = lazy = vector<ll>(4*(n+1), 0);\n  }\n\n  void add(int pos0, int pos1, ll val) {\n    fes(1, 0, n, pos0, pos1, val);\n  }\n\n  ll ask(int pos0, int pos1) {\n    return que(1, 0, n, pos0, pos1);\n  }\n\n  void actu(int node, bool b) {\n    T[node] += lazy[node];\n    if (b) {\n      lazy[2*node] += lazy[node];\n      lazy[2*node+1] += lazy[node];\n    }\n    lazy[node] = 0;\n  }\n\n  void fes(int node, int a, int b, int x, int y, ll val) {\n    actu(node, a != b);\n    if (b < x or y < a) return;\n    if (x <= a and b <= y) {\n      lazy[node] = val;\n      actu(node, a != b);\n      return;\n    }\n    int mid = (a+b)/2;\n    fes(2*node, a, mid, x, y, val);\n    fes(2*node+1, 1+mid, b, x, y, val);\n    T[node] = max(T[2*node], T[2*node+1]);\n  }\n\n  ll que(int node, int a, int b, int x, int y) {\n    actu(node, a != b);\n    if (b < x or y < a) return 0;\n    if (x <= a and b <= y) return T[node];\n    int mid = (a+b)/2;\n    return max(\n        que(2*node, a, mid, x, y),\n        que(2*node+1, 1+mid, b, x, y));\n  }\n\n};\n\nstruct block {\n\n  SegmentTree tree;\n  unordered_map<int,pi> A;\n  \n  vector<block*> sons;\n  multiset<ll> diameters;\n  multiset<ll> radials;\n  vi sonsnodes;\n  vpll sonsvalues;\n\n  block* parent;\n  int ind;\n  int depth;\n\n  ll diameter;\n\n  int dfs1(int x, vi& V, vvpll& G) {\n    V[x] = 1;\n    for (auto it : G[x]) {\n      int y = (int)it.first;\n      if (V[y] == 0) {\n        V[x] += dfs1(y, V, G);\n      }\n    }\n    return V[x];\n  }\n\n  int dfs2(int x, vi& V, vvpll& G, int n) {\n    V[x] = -1;\n    for (auto it : G[x]) {\n      int y = (int)it.first;\n      if (V[y] > 0 and 2*V[y] >= n) \n        return dfs2(y, V, G, n);\n    }\n    return x;\n  }\n\n  void dfs3(int x, vi& V, vvpll& G, int& cont, ll val) {\n    A[x].first = cont++;\n    V[x] = 0;\n    for (auto it : G[x]) {\n      int y = (int)it.first;\n      ll w = it.second;\n      if (V[y] != 0 and V[y] != -2) dfs3(y, V, G, cont, w);\n    }\n    A[x].second = cont;\n    tree.add(A[x].first, A[x].second-1, val);\n  }\n\n  void calc_diameter() {\n    diameter = 0;\n    if (sons.size()) {\n      diameter = max(diameter, -(*diameters.begin()));\n      diameter = max(diameter, -(*radials.begin()));\n    }\n    if (sons.size() >= 2) {\n      auto it1 = radials.begin();\n      auto it2 = it1; ++it2;\n      ll val = *it1 + *it2;\n      diameter = max(diameter, -val);\n    }\n  }\n\n  void print() {\n    cerr << \"Block :\";\n    for (auto it : A) {\n      cerr << ' ' << it.first;\n    }\n    cerr << endl;\n    cerr << \"diameter = \" << diameter << endl;\n    for (int i = 0; i < (int)sonsnodes.size(); ++i) {\n      cerr << sonsnodes[i] << \" -> (\" << sonsvalues[i].first << \", \" << sonsvalues[i].second << \")\" << endl;\n    }\n    cerr << endl;\n  }\n\n  block(block* _parent, int _ind, int _depth, vvpll& G, vi& V, int x, vector<block*>& B) {\n    parent = _parent;\n    ind = _ind;\n    depth = _depth;\n\n    int n = dfs1(x, V, G);\n    x = dfs2(x, V, G, n);\n    tree = SegmentTree(n);\n    int cont = 0;\n    dfs3(x, V, G, cont, 0);\n\n    V[x] = -2;\n    B[x] = this;\n    for (auto it : G[x]) {\n      int y = (int)it.first;\n      if (V[y] == 0) {\n        block* b = new block(this, (int)sons.size(), depth + 1, G, V, y, B);\n        sons.push_back(b);\n        sonsnodes.push_back(y);\n        sonsvalues.push_back(pll(b->diameter, tree.ask(A[y].first, A[y].second-1))); \n        diameters.insert(-sonsvalues.back().first);\n        radials.insert(-sonsvalues.back().second);\n      }\n    }\n    calc_diameter();\n  }\n\n  ~block() {\n    for (auto s : sons) delete s;\n  }\n\n  ll query(int x, int y, ll val, int index) {\n    if (A[y].first <= A[x].first and A[x].second <= A[y].second) swap(x,y);\n    tree.add(A[y].first, A[y].second-1, val);\n\n    auto itd = diameters.find(-sonsvalues[index].first);\n    diameters.erase(itd);\n    sonsvalues[index].first = sons[index]->diameter;\n    diameters.insert(-sonsvalues[index].first);\n\n    auto itr = radials.find(-sonsvalues[index].second);\n    radials.erase(itr);\n    sonsvalues[index].second = tree.ask(A[sonsnodes[index]].first, A[sonsnodes[index]].second-1);\n    radials.insert(-sonsvalues[index].second);\n\n    calc_diameter();\n    if (parent != nullptr) {\n      return max(diameter, parent->query(x, y, val, ind));\n    }\n    return diameter;\n  }\n\n};\n\nstruct aresta {\n  int x, y;\n  ll c;\n  aresta() {}\n  aresta(int _x, int _y, ll _c) : x(_x), y(_y), c(_c) {}\n};\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, q;\n  ll w;\n  cin >> n >> q >> w;\n\n  vvpll G(n);\n  vector<aresta> M(n-1);\n\n  for (int i = 0; i < n-1; ++i) {\n    int x, y;\n    ll c;\n    cin >> x >> y >> c;\n    --x; --y;\n    G[x].push_back({y, c});\n    G[y].push_back({x, c});\n    M[i] = aresta(x,y,c);\n  }\n\n  vi V(n, 0);\n  vector<block*> B(n);\n\n  block* root = new block(nullptr, -1, 0, G, V, 0, B); \n\n  ll last = 0;\n\n  while (q--) {\n    ll ind, c;\n    cin >> ind >> c;\n    \n    ind = (ind + last)%(n-1);\n    c = (c + last)%w;\n\n    ll val = c - M[ind].c;\n    M[ind].c = c;\n\n    int x = M[ind].x;\n    int y = M[ind].y;\n    int index = -1;\n    if (B[x]->depth > B[y]->depth) swap(x,y);\n    auto blocky = B[y];\n    while (B[x]->depth < blocky->depth) {\n      index = blocky->ind;\n      blocky = blocky->parent;\n    }\n\n    last = blocky->query(x, y, val, index);\n    cout << last << '\\n';\n  }\n  \n  delete root;\n}\n",
    "ext": "cpp"
  },
  "57794839": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\nusing lint = long long;\nusing pi = pair<int, int>;\n \nstruct edg{\n\tint pos; lint cst;\n\tint idx;\n};\n \nint n, q; lint w;\nvector<edg> gph[MAXN];\nvector<int> updList[MAXN];\nbool vis[MAXN];\n\nstruct segtree{\n\tvector<lint> tree, lazy;\n\tint lim;\n\tvoid init(int n){\n\t\tfor(lim = 1; lim <= n; lim <<= 1);\n\t\ttree.resize(2 * lim);\n\t\tlazy.resize(2 * lim);\n\t}\n\tvoid lazydown(int p){\n\t\tlint cur = lazy[p]; lazy[p] = 0;\n\t\tfor(int j=0; j<2; j++){\n\t\t\tlazy[2*p+j] += cur;\n\t\t\ttree[2*p+j] += cur;\n\t\t}\n\t}\n\tvoid add(int s, int e, int ps, int pe, int p, lint v){\n\t\tif(e < ps || pe < s) return;\n\t\tif(s <= ps && pe <= e){\n\t\t\ttree[p] += v;\n\t\t\tlazy[p] += v;\n\t\t\treturn;\n\t\t}\n\t\tint pm = (ps+pe)/2;\n\t\tlazydown(p);\n\t\tadd(s, e, ps, pm, 2*p, v);\n\t\tadd(s, e, pm+1, pe, 2*p+1, v);\n\t\ttree[p] = max(tree[2*p], tree[2*p+1]);\n\t}\n\tlint query(int s, int e, int ps, int pe, int p){\n\t\tif(e < ps || pe < s) return -1e18;\n\t\tif(s <= ps && pe <= e) return tree[p];\n\t\tint pm = (ps + pe) / 2;\n\t\tlazydown(p);\n\t\treturn max(query(s, e, ps, pm, 2*p), query(s, e, pm+1, pe, 2*p+1));\n\t}\n};\n\nstruct dcmp{\n\tint idx;\n\tmap<int, int> din, dout;\n\tint piv;\n\tvector<lint> ds;\n\tvector<pi> intv;\n\tvector<lint> assoc;\n\tmultiset<lint> maxVal;\n\tlint ans;\n\n\tsegtree DS;\n}cd[MAXN];\n\npriority_queue<pair<lint, int>> pq;\n\nlint query(){\n\twhile(!pq.empty() && cd[pq.top().second].ans != pq.top().first){\n\t\tpq.pop();\n\t}\n\tif(pq.empty()) return 0;\n\treturn pq.top().first;\n}\n \nvoid update(int e, int x, int y, lint d){\n\tfor(auto &i : updList[e]){\n\t\tif(cd[i].din[x] > cd[i].din[y]) swap(x, y);\n\t\tint l = cd[i].din[y];\n\t\tint r = cd[i].dout[y];\n\n\t\tcd[i].DS.add(l, r - 1, 0, cd[i].piv - 1, 1, d);\n\n\t\tint pos = lower_bound(cd[i].intv.begin(), cd[i].intv.end(), pi(l, 1e9)) \n\t\t- cd[i].intv.begin() - 1;\n\t\tcd[i].maxVal.erase(cd[i].maxVal.find(cd[i].assoc[pos]));\n\n\t\tcd[i].assoc[pos] = \n\t\tcd[i].DS.query(cd[i].intv[pos].first, cd[i].intv[pos].second - 1, \n\t\t0, cd[i].piv - 1, 1);\n\n\t\tcd[i].maxVal.insert(cd[i].assoc[pos]);\n\t\tassert(cd[i].maxVal.size());\n\t\tif(cd[i].maxVal.size() == 1) cd[i].ans = *cd[i].maxVal.rbegin();\n\t\telse{\n\t\t\tauto cur = prev(cd[i].maxVal.end());\n\t\t\tcd[i].ans = *cur + *prev(cur);\n\t\t}\n\t\tpq.emplace(cd[i].ans, i);\n\t}\n}\n \nvoid dfs(int x, int p, dcmp &cd){\n\tcd.din[x] = cd.piv++;\n\tfor(auto &i : gph[x]){\n\t\tif(i.pos != p && !vis[i.pos]){\n\t\t\tupdList[i.idx].push_back(cd.idx);\n\t\t\tdfs(i.pos, x, cd);\n\t\t}\n\t}\n\tcd.dout[x] = cd.piv;\n}\n\nvoid sangsoo(int x, int p, dcmp &cd){\n\tfor(auto &i : gph[x]){\n\t\tif(i.pos != p && !vis[i.pos]){\n\t\t\tcd.DS.add(cd.din[i.pos], cd.dout[i.pos] - 1, 0, cd.piv - 1, 1, i.cst);\n\t\t\tsangsoo(i.pos, x, cd);\n\t\t}\n\t}\n}\n\nvoid build(int v, dcmp &cd){\n\tcd.idx = v;\n\tdfs(v, -1, cd);\n\tcd.DS.init(cd.piv);\n\tsangsoo(v, -1, cd);\n\tfor(auto &i : gph[v]){\n\t\tif(vis[i.pos]) continue;\n\t\tcd.intv.emplace_back(cd.din[i.pos], cd.dout[i.pos]);\n\t}\n\tsort(cd.intv.begin(), cd.intv.end());\n\tfor(int i=0; i<cd.intv.size(); i++){\n\t\tint l = cd.intv[i].first, r = cd.intv[i].second;\n\t\tlint ans = cd.DS.query(l, r - 1, 0, cd.piv - 1, 1);\n\t\tcd.maxVal.insert(ans);\n\t\tcd.assoc.push_back(ans);\n\t}\n\tif(cd.maxVal.size() == 0) cd.ans = 0;\n\telse if(cd.maxVal.size() == 1) cd.ans = *cd.maxVal.rbegin();\n\telse{\n\t\tauto cur = prev(cd.maxVal.end());\n\t\tcd.ans = *cur + *prev(cur);\n\t}\n\tpq.emplace(cd.ans, v);\n}\n\nvector<int> dfn;\nint sz[MAXN], msz[MAXN];\n \nvoid dfsc(int x, int p){\n\tdfn.push_back(x);\n\tsz[x] = 1;\n\tmsz[x] = 0;\n\tfor(auto &i : gph[x]){\n\t\tif(!vis[i.pos] && i.pos != p){\n\t\t\tdfsc(i.pos, x);\n\t\t\tsz[x] += sz[i.pos];\n\t\t\tmsz[x] = max(msz[x], sz[i.pos]);\n\t\t}\n\t}\n}\n \nint get_center(int x){\n\tdfsc(x, -1);\n\tpi ret(1e9, 1e9);\n\tfor(auto &i : dfn){\n\t\tint mxv = max(msz[i], (int)dfn.size() - sz[i]);\n\t\tret = min(ret, pi(mxv, i));\n\t}\n\tdfn.clear();\n\treturn ret.second;\n}\n \nint main(){\n\tlint w;\n\tscanf(\"%d %d %lld\",&n,&q,&w);\n\tvector<int> S(n - 1), E(n - 1); \n\tvector<lint> X(n - 1);\n\tfor(int i=0; i<n-1; i++){\n\t\tint s, e; lint x;\n\t\tscanf(\"%d %d %lld\",&s,&e,&x);\n\t\tgph[s].push_back({e, x, i});\n\t\tgph[e].push_back({s, x, i});\n\t\ttie(S[i], E[i], X[i]) = make_tuple(s, e, x);\n\t}\n\tqueue<int> que;\n\tque.push(1);\n\twhile(!que.empty()){\n\t\tint x = que.front(); que.pop();\n\t\tx = get_center(x);\n\t\tbuild(x, cd[x]);\n\t\tvis[x] = 1;\n\t\tfor(auto &i : gph[x]){\n\t\t\tif(!vis[i.pos]){\n\t\t\t\tque.push(i.pos);\n\t\t\t}\n\t\t}\n\t}\n\tlint last = 0;\n\twhile(q--){\n\t\tlint d, e; scanf(\"%lld %lld\",&d,&e);\n\t\td = (d + last) % (n - 1);\n\t\te = (e + last) % w;\n\t\tupdate(d, S[d], E[d], e - X[d]);\n\t\tX[d] = e;\n\t\tlast = query();\n\t\tprintf(\"%lld\\n\", last);\n\t}\n}\n\n",
    "ext": "cpp"
  },
  "57794689": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int Nmax = 1e5 + 5;\n\n\n\nint n, q, All, tmp, start;\nll Lim, cost[Nmax];\n\nvector<int> root[Nmax], L[Nmax], R[Nmax], son[Nmax];\nvector<int> v[Nmax];\n\npair<int,int> edge[Nmax];\nint who[Nmax];\n\n\n#define mid ((st+dr)>>1)\n#define left_son (node<<1)\n#define right_son ((node<<1)|1)\n\n\nclass SegTree\n{\n    pair<ll, int> *a;\n    int n;\n    ll *lazy;\n\n\n    void propag(int node)\n    {\n        if(!lazy[node]) return;\n        a[left_son].first += lazy[node];\n        a[right_son].first += lazy[node];\n        lazy[left_son] += lazy[node]; lazy[right_son] += lazy[node];\n        lazy[node] = 0;\n    }\n\n    pair<ll, int> query(int node, int st, int dr, int Left, int Right)\n    {\n        if(Left > Right) return {-1, -1};\n\n        if(Left <= st && dr <= Right) return a[node];\n\n        propag(node);\n\n        pair<ll, int> res = {-1, -1};\n        if(Left <= mid) res = query(left_son, st, mid, Left, Right);\n        if(mid < Right) res = max(res, query(right_son, mid+1, dr, Left, Right));\n        return res;\n    }\n\n    void init_dfs(int node, int st, int dr)\n    {\n        lazy[node] = 0;\n        if(st == dr)\n        {\n            a[node] = {0, who[st]};\n            return;\n        }\n\n        init_dfs(left_son, st, mid);\n        init_dfs(right_son, mid+1, dr);\n        a[node] = max(a[left_son], a[right_son]);\n    }\n\n    void update(int node, int st, int dr, int Left, int Right, ll delta)\n    {\n        if(Left <= st && dr <= Right)\n        {\n            a[node].first += delta;\n            lazy[node] += delta;\n            return;\n        }\n\n        propag(node);\n        if(Left <= mid) update(left_son, st, mid, Left, Right, delta);\n        if(mid < Right) update(right_son, mid+1, dr, Left, Right, delta);\n\n        a[node] = max(a[left_son], a[right_son]);\n    }\n\npublic:\n    void init(int _n)\n    {\n        n = _n;\n        a = new pair<ll, int> [(n<<2) + 2];\n        lazy = new ll [(n<<2) + 2];\n\n        init_dfs(1, 1, n);\n    }\n\n    ll query(int pos)\n    {\n        return query(1, 1, n, pos, pos).first;\n    }\n\n    pair<ll, int> query(int L, int R) /// except [L, R]\n    {\n        return max(query(1, 1, n, 1, L-1), query(1, 1, n, R+1, n));\n    }\n\n    void add(int Left, int Right, ll delta)\n    {\n        update(1, 1, n, Left, Right, delta);\n    }\n\n} aint[Nmax];\n\n\nnamespace prep\n{\n    static int w[Nmax];\n    static bool used[Nmax];\n\n    void dfs(int node, int dad = 0)\n    {\n        w[node] = 1;\n        for(auto it : v[node])\n            if(it != dad && !used[it])\n            {\n                dfs(it, node);\n                w[node] += w[it];\n            }\n    }\n\n    pair<int,int> centroid(int node, int dad = 0)\n    {\n        int worst = All - w[node]; pair<int,int> best = {n, n};\n\n        for(auto it : v[node])\n            if(it != dad && !used[it])\n            {\n                worst = max(worst, w[it]);\n                best = min(best, centroid(it, node));\n            }\n        best = min(best, {worst, node});\n        return best;\n    }\n\n    void dfs2(int node, int dad = 0)\n    {\n        L[node].push_back(++tmp);\n        who[tmp] = node;\n\n        if(!dad)\n        {\n            root[node].push_back(node);\n        }\n        else\n        {\n            root[node].push_back(root[dad].back());\n            if(dad == root[dad].back()) son[node].push_back(node);\n                else son[node].push_back(son[dad].back());\n        }\n\n        for(auto it : v[node])\n            if(it != dad && !used[it]) dfs2(it, node);\n\n        R[node].push_back(tmp);\n    }\n\n    void centr(int node)\n    {\n        dfs(node);\n        All = w[node];\n        node = centroid(node).second;\n\n        tmp = 0;\n        dfs2(node);\n\n        aint[node].init(All);\n\n        used[node] = 1;\n\n        for(auto it : v[node])\n            if(!used[it]) centr(it);\n    }\n}\n\n\nvoid addEdge(int id, ll delta)\n{\n    int j, x, y;\n\n    tie(x, y) = edge[id];\n    if(root[x].size() > root[y].size()) swap(x, y);\n\n    for(j=0; j<root[x].size(); ++j)\n    {\n        if(L[x][j] < L[y][j]) aint[root[x][j]].add(L[y][j], R[y][j], delta);\n            else aint[root[x][j]].add(L[x][j], R[x][j], delta);\n\n        assert(root[x][j] == root[y][j]);\n    }\n}\n\nvoid prepare()\n{\n    prep :: centr(1);\n\n    int i;\n    for(i=1; i<n; ++i)\n        addEdge(i, cost[i]);\n}\n\nvoid update(int id, ll new_cost)\n{\n    new_cost -= cost[id];\n    cost[id] += new_cost;\n    addEdge(id, new_cost);\n}\n\npair<ll, int> farthest(int node)\n{\n    pair<ll, int> ans = {0, node};\n\n    int i;\n    for(i=0; i<root[node].size(); ++i)\n    {\n        int Left, Right;\n\n        if(root[node][i] != node)\n        {\n            Left  = L[son[node][i]][i];\n            Right = R[son[node][i]][i];\n        }\n        else Left = 1, Right = 0;\n    //    cerr << L[node][i] << ' ' << R[node][i] << '\\n';\n      //  cerr << Left << ' ' << Right << '\\n';\n\n        pair<ll, int> now = aint[root[node][i]].query(Left, Right);\n\n        now.first += aint[root[node][i]].query(L[node][i]);\n        ans = max(ans, now);\n    }\n    return ans;\n}\n\nll query()\n{\n    int node = farthest(start).second;\n    return farthest(node).first;\n}\n\nint main()\n{\n    #ifndef ONLINE_JUDGE\n    freopen(\"input\", \"r\", stdin);\n    #endif // ONLINE_JUDGE\n    cin.sync_with_stdio(false); cin.tie(0);\n\n    cin >> n >> q >> Lim;\n\n    int i;\n    for(i=1; i<n; ++i)\n    {\n        int x, y;\n        cin >> x >> y >> cost[i];\n        edge[i] = {x, y};\n\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n\n    prepare();\n\n    for(i=1; i<=n; ++i)\n        if(root[i].size() == 1) start = i;\n\n    ll last = 0;\n    while(q--)\n    {\n        int D; ll E;\n\n        cin >> D >> E;\n        D = (D + last) % (n-1) + 1;\n        E = (E + last) % Lim;\n\n        update(D, E);\n        last = query();\n        cout << last << '\\n';\n    }\n\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57794106": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int Nmax = 1e5 + 5;\n\n\n\nint n, q, All, tmp;\nll Lim, cost[Nmax];\n\nvector<int> root[Nmax], L[Nmax], R[Nmax], son[Nmax];\nvector<int> v[Nmax];\n\npair<int,int> edge[Nmax];\nint who[Nmax];\n\n\n#define mid ((st+dr)>>1)\n#define left_son (node<<1)\n#define right_son ((node<<1)|1)\n\n\nclass SegTree\n{\n    pair<ll, int> *a;\n    int n;\n    ll *lazy;\n\n\n    void propag(int node)\n    {\n        if(!lazy[node]) return;\n        a[left_son].first += lazy[node];\n        a[right_son].first += lazy[node];\n        lazy[left_son] += lazy[node]; lazy[right_son] += lazy[node];\n        lazy[node] = 0;\n    }\n\n    pair<ll, int> query(int node, int st, int dr, int Left, int Right)\n    {\n        if(Left > Right) return {-1, -1};\n\n        if(Left <= st && dr <= Right) return a[node];\n\n        propag(node);\n\n        pair<ll, int> res = {-1, -1};\n        if(Left <= mid) res = query(left_son, st, mid, Left, Right);\n        if(mid < Right) res = max(res, query(right_son, mid+1, dr, Left, Right));\n        return res;\n    }\n\n    void init_dfs(int node, int st, int dr)\n    {\n        lazy[node] = 0;\n        if(st == dr)\n        {\n            a[node] = {0, who[st]};\n            return;\n        }\n\n        init_dfs(left_son, st, mid);\n        init_dfs(right_son, mid+1, dr);\n        a[node] = max(a[left_son], a[right_son]);\n    }\n\n    void update(int node, int st, int dr, int Left, int Right, ll delta)\n    {\n        if(Left <= st && dr <= Right)\n        {\n            a[node].first += delta;\n            lazy[node] += delta;\n            return;\n        }\n\n        propag(node);\n        if(Left <= mid) update(left_son, st, mid, Left, Right, delta);\n        if(mid < Right) update(right_son, mid+1, dr, Left, Right, delta);\n\n        a[node] = max(a[left_son], a[right_son]);\n    }\n\npublic:\n    void init(int _n)\n    {\n        n = _n;\n        a = new pair<ll, int> [(n<<2) + 2];\n        lazy = new ll [(n<<2) + 2];\n\n        init_dfs(1, 1, n);\n    }\n\n    ll query(int pos)\n    {\n        return query(1, 1, n, pos, pos).first;\n    }\n\n    pair<ll, int> query(int L, int R) /// except [L, R]\n    {\n        return max(query(1, 1, n, 1, L-1), query(1, 1, n, R+1, n));\n    }\n\n    void add(int Left, int Right, ll delta)\n    {\n        update(1, 1, n, Left, Right, delta);\n    }\n\n} aint[Nmax];\n\n\nnamespace prep\n{\n    static int w[Nmax];\n    static bool used[Nmax];\n\n    void dfs(int node, int dad = 0)\n    {\n        w[node] = 1;\n        for(auto it : v[node])\n            if(it != dad && !used[it])\n            {\n                dfs(it, node);\n                w[node] += w[it];\n            }\n    }\n\n    pair<int,int> centroid(int node, int dad = 0)\n    {\n        int worst = All - w[node]; pair<int,int> best = {n, n};\n\n        for(auto it : v[node])\n            if(it != dad && !used[it])\n            {\n                worst = max(worst, w[it]);\n                best = min(best, centroid(it, node));\n            }\n        best = min(best, {worst, node});\n        return best;\n    }\n\n    void dfs2(int node, int dad = 0)\n    {\n        L[node].push_back(++tmp);\n        who[tmp] = node;\n\n        if(!dad)\n        {\n            root[node].push_back(node);\n        }\n        else\n        {\n            root[node].push_back(root[dad].back());\n            if(dad == root[dad].back()) son[node].push_back(node);\n                else son[node].push_back(son[dad].back());\n        }\n\n        for(auto it : v[node])\n            if(it != dad && !used[it]) dfs2(it, node);\n\n        R[node].push_back(tmp);\n    }\n\n    void centr(int node)\n    {\n        dfs(node);\n        All = w[node];\n        node = centroid(node).second;\n\n        tmp = 0;\n        dfs2(node);\n\n        aint[node].init(All);\n\n        used[node] = 1;\n\n        for(auto it : v[node])\n            if(!used[it]) centr(it);\n    }\n}\n\n\nvoid addEdge(int id, ll delta)\n{\n    int j, x, y;\n\n    tie(x, y) = edge[id];\n    if(root[x].size() > root[y].size()) swap(x, y);\n\n    for(j=0; j<root[x].size(); ++j)\n    {\n        if(L[x][j] < L[y][j]) aint[root[x][j]].add(L[y][j], R[y][j], delta);\n            else aint[root[x][j]].add(L[x][j], R[x][j], delta);\n\n        assert(root[x][j] == root[y][j]);\n    }\n}\n\nvoid prepare()\n{\n    prep :: centr(1);\n\n    int i;\n    for(i=1; i<n; ++i)\n        addEdge(i, cost[i]);\n}\n\nvoid update(int id, ll new_cost)\n{\n    new_cost -= cost[id];\n    cost[id] += new_cost;\n    addEdge(id, new_cost);\n}\n\npair<ll, int> farthest(int node)\n{\n    pair<ll, int> ans = {0, node};\n\n    int i;\n    for(i=0; i<root[node].size(); ++i)\n    {\n        int Left, Right;\n\n        if(root[node][i] != node)\n        {\n            Left  = L[son[node][i]][i];\n            Right = R[son[node][i]][i];\n        }\n        else Left = 1, Right = 0;\n    //    cerr << L[node][i] << ' ' << R[node][i] << '\\n';\n      //  cerr << Left << ' ' << Right << '\\n';\n\n        pair<ll, int> now = aint[root[node][i]].query(Left, Right);\n\n        now.first += aint[root[node][i]].query(L[node][i]);\n        ans = max(ans, now);\n    }\n    return ans;\n}\n\nll query()\n{\n    int node = farthest(1).second;\n    return farthest(node).first;\n}\n\nint main()\n{\n    #ifndef ONLINE_JUDGE\n    freopen(\"input\", \"r\", stdin);\n    #endif // ONLINE_JUDGE\n    cin.sync_with_stdio(false); cin.tie(0);\n\n    cin >> n >> q >> Lim;\n\n    int i;\n    for(i=1; i<n; ++i)\n    {\n        int x, y;\n        cin >> x >> y >> cost[i];\n        edge[i] = {x, y};\n\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n\n    prepare();\n\n    ll last = 0;\n    while(q--)\n    {\n        int D; ll E;\n\n        cin >> D >> E;\n        D = (D + last) % (n-1) + 1;\n        E = (E + last) % Lim;\n\n        update(D, E);\n        last = query();\n        cout << last << '\\n';\n    }\n\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57793581": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing nagai = long long;\n#define sz(x) int((x).size())\n//#define int long long\n\n\nconst nagai oo=0x3f3f3f3f3f3f3f3f;\nconst int LG=17;\nconst int N=1<<LG;\nstruct it{\n\tpair<nagai,int> t[2*N];\n\tnagai psh[2*N];\n\tit(){\n\t\tfor(int i=2*N-1;i>0;--i)\n\t\t\tif(i>=N)t[i].second=i-N;\n\t\t\telse\n\t\t\t\tt[i].second=t[2*i].second;\n\t}\n\tvoid app(int x,nagai y){\n\t\t t[x].first+=y;\n\t\t psh[x]+=y;\n\t}\n\tvoid push1(int u){\n\t\t app(2*u,psh[u]);\n\t\t app(2*u+1,psh[u]);\n\t\t psh[u]=0;\n\t}\n\tvoid push(int u){\n\t\t for(int i=LG;i;--i)\n\t\t\t push1(u>>i);\n\t}\n\tvoid upd(int x){\n\t\t while(x>1)\n\t\t\t t[x>>1]=max(t[x],t[x^1]),x>>=1;\n\t}\n\tvoid add(int l,int r,nagai v){\n\t\tif(l>=r)return;\n\t\tl+=N;\n\t\tr+=N;\n\t\tint l1=l,r1=r;\n\t\twhile(l<r){\n\t\t\t if(l&1)app(l++,v);\n\t\t\t if(r&1)app(--r,v);\n\t\t\t l/=2,r/=2;\n\t\t}\n\t\tpush(l1);\n\t\tpush(r1-1);\n\t\tupd(l1);\n\t\tupd(r1-1);\n\t}\n\tpair<nagai,int> getmax(int l,int r){\n\t\tif(l>=r)return {-oo,-1};\n\t\tl+=N;\n\t\tr+=N;\n\t\tpush(l);\n\t\tpush(r-1);\n\t\tpair<nagai,int>ans={-oo,-1};\n\t\twhile(l<r){\n\t\t\t if(l&1)ans=max(ans,t[l++]);\n\t\t\t if(r&1)ans=max(ans,t[--r]);\n\t\t\t l/=2,r/=2;\n\t\t}\n\t\treturn ans;\n\t}\n} depit,hldit;\nint n,q;\nvector<tuple<int,nagai,int>>g[N];\nnagai w[N];\nint id[N];\nint invid[N];\nnagai dew[N];\nint de[N];\nint par[N];\nint ups[LG][N];\nint tin[N],tout[N];\nint sz[N];\nint top[N];\nvector<int>ch[N];\n\nvoid d(int u,int p=-1){\n\tsz[u]=1;\n\tfor(auto&[v,w,i]:g[u]){\n\t\tif(v==p)continue;\n\t\t::w[v]=w;\n\t\tid[v]=i;\n\t\tups[0][v]=u;\n\t\tinvid[i]=v;\n\t\tdew[v]=dew[u]+w;\n\t\tpar[v]=u;\n\t\tde[v]=de[u]+1;\n\t\td(v,u);\n\t\tsz[u]+=sz[v];\n\t\tch[u].push_back(v);\n\t\tif(sz[v]>sz[ch[u][0]])\n\t\t\tswap(ch[u][0],ch[u].back());\n\t}\n}\nint tot=0;\nvector<int>ord;\nvoid d1(int u){\n\ttin[u]=tot++;\n\tord.push_back(u);\n\tfor(int v:ch[u]){\n\t\tif(v==ch[u][0])\n\t\t\ttop[v]=top[u];\n\t\telse\n\t\t\ttop[v]=v;\n\t\td1(v);\n\t}\n\ttout[u]=tot;\n}\nvoid cups(){\n\tfor(int i=0;i+1<LG;++i)\n\t\tfor(int j=0;j<n;++j)\n\t\t\tups[i+1][j]=ups[i][ups[i][j]];\n}\nint goup(int x,int y){\n\tfor(int i=0;i<LG;++i)\n\t\tif(y>>i&1)x=ups[i][x];\n\treturn x;\n}\nnagai W;\nnagai getone(){\n\tauto p=depit.getmax(0,n);\n\tint v=ord[p.second];\n\tint xd=goup(v,de[v]-1);\n\tauto q=depit.getmax(0,tin[xd]);\n\tauto t=depit.getmax(tout[xd],n);\n\treturn p.first+max(0LL,max(q.first,t.first));\n}\nvoid recalc(int u){\n\tnagai de=depit.getmax(tin[u],tin[u]+1).first;\n\tnagai old=hldit.getmax(tin[u],tin[u]+1).first;\n\tnagai mx=0;\n\tif(ch[u].size()>1)\n\t\tmx=depit.getmax(tin[ch[u][1]],tout[u]).first;\n\tnagai nw=mx-2*de;\n\thldit.add(tin[u],tin[u]+1,nw-old);\n}\nvoid inc_edge(int v,nagai w){\n\tdepit.add(tin[v],tout[v],w);\n\t::w[v]+=w;\n\thldit.add(tin[v],tout[v],-w);\n//\tcerr<<hldit.getmax(tin[v],tin[v]+1).first<<'\\n';\n//\tcerr<<\"INC \"<<v<<'\\n';\n\twhile(top[v]!=0){\n\t\tv=top[v];\n\t\tv=par[v];\n\t\trecalc(v);\n//\t\tcerr<<v<<'\\n';\n\t}\n}\nnagai get_most_remote(int x){\n\tnagai de=depit.getmax(tin[x],tin[x]+1).first;\n\tnagai ans=0;\n\twhile(true){\n\t\tint t=top[x];\n\t\t/*\n\t\tfor(int i=tin[t];i<tin[x];++i){\n\t\t\tint old=hldit.getmax(i,i+1).first;\n\t\t\trecalc(ord[i]);\n\t\t\tint nw=hldit.getmax(i,i+1).first;\n//\t\t\tif(old!=nw)cerr<<ord[i]<<' '<<old<<' '<<nw<<'\\n';\n\t\t}\n\t\t*/\n\t\tans=max(ans,hldit.getmax(tin[t],tin[x]).first+de);\n\t\tif(t==0)break;\n\t\tx=par[t];\n\t\tnagai mx=max(depit.getmax(tin[x],tin[t]),depit.getmax(tout[t],tout[x])).first;\n\t\tans=max(ans,mx+de-2*depit.getmax(tin[x],tin[x]+1).first);\n\t}\n\treturn ans;\n}\nnagai getfull(){\n\tauto p=depit.getmax(0,n);\n\treturn get_most_remote(ord[p.second]);\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>n>>q>>W;\n\tfor(int i=0;i<n-1;++i){\n\t\t int a,b;\n\t\t nagai c;\n\t\t cin>>a>>b>>c;\n\t\t --a,--b;\n\t\t g[a].emplace_back(b,c,i);\n\t\t g[b].emplace_back(a,c,i);\n\t}\n\td(0);\n\td1(0);\n\tcups();\n\tfor(int i=0;i<n;++i)\n\t\tdepit.add(i,i+1,dew[ord[i]]);\n\tfor(int i=0;i<n;++i)\n\t\trecalc(i);\n\tnagai last=0;\n\twhile(q--){\n\t\tint d;\n\t\tnagai e;\n\t\tcin>>d>>e;\n\t\td=(d+last)%(n-1);\n\t\te=(e+last)%W;\n\t\tint v=invid[d];\n\t\te-=w[v];\n\t\tinc_edge(v,e);\n\t\tlast=getfull();\n\t\tcout<<last<<'\\n';\n\t}\n\treturn 0;\n}\n\n",
    "ext": "cpp"
  },
  "57792750": {
    "code": "#include <bits/stdc++.h>\n#define finish(x) return cout << x << endl, 0\ntypedef long long ll;\ntypedef long double ldb;\nconst int md = 1e9 + 7;\nconst ll inf = 4e18;\nconst int OO = 0;\nconst int OOO = 1;\nusing namespace std;\n\nconst int K = 3, eff[3] = { 1, -2, 1 };\n\nstruct block {\n\tll dp[K][K];\n\tblock() {\n\t\tfor (int i = 0; i < K; i++) for (int j = 0; j < K; j++) dp[i][j] = -inf;\n\t}\n\tblock(ll x) {\n\t\tfor (int i = 0; i < K; i++) for (int j = 0; j < K; j++) dp[i][j] = -inf;\n\t\tfor (int i = 0, sum; i < K; i++) {\n\t\t\tsum = 0;\n\t\t\tfor (int j = i; j < K; j++) {\n\t\t\t\tsum += eff[j];\n\t\t\t\tdp[i][j] = sum * x;\n\t\t\t}\n\t\t}\n\t}\n\tvoid push(ll x) {\n\t\tfor (int i = 0, sum; i < K; i++) {\n\t\t\tsum = 0;\n\t\t\tfor (int j = i; j < K; j++) {\n\t\t\t\tsum += eff[j];\n\t\t\t\tdp[i][j] += sum * x;\n\t\t\t}\n\t\t}\n\t}\n};\nblock operator * (const block &a, const block &b) {\n\tblock rtn;\n\tfor (int i = 0; i < K; i++) for (int j = i; j < K; j++) {\n\t\trtn.dp[i][j] = max(a.dp[i][j], b.dp[i][j]);\n\t\tfor (int k = i; k < j; k++)\n\t\t\trtn.dp[i][j] = max(rtn.dp[i][j], a.dp[i][k] + b.dp[k + 1][j]);\n\t}\n\treturn rtn;\n}\n\nstruct segtree {\n\tint n;\n\tvector<block> t;\n\tvector<ll> tag;\n\tsegtree() {}\n\tsegtree(const vector<ll> &a) {\n\t\tn = max(2, (int)a.size());\n\t\twhile (n != (n & -n)) n += (n & -n);\n\t\tt.resize(2 * n);\n\t\ttag.resize(2 * n, 0);\n\t\tfor (int i = 0; i < a.size(); i++)\n\t\t\tt[i + n - 1] = a[i];\n\t\tfor (int i = n - 2; i >= 0; i--)\n\t\t\tt[i] = t[i + i + 1] * t[i + i + 2];\n\t}\n\tvoid push(int x) {\n\t\tif (!tag[x]) return;\n\t\tt[x].push(tag[x]);\n\t\tif (x < n - 1) {\n\t\t\ttag[x + x + 1] += tag[x];\n\t\t\ttag[x + x + 2] += tag[x];\n\t\t}\n\t\ttag[x] = 0;\n\t}\n\tvoid fix(int x) {\n\t\tpush(x + x + 1), push(x + x + 2);\n\t\tt[x] = t[x + x + 1] * t[x + x + 2];\n\t}\n\tvoid upd(int l, int r, ll v) {\n\t\tupd(l, r, v, 0, 0, n - 1);\n\t}\n\tvoid upd(int l, int r, ll v, int node, int nl, int nr) {\n\t\tif (r < nl || nr < l) return;\n\t\tif (l <= nl && nr <= r) {\n\t\t\ttag[node] += v;\n\t\t\treturn;\n\t\t}\n\t\tpush(node);\n\t\tint mid = (nl + nr) / 2;\n\t\tupd(l, r, v, 2 * node + 1, nl, mid);\n\t\tupd(l, r, v, 2 * node + 2, mid + 1, nr);\n\t\tfix(node);\n\t}\n\tll query() {\n\t\tpush(0);\n\t\treturn t[0].dp[0][K - 1];\n\t}\n};\n\nstruct edge {\n\tint to;\n\tll w;\n\tedge() {}\n\tedge(int tt, ll ww) {\n\t\tto = tt;\n\t\tw = ww;\n\t}\n};\n\nint n, q;\nll w;\nvector<edge> e;\nvector<vector<int>> g;\nvector<int> par;\nll dp[100005][2];\n\nint st[100005], en[100005], tim = 0;\nvector<ll> initw;\nsegtree T;\n\nll LAST = 0;\n\nvoid answer(ll X) {\n\tcout << (LAST = X) << '\\n';\n}\nvoid encode(int &ind, ll &nw) {\n\tind = 2 * ((ind + LAST) % (n - 1));\n\tnw = (nw + LAST) % w;\n}\nint dfs(int v, int pre, ll W = 0) {\n\tpar[v] = pre;\n\tint rtn = 0;\n\tinitw[tim] = W;\n\tst[v] = tim++;\n\tfor (const auto &i : g[v])\n\t\tif (e[i].to != pre) {\n\t\t\trtn = max(rtn, 1 + dfs(e[i].to, v, W + e[i].w));\n\t\t\tinitw[tim++] = W;\n\t\t}\n\tfor (int i = 0; i < g[v].size(); i++)\n\t\tif (e[g[v][i]].to == pre) {\n\t\t\tswap(g[v].back(), g[v][i]);\n\t\t\tg[v].pop_back();\n\t\t\tbreak;\n\t\t}\n\ten[v] = tim - 1;\n\tinitw[tim - 1] = W;\n\treturn rtn;\n}\n\nint main() {\n\tios::sync_with_stdio(0), cin.tie(0);\n\n\tcin >> n >> q >> w;\n\tg.resize(n);\n\tpar.resize(n);\n\tinitw.resize(2 * n - 1);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tll ww;\n\t\tcin >> u >> v >> ww;\n\t\t--u, --v;\n\t\tg[u].push_back(e.size());\n\t\te.push_back(edge(v, ww));\n\t\tg[v].push_back(e.size());\n\t\te.push_back(edge(u, ww));\n\t}\n\tdfs(0, 0);\n\tint eind;\n\tll nw;\n\tT = segtree(initw);\n\n\twhile (q--) {\n\t\tcin >> eind >> nw;\n\t\tencode(eind, nw);\n\t\tif (OO) cout << \"real query \" << eind / 2 << \" \" << nw << '\\n';\n\t\tll diff = nw - e[eind].w;\n\t\te[eind].w = nw;\n\t\tint nl, nr;\n\t\tif (par[e[eind].to] == e[eind + 1].to)\n\t\t\tnl = st[e[eind].to], nr = en[e[eind].to];\n\t\telse\n\t\t\tnl = st[e[eind + 1].to], nr = en[e[eind + 1].to];\n\t\tif (OO) cout << \"updating \" << nl << \" \" << nr << \" \" << diff << '\\n';\n\t\tT.upd(nl, nr, diff);\n\t\tanswer(T.query());\n\t}\n}",
    "ext": "cpp"
  },
  "57792519": {
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing fl = long double;\ntemplate<typename T>\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename S, typename T>\nvoid xmin(S&a, T const&b){if(b<a) a=b;}\ntemplate<typename S, typename T>\nvoid xmax(S&a, T const&b){if(b>a) a=b;}\n\ntemplate<bool enabled>\nstruct Debug{\n    template<typename S, typename T = void> struct Tag_Printable : false_type {};\n    template<typename S> struct Tag_Printable<S, decltype((void)(cerr << declval<S>()))> : true_type {};\n    template<typename S, typename T = void> struct Tag_Iterable: false_type {};\n    template<typename S> struct Tag_Iterable<S, decltype((void)(begin(declval<S>()), end(declval<S>())))> : true_type {};\n    template<typename T, typename... Args>\n    Debug& print(T const&x, true_type, Args...){\n        #ifdef LOCAL_RUN\n        if(enabled){\n            cerr << boolalpha << x;\n        }\n        #endif // LOCAL_RUN\n        return *this;\n    }\n    template<typename T>\n    Debug& print(T const&x, false_type, true_type){\n        *this << \"[\";\n        bool first = true;\n        for(auto &e:x){\n            if(!first) *this << \", \";\n            *this << e;\n            first = false;\n        }\n        return *this << \"]\";\n    }\n    template<typename S, typename T>\n    Debug& print(pair<S, T> const&x, false_type, false_type){\n        return *this << \"(\" << x.first << \", \" << x.second << \")\";\n    }\n    template<typename T>\n    Debug& operator<<(T const&x){\n        return print(x, Tag_Printable<T>{}, Tag_Iterable<T>{});\n    }\n};\n Debug<true> debug;\n// Debug<false> debug; // disable debug printing\n#define named(x) string(#x) << \" : \" <<  x\n\nconstexpr ll inf = 1e18;\n\n//really fast iterative segment-tree implementation\n// nicer implementation with struct\ntemplate<class Segtree_Data>\nstruct Segment_Tree{\n\tusing T = typename Segtree_Data::node_t;\n\tint n;\n\tvector<T>data;\n\tSegment_Tree(int _n):n(_n), data(2*n, Segtree_Data::node_ne()){\n\t\tfor(int i=n-1;i>=0;--i) data[i] = Segtree_Data::merge_nodes(data[i<<1], data[i<<1|1]);\n\t}\n\tSegment_Tree(vector<T> const&base):n(base.size()), data(2*n, Segtree_Data::node_ne()){\n\t\tcopy(base.begin(), base.end(), data.begin()+n);\n\t\tfor(int i=n-1;i>=0;--i) data[i] = Segtree_Data::merge_nodes(data[i<<1], data[i<<1|1]);\n\t}\n\tvoid update(int pos, typename Segtree_Data::update_t const&val){\n\t\tfor(Segtree_Data::update_node(data[pos+=n], val);pos>>=1;){\n\t\t\tdata[pos] = Segtree_Data::merge_nodes(data[pos<<1], data[pos<<1|1]);\n\t\t}\n\t}\n\tT query(int l, int r)const{\n\t\tT retL = Segtree_Data::node_ne(), retR = Segtree_Data::node_ne();\n\t\tfor(l+=n, r+=n;l<r;l>>=1, r>>=1){\n\t\t\tif(l&1) retL = Segtree_Data::merge_nodes(retL, data[l++]);\n\t\t\tif(r&1) retR = Segtree_Data::merge_nodes(data[--r], retR);\n\t\t}\n\t\treturn Segtree_Data::merge_nodes(retL, retR);\n\t}\n};\nstruct Segtreedata{\n    struct Data{\n        ll min, max, ans, sum;\n        ll lp, pr;\n    };\n    typedef Data node_t;\n    typedef ll update_t;\n    static constexpr node_t node_ne() {\n        return node_t{\n            inf, -inf, 0, 0, -inf, -inf\n        };\n    }\n    static node_t from_int(ll const x){\n        return node_t{\n            x, x, 0, x, -x, -x\n        };\n    }\n    static node_t merge_nodes(node_t const&left, node_t right){\n        right.min+=left.sum;\n        right.max+=left.sum;\n        right.lp-=left.sum;\n        right.pr-=left.sum;\n        return node_t{\n            min(left.min, right.min),\n            max(left.max, right.max),\n            max({left.ans, right.ans, left.lp + right.max, left.max + right.pr}),\n            left.sum+right.sum,\n            max({left.lp, right.lp, left.max-2*right.min}),\n            max({left.pr, right.pr, -2*left.min+right.max})\n        };\n    }\n    static void update_node(node_t &node, update_t const&update){\n        node = from_int(update);\n    }\n};\n\n\nvector<vector<pair<int, int> > > g;\nvector<ll> w;\nvector<int> L, R;\nint tim;\nvoid dfs(int u, int p){\n    for(auto const&e:g[u]) if(e.first!=p){\n        L[e.second] = tim++;\n        dfs(e.first, u);\n        R[e.second] = tim++;\n    }\n}\n\n\nvoid solve(){\n    /// SOLVE HERE\n    ll W;\n    int n, q;\n    cin >> n >> q >> W;\n\n    g.assign(n, decltype(g)::value_type{});\n    w.resize(n);\n    for(int i=1;i<n;++i){\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        --a; --b;\n        g[a].emplace_back(b, i);\n        g[b].emplace_back(a, i);\n        w[i] = c;\n    }\n    L.resize(n);\n    R.resize(n);\n    tim = 0;\n    dfs(0, -1);\n    Segment_Tree<Segtreedata> st(2*n-2);\n    auto recalc_edge = [&](int index){\n        st.update(L[index], w[index]);\n        st.update(R[index], -w[index]);\n    };\n    for(int i=1;i<n;++i) recalc_edge(i);\n\n    ll last = 0;\n    for(int it=0;it<q;++it){\n        int d;\n        ll e;\n        cin >> d >> e;\n        d = (d+last)%(n-1)+1;\n        e = (e+last)%W;\n        w[d] = e;\n        recalc_edge(d);\n        auto tmp = st.query(0, 2*n-2);\n        last = tmp.ans;\n        cout << last << \"\\n\";\n    }\n\n\n}\n\nsigned gen(int T){\n    mt19937 rng(43151);\n    auto get_rand = [&](int64_t l, int64_t r){\n        return uniform_int_distribution<int64_t>(l, r)(rng);\n    }; (void) get_rand;\n    auto get_double = [&](double l, double r){\n        return uniform_real_distribution<double>(l, r)(rng);\n    };  (void) get_double;\n    ofstream o(\"gen.txt\");\n    o << T << \"\\n\";\n    for(int cas=0;cas<T;++cas){\n        /// GEN HERE\n\n        o << \"\\n\";\n    }\n    o << endl;\n    o.close();\n    return 0;\n}\n\nsigned main()\n{\n    #ifdef LOCAL_RUN\n    freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n    cin.exceptions(ios::badbit | ios::eofbit | ios::failbit);\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int TTT; cin >> TTT;\n\tif(TTT < 0) return gen(-TTT);\n\twhile(TTT--){\n    #else\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    #endif // LOCAL_RUN\n\n    solve();\n\n    #ifdef LOCAL_RUN\n    cout << flush;\n    }\n    #endif // LOCAL_RUN\n    return 0;\n}\n",
    "ext": "cpp"
  },
  "57782685": {
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <ll, ll> pll;\ntypedef priority_queue <ll> pql;\n\nstruct node{\n\tll v, l, r, s;\n\t\n\tnode() : v(0), l(0), r(0), s(0) {}\t\n\tnode(ll v, ll d, ll c) : v(v), l(d + c), r(d), s(c) {}\n\t\n\tnode operator + (node n)\n\t{\n\t\tnode ret;\n\t\t\n\t\tret.s = s + n.s;\n\t\tret.l = max(l, s + n.l);\n\t\tret.r = max(n.r, n.s + r);\n\t\tret.v = max(max(v, n.v), r + n.l);\n\t\t\n\t\treturn ret;\n\t}\n};\n\nstruct segtree{\n\tnode T[303030];\n\tll sz = 1 << 17;\n\t\n\tvoid update(ll p, ll v, ll d, ll c)\n\t{\n\t\tp += sz; T[p] = node(v, d, c);\n\t\t\n\t\tfor(p>>=1; p; p>>=1){\n\t\t\tT[p] = T[p << 1] + T[p << 1 | 1];\n\t\t}\n\t}\n\t\n\tnode getval(ll l, ll r)\n\t{\n\t\tnode vl, vr;\n\t\tbool fl = 0, fr = 0;\n\t\t\n\t\tl += sz; r += sz;\n\t\t\n\t\tfor(; l<=r; ){\n\t\t\tif(l & 1){\n\t\t\t\tif(fl) vl = vl + T[l];\n\t\t\t\telse vl = T[l], fl = 1;\n\t\t\t}\n\t\t\tif(~r & 1){\n\t\t\t\tif(fr) vr = T[r] + vr;\n\t\t\t\telse vr = T[r], fr = 1;\n\t\t\t}\n\t\t\tl = l + 1 >> 1;\n\t\t\tr = r - 1 >> 1;\n\t\t}\n\t\t\n\t\tif(fl && fr) return vl + vr;\n\t\telse if(fl) return vl;\n\t\telse if(fr) return vr;\n\t\telse 1 / 0;\n\t}\n};\n\nsegtree T;\nvector <ll> V[101010];\npql PV[101010], QV[101010], PL[101010], QL[101010];\nll P[101010], C[101010], N[101010];\nll A[101010], B[101010], E[101010], _C[101010], Z[101010];\nll H[101010], G[101010], S[101010];\nvector <ll> X;\nll n, q, w, g, cnt, ans;\n\nvoid dfs1(ll p, ll r)\n{\n\tZ[p] = 1;\n\t\n\tfor(ll &t: V[p]){\n\t\tif(t != r){\n\t\t\tdfs1(t, p);\n\t\t\tZ[p] += Z[t]; P[t] = p;\n\t\t}\n\t}\n}\n\nvoid dfs2(ll p, ll r, ll c)\n{\n\tll m = -1;\n\t\n\tN[p] = ++cnt;\n\tX.push_back(p);\n\t\n\tfor(ll &t: V[p]){\n\t\tif(t == r) continue;\n\t\tif(m == -1 || Z[t] > Z[m]){\n\t\t\tm = t;\n\t\t}\n\t}\n\t\n\tif(m != -1){\n\t\tG[m] = c; S[c] ++;\n\t\tdfs2(m, p, c);\n\t}\n\t\n\tfor(ll &t: V[p]){\n\t\tif(t != r && t != m){\n\t\t\tH[++g] = t; G[t] = g; S[g] ++;\n\t\t\tdfs2(t, p, g);\n\t\t\t\n\t\t\tPV[p].push(0); PL[p].push(0);\n\t\t}\n\t}\n}\n\nvoid sync(pql &P, pql &Q) { for(; !P.empty() && !Q.empty() && P.top() == Q.top(); P.pop(), Q.pop()); }\n\npll nodeval(ll p)\n{\n\tll v, v1, v2;\n\t\n\tsync(PL[p], QL[p]);\n\tif(PL[p].empty()) v1 = -1;\n\telse v1 = PL[p].top(), PL[p].pop();\n\t\n\tsync(PL[p], QL[p]);\n\tif(PL[p].empty()) v2 = 0;\n\telse v2 = PL[p].top();\n\t\n\tif(v1 != -1) PL[p].push(v1);\n\t\n\tsync(PV[p], QV[p]);\n\tif(PV[p].empty()) v = 0;\n\telse v = PV[p].top();\n\t\n\tif(v1 == -1) v1 = 0;\n\t\n\tv = max(v, v1 + v2);\n\t\n\treturn pll(v, v1);\n}\n\nvoid query(ll p)\n{\n\tif(!p) return;\n\t\n\tnode _n;\n\tll h, v, d;\n\t\n\th = H[G[p]];\n\t\n\t_n = T.getval(N[h], N[h] + S[G[p]] - 1);\n\tv = _n.v; d = _n.l;\n\tQV[P[h]].push(v); QL[P[h]].push(d);\n\t\n\ttie(v, d) = nodeval(p); v = max(v, d + C[p]);\n\tT.update(N[p], v, d, C[p]);\n\t\n\t_n = T.getval(N[h], N[h] + S[G[p]] - 1);\n\tv = _n.v; d = _n.l;\n\tPV[P[h]].push(v); PL[P[h]].push(d);\n\t\n\tquery(P[h]);\n}\n\nll getans() { return nodeval(0).first; }\n\nint main()\n{\n\tll i, c;\n\t\n\tscanf(\"%lld%lld%lld\", &n, &q, &w);\n\t\n\tfor(i=1; i<n; i++){\n\t\tscanf(\"%lld%lld%lld\", A + i, B + i, _C + i);\n\t\tV[A[i]].push_back(B[i]);\n\t\tV[B[i]].push_back(A[i]);\n\t}\n\t\n\tdfs1(1, 0);\n\tH[++g] = 1; G[1] = g; S[g] ++;\n\tdfs2(1, 0, g);\n\tPV[0].push(0); PL[0].push(0);\n\t\n\treverse(X.begin(), X.end());\n\t\n\tfor(i=1; i<n; i++){\n\t\tif(P[A[i]] != B[i]) swap(A[i], B[i]);\n\t\tE[A[i]] = i;\n\t}\n\t\n\tfor(ll &t: X){\n\t\tC[t] = _C[E[t]];\n\t\tquery(t);\n\t}\n\t\n\tfor(i=1; i<=n; i++){\n\t\tll v, d;\n\t\ttie(v, d) = nodeval(i);\n\t}\n\t\n\tfor(; q--; ){\n\t\tscanf(\"%lld%lld\", &i, &c);\n\t\ti = A[(i + ans) % (n - 1) + 1];\n\t\tc = (c + ans) % w;\n\t\tC[i] = c; query(i);\n\t\tans = getans();\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\t\t\n\treturn 0;\n}",
    "ext": "cpp"
  }
}